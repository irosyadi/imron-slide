[
  {
    "objectID": "control-1.html",
    "href": "control-1.html",
    "title": "Instrumentation",
    "section": "",
    "text": "title: “Introduction to Control Systems” subtitle: “Control 1” author: “Imron Rosyadi” format: live-revealjs: slide-number: true chalkboard: true scrollable: true controls: true progress: true transition: fade theme: [default, qrjs_assets/ir_style_v2.scss] mermaid-format: png mermaid: theme: neutral layout: elk logo: “qrjs_pics/unsoed_logo.png” footer: “irosyadi-2025” pyodide: packages: - numpy - plotly - nbformat —"
  },
  {
    "objectID": "control-1.html#learning-objectives",
    "href": "control-1.html#learning-objectives",
    "title": "Introduction to Control Systems",
    "section": "Learning Objectives",
    "text": "Learning Objectives\nAfter this session, you will be able to:\n\nDefine a control system and recognize common ECE applications.\nDistinguish open-loop and closed-loop (feedback) systems.\nExplain transient response, steady-state error, and stability qualitatively.\nDescribe the main steps of the control system design process.\nAppreciate the role of computer-aided tools (e.g., MATLAB) in control design.\nInterpret the antenna-azimuth case study as a canonical position control problem.\n\n\nClarify that today’s focus is conceptual, with minimal equations. These objectives line up with Sections 1.1–1.7 of the text and the antenna case study. Point out that understanding this “big picture” will make the math in later chapters much more intuitive."
  },
  {
    "objectID": "control-1.html#big-picture-what-is-a-control-system",
    "href": "control-1.html#big-picture-what-is-a-control-system",
    "title": "Introduction to Control Systems",
    "section": "Big Picture: What Is a Control System?",
    "text": "Big Picture: What Is a Control System?\n\n\nA control system is:\n\nA collection of subsystems and processes (the plant) assembled to produce a desired output, with desired performance, in response to a specified input.\n\nKey ingredients:\n\nInput (command / reference) – what we want.\nPlant / process – the physical system we influence.\nOutput – what actually happens.\nController – logic that decides how to drive the plant.\nOptionally: feedback that measures the output.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nRelate to something they know: - Audio volume knob → amplifier → speaker → sound level. - Temperature setpoint → HVAC → room temperature.\nHighlight that at this stage we’re not yet distinguishing open- vs. closed-loop; this is just the “block-level” view."
  },
  {
    "objectID": "control-1.html#everyday-examples-ece-focus",
    "href": "control-1.html#everyday-examples-ece-focus",
    "title": "Introduction to Control Systems",
    "section": "Everyday Examples (ECE Focus)",
    "text": "Everyday Examples (ECE Focus)\n\n\nEngineering / technology examples\n\nElevator position and speed control.\nDisk drive head positioning.\nAntenna pointing for satellites.\nMotor drives in robots and drones.\nPower electronics: DC–DC converter voltage regulation.\nCommunication systems: automatic gain control (AGC).\n\n\nNatural / “biological” control systems\n\nBlood sugar regulation (pancreas / insulin).\nHeart rate and oxygen delivery in “fight or flight.”\nEye tracking to keep moving targets centered on the retina.\nMuscle control when you reach and place an object precisely.\n\n\n\n\n\n\n\n\nNote\n\n\nControl concepts cut across electrical, mechanical, chemical, biological, and even economic systems.\n\n\n\n\nUnderline the universality of feedback and regulation. Ask: “Who wears a smartwatch? It’s measuring your heart rate and sometimes controlling your behavior via notifications. That’s a cyber-physical control loop involving you.”"
  },
  {
    "objectID": "control-1.html#case-study-learning-outcome",
    "href": "control-1.html#case-study-learning-outcome",
    "title": "Introduction to Control Systems",
    "section": "Case-Study Learning Outcome",
    "text": "Case-Study Learning Outcome\nWe will repeatedly return to a running case study:\nAntenna azimuth position control system\nYou will use it to:\n\nSee how a real electromechanical control loop is built.\nConnect physical hardware (motors, sensors, amplifiers) to block diagrams.\nVisualize transient response, steady-state error, and stability.\nPractice design trade-offs (speed vs. overshoot, accuracy vs. complexity).\n\n\nStress that this is not a one-off example; it threads through many chapters. The “antenna azimuth” problem is a classic, but it is also very close to modern applications: gimbals in drones, phased-array pointing, etc."
  },
  {
    "objectID": "control-1.html#control-systems-all-around-us",
    "href": "control-1.html#control-systems-all-around-us",
    "title": "Introduction to Control Systems",
    "section": "1.1 Control Systems All Around Us",
    "text": "1.1 Control Systems All Around Us\nControl systems are integral to modern society:\n\nSpace shuttle launch and orbit control – rocket thrust, attitude, and trajectory.\nCNC machining – precise movement of tools with cooling and speed control.\nAutomated guided vehicles in factories – follow paths and avoid obstacles.\n\nNatural examples inside your body:\n\nHormonal control (e.g., insulin) maintains blood sugar.\nAdrenaline raises heart rate and breathing when stressed.\nEyes and hands coordinate to track and grasp objects.\n\nEven abstract systems like student performance vs. study time can be modeled as control systems.\n\nUse the study-time model as a fun analogy: - Input: study time. - Output: grade. - Disturbance: surprise extra chapter on the exam. - Control action: adjust study plan.\nThe point is not that the model is perfect, but that control thinking is pervasive."
  },
  {
    "objectID": "control-1.html#control-system-definition-basic-block-diagram",
    "href": "control-1.html#control-system-definition-basic-block-diagram",
    "title": "Introduction to Control Systems",
    "section": "Control System Definition & Basic Block Diagram",
    "text": "Control System Definition & Basic Block Diagram\n\n\n\nFigure 1.1 Simplified description of a control system\n\n\nA control system consists of:\n\nController – implements the control law.\nPlant / process – physical system we’re controlling.\nInput – desired plant output (command).\nOutput – measured plant response.\n\n\nRelate Figure 1.1 to the previous generic block diagram. Emphasize: here, input is a desired output (e.g., desired elevator floor). Set up that later we will add feedback explicitly to this simple picture."
  },
  {
    "objectID": "control-1.html#elevator-example-input-output-performance",
    "href": "control-1.html#elevator-example-input-output-performance",
    "title": "Introduction to Control Systems",
    "section": "Elevator Example: Input, Output, Performance",
    "text": "Elevator Example: Input, Output, Performance\n\n\nThink of a modern elevator:\n\nYou press the 4th floor button on the 1st floor.\nThe car should move:\n\nFast enough (but not scary).\nSmoothly, without oscillations.\nStop level with the floor.\n\n\nInput: “Go to 4th floor” (a step in desired position).\nOutput: actual car position vs. time.\n\n\n\n\nFigure 1.2 Elevator response\n\n\n\nTwo key performance aspects visible here:\n\nTransient response – how the elevator moves while changing floors.\nSteady-state error – how close the final position is to the floor.\n\n\nUse the plot conceptually, even if students cannot read all details yet. - Transient response → passenger comfort and patience. - Steady-state error → safety and convenience.\nAsk: “Have you ever felt an elevator ‘bounce’ a little at a floor?” That’s underdamped transient behavior."
  },
  {
    "objectID": "control-1.html#why-use-control-systems",
    "href": "control-1.html#why-use-control-systems",
    "title": "Introduction to Control Systems",
    "section": "Why Use Control Systems?",
    "text": "Why Use Control Systems?\n \nWe build control systems to:\n\nAmplify power – small electrical signals command large mechanical power.\nEnable remote control – operate systems from a distance or hazardous area.\nChange input form – e.g., a knob position → room temperature.\nCompensate for disturbances – maintain performance despite wind, load changes, noise, etc.\n\n\nUse the elevator photos:\n\nEarly elevators: human operator pulls ropes, directly controlling motion.\nModern elevators: motors provide power, control systems manage position and speed.\n\nEmphasize that with control systems, a low-power, convenient command (button press) can safely control a high-power system."
  },
  {
    "objectID": "control-1.html#disturbances-compensation-antenna-example",
    "href": "control-1.html#disturbances-compensation-antenna-example",
    "title": "Introduction to Control Systems",
    "section": "Disturbances & Compensation: Antenna Example",
    "text": "Disturbances & Compensation: Antenna Example\n\n\n\nRover robot arm in contaminated area\n\n\nExample: Antenna pointing system\n\nGoal: keep antenna aimed at a satellite.\nDisturbances:\n\nWind gusts push the antenna off target.\nMechanical friction or backlash.\nElectrical noise in sensors/actuators.\n\n\nA good control system:\n\nDetects deviation from commanded angle.\nApplies correction so the antenna returns to the right direction.\nDoes this automatically; the reference input does not change.\n\n\nUse Rover as another example of remote control in dangerous environments. Link to the antenna case study: we will design such a position loop."
  },
  {
    "objectID": "control-1.html#brief-history-of-control-systems-human-designed",
    "href": "control-1.html#brief-history-of-control-systems-human-designed",
    "title": "Introduction to Control Systems",
    "section": "1.2 Brief History of Control Systems (Human-Designed)",
    "text": "1.2 Brief History of Control Systems (Human-Designed)\nControl ideas go back over 2000 years:\n\n300 B.C. – Greek water clocks (Ktesibios). Liquid-level regulation to maintain constant flow.\nAncient oil lamps (Philon of Byzantium). Self-regulated oil level by clever tubing and air pressure.\n1681 – Papin’s safety valve. Steam pressure regulation via weighted valve.\n17th century – Drebbel’s incubator. Mechanical temperature controller using alcohol/mercury expansion.\n\nKey theme: automatic regulation of a variable (level, pressure, temperature) using feedback-like mechanisms.\n\nYou don’t need students to remember names and dates. Instead, focus on the idea: humans have been building feedback-like devices for centuries. Draw parallels: liquid-level controller → modern tank-level control in chemical plants."
  },
  {
    "objectID": "control-1.html#historical-milestones-speed-control",
    "href": "control-1.html#historical-milestones-speed-control",
    "title": "Introduction to Control Systems",
    "section": "Historical Milestones: Speed Control",
    "text": "Historical Milestones: Speed Control\n\n1745 – Edmund Lee\n\nWindmill speed control by automatically changing blade pitch.\n\n1809 – William Cubitt\n\nImproved windmill with movable louvers for better speed regulation.\n\nLate 18th century – James Watt’s flyball governor\n\nRotating balls rise with speed, mechanically throttling steam input.\nClassic mechanical speed feedback system.\n\n\nKey idea: speed is measured, compared to desired value, and used to adjust input.\n\nStudents often have seen animations of Watt’s governor. Make the connection: this is essentially a mechanical proportional feedback controller."
  },
  {
    "objectID": "control-1.html#mathematical-foundations-stability-criteria",
    "href": "control-1.html#mathematical-foundations-stability-criteria",
    "title": "Introduction to Control Systems",
    "section": "Mathematical Foundations: Stability Criteria",
    "text": "Mathematical Foundations: Stability Criteria\nMajor contributions in the 19th century:\n\nMaxwell (1868) – early stability criterion for 3rd-order systems.\nRouth (1874, 1877) – extended criteria to higher orders → Routh–Hurwitz stability test.\nLyapunov (1892) – generalized stability theory to nonlinear systems.\n\nThese works turned practical control problems into mathematical questions about differential equations and their roots.\n\n\n\n\n\n\nTip\n\n\nIn later chapters, you will learn how to decide if a system is stable by looking at coefficients or roots of characteristic equations, not by trial-and-error experiments.\n\n\n\n\nReassure students: they don’t need to memorize all history, but they should recognize Routh and Lyapunov as names linked to stability methods they will use later."
  },
  {
    "objectID": "control-1.html#th-century-frequency-and-root-locus-methods",
    "href": "control-1.html#th-century-frequency-and-root-locus-methods",
    "title": "Introduction to Control Systems",
    "section": "20th-Century Frequency and Root-Locus Methods",
    "text": "20th-Century Frequency and Root-Locus Methods\nKey developments:\n\nNicholas Minorsky (1920s) – theoretical basis of PID control for ship steering.\nBode & Nyquist (Bell Labs, 1920s–30s) –\n\nFeedback amplifier analysis.\nBode plots and Nyquist criteria for frequency-domain design.\n\nWalter R. Evans (1948) –\n\nRoot locus: graphical method to see how closed-loop poles move as a gain changes.\n\n\nThese are the core analysis tools for classical linear control.\n\nExplain that these methods remain in heavy use in industry and are embedded in tools like MATLAB’s Control System Toolbox. Set expectations: Bode/Nyquist → Chapters 10–11; root locus → Chapters 8–9, 13."
  },
  {
    "objectID": "control-1.html#contemporary-applications",
    "href": "control-1.html#contemporary-applications",
    "title": "Introduction to Control Systems",
    "section": "Contemporary Applications",
    "text": "Contemporary Applications\nModern control systems are everywhere:\n\nAerospace – missile and spacecraft guidance, aircraft autopilots, UAVs.\nShips – heading control, roll stabilization, dynamic positioning.\nProcess industry – temperature, pressure, concentration, flow, and thickness regulation.\nAutomation & robotics – industrial robot arms, collaborative robots, warehouse robots.\nConsumer electronics – camera autofocus, disk drives, optical disk tracking.\n\nModern systems almost always include a digital computer as part of the controller.\n\nHighlight that ECE graduates will likely interact with digital controllers (microcontrollers, FPGAs, embedded CPUs) implementing control laws."
  },
  {
    "objectID": "control-1.html#space-shuttle-a-complex-control-system",
    "href": "control-1.html#space-shuttle-a-complex-control-system",
    "title": "Introduction to Control Systems",
    "section": "Space Shuttle: A Complex Control System",
    "text": "Space Shuttle: A Complex Control System\nThe (now retired) space shuttle is a powerful example:\n\nOnboard computers handled:\n\nNavigation – estimating position and velocity from sensors.\nGuidance – computing desired trajectory and attitude.\nControl – generating commands to engines, thrusters, and aerosurfaces.\n\nControl subsystems included:\n\nOMS engine gimbaling in space.\nElevon and rudder control in atmosphere.\nReaction control system (RCS) jets for attitude when aero surfaces were ineffective.\nPower and life-support regulation (fuel cells, tank pressures, temperatures).\n\n\nAll these formed a hierarchical control architecture.\n\nUse this to convey the scale and complexity of real-world control systems. Make the point that what we study (single-loop position control, etc.) are building blocks in a much larger system-of-systems."
  },
  {
    "objectID": "control-1.html#system-configurations-open--vs-closed-loop",
    "href": "control-1.html#system-configurations-open--vs-closed-loop",
    "title": "Introduction to Control Systems",
    "section": "1.3 System Configurations: Open- vs Closed-Loop",
    "text": "1.3 System Configurations: Open- vs Closed-Loop\n\n\n\nOpen-loop and closed-loop block diagrams\n\n\n\n\n\nClosed-loop system\n\n\nTwo main architectures:\n\nOpen-loop systems – no feedback; no automatic correction.\nClosed-loop (feedback) systems – output is measured and used to adjust input.\n\nWe can think of these as different internal architectures of the generic system in Figure 1.1.\n\nShow both figures and verbally identify each block. Stress that in ECE, almost all interesting high-performance controllers are closed-loop; but open-loop still has uses when environment is predictable."
  },
  {
    "objectID": "control-1.html#open-loop-control-structure",
    "href": "control-1.html#open-loop-control-structure",
    "title": "Introduction to Control Systems",
    "section": "Open-Loop Control: Structure",
    "text": "Open-Loop Control: Structure\n\n\n\n\n\n\n\n\n\n\n\nCharacteristics:\n\nControl signal depends only on the input, not on output.\nCannot correct for Disturbance 1 (added to controller output) or Disturbance 2 (added at plant output).\nOutput may deviate significantly if environment or plant changes.\n\n\nGive intuitive ECE-style examples: - DSM or microcontroller generating PWM to a heater without temperature feedback. - LED brightness scheduled from a lookup table, not measured. Emphasize: works only if the plant and disturbances are well known and nearly constant."
  },
  {
    "objectID": "control-1.html#open-loop-examples",
    "href": "control-1.html#open-loop-examples",
    "title": "Introduction to Control Systems",
    "section": "Open-Loop Examples",
    "text": "Open-Loop Examples\n\nToaster\n\nInput: time setting.\nOutput: toast color.\nAssumes “longer time → darker toast.”\nDoes not sense actual color, bread type, or thickness.\n\nMass–spring–damper with constant force\n\nConstant force determines equilibrium position.\nIf another external force (disturbance) is applied, position changes and system does not correct.\n\nYour study plan\n\nYou compute hours to study for 3 chapters.\nProfessor adds a 4th chapter (disturbance).\nIf you don’t adjust your plan, you are acting as an open-loop system.\n\n\n\n\n\n\n\n\nWarning\n\n\nOpen-loop control is simple and cheap, but can be very sensitive to disturbances and modeling errors.\n\n\n\n\nThis is a good place to ask students for more open-loop examples. Guide them to think about devices whose operation is purely time-based or schedule-based, with no output measurement."
  },
  {
    "objectID": "control-1.html#closed-loop-feedback-control-structure",
    "href": "control-1.html#closed-loop-feedback-control-structure",
    "title": "Introduction to Control Systems",
    "section": "Closed-Loop (Feedback) Control: Structure",
    "text": "Closed-Loop (Feedback) Control: Structure\n\n\n\n\n\n\n\n\n\n\n\nKey features:\n\nSensor / output transducer measures output.\nFeedback path returns a signal proportional to output.\nAt the summing junction, feedback is subtracted from input to form an error (actuating) signal.\nController drives plant to reduce error toward zero.\n\n\nExplain “unity transducers”: when generation/measurement gains are 1, the actuator signal equals the actual physical error. Emphasize that the system acts to minimize error: if output lags input, error is nonzero, and the controller pushes the plant in the right direction."
  },
  {
    "objectID": "control-1.html#why-feedback-helps",
    "href": "control-1.html#why-feedback-helps",
    "title": "Introduction to Control Systems",
    "section": "Why Feedback Helps",
    "text": "Why Feedback Helps\nClosed-loop systems:\n\nAre less sensitive to disturbances and plant parameter variations.\nCan achieve higher accuracy (lower steady-state error).\nAllow designers to shape transient response and steady-state behavior more flexibly by adjusting loop gain or adding compensators.\n\nTrade-offs:\n\nMore complex hardware and software.\nAdditional sensors, actuators, and signal processing.\nPotential for instability if the loop is not designed carefully.\n\nExample: smart toaster oven - Measures internal light level / humidity → estimates toast “doneness.” - Adjusts time and heat dynamically. - More accurate but more complex and costly than a simple timer toaster.\n\nStress that complexity must be justified by performance gains and application needs. Point ahead: much of this course is about using math to design stable, high-performance feedback loops."
  },
  {
    "objectID": "control-1.html#computer-controlled-systems",
    "href": "control-1.html#computer-controlled-systems",
    "title": "Introduction to Control Systems",
    "section": "Computer-Controlled Systems",
    "text": "Computer-Controlled Systems\nIn many modern systems, the controller is a digital computer (microcontroller, DSP, FPGA, etc.).\nAdvantages:\n\nTime-sharing: one computer can manage many loops.\nEasy to change controller characteristics via software, not hardware.\nImplement complex algorithms: adaptive control, optimal control, digital filters.\nPerform supervisory tasks: scheduling, fault detection, diagnostics, user interface.\n\nExample: Space Shuttle Main Engine (SSME) controller - Two digital computers monitored: pressures, temperatures, flows, turbopump speed, valve positions, servo actuators. - Provided closed-loop control of thrust and mixture ratio.\n\nConnect with students’ embedded systems courses: They’ve likely programmed microcontrollers; here, the difference is the use of feedback on physical variables to meet dynamic performance specs."
  },
  {
    "objectID": "control-1.html#analysis-and-design-objectives",
    "href": "control-1.html#analysis-and-design-objectives",
    "title": "Introduction to Control Systems",
    "section": "1.4 Analysis and Design Objectives",
    "text": "1.4 Analysis and Design Objectives\nAnalysis vs. design:\n\nAnalysis – determine how a given system behaves.\n\nEvaluate transient response and steady-state error.\nCheck stability.\n\nDesign – choose or modify system components/parameters to meet performance specs.\n\nThree major objectives for control-system design:\n\nDesired transient response.\nAcceptable steady-state error.\nStability.\n\nOther considerations: cost, robustness, hardware constraints.\n\nTell students that nearly every problem in later chapters will boil down to: “Given a plant and specs on speed, overshoot, error, and stability, design a controller that meets them.”"
  },
  {
    "objectID": "control-1.html#transient-response-what-happens-before-steady-state",
    "href": "control-1.html#transient-response-what-happens-before-steady-state",
    "title": "Introduction to Control Systems",
    "section": "Transient Response: What Happens Before Steady State?",
    "text": "Transient Response: What Happens Before Steady State?\nTransient response = system behavior from the moment the input changes until it settles.\nImportant because:\n\nAffects comfort and usability (elevator, car cruise control).\nAffects throughput (disk drive head must settle before reading/writing).\nMay affect mechanical stress and reliability (too aggressive motion can damage hardware).\n\nExample: disk drive head\n\n\n\nComputer hard disk and head\n\n\n\nHead moves from one track to another.\nReading/writing cannot start until motion settles.\nTransient performance (speed, overshoot, damping) directly affects transfer rate.\n\n\nIn later chapters we will define metrics like rise time, overshoot, settling time, etc. For now, just convey that transient design is crucial to performance and user experience."
  },
  {
    "objectID": "control-1.html#steady-state-response-error",
    "href": "control-1.html#steady-state-response-error",
    "title": "Introduction to Control Systems",
    "section": "Steady-State Response & Error",
    "text": "Steady-State Response & Error\nSteady-state response = behavior after transients have effectively died out.\nSteady-state error (SSE) = difference between desired output and actual output in steady state.\nExamples:\n\nElevator leveling error: a few centimeters off can be dangerous.\nAntenna tracking error: if too large, satellite falls outside the beam.\nDisk drive head offset: results in read/write errors.\n\nDesign goals:\n\nSSE must be small enough to meet accuracy and safety requirements.\nBut sometimes we trade between transient performance and SSE.\n\n\n\n\n\n\n\nImportant\n\n\nLater we will quantify SSE for standard input types (step, ramp, parabola) and relate it to system type and gain.\n\n\n\n\nEmphasize that SSE depends on both system structure (e.g., integrator presence) and loop gain. This foreshadows integral control and error constants."
  },
  {
    "objectID": "control-1.html#stability-the-non-negotiable-requirement",
    "href": "control-1.html#stability-the-non-negotiable-requirement",
    "title": "Introduction to Control Systems",
    "section": "Stability: The Non-Negotiable Requirement",
    "text": "Stability: The Non-Negotiable Requirement\nTotal response = natural response + forced response\n\\[\n\\text{Total response} = \\text{Natural response} + \\text{Forced response}\n\\]\n\nNatural response – how the system behaves due to its own dynamics (homogeneous solution).\nForced response – driven directly by the input (particular solution).\n\nA useful control system must have a natural response that:\n\nDecays to zero as time → ∞, or\nOscillates with bounded amplitude.\n\nIf the natural response grows without bound, the system is unstable:\n\nElevator overspeeds and crashes limit stops.\nAircraft diverges into uncontrollable roll.\nAntenna oscillates with increasing amplitude, hitting mechanical stops.\n\n\n\n\n\n\n\nWarning\n\n\nIf the system is unstable, discussions of transient response and steady-state error are meaningless. Stability is the first checkpoint.\n\n\n\n\nMention that in many linear systems, we can infer stability directly from pole locations or Routh-Hurwitz tables. Assure students that they’ll learn precise stability tests, but the intuition is: does the system “settle” or “blow up”?"
  },
  {
    "objectID": "control-1.html#other-design-considerations",
    "href": "control-1.html#other-design-considerations",
    "title": "Introduction to Control Systems",
    "section": "Other Design Considerations",
    "text": "Other Design Considerations\nBeyond transient, SSE, and stability, we must consider:\n\nHardware constraints\n\nMotor torque and speed limits.\nSensor accuracy, range, and bandwidth.\nActuator saturation and dead zones.\n\nCost and manufacturability\n\nComponent selection vs. budget.\nCost per unit for mass-produced products.\n\nRobustness / Sensitivity\n\nReal systems’ parameters change (temperature, aging, wear).\nA robust design maintains performance despite parameter variations.\nSensitivity analysis quantifies how much specs change when parameters change.\n\n\n\nForeshadow that Chapters 7–8 will look at sensitivity and robustness in more mathematical detail. Point out that several mathematically “optimal” designs are rejected in practice because they are too sensitive or fragile."
  },
  {
    "objectID": "control-1.html#case-study-antenna-azimuth-control",
    "href": "control-1.html#case-study-antenna-azimuth-control",
    "title": "Introduction to Control Systems",
    "section": "Case Study: Antenna Azimuth Control",
    "text": "Case Study: Antenna Azimuth Control\n\n\n\nRadio antenna with position control\n\n\n\nWe want an antenna to rotate (azimuth) to a commanded angle.\nTypical ECE components:\n\nPotentiometer for position sensing.\nAmplifiers for signal and power.\nDC motor and gears to move the antenna.\n\n\nThis is a position control system, similar in spirit to: - Robot joint control. - Camera pan/tilt platforms. - Radar and satellite dish pointing.\n\nTell students that by understanding this one system well, they gain insight applicable to many other systems with similar structure."
  },
  {
    "objectID": "control-1.html#antenna-azimuth-system-layout",
    "href": "control-1.html#antenna-azimuth-system-layout",
    "title": "Introduction to Control Systems",
    "section": "Antenna Azimuth System Layout",
    "text": "Antenna Azimuth System Layout\n \nGoal: output angle \\(\\theta_o(t)\\) tracks input command \\(\\theta_i(t)\\).\nFlow (qualitative):\n\nInput angle \\(\\theta_i(t)\\) → potentiometer → input voltage.\nOutput angle \\(\\theta_o(t)\\) → feedback potentiometer → feedback voltage.\nError = input voltage – feedback voltage.\nSignal and power amplifiers amplify error to drive DC motor.\nMotor + load rotate antenna until error ≈ 0.\n\n\nWalk through both physical layout and block diagram: - Physical: students see actual motor, gears, potentiometers. - Functional: they see how to abstract to blocks.\nEmphasize that in steady state (no disturbance), motor stops when input and output match."
  },
  {
    "objectID": "control-1.html#effect-of-controller-gain-on-response",
    "href": "control-1.html#effect-of-controller-gain-on-response",
    "title": "Introduction to Control Systems",
    "section": "Effect of Controller Gain on Response",
    "text": "Effect of Controller Gain on Response\n\n\n\nEffect of controller gain on response\n\n\n\nWith low gain:\n\nMotor turns slowly.\nResponse is sluggish; long time to reach final angle.\nOften no overshoot.\n\nWith high gain:\n\nMotor turns faster toward target.\nMay overshoot and oscillate before settling.\nCan produce damped oscillations (under-damped response).\n\n\nSteady-state value may still be exactly correct (zero steady-state error) in both cases, but transients differ.\n\nClarify that, for this system type and step input, increasing gain usually reduces steady-state error but can worsen overshoot and oscillations. Point out that later we’ll see “too much gain” eventually causes instability."
  },
  {
    "objectID": "control-1.html#need-for-more-than-just-gain-compensators",
    "href": "control-1.html#need-for-more-than-just-gain-compensators",
    "title": "Introduction to Control Systems",
    "section": "Need for More Than Just Gain: Compensators",
    "text": "Need for More Than Just Gain: Compensators\nSometimes, adjusting only the gain cannot meet both:\n\nA desired fast, well-damped transient response, and\nA desired small steady-state error.\n\nSolution: use a controller with dynamic behavior, e.g.:\n\nAdd integrators or filters in the controller.\nImplement full PID controllers or lead/lag compensators.\nPossibly add dynamic elements in the feedback path.\n\nThese added dynamics are called compensators.\n\n\n\n\n\n\nNote\n\n\nCompensators give us more degrees of freedom to shape both transient and steady-state performance, at the price of more complexity.\n\n\n\n\nExplain that a pure gain can sometimes force a trade-off (overshoot vs SSE). Compensators (e.g., lead, lag, PID) help to break this trade-off in many cases. You don’t need to define specific compensators yet—that comes in later chapters."
  },
  {
    "objectID": "control-1.html#the-control-system-design-process",
    "href": "control-1.html#the-control-system-design-process",
    "title": "Introduction to Control Systems",
    "section": "1.5 The Control System Design Process",
    "text": "1.5 The Control System Design Process\n\n\n\nDesign process flow\n\n\nTypical steps:\n\nTransform requirements into a physical system concept.\nDraw a functional block diagram.\nCreate a schematic with actual components.\nDevelop a mathematical model (differential equations, transfer functions, or state-space).\nReduce to an equivalent block diagram (simplify interconnections).\nAnalyze and design to meet performance specs; iterate with testing.\n\n\nEmphasize that real design is iterative: - If testing (Step 6) fails, you may need to refine the schematic (Step 3) or even revisit requirements (Step 1). Mention that this flow will structure the rest of the course."
  },
  {
    "objectID": "control-1.html#step-1-from-requirements-to-physical-system",
    "href": "control-1.html#step-1-from-requirements-to-physical-system",
    "title": "Introduction to Control Systems",
    "section": "Step 1 – From Requirements to Physical System",
    "text": "Step 1 – From Requirements to Physical System\nRequirements might say:\n\nAntenna must track commands with:\n\nMax settling time: e.g., 1 second.\nMax overshoot: e.g., 10%.\nMax steady-state error: small fraction of a degree.\n\nConstraints: weight, size, power, environmental limits.\nOperational needs: remote operation, maintainability.\n\nFrom these, we propose a physical concept, like Figure 1.8(a): - Antenna + gear train + motor + sensors + electronics.\n\nHighlight that interpreting vague or verbal requirements into precise performance specs is a key engineering skill. Explain that at this stage you think qualitatively about architecture, not detailed math."
  },
  {
    "objectID": "control-1.html#step-2-functional-block-diagram",
    "href": "control-1.html#step-2-functional-block-diagram",
    "title": "Introduction to Control Systems",
    "section": "Step 2 – Functional Block Diagram",
    "text": "Step 2 – Functional Block Diagram\nWe translate the physical idea into functional blocks:\n\nInput transducer (potentiometer).\nController (amplifiers, logic).\nPlant (motor + load).\nOutput transducer (feedback potentiometer).\n\n\n\n\nFunctional block diagram of antenna system\n\n\n\nStress that block diagrams are about functions and interconnections, not exact component values. They are a bridge between physical understanding and mathematical modeling."
  },
  {
    "objectID": "control-1.html#step-3-schematic-diagram",
    "href": "control-1.html#step-3-schematic-diagram",
    "title": "Introduction to Control Systems",
    "section": "Step 3 – Schematic Diagram",
    "text": "Step 3 – Schematic Diagram\nNext, we draw a more detailed electrical / mechanical schematic:\n\nShow potentiometers, amplifiers, motor, gear train, load inertia, friction.\nMake simplifying assumptions:\n\nPotentiometer inertia and friction negligible.\nAmplifier dynamics much faster than motor → model as pure gain \\(K\\).\nDC motor armature inductance small → model with resistance only.\n\n\n\n\n\nAntenna schematic (simplified)\n\n\n\nExplain that we deliberately simplify to get a tractable model, then later verify these approximations via analysis and experimental testing."
  },
  {
    "objectID": "control-1.html#step-4-mathematical-model",
    "href": "control-1.html#step-4-mathematical-model",
    "title": "Introduction to Control Systems",
    "section": "Step 4 – Mathematical Model",
    "text": "Step 4 – Mathematical Model\nWe use physical laws to derive equations:\n\nKirchhoff’s voltage law (KVL) – sum of voltages around any closed loop is zero.\nKirchhoff’s current law (KCL) – sum of currents at a node is zero.\nNewton’s laws – sum of forces (or torques) equals mass (or inertia) times acceleration.\n\nFor many systems, the model is a linear, time-invariant (LTI) differential equation:\n\\[\n\\frac{d^{n} c(t)}{dt^{n}}\n+ a_{n-1} \\frac{d^{n-1} c(t)}{dt^{n-1}}\n+ \\cdots + a_0 c(t)\n=\nb_m \\frac{d^{m} r(t)}{dt^{m}}\n+ b_{m-1} \\frac{d^{m-1} r(t)}{dt^{m-1}}\n+ \\cdots + b_0 r(t)\n\\]\nWhere:\n\n\\(c(t)\\) = output, \\(r(t)\\) = input.\nCoefficients \\(a_i, b_j\\) are functions of physical parameters.\n\nAlternative models:\n\nTransfer functions (Laplace domain).\nState-space models (first-order vector form).\n\n\nYou don’t need to derive the equation in class here, but do stress: - Linear models are approximations; they’re powerful because they enable analytic design. - Nonlinear or time-varying aspects may be considered later or in simulations."
  },
  {
    "objectID": "control-1.html#step-5-block-diagram-reduction",
    "href": "control-1.html#step-5-block-diagram-reduction",
    "title": "Introduction to Control Systems",
    "section": "Step 5 – Block Diagram Reduction",
    "text": "Step 5 – Block Diagram Reduction\nWe interconnect subsystem transfer functions to get an overall block diagram.\nFor the antenna azimuth system, we can reduce the full diagram to an equivalent single block:\n\n\n\nEquivalent antenna block diagram\n\n\nThis “big” transfer function describes the relationship between:\n\nInput: commanded angle \\(\\Theta_i(s)\\).\nOutput: antenna angle \\(\\Theta_o(s)\\).\n\n\nMention that Chapter 5 will cover formal rules for combining blocks in series, parallel, and feedback to get an equivalent transfer function."
  },
  {
    "objectID": "control-1.html#step-6-analyze-and-design",
    "href": "control-1.html#step-6-analyze-and-design",
    "title": "Introduction to Control Systems",
    "section": "Step 6 – Analyze and Design",
    "text": "Step 6 – Analyze and Design\nNow we:\n\nApply standard test inputs to predict performance:\n\nImpulse, step, ramp, parabola, sinusoid.\n\nAnalyze:\n\nStability.\nTransient response metrics.\nSteady-state error.\n\nDesign / tune:\n\nAdjust gains.\nAdd compensators.\nPossibly revise earlier steps if specs cannot be met.\n\n\nStandard test inputs (from Table 1.1):\n\nImpulse \\(\\delta(t)\\) → pure transient characterization, modeling.\nStep \\(u(t)\\) → transient + steady-state error.\nRamp \\(t u(t)\\), parabola \\(\\frac12 t^2 u(t)\\) → steady-state tracking quality.\nSinusoid \\(\\sin \\omega t\\) → frequency response and modeling.\n\n\n\n\n\n\nimpulse\n\n\n\n\n\n\nstep\n\n\n\n\n\n\nramp\n\n\n\n\n\n\nparabola\n\n\n\n\n\n\nsinusoid\n\n\n\n\n\nEmphasize that these simple inputs are mathematically convenient and still capture key aspects of performance. We often design so these test responses meet specs, which correlates well with performance under more complicated real inputs."
  },
  {
    "objectID": "control-1.html#interactive-exercise-step-response-intuition",
    "href": "control-1.html#interactive-exercise-step-response-intuition",
    "title": "Introduction to Control Systems",
    "section": "Interactive Exercise – Step Response Intuition",
    "text": "Interactive Exercise – Step Response Intuition\nUse this interactive block to explore how gain affects a second-order system’s step response.\n\nviewof wn = Inputs.range([0.1, 10], {step: 0.1, value: 2, label: \"Natural frequency ω_n\"})\nviewof zeta = Inputs.range([0, 2], {step: 0.05, value: 0.4, label: \"Damping ratio ζ\"})\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nAsk students to: - Decrease ζ → observe more oscillations and overshoot. - Increase ζ → slower but smoother response. - Increase ωₙ → faster system overall.\nTie this back to the antenna example: gain changes effectively modify these parameters."
  },
  {
    "objectID": "control-1.html#computer-aided-design-cad",
    "href": "control-1.html#computer-aided-design-cad",
    "title": "Introduction to Control Systems",
    "section": "1.6 Computer-Aided Design (CAD)",
    "text": "1.6 Computer-Aided Design (CAD)\nHistorically:\n\nControl design involved hand calculations and manual plotting.\nLarge mainframes were needed for complex simulations.\n\nToday:\n\nDesktop/laptop tools like MATLAB + Control System Toolbox, Simulink, LabVIEW, and others allow:\n\nEasy simulation of linear and nonlinear systems.\nRapid “what-if” tuning of parameters.\nAutomated plotting of time and frequency responses.\nDesign and optimization of controllers (PID, state feedback, etc.).\n\n\n\n\n\n\n\n\nTip\n\n\nIn this course, you should: - First understand the theory and hand calculations. - Then use tools like MATLAB to speed up analysis and explore more complex designs.\n\n\n\n\nWarn students against becoming “button-pushers”: the tools are powerful, but only if they understand what the plots and numbers mean."
  },
  {
    "objectID": "control-1.html#the-control-systems-engineer",
    "href": "control-1.html#the-control-systems-engineer",
    "title": "Introduction to Control Systems",
    "section": "1.7 The Control Systems Engineer",
    "text": "1.7 The Control Systems Engineer\nA control systems engineer often:\n\nWorks at a system level defining and refining requirements.\nInterfaces with multiple disciplines:\n\nElectrical, mechanical, chemical, aerospace, biomedical.\nComputer science / software, applied mathematics, physics.\n\nEngages in top-down design:\n\nStart with system-level goals and constraints.\nBreak them down into subsystems and detailed designs.\n\n\nBenefits of studying control systems:\n\nYou will see how earlier courses (circuits, signals, mechanics, programming) fit into a unified system design process.\nYou learn a common language that bridges different engineering domains.\n\n\nReassure students that this course will help them connect many bits of their curriculum into a coherent whole. Encourage them to think of control as a “glue discipline” that makes systems intelligent and robust."
  },
  {
    "objectID": "control-1.html#summary-key-points",
    "href": "control-1.html#summary-key-points",
    "title": "Introduction to Control Systems",
    "section": "Summary / Key Points",
    "text": "Summary / Key Points\n\nA control system regulates a plant’s output to follow a desired input, often in the presence of disturbances.\nControl systems are everywhere: elevators, antennas, disk drives, robots, power converters, biological systems, and more.\nThere are two main architectures:\n\nOpen-loop – simple but cannot correct for disturbances.\nClosed-loop (feedback) – uses output measurement to reduce error and improve robustness.\n\nCore performance objectives:\n\nDesired transient response.\nSmall steady-state error.\nGuaranteed stability.\n\nThe design process follows an ordered sequence: from requirements → physical concept → functional diagram → schematic → mathematical model → analysis and design.\nComputer tools (MATLAB, Simulink, LabVIEW, etc.) are essential, but must be used with understanding.\nThe antenna azimuth position control system provides a concrete case study to illustrate these ideas throughout the course.\n\n\nUse this slide as a quick recap. Ask students to volunteer one real-world control system they’ve encountered and identify: input, plant, output, feedback (if any)."
  },
  {
    "objectID": "control-1.html#formula-concept-summary",
    "href": "control-1.html#formula-concept-summary",
    "title": "Introduction to Control Systems",
    "section": "Formula & Concept Summary",
    "text": "Formula & Concept Summary\nAlthough this chapter is mostly conceptual, remember these key mathematical ideas and terms:\n\nTotal response decomposition: \\[\n\\text{Total response} = \\text{Natural response} + \\text{Forced response}\n\\]\nStandard linear differential equation model (LTI system): \\[\n\\frac{d^{n} c(t)}{dt^{n}}\n+ a_{n-1} \\frac{d^{n-1} c(t)}{dt^{n-1}}\n+ \\cdots + a_0 c(t)\n=\nb_m \\frac{d^{m} r(t)}{dt^{m}}\n+ b_{m-1} \\frac{d^{m-1} r(t)}{dt^{m-1}}\n+ \\cdots + b_0 r(t)\n\\]\nKey performance concepts (to be quantified later):\n\nTransient response – rise time, overshoot, settling time, damping.\nSteady-state error – final error for step/ramp/parabola inputs.\nStability – whether natural response decays or grows unbounded.\n\nStandard test inputs (Table 1.1):\n\nImpulse: \\(\\delta(t)\\).\nStep: \\(u(t)\\).\nRamp: \\(t\\,u(t)\\).\nParabola: \\(\\frac{1}{2} t^2 u(t)\\).\nSinusoid: \\(\\sin \\omega t\\).\n\n\n\nMention that upcoming chapters will: - Turn these conceptual definitions into precise mathematical metrics. - Show how to derive transfer functions and state-space models from schematics. - Use these formulas to actually design controllers."
  },
  {
    "objectID": "control-1.html#practice-problem-conceptual",
    "href": "control-1.html#practice-problem-conceptual",
    "title": "Introduction to Control Systems",
    "section": "Practice Problem (Conceptual)",
    "text": "Practice Problem (Conceptual)\nYou press the accelerator pedal in a car to go from 40 km/h to 60 km/h using cruise control.\n\nIdentify:\n\nInput (reference).\nPlant.\nOutput.\nFeedback signal.\n\nSuppose the cruise control is disabled and you manually hold the pedal at a fixed position.\n\nIs this open-loop or closed-loop control?\nWhat kind of disturbances might affect your speed?\n\nWith cruise control enabled, what advantages does closed-loop control give compared to holding the pedal manually?\n\n\nUse this as in-class discussion or a quiz. Tie answers back to open-loop vs closed-loop, disturbance rejection, and driver as a (slow, imprecise) feedback element vs electronic controller."
  },
  {
    "objectID": "control-1.html#next-steps",
    "href": "control-1.html#next-steps",
    "title": "Introduction to Control Systems",
    "section": "Next Steps",
    "text": "Next Steps\nIn the next chapter, we will:\n\nLearn how to derive mathematical models (transfer functions, state-space) from electrical and mechanical schematics.\nStart connecting physical parameters (mass, resistance, inductance, gain) to dynamic behavior.\nApply these techniques to the antenna azimuth case study.\n\nEncouraged preparation:\n\nReview basic differential equations (homogeneous + particular solutions).\nReview Laplace transforms and linear time-invariant systems if you’ve seen them.\n\n\nEnd by setting expectations: some math is coming, but it will be grounded in physical systems like the antenna. Remind students that the conceptual picture from this chapter should guide their understanding of all the upcoming technical details."
  },
  {
    "objectID": "ICCT_en/Table-of-Contents-ICCT.html",
    "href": "ICCT_en/Table-of-Contents-ICCT.html",
    "title": "\nInteractive Course for Control Theory\n",
    "section": "",
    "text": "# Erasmus+ ICCT project (2018-1-SI01-KA203-047081)\n\n# Hide the code completely\n\nfrom IPython.display import HTML\ntag = HTML('''&lt;style&gt;div.input{display:none;}&lt;/style&gt;''')\ndisplay(tag)\nWelcome to the Interactive Course for Control Theory (ICCT) platform!\nThe interactive examples are organized in four chapters: Mathematical Examples, Time-domain Examples, Frequency-domain Examples and State-space Examples."
  },
  {
    "objectID": "ICCT_en/Table-of-Contents-ICCT.html#table-of-contents",
    "href": "ICCT_en/Table-of-Contents-ICCT.html#table-of-contents",
    "title": "\nInteractive Course for Control Theory\n",
    "section": "Table of Contents",
    "text": "Table of Contents\n\n1. Mathematical Examples\n1.1 Complex Numbers        1.1.1 Complex Numbers in Cartesian Form        1.1.2 Complex Numbers in Polar Form        1.1.2 Powers of Complex Numbers 1.2 Derivatives of Polynomials 1.3 Integrals of Polynomials 1.4 Matrix Operations 1.5 Functions and Their Graphs 1.6 Fast-Fourier Transform (FFT) 1.7 Laplace Transform\n\n\n2. Time-domain Examples\n2.1 Water Level Control System 2.2 Antenna Azimuth Position Control System 2.3 Mechanical Systems 2.4 Differential Equations 2.5 Linearization\n       2.5.1 Linearization of a Function        2.5.2 Linearization of a Simple Pendulum 2.6 Poles, Zeros - Basics 2.7 Pole/Zero Placement 2.8 Partial Fraction Decomposition 2.9 First- and Second-Order Systems - Basics 2.10 Time Response of the First-Order Systems 2.11 Dominant Pole Approximation 2.12 Loading Problem 2.13 Routh and Hurwitz Stability Criterion 2.14 PID Controller        2.14.1 Time Response        2.14.2 Closed-Loop System 2.15 Steady-state Error 2.16 Root Locus\n\n\n3. Frequency-domain Examples\n3.1 Transfer Functions 3.2 Bode Diagram 3.3 Nyquist Diagram 3.4 Negative Feedback systems 3.5 Gain and Phase Margin 3.6 PID Controller - Basics        3.6.1 Tuning a PID controller        3.6.2 PID Control of First-Order Systems        3.6.3 PID Control of First-Order Systems with Integrator        3.6.4 Control of First-Order Systems with Time Delay        3.6.5 PID Control of Second-Order Undamped and Critically Damped Systems        3.6.6 PID Control of Second-Order Underdamped Systems        3.6.7 PID Control of Second-Order Overdamped Systems        3.6.8 PID Disturbance Rejection        3.6.9 Discrete PID Control of Continuous First-Order Systems        3.6.10 Discrete PID Control of Continuous Second-Order Systems 3.7 PID Controller Design        3.7.1 Operational Amplifier – P Controller        3.7.2 Operational Amplifier – PI Controller        3.7.3 Operational Amplifier – PD Controller        3.7.4 Operational Amplifier – PID Controller 3.8 Real-world Systems        3.8.1 Mass-Spring-Damper        3.8.2 Ball and Beam        3.8.3 DC Motor        3.8.4 Ballscrew Positioner        3.8.5 Pendulum on a Cart\n\n\n4. State-space Examples\n4.1 Solution of Differential Equations in Matrix Form 4.2 Modal Analysis 4.3 Diagonal Matrices        4.3.1 Convergent Modes Only        4.3.2 Divergent Modes 4.4 Jordan Form        4.4.1 Jordan Form with Real Eigenvalues        4.4.2 Jordan Form with Complex Eigenvalues 4.5 Transition From Differential Equation to State Space Form 4.6 Modal Analysis of the Mass-Spring-Damper System 4.7 Car Speed Dynamics        4.7.1 Modal Analysis of Car Speed Dynamics 4.8 Lunar Lander Lateral Position Dynamics        4.8.1 Modal Analysis of Lunar Lander 4.9 Equilibrium Points        4.9.1 Example 1        4.9.2 Example 2        4.9.3 Example 3 4.10 Internal Stability        4.10.1 Example 1        4.10.2 Example 2        4.10.3 Example 3        4.10.4 Example 4 4.11 Observability 4.12 Controllability 4.13 State Space Formulation and Transfer Function 4.14 Internal and External Stability 4.15 Asymptotic Observer 4.16 Luenberger Observer with Dynamic Requirements 4.17 Observer for the Mass-Spring-Damper System 4.18 Observer for Unobservable Plants 4.19 State Feedback Control        4.19.1 State Feedback Control - Performance        4.19.2 State Feedback Control - Tracking Specifications        4.19.3 State Feedback Control for Mass-Spring-Damper System 4.20 Regulator Design        4.20.1 Regulator for Mass-Spring-Damper System 4.21 Real-world Examples        4.21.1 Satellite Orbit Control        4.21.2 Quadrotor Longitudinal Velocity Control        4.21.3 Lunar Lander Horizontal Position Control        4.21.4 Crane Load Position Control        4.21.5 Robotic Arm with Flexible Joint Control        4.21.6 Rotary Actuator Position Control        4.21.7 Missile Attitude Control        4.21.8 Hard Disk Head Control        4.21.9 Car Cruise Control        4.21.10 Aircraft Taxi Trajectory Control        4.21.11 Quadrotor Lateral Position Control        4.21.12 Pneumatic Position Control        4.21.13 Autonomous Underwater Vehicle (AUV) Velocity Control        4.21.14 Autonomous Underwater Vehicle (AUV) Heading Control        4.21.15 Autonomous Underwater Vehicle (AUV) Depth Control\n\n\nRead more about the ICCT project on our website."
  },
  {
    "objectID": "ICCT_en/examples/04/SS-50-AUV_depth_control.html",
    "href": "ICCT_en/examples/04/SS-50-AUV_depth_control.html",
    "title": "Autonomous Underwater Vehicle (AUV) depth control",
    "section": "",
    "text": "#remove cell visibility\nfrom IPython.display import HTML\ntag = HTML('''&lt;script&gt;\ncode_show=true; \nfunction code_toggle() {\n    if (code_show){\n        $('div.input').hide()\n    } else {\n        $('div.input').show()\n    }\n    code_show = !code_show\n} \n$( document ).ready(code_toggle);\n&lt;/script&gt;\nToggle cell visibility &lt;a href=\"javascript:code_toggle()\"&gt;here&lt;/a&gt;.''')\ndisplay(tag)\n\n\nToggle cell visibility here.\n\n\n\n%matplotlib inline\nimport control\nimport numpy\nimport sympy as sym\nfrom IPython.display import display, Markdown\nimport ipywidgets as widgets\nimport matplotlib.pyplot as plt\n\n\n#print a matrix latex-like\ndef bmatrix(a):\n     \"\"\"Returns a LaTeX bmatrix - by Damir Arbula (ICCT project)\n\n     :a: numpy array\n     :returns: LaTeX bmatrix as a string\n     \"\"\"\n     if len(a.shape) &gt; 2:\n         raise ValueError('bmatrix can at most display two dimensions')\n     lines = str(a).replace('[', '').replace(']', '').splitlines()\n     rv = [r'\\begin{bmatrix}']\n     rv += ['  ' + ' & '.join(l.split()) + r'\\\\' for l in lines]\n     rv +=  [r'\\end{bmatrix}']\n     return '\\n'.join(rv)\n\n\n# Display formatted matrix: \ndef vmatrix(a):\n    if len(a.shape) &gt; 2:\n         raise ValueError('bmatrix can at most display two dimensions')\n    lines = str(a).replace('[', '').replace(']', '').splitlines()\n    rv = [r'\\begin{vmatrix}']\n    rv += ['  ' + ' & '.join(l.split()) + r'\\\\' for l in lines]\n    rv +=  [r'\\end{vmatrix}']\n    return '\\n'.join(rv)\n\n\n#matrixWidget is a matrix looking widget built with a VBox of HBox(es) that returns a numPy array as value !\nclass matrixWidget(widgets.VBox):\n    def updateM(self,change):\n        for irow in range(0,self.n):\n            for icol in range(0,self.m):\n                self.M_[irow,icol] = self.children[irow].children[icol].value\n                #print(self.M_[irow,icol])\n        self.value = self.M_\n\n    def dummychangecallback(self,change):\n        pass\n    \n    \n    def __init__(self,n,m):\n        self.n = n\n        self.m = m\n        self.M_ = numpy.matrix(numpy.zeros((self.n,self.m)))\n        self.value = self.M_\n        widgets.VBox.__init__(self,\n                             children = [\n                                 widgets.HBox(children = \n                                              [widgets.FloatText(value=0.0, layout=widgets.Layout(width='90px')) for i in range(m)]\n                                             ) \n                                 for j in range(n)\n                             ])\n        \n        #fill in widgets and tell interact to call updateM each time a children changes value\n        for irow in range(0,self.n):\n            for icol in range(0,self.m):\n                self.children[irow].children[icol].value = self.M_[irow,icol]\n                self.children[irow].children[icol].observe(self.updateM, names='value')\n        #value = Unicode('example@example.com', help=\"The email value.\").tag(sync=True)\n        self.observe(self.updateM, names='value', type= 'All')\n        \n    def setM(self, newM):\n        #disable callbacks, change values, and reenable\n        self.unobserve(self.updateM, names='value', type= 'All')\n        for irow in range(0,self.n):\n            for icol in range(0,self.m):\n                self.children[irow].children[icol].unobserve(self.updateM, names='value')\n        self.M_ = newM\n        self.value = self.M_\n        for irow in range(0,self.n):\n            for icol in range(0,self.m):\n                self.children[irow].children[icol].value = self.M_[irow,icol]\n        for irow in range(0,self.n):\n            for icol in range(0,self.m):\n                self.children[irow].children[icol].observe(self.updateM, names='value')\n        self.observe(self.updateM, names='value', type= 'All')        \n\n                #self.children[irow].children[icol].observe(self.updateM, names='value')\n\n             \n#overlaod class for state space systems that DO NOT remove \"useless\" states (what \"professor\" of automatic control would do this?)\nclass sss(control.StateSpace):\n    def __init__(self,*args):\n        #call base class init constructor\n        control.StateSpace.__init__(self,*args)\n    #disable function below in base class\n    def _remove_useless_states(self):\n        pass\n\nDynamics of the pitch angle \\(\\theta\\) of an Autonomous Underwater Vehicle (AUV) can be modelled as:\n\\[\nJ_y\\ddot{\\theta}=−D\\dot{\\theta}+CV\\gamma,\n\\] where \\(J_y=8.333\\) kg\\(\\text{m}^2\\) is the vehicle moment of inertia around the pitch axis, \\(D = 30\\) Nms the drag coefficient, \\(C=45\\) Ns the tail fin effectiveness coefficient, \\(\\gamma\\) the tail fin angle (expressed in radians and to be kept within \\(\\pm10°\\)), and \\(V\\) current cruising speed in m/s.\nThe vertical (heave) velocity \\(w\\) of an AUV can be modelled approximately as: \\[\nw = V\\theta.\n\\]\nFor safety reasons, the pitch angle should never exceed \\(\\pm20°\\) during operation. Pitch angle and depth (\\(z\\)) are measured by a Navigation Filter.\nThe dynamics equations in state space form are\n\\[\\begin{cases}\n    \\dot{x} = \\begin{bmatrix} -D/J_y & 0 & 0 \\\\ 1 & 0 & 0 \\\\ 0 & V & 0 \\end{bmatrix}x + \\begin{bmatrix} CV/J_y \\\\ 0 \\\\ 0 \\end{bmatrix}u\\\\\n    y = \\begin{bmatrix} 0 & 1 & 0 \\\\ 0 & 0 & 1 \\end{bmatrix}x,\n\\end{cases}\\]\nwhere \\(x=\\begin{bmatrix} x_1 & x_2 & x_3 \\end{bmatrix}^T=\\begin{bmatrix} \\dot{\\theta} & \\theta & z \\end{bmatrix}^T\\) and \\(u=\\gamma\\).\nConsidering \\(V=1\\) m/s constant, we want to develop a regulator for \\(z\\) which allows to have zero steady-state error in response to a step position request.\n\nRegulator design\n\nController design\nTo meet the requirements we first add a new state: \\[\n\\dot{x_4} = z-y_d = x_3 - y_d\n\\] The resulting augmented system is thus:\n\\[\\begin{cases}\n    \\dot{x_a} = \\begin{bmatrix} -D/J_y & 0 & 0 & 0 \\\\ 1 & 0 & 0 & 0 \\\\ 0 & V & 0 & 0 \\\\ 0 & 0 & 1 & 0 \\end{bmatrix}x_a + \\begin{bmatrix} CV/J_y & 0 \\\\ 0 & 0 \\\\ 0 & 0 \\\\ 0 & -1 \\end{bmatrix} \\begin{bmatrix} u \\\\ y_d \\end{bmatrix}\\\\\n    y = \\begin{bmatrix} 0 & 1 & 0 & 0 \\\\ 0 & 0 & 1 & 0 \\\\ 0 & 0 & 0 & 1 \\end{bmatrix}x_a,\n\\end{cases}\\]\nwhere \\(x_a = \\begin{bmatrix} x_1 & x_2 & x_3 & x_4 \\end{bmatrix}^T = \\begin{bmatrix} \\dot{\\theta} & \\theta & z & x_4 \\end{bmatrix}^T\\).\nWith the first input \\(u\\), since the system is controllable, we place the poles in order to stabilize the system and respect the limits on \\(u\\) (\\(\\pm10°\\)) and \\(\\theta\\) (\\(\\pm20°\\)) when giving a step of \\(y_d=1\\) m. A possible solution is to place the poles in \\(-5.9\\), \\(-0.9\\) and \\(-0.63\\pm0.70i\\).\n\n\nObserver design\nWe have the measurements of \\(x_2\\), \\(x_3\\) and \\(x_4\\) so we need only to estimate \\(x_1\\). We can work with the subsystem \\(x_l =\\begin{bmatrix} x_1 & x_2 \\end{bmatrix}^T\\), \\(\\dot{x_l}=A_lx_l + B_lu\\) and \\(y_l = x_2 = C_lx_l\\). Defining \\(L=\\begin{bmatrix} l_1 & l_2 \\end{bmatrix}^T\\) we can calculate the eigenvalues \\(\\lambda_1\\) and \\(\\lambda_2\\) of \\(A_l-LC_l\\) and solve for \\(l_1\\) and \\(l_2\\):\n\\[\\begin{cases}\nl_1 = \\lambda_1\\lambda_2 + D\\lambda_1/J_y + D\\lambda_2/J_y + D^2/J_y^2 \\\\\nl_2 = -\\lambda_1 - \\lambda_2 - D/J_y \\, .\n\\end{cases}\\]\nWe choose \\(\\lambda_1 = \\lambda_2 = -15\\).\n\n\n\nHow to use this notebook?\n\nTry, changing the poles of the controller, to meet the requirements with \\(V = 0.75\\) m/s.\nVerify the behaviour of the regulator in presence of an initial error in the estimate and try to improve its performance.\n\n\n# Preparatory cell\n\nX0 = numpy.matrix('0.0')\nK = numpy.matrix([0,0,0,0])\nL = numpy.matrix([[0],[0]])\n\nX0w = matrixWidget(1,1)\nX0w.setM(X0)\nKw = matrixWidget(1,4)\nKw.setM(K)\nLw = matrixWidget(2,1)\nLw.setM(L)\n\n\neig1c = matrixWidget(1,1)\neig2c = matrixWidget(2,1)\neig3c = matrixWidget(1,1)\neig4c = matrixWidget(2,1)\neig1c.setM(numpy.matrix([-5.7])) \neig2c.setM(numpy.matrix([[-0.63],[-0.70]]))\neig3c.setM(numpy.matrix([-0.9]))\neig4c.setM(numpy.matrix([[-0.63],[-0.70]]))\n\neig1o = matrixWidget(1,1)\neig2o = matrixWidget(2,1)\neig1o.setM(numpy.matrix([-15.])) \neig2o.setM(numpy.matrix([[-15.],[0.]]))\n\n\n# Misc\n\n#create dummy widget \nDW = widgets.FloatText(layout=widgets.Layout(width='0px', height='0px'))\n\n#create button widget\nSTART = widgets.Button(\n    description='Test',\n    disabled=False,\n    button_style='', # 'success', 'info', 'warning', 'danger' or ''\n    tooltip='Test',\n    icon='check'\n)\n                       \ndef on_start_button_clicked(b):\n    #This is a workaround to have intreactive_output call the callback:\n    #   force the value of the dummy widget to change\n    if DW.value&gt; 0 :\n        DW.value = -1\n    else: \n        DW.value = 1\n    pass\nSTART.on_click(on_start_button_clicked)\n\n# Define type of method \nselm = widgets.Dropdown(\n    options= ['Set K and L', 'Set the eigenvalues'],\n    value= 'Set the eigenvalues',\n    description='',\n    disabled=False\n)\n\n# Define the number of complex eigenvalues\nselec = widgets.Dropdown(\n    options= ['0 complex eigenvalues', '2 complex eigenvalues', '4 complex eigenvalues'],\n    value= '2 complex eigenvalues',\n    description='Eig controller:',\n    disabled=False\n)\nseleo = widgets.Dropdown(\n    options= ['0 complex eigenvalues', '2 complex eigenvalues'],\n    value= '0 complex eigenvalues',\n    description='Eig observer:',\n    disabled=False\n)\n\n#define type of ipout \nselu = widgets.Dropdown(\n    options=['impulse', 'step', 'sinusoid', 'square wave'],\n    value='step',\n    description='Type of reference:',\n    style = {'description_width': 'initial'},\n    disabled=False\n)\n# Define the values of the input\nu = widgets.FloatSlider(\n    value=1,\n    min=0,\n    max=4,\n    step=0.1,\n    description='',\n    disabled=False,\n    continuous_update=False,\n    orientation='horizontal',\n    readout=True,\n    readout_format='.1f',\n)\nv = widgets.FloatSlider(\n    value=1,\n    min=0.5,\n    max=4,\n    step=0.1,\n    description=r'$V$:',\n    disabled=False,\n    continuous_update=False,\n    orientation='horizontal',\n    readout=True,\n    readout_format='.1f',\n)\nperiod = widgets.FloatSlider(\n    value=0.5,\n    min=0.001,\n    max=10,\n    step=0.001,\n    description='Period: ',\n    disabled=False,\n    continuous_update=False,\n    orientation='horizontal',\n    readout=True,\n    readout_format='.2f',\n)\n\nsimTime = widgets.FloatText(\n    value=10,\n    description='',\n    disabled=False\n)\n\n\n# Support functions\n\ndef eigen_choice(selec,seleo):\n    if selec == '0 complex eigenvalues':\n        eig1c.children[0].children[0].disabled = False\n        eig2c.children[1].children[0].disabled = True\n        eig3c.children[0].children[0].disabled = False\n        eig4c.children[0].children[0].disabled = False\n        eig4c.children[1].children[0].disabled = True\n        eigc = 0\n    if seleo == '0 complex eigenvalues':\n        eig1o.children[0].children[0].disabled = False\n        eig2o.children[1].children[0].disabled = True\n        eigo = 0\n    if selec == '2 complex eigenvalues':\n        eig1c.children[0].children[0].disabled = False\n        eig2c.children[1].children[0].disabled = False\n        eig3c.children[0].children[0].disabled = False\n        eig4c.children[0].children[0].disabled = True\n        eig4c.children[1].children[0].disabled = True\n        eigc = 2\n    if seleo == '2 complex eigenvalues':\n        eig1o.children[0].children[0].disabled = True\n        eig2o.children[1].children[0].disabled = False\n        eigo = 2\n    if selec == '4 complex eigenvalues':\n        eig1c.children[0].children[0].disabled = True\n        eig2c.children[1].children[0].disabled = False\n        eig3c.children[0].children[0].disabled = True\n        eig4c.children[0].children[0].disabled = False\n        eig4c.children[1].children[0].disabled = False\n        eigc = 4\n    return eigc, eigo\n\ndef method_choice(selm):\n    if selm == 'Set K and L':\n        method = 1\n        selec.disabled = True\n        seleo.disabled = True\n    if selm == 'Set the eigenvalues':\n        method = 2\n        selec.disabled = False\n        seleo.disabled = False\n    return method\n\n\nD = 30\nc = 45\nV = 1\nJy = 8.333\n\nA = numpy.matrix([[-D/Jy, 0, 0, 0],\n                  [1, 0, 0, 0],\n                  [0, V, 0, 0],\n                  [0, 0, 1, 0]])\nBu = numpy.matrix([[c*V/Jy],[0],[0],[0]])\nBref = numpy.matrix([[0],[0],[0],[-1]])\nC = numpy.matrix([0,0,1,0])\n\nAl = numpy.matrix([[-D/Jy, 0],\n                  [1, 0]])\nCl = numpy.matrix([0,1])\n\ndef main_callback2(v, X0w, K, L, eig1c, eig2c, eig3c, eig4c, eig1o, eig2o, u, period, selm, selec, seleo, selu, simTime, DW):\n    eigc, eigo = eigen_choice(selec,seleo)\n    method = method_choice(selm)\n    \n    A = numpy.matrix([[-D/Jy, 0, 0, 0],\n                  [1, 0, 0, 0],\n                  [0, v, 0, 0],\n                  [0, 0, 1, 0]])\n    Bu = numpy.matrix([[c*v/Jy],[0],[0],[0]])\n    \n    if method == 1:\n        solc = numpy.linalg.eig(A-Bu*K)\n        solo = numpy.linalg.eig(Al-L*Cl)\n    if method == 2:\n        if eig1c[0,0]==eig2c[0,0] or eig1c[0,0]==eig3c[0,0] or eig1c[0,0]==eig4c[0,0]:\n            eig1c[0,0] -= 0.0001\n        if eig2c[0,0]==eig3c[0,0] or eig2c[0,0]==eig4c[0,0]:\n            eig3c[0,0] -= 0.0002\n        if eigc == 0:\n            K = control.acker(A, Bu, [eig1c[0,0], eig2c[0,0], eig3c[0,0], eig4c[0,0]])\n            Kw.setM(K)\n        if eigc == 2:\n            K = control.acker(A, Bu, [eig3c[0,0],\n                                      eig1c[0,0],\n                                      numpy.complex(eig2c[0,0], eig2c[1,0]), \n                                      numpy.complex(eig2c[0,0],-eig2c[1,0])])\n            Kw.setM(K)\n        if eigc == 4:\n            K = control.acker(A, Bu, [numpy.complex(eig4c[0,0], eig4c[1,0]), \n                                      numpy.complex(eig4c[0,0],-eig4c[1,0]),\n                                      numpy.complex(eig2c[0,0], eig2c[1,0]), \n                                      numpy.complex(eig2c[0,0],-eig2c[1,0])])\n            Kw.setM(K)\n        if eigo == 0:\n            temp1 = eig1o[0,0]\n            temp2 = eig2o[0,0]\n            L = numpy.matrix([[temp1*temp2 + D*temp1/Jy + D*temp2/Jy + D**2/Jy**2], [-temp1 - temp2 - D/Jy]]) \n            Lw.setM(L)\n        if eigo == 2:\n            temp1 = numpy.complex(eig2o[0,0], eig2o[1,0])\n            temp2 = numpy.complex(eig2o[0,0],-eig2o[1,0])\n            L = numpy.matrix([[temp1*temp2 + D*temp1/Jy + D*temp2/Jy + D**2/Jy**2], [-temp1 - temp2 - D/Jy]]) \n            L = numpy.real(L)\n            Lw.setM(L)\n            \n    sys = sss(A,numpy.hstack((Bu,Bref)),[[0,1,0,0],[0,0,1,0],[0,0,0,1]],[[0,0],[0,0],[0,0]])\n    syse = sss(Al-L*Cl,numpy.hstack((Bu[0:2],L)),[1,0],[0,0])\n    sysc = sss(0,[0,0,0,0],0,-K)\n    sys_append = control.append(sys,syse,sysc)\n    sys_CL = control.connect(sys_append,\n                             [[1,5],[3,5],[4,1],[5,4],[6,1],[7,2],[8,3]],\n                             [2],\n                             [2,5])\n    \n    X0w1 = numpy.zeros((6,1))\n    X0w1[4,0] = X0w\n    if simTime != 0:\n        T = numpy.linspace(0, simTime, 10000)\n    else:\n        T = numpy.linspace(0, 1, 10000)\n      \n    if selu == 'impulse': #selu\n        U = [0 for t in range(0,len(T))]\n        U[0] = u\n        T, yout, xout = control.forced_response(sys_CL,T,U,X0w1)\n    if selu == 'step':\n        U = [u for t in range(0,len(T))]\n        T, yout, xout = control.forced_response(sys_CL,T,U,X0w1)\n    if selu == 'sinusoid':\n        U = u*numpy.sin(2*numpy.pi/period*T)\n        T, yout, xout = control.forced_response(sys_CL,T,U,X0w1)\n    if selu == 'square wave':\n        U = u*numpy.sign(numpy.sin(2*numpy.pi/period*T))\n        T, yout, xout = control.forced_response(sys_CL,T,U,X0w1)\n    \n    try:\n        step_info_dict = control.step_info(sys_CL[0,0],SettlingTimeThreshold=0.05,T=T)\n        print('Step info: \\n\\tRise time =',step_info_dict['RiseTime'],'\\n\\tSettling time (5%) =',step_info_dict['SettlingTime'],'\\n\\tOvershoot (%)=',step_info_dict['Overshoot'])\n        print('Max x_2 value (% of 20°)=', max(abs(xout[1]))/(numpy.pi/180*20)*100)\n        print('Max u value (% of 10°)=', max(abs(yout[1]))/(numpy.pi/180*10)*100)\n    except:\n        print(\"Error in the calculation of step info.\")\n    \n    fig = plt.figure(num='Simulation1', figsize=(14,12))\n    \n    fig.add_subplot(221)\n    plt.title('Output response')\n    plt.ylabel('Output')\n    plt.plot(T,yout[0],T,U,'r--')\n    plt.xlabel('$t$ [s]')\n    plt.axvline(x=0,color='black',linewidth=0.8)\n    plt.axhline(y=0,color='black',linewidth=0.8)\n    plt.legend(['$y$','Reference'])\n    plt.grid()\n    \n    fig.add_subplot(222)\n    plt.title('Input')\n    plt.ylabel('$u$')\n    plt.plot(T,yout[1])\n    plt.plot(T,[numpy.pi/180*10 for i in range(len(T))],'r--')\n    plt.plot(T,[-numpy.pi/180*10 for i in range(len(T))],'r--')\n    plt.xlabel('$t$ [s]')\n    plt.axvline(x=0,color='black',linewidth=0.8)\n    plt.axhline(y=0,color='black',linewidth=0.8)\n    plt.grid()\n    \n    fig.add_subplot(223)\n    plt.title('States response')\n    plt.ylabel('States')\n    plt.plot(T,xout[0],\n             T,xout[1],\n             T,xout[2],\n             T,xout[3],\n             T,[numpy.pi/180*20 for i in range(len(T))],'r--',\n             T,[-numpy.pi/180*20 for i in range(len(T))],'r--')\n    plt.xlabel('$t$ [s]')\n    plt.axvline(x=0,color='black',linewidth=0.8)\n    plt.axhline(y=0,color='black',linewidth=0.8)\n    plt.legend(['$x_{1}$','$x_{2}$','$x_{3}$','$x_{4}$','+lim $x_2$','-lim $x_2$'])\n    plt.grid()\n    \n    fig.add_subplot(224)\n    plt.title('Estimated errors')\n    plt.ylabel('Error')\n    plt.plot(T,xout[4]-xout[0])\n    plt.xlabel('$t$ [s]')\n    plt.axvline(x=0,color='black',linewidth=0.8)\n    plt.axhline(y=0,color='black',linewidth=0.8)\n    plt.legend(['$e_{1}$'])\n    plt.grid()\n    #plt.tight_layout()\n   \nalltogether2 = widgets.VBox([widgets.HBox([selm, \n                                          selec,\n                                          seleo,\n                                          selu]),\n                            widgets.Label(' ',border=3),\n                            widgets.HBox([widgets.VBox([widgets.Label('K:',border=3), Kw, \n                                                        widgets.Label('Eigenvalues:',border=3),\n                                                        widgets.HBox([eig1c, \n                                                                      eig2c, \n                                                                      eig3c,\n                                                                      eig4c])]),\n                            widgets.Label(' ',border=3),\n                            widgets.HBox([widgets.VBox([widgets.HBox([widgets.Label('L:',border=3), Lw, widgets.Label(' ',border=3),\n                                          widgets.Label(' ',border=3),\n                                          widgets.Label('Eigenvalues:',border=3), \n                                          eig1o, \n                                          eig2o,\n                                          widgets.Label(' ',border=3),\n                                          widgets.Label(' ',border=3),\n                                          widgets.Label('X0 est.:',border=3), X0w]),\n                                          widgets.Label(' ',border=3),\n                                          widgets.Label(' ',border=3),\n                                                       widgets.HBox([\n                                          widgets.VBox([widgets.Label('Simulation time [s]:',border=3)]),\n                                          widgets.VBox([simTime])])])]),\n                                          widgets.Label(' ',border=3)]),\n                            widgets.Label(' ',border=3),\n                            widgets.HBox([widgets.Label('Reference [m]:',border=3),u,\n                                          v]),\n                            widgets.HBox([period,START])])\nout2 = widgets.interactive_output(main_callback2, {'v':v, 'X0w':X0w, 'K':Kw, 'L':Lw,\n                                                   'eig1c':eig1c, 'eig2c':eig2c, 'eig3c':eig3c, 'eig4c':eig4c, \n                                                   'eig1o':eig1o, 'eig2o':eig2o, \n                                                   'u':u, 'period':period, 'selm':selm, 'selec':selec, 'seleo':seleo, 'selu':selu, 'simTime':simTime, 'DW':DW})\nout2.layout.height = '880px'\ndisplay(out2, alltogether2)"
  },
  {
    "objectID": "ICCT_en/examples/04/SS-48-AUV_surge_velocity_control.html",
    "href": "ICCT_en/examples/04/SS-48-AUV_surge_velocity_control.html",
    "title": "Autonomous Underwater Vehicle (AUV) surge velocity control",
    "section": "",
    "text": "# Erasmus+ ICCT project (2018-1-SI01-KA203-047081)\n\n# Toggle cell visibility\n\nfrom IPython.display import HTML\ntag = HTML('''&lt;script&gt;\ncode_show=true; \nfunction code_toggle() {\n    if (code_show){\n        $('div.input').hide()\n    } else {\n        $('div.input').show()\n    }\n    code_show = !code_show\n} \n$( document ).ready(code_toggle);\n&lt;/script&gt;\nToggle cell visibility &lt;a href=\"javascript:code_toggle()\"&gt;here&lt;/a&gt;.''')\ndisplay(tag)\n\n\nToggle cell visibility here.\n\n\n\n%matplotlib inline\nimport control\nimport numpy\nimport sympy as sym\nfrom IPython.display import display, Markdown\nimport ipywidgets as widgets\nimport matplotlib.pyplot as plt\n\n\n#print a matrix latex-like\ndef bmatrix(a):\n     \"\"\"Returns a LaTeX bmatrix - by Damir Arbula (ICCT project)\n\n     :a: numpy array\n     :returns: LaTeX bmatrix as a string\n     \"\"\"\n     if len(a.shape) &gt; 2:\n         raise ValueError('bmatrix can at most display two dimensions')\n     lines = str(a).replace('[', '').replace(']', '').splitlines()\n     rv = [r'\\begin{bmatrix}']\n     rv += ['  ' + ' & '.join(l.split()) + r'\\\\' for l in lines]\n     rv +=  [r'\\end{bmatrix}']\n     return '\\n'.join(rv)\n\n\n# Display formatted matrix: \ndef vmatrix(a):\n    if len(a.shape) &gt; 2:\n         raise ValueError('bmatrix can at most display two dimensions')\n    lines = str(a).replace('[', '').replace(']', '').splitlines()\n    rv = [r'\\begin{vmatrix}']\n    rv += ['  ' + ' & '.join(l.split()) + r'\\\\' for l in lines]\n    rv +=  [r'\\end{vmatrix}']\n    return '\\n'.join(rv)\n\n\n#matrixWidget is a matrix looking widget built with a VBox of HBox(es) that returns a numPy array as value !\nclass matrixWidget(widgets.VBox):\n    def updateM(self,change):\n        for irow in range(0,self.n):\n            for icol in range(0,self.m):\n                self.M_[irow,icol] = self.children[irow].children[icol].value\n                #print(self.M_[irow,icol])\n        self.value = self.M_\n\n    def dummychangecallback(self,change):\n        pass\n    \n    \n    def __init__(self,n,m):\n        self.n = n\n        self.m = m\n        self.M_ = numpy.matrix(numpy.zeros((self.n,self.m)))\n        self.value = self.M_\n        widgets.VBox.__init__(self,\n                             children = [\n                                 widgets.HBox(children = \n                                              [widgets.FloatText(value=0.0, layout=widgets.Layout(width='90px')) for i in range(m)]\n                                             ) \n                                 for j in range(n)\n                             ])\n        \n        #fill in widgets and tell interact to call updateM each time a children changes value\n        for irow in range(0,self.n):\n            for icol in range(0,self.m):\n                self.children[irow].children[icol].value = self.M_[irow,icol]\n                self.children[irow].children[icol].observe(self.updateM, names='value')\n        #value = Unicode('example@example.com', help=\"The email value.\").tag(sync=True)\n        self.observe(self.updateM, names='value', type= 'All')\n        \n    def setM(self, newM):\n        #disable callbacks, change values, and reenable\n        self.unobserve(self.updateM, names='value', type= 'All')\n        for irow in range(0,self.n):\n            for icol in range(0,self.m):\n                self.children[irow].children[icol].unobserve(self.updateM, names='value')\n        self.M_ = newM\n        self.value = self.M_\n        for irow in range(0,self.n):\n            for icol in range(0,self.m):\n                self.children[irow].children[icol].value = self.M_[irow,icol]\n        for irow in range(0,self.n):\n            for icol in range(0,self.m):\n                self.children[irow].children[icol].observe(self.updateM, names='value')\n        self.observe(self.updateM, names='value', type= 'All')        \n\n                #self.children[irow].children[icol].observe(self.updateM, names='value')\n\n             \n#overlaod class for state space systems that DO NOT remove \"useless\" states (what \"professor\" of automatic control would do this?)\nclass sss(control.StateSpace):\n    def __init__(self,*args):\n        #call base class init constructor\n        control.StateSpace.__init__(self,*args)\n    #disable function below in base class\n    def _remove_useless_states(self):\n        pass\n\nDynamics of the surge (longitudinal) velocity \\(u\\) of an Autonomous Underwater Vehicle (AUV) can be modelled as:\n\\[\n(m+m_a)\\dot{u} = -D(u-u_{current})+X,\n\\]\nwhere \\(m = 40\\) kg is the vehicle mass, \\(m_a = 25\\) kg the added mass, \\(D = 12\\) Ns/m the drag coefficient, \\(X\\) the propulsion force generated by the propeller and \\(u_{current}\\) the water current velocity. The propeller motor is controlled by a controller that regulates propulsion force; the motor controller transfer function (from commanded force \\(X_a\\) to actual force \\(X\\)) can be approximated by a unit gain of the second-order system with natural frequency \\(\\omega_n = 1.3\\) rad/s and damping \\(\\xi=0.7\\). The surge velocity is estimated by a navigation filter.\nThe goal is to design a regulator that meets the following requirements: - settling time for 5% tolerance band of less than 5 seconds, - overshoot less than 20%, - no steady-state error in response to a step velocity request, - maximum absolute force \\(X\\) equal to 60 N,\nconsidering \\(u_{current} = 0\\).\nIn order to develop a state feedback controller we must have the system dynamics in state space form so, we have to make a realisation of the motor controller.\nThe transfer function from \\(X_a\\) to \\(X\\) is\n\\[\nX(s) = \\frac{\\omega_n^2}{s^2+2\\xi\\omega_ns+\\omega_n^2} X_a(s)\n\\]\ntherefore, defining \\(z=\\begin{bmatrix} z_1 & z_2 \\end{bmatrix}^T\\), a possible realisation in controllable canonical form is\n\\[\\begin{cases}\n    \\dot{z} = \\begin{bmatrix} 0 & 1 \\\\ -\\omega_n^2 & -2\\xi\\omega_n \\end{bmatrix}z + \\begin{bmatrix} 0 \\\\ 1 \\end{bmatrix}X_a \\\\\n    X = \\begin{bmatrix} \\omega_n^2 & 0 \\end{bmatrix}z.\n\\end{cases}\\]\nThe complete system dynamics is the series connection of the two dynamics at which we add a new state in order to have zero steady-state error. Defining the state vector as \\(x=\\begin{bmatrix} x_1 & x_2 & x_3 & x_4 \\end{bmatrix}^T = \\begin{bmatrix} u & z_1 & z_2 & x_a \\end{bmatrix}^T\\) with \\(\\dot{x_a}=u-y_d\\) we can write\n\\[\\begin{cases}\n    \\dot{x} = \\begin{bmatrix} -\\frac{D}{m+m_a} & \\frac{\\omega_n^2}{m+m_a} & 0 & 0 \\\\ 0 & 0 & 1 & 0 \\\\ 0 & -\\omega_n^2 & -2\\xi\\omega_n & 0 \\\\ 1 & 0 & 0 & 0 \\end{bmatrix}x + \\begin{bmatrix} 0 & 0 \\\\ 0 & 0 \\\\ 1 & 0 \\\\ 0 & -1 \\end{bmatrix}\\begin{bmatrix}X_a \\\\ y_d \\end{bmatrix}\\\\\n    y = \\begin{bmatrix} 1 & 0 & 0 & 0 \\\\ 0 & 0 & 0 & 1 \\end{bmatrix}x.\n\\end{cases}\\]\nThe controllability matrix \\(\\mathcal{C}\\)\n\nA = numpy.matrix([[-12/65,1.3**2/65,0,0],[0,0,1,0],[0,-1.3**2,-2*1.3*0.7,0],[1,0,0,0]])\nB = numpy.matrix('0 0; 0 0; 1 0; 0 -1')\nC = numpy.matrix('1 0 0 0; 0 0 0 1')\nD = numpy.matrix('0 0; 0 0')\n\nCtrb = control.ctrb(A,B)\ndisplay(Markdown(bmatrix(Ctrb)))\n# print(numpy.linalg.matrix_rank(Ctrb))\n\n\\[\\begin{bmatrix}\n  0. & 0. & 0. & 0. & 0.026 & 0. & -0.05212\\\\\n  0.\\\\\n  0. & 0. & 1. & 0. & -1.82 & 0. & 1.6224\\\\\n  0.\\\\\n  1. & 0. & -1.82 & 0. & 1.6224 & 0. & 0.123032\\\\\n  0.\\\\\n  0. & -1. & 0. & 0. & 0. & 0. & 0.026\\\\\n  0.\\\\\n\\end{bmatrix}\\]\n\n\nhas rank equal to 4 so, the system is controllable.\nThe observability matrix \\(\\mathcal{O}\\)\n\nObsv = control.obsv(A,C)\ndisplay(Markdown(bmatrix(Obsv)))\n# print(numpy.linalg.matrix_rank(Obsv))\n\n\\[\\begin{bmatrix}\n  1. & 0. & 0. & 0.\\\\\n  0. & 0. & 0. & 1.\\\\\n  -0.18461538 & 0.026 & 0. & 0.\\\\\n  1. & 0. & 0. & 0.\\\\\n  0.03408284 & -0.0048 & 0.026 & 0.\\\\\n  -0.18461538 & 0.026 & 0. & 0.\\\\\n  -0.00629222 & -0.04305385 & -0.05212 & 0.\\\\\n  0.03408284 & -0.0048 & 0.026 & 0.\\\\\n\\end{bmatrix}\\]\n\n\nhas rank equal to 4 so, the system is observable.\n\nRegulator design\n\nController design\nAs a possible solution we can change the location of the real pole and that of the integrator, while leaving the poles of the motor controller where they are. In this way we change the minimum of the structure of the system and thus limit the total control effort. The poles chosen are therefore \\(-0.9\\pm0.92\\), \\(-1.3\\) and \\(-1.1\\).\n\n\nObserver design\nIn order to support the controller with a good transient of estimation error in case of initial error in the state estimation we place the observer poles close to -10 rad/s.\n\n\n\nHow to use this notebook?\n\nTry to change the controller in order to limit the absolute value of \\(X\\) to \\(\\pm30\\) N while meeting the requirements.\n\n\n# Preparatory cell\n\nX0 = numpy.matrix('0.0; 0.0; 0.0; 0.0')\nK = numpy.matrix([0,0,0,0])\nL = numpy.matrix([[0, 0],[0, 0],[0, 0],[0, 0]])\n\nX0w = matrixWidget(4,1)\nX0w.setM(X0)\nKw = matrixWidget(1,4)\nKw.setM(K)\nLw = matrixWidget(4,2)\nLw.setM(L)\n\n\neig1c = matrixWidget(1,1)\neig2c = matrixWidget(2,1)\neig3c = matrixWidget(1,1)\neig4c = matrixWidget(2,1)\neig1c.setM(numpy.matrix([-1.3])) \neig2c.setM(numpy.matrix([[-0.9],[-0.92]]))\neig3c.setM(numpy.matrix([-1.1]))\neig4c.setM(numpy.matrix([[-1],[-1]]))\n\neig1o = matrixWidget(1,1)\neig2o = matrixWidget(2,1)\neig3o = matrixWidget(1,1)\neig4o = matrixWidget(2,1)\neig1o.setM(numpy.matrix([-11.])) \neig2o.setM(numpy.matrix([[-10.],[0.]]))\neig3o.setM(numpy.matrix([-12.]))\neig4o.setM(numpy.matrix([[-10.],[0.]]))\n\n\n# Misc\n\n#create dummy widget \nDW = widgets.FloatText(layout=widgets.Layout(width='0px', height='0px'))\n\n#create button widget\nSTART = widgets.Button(\n    description='Test',\n    disabled=False,\n    button_style='', # 'success', 'info', 'warning', 'danger' or ''\n    tooltip='Test',\n    icon='check'\n)\n                       \ndef on_start_button_clicked(b):\n    #This is a workaround to have intreactive_output call the callback:\n    #   force the value of the dummy widget to change\n    if DW.value&gt; 0 :\n        DW.value = -1\n    else: \n        DW.value = 1\n    pass\nSTART.on_click(on_start_button_clicked)\n\n# Define type of method \nselm = widgets.Dropdown(\n    options= ['Set K and L', 'Set the eigenvalues'],\n    value= 'Set the eigenvalues',\n    description='',\n    disabled=False\n)\n\n# Define the number of complex eigenvalues\nsele = widgets.Dropdown(\n    options= ['0 complex eigenvalues', '2 complex eigenvalues', '4 complex eigenvalues'],\n    value= '2 complex eigenvalues',\n    description='Complex eigenvalues:',\n    style = {'description_width': 'initial'},\n    disabled=False\n)\n\n#define type of ipout \nselu = widgets.Dropdown(\n    options=['impulse', 'step', 'sinusoid', 'square wave'],\n    value='step',\n    description='Type of reference:',\n    style = {'description_width': 'initial'},\n    disabled=False\n)\n# Define the values of the input\nu = widgets.FloatSlider(\n    value=2,\n    min=0,\n    max=4,\n    step=0.1,\n    description='',\n    disabled=False,\n    continuous_update=False,\n    orientation='horizontal',\n    readout=True,\n    readout_format='.1f',\n)\nperiod = widgets.FloatSlider(\n    value=0.5,\n    min=0.001,\n    max=10,\n    step=0.001,\n    description='Period: ',\n    disabled=False,\n    continuous_update=False,\n    orientation='horizontal',\n    readout=True,\n    readout_format='.2f',\n)\n\ngain_w2 = widgets.FloatText(\n    value=1.,\n    description='',\n    disabled=True\n)\n\nsimTime = widgets.FloatText(\n    value=7,\n    description='',\n    disabled=False\n)\n\n\n# Support functions\n\ndef eigen_choice(sele):\n    if sele == '0 complex eigenvalues':\n        eig1c.children[0].children[0].disabled = False\n        eig2c.children[1].children[0].disabled = True\n        eig3c.children[0].children[0].disabled = False\n        eig4c.children[0].children[0].disabled = False\n        eig4c.children[1].children[0].disabled = True\n        eig1o.children[0].children[0].disabled = False\n        eig2o.children[1].children[0].disabled = True\n        eig3o.children[0].children[0].disabled = False\n        eig4o.children[0].children[0].disabled = False\n        eig4o.children[1].children[0].disabled = True\n        eig = 0\n    if sele == '2 complex eigenvalues':\n        eig1c.children[0].children[0].disabled = False\n        eig2c.children[1].children[0].disabled = False\n        eig3c.children[0].children[0].disabled = False\n        eig4c.children[0].children[0].disabled = True\n        eig4c.children[1].children[0].disabled = True\n        eig1o.children[0].children[0].disabled = False\n        eig2o.children[1].children[0].disabled = False\n        eig3o.children[0].children[0].disabled = False\n        eig4o.children[0].children[0].disabled = True\n        eig4o.children[1].children[0].disabled = True\n        eig = 2\n    if sele == '4 complex eigenvalues':\n        eig1c.children[0].children[0].disabled = True\n        eig2c.children[1].children[0].disabled = False\n        eig3c.children[0].children[0].disabled = True\n        eig4c.children[0].children[0].disabled = False\n        eig4c.children[1].children[0].disabled = False\n        eig1o.children[0].children[0].disabled = True\n        eig2o.children[1].children[0].disabled = False\n        eig3o.children[0].children[0].disabled = True\n        eig4o.children[0].children[0].disabled = False\n        eig4o.children[1].children[0].disabled = False\n        eig = 4\n    return eig\n\ndef method_choice(selm):\n    if selm == 'Set K and L':\n        method = 1\n        sele.disabled = True\n    if selm == 'Set the eigenvalues':\n        method = 2\n        sele.disabled = False\n    return method\n\n\nnumU = 1\nimport warnings\n# In order to suppress the warning for the precision of control.place\nwarnings.filterwarnings(\"ignore\")\n\ndef main_callback2(X0w, K, L, eig1c, eig2c, eig3c, eig4c, eig1o, eig2o, eig3o, eig4o, u, period, selm, sele, selu, simTime, DW):\n    eige = eigen_choice(sele)\n    method = method_choice(selm)\n    \n    if method == 1:\n        solc = numpy.linalg.eig(A-B[:,0:numU]*K)\n        solo = numpy.linalg.eig(A-L*C)\n    if method == 2:\n        if eig1c[0,0]==eig2c[0,0] or eig1c[0,0]==eig3c[0,0] or eig1c[0,0]==eig4c[0,0]:\n            eig1c[0,0] -= 0.0001\n        if eig2c[0,0]==eig3c[0,0] or eig2c[0,0]==eig4c[0,0]:\n            eig2c[0,0] -= 0.0002\n        if eig1o[0,0]==eig2o[0,0] or eig1o[0,0]==eig3o[0,0] or eig1o[0,0]==eig4o[0,0]:\n            eig1o[0,0] -= 0.0001\n        if eig2o[0,0]==eig3o[0,0] or eig2o[0,0]==eig4o[0,0]:\n            eig2o[0,0] -= 0.0002\n        if eige == 0:\n            K = control.acker(A, B[:,0:numU], [eig1c[0,0], eig2c[0,0], eig3c[0,0], eig4c[0,0]])\n            Kw.setM(K)\n            L = control.place(A.T, C.T, [eig1o[0,0], eig2o[0,0], eig3o[0,0], eig4o[0,0]]).T\n            Lw.setM(L)\n        if eige == 2:\n            K = control.acker(A, B[:,0:numU], [eig3c[0,0],\n                                               eig1c[0,0],\n                                               numpy.complex(eig2c[0,0],eig2c[1,0]), \n                                               numpy.complex(eig2c[0,0],-eig2c[1,0])])\n            Kw.setM(K)\n            L = control.place(A.T, C.T, [eig3o[0,0],\n                                         eig1o[0,0],\n                                         numpy.complex(eig2o[0,0],eig2o[1,0]), \n                                         numpy.complex(eig2o[0,0],-eig2o[1,0])]).T\n            Lw.setM(L)\n        if eige == 4:\n            K = control.acker(A, B[:,0:numU], [numpy.complex(eig4c[0,0],eig4c[1,0]), \n                                               numpy.complex(eig4c[0,0],-eig4c[1,0]),\n                                               numpy.complex(eig2c[0,0],eig2c[1,0]), \n                                               numpy.complex(eig2c[0,0],-eig2c[1,0])])\n            Kw.setM(K)\n            L = control.place(A.T, C.T, [numpy.complex(eig4o[0,0],eig4o[1,0]), \n                                         numpy.complex(eig4o[0,0],-eig4o[1,0]), \n                                         numpy.complex(eig2o[0,0],eig2o[1,0]), \n                                         numpy.complex(eig2o[0,0],-eig2o[1,0])]).T\n            Lw.setM(L)\n            \n    \n    sys = control.ss(A,B,numpy.vstack((C,numpy.zeros((B.shape[1],C.shape[1])))),numpy.vstack((D,numpy.eye(B.shape[1]))))\n    sysC = control.ss(numpy.zeros((1,1)),\n                      numpy.zeros((1,numpy.shape(A)[0])),\n                      numpy.zeros((numpy.shape(B[:,0:numU])[1],1)),\n                      -K)\n    \n    sysE = control.ss(A-L*C,\n                      numpy.hstack((L,B-L*D)),\n                      numpy.eye(numpy.shape(A)[0]),\n                      numpy.zeros((A.shape[0],C.shape[0]+B.shape[1])))\n    \n    sys_append = control.append(sys, sysE, sysC, control.ss(A,B,numpy.eye(A.shape[0]),numpy.zeros((A.shape[0],B.shape[1]))))\n    Q = []\n    # y in ingresso a sysE\n    for i in range(C.shape[0]):\n        Q.append([B.shape[1]+i+1, i+1])\n    # u in ingresso a sysE\n    for i in range(B.shape[1]):\n        Q.append([B.shape[1]+C.shape[0]+i+1, C.shape[0]+i+1])\n    # u in ingresso a sys\n    for i in range(B[:,0:numU].shape[1]):\n        Q.append([i+1, C.shape[0]+B.shape[1]+A.shape[0]+i+1])\n    # u in ingresso al sistema che ha come uscite gli stati reali\n    for i in range(B.shape[1]):\n        Q.append([2*B.shape[1]+C.shape[0]+A.shape[0]+i+1, C.shape[0]+i+1])\n    # xe in ingresso a sysC\n    for i in range(A.shape[0]):\n        Q.append([2*B.shape[1]+C.shape[0]+i+1, C.shape[0]+B.shape[1]+i+1])\n        \n    inputv = [i+numU+1 for i in range(B[:,numU:].shape[1])]\n    outputv = [i+1 for i in range(numpy.shape(sys_append.C)[0])]\n    # in order to avoid singular value exception\n    try:\n        sys_CL = control.connect(sys_append, Q, inputv, outputv)\n    except:\n        sys_CL = control.connect(sys_append, Q, inputv, outputv)\n    \n    dcgain = control.dcgain(sys_CL[0,0])\n    gain_w2.value = dcgain\n    if dcgain != 0:\n        u1 = u/1\n    else:\n        print('The feedforward gain setted is 0 and it is changed to 1')\n        u1 = u/1\n    print('The static gain of the closed loop system (from the reference to the output) is: %.5f' %dcgain)\n    \n    X0w1 = numpy.zeros((A.shape[0],1))\n    for j in range(A.shape[0]):\n        X0w1 = numpy.vstack((X0w1,X0w[j]))\n    X0w1 = numpy.vstack((X0w1,numpy.zeros((A.shape[0],1))))\n    if simTime != 0:\n        T = numpy.linspace(0, simTime, 10000)\n    else:\n        T = numpy.linspace(0, 1, 10000)\n      \n    if selu == 'impulse': #selu\n        U = [0 for t in range(0,len(T))]\n        U[0] = u\n        U1 = [0 for t in range(0,len(T))]\n        U1[0] = u1\n        T, yout, xout = control.forced_response(sys_CL[:,0],T,U1,X0w1)\n    if selu == 'step':\n        U = [u for t in range(0,len(T))]\n        U1 = [u1 for t in range(0,len(T))]\n        T, yout, xout = control.forced_response(sys_CL[:,0],T,U1,X0w1)\n    if selu == 'sinusoid':\n        U = u*numpy.sin(2*numpy.pi/period*T)\n        U1 = u1*numpy.sin(2*numpy.pi/period*T)\n        T, yout, xout = control.forced_response(sys_CL[:,0],T,U1,X0w1)\n    if selu == 'square wave':\n        U = u*numpy.sign(numpy.sin(2*numpy.pi/period*T))\n        U1 = u1*numpy.sign(numpy.sin(2*numpy.pi/period*T))\n        T, yout, xout = control.forced_response(sys_CL[:,0],T,U1,X0w1)\n    \n    step_info_dict = control.step_info(sys_CL[0,0],SettlingTimeThreshold=0.05,T=T)\n    print('Step info: \\n\\tRise time =',step_info_dict['RiseTime'],'\\n\\tSettling time (5%) =',step_info_dict['SettlingTime'],'\\n\\tOvershoot (%)=',step_info_dict['Overshoot'])\n    print('Max x_2 value (% of 60N)=', max(abs(yout[C.shape[0]+B.shape[1]+B[:,numU:].shape[1]+A.shape[0]+1]))/(60/1.3**2)*100)\n    \n    fig = plt.figure(num='Simulation1', figsize=(14,12))\n    \n    fig.add_subplot(221)\n    plt.title('Output response')\n    plt.ylabel('Output')\n    plt.plot(T,yout[0],T,U,'r--')\n    plt.xlabel('$t$ [s]')\n    plt.axvline(x=0,color='black',linewidth=0.8)\n    plt.axhline(y=0,color='black',linewidth=0.8)\n    plt.legend(['$y$','Reference'])\n    plt.grid()\n    \n    fig.add_subplot(222)\n    plt.title('Input')\n    plt.ylabel('$u$')\n    plt.plot(T,yout[C.shape[0]])\n    plt.xlabel('$t$ [s]')\n    plt.axvline(x=0,color='black',linewidth=0.8)\n    plt.axhline(y=0,color='black',linewidth=0.8)\n    plt.grid()\n    \n    fig.add_subplot(223)\n    plt.title('States response')\n    plt.ylabel('States')\n    plt.plot(T,yout[C.shape[0]+B.shape[1]+B[:,numU:].shape[1]+A.shape[0]],\n             T,yout[C.shape[0]+B.shape[1]+B[:,numU:].shape[1]+A.shape[0]+1],\n             T,yout[C.shape[0]+B.shape[1]+B[:,numU:].shape[1]+A.shape[0]+2],\n             T,yout[C.shape[0]+B.shape[1]+B[:,numU:].shape[1]+A.shape[0]+3],\n             T,[60/1.3**2 for i in range(len(T))],'r--',\n             T,[-60/1.3**2 for i in range(len(T))],'r--')\n    plt.xlabel('$t$ [s]')\n    plt.axvline(x=0,color='black',linewidth=0.8)\n    plt.axhline(y=0,color='black',linewidth=0.8)\n    plt.legend(['$x_{1}$','$x_{2}$','$x_{3}$','$x_{4}$','$+60/\\omega_n^2$','$-60/\\omega_n^2$'])\n    plt.grid()\n    \n    fig.add_subplot(224)\n    plt.title('Estimation errors')\n    plt.ylabel('Errors')\n    plt.plot(T,yout[C.shape[0]+B.shape[1]+B[:,numU:].shape[1]+A.shape[0]]-yout[C.shape[0]+B.shape[1]],\n             T,yout[C.shape[0]+B.shape[1]+B[:,numU:].shape[1]+A.shape[0]+1]-yout[C.shape[0]+B.shape[1]+1],\n             T,yout[C.shape[0]+B.shape[1]+B[:,numU:].shape[1]+A.shape[0]+2]-yout[C.shape[0]+B.shape[1]+2],\n             T,yout[C.shape[0]+B.shape[1]+B[:,numU:].shape[1]+A.shape[0]+3]-yout[C.shape[0]+B.shape[1]+3])\n    plt.xlabel('$t$ [s]')\n    plt.axvline(x=0,color='black',linewidth=0.8)\n    plt.axhline(y=0,color='black',linewidth=0.8)\n    plt.legend(['$e_{1}$','$e_{2}$','$e_{3}$','$e_{4}$'])\n    plt.grid()\n    #plt.tight_layout()\n   \nalltogether2 = widgets.VBox([widgets.HBox([selm, \n                                          sele,\n                                          selu]),\n                            widgets.Label(' ',border=3),\n                            widgets.HBox([widgets.VBox([widgets.Label('K:',border=3), Kw, \n                                                        widgets.Label('Eigenvalues:',border=3),\n                                                        widgets.HBox([eig1c, \n                                                                      eig2c, \n                                                                      eig3c,\n                                                                      eig4c])])]),\n                            widgets.Label(' ',border=3),\n                            widgets.HBox([widgets.Label('L:',border=3), Lw, \n                                          widgets.Label(' ',border=3),\n                                          widgets.Label(' ',border=3),\n                                          widgets.Label('Eigenvalues:',border=3), \n                                          eig1o, \n                                          eig2o, \n                                          eig3o,\n                                          eig4o,\n                                          widgets.Label(' ',border=3),\n                                          widgets.Label(' ',border=3),\n                                          widgets.Label('X0 est.:',border=3), X0w,\n                                          widgets.Label(' ',border=3)]),widgets.HBox([\n                                          widgets.VBox([widgets.Label('Inverse reference gain:',border=3),\n                                                        widgets.Label('Simulation time [s]:',border=3)]),\n                                          widgets.VBox([gain_w2,simTime])]),\n                            widgets.Label(' ',border=3),\n                            widgets.HBox([widgets.Label('Reference [m/s]:',border=3),\n                                          u, \n                                          period, \n                                          START])])\nout2 = widgets.interactive_output(main_callback2, {'X0w':X0w, 'K':Kw, 'L':Lw,\n                                                   'eig1c':eig1c, 'eig2c':eig2c, 'eig3c':eig3c, 'eig4c':eig4c, \n                                                   'eig1o':eig1o, 'eig2o':eig2o, 'eig3o':eig3o, 'eig4o':eig4o, \n                                                   'u':u, 'period':period, 'selm':selm, 'sele':sele, 'selu':selu, 'simTime':simTime, 'DW':DW})\nout2.layout.height = '860px'\ndisplay(out2, alltogether2)"
  },
  {
    "objectID": "ICCT_en/examples/04/SS-46-Quadrotor_lateral_position_control.html",
    "href": "ICCT_en/examples/04/SS-46-Quadrotor_lateral_position_control.html",
    "title": "Quadrotor lateral position control",
    "section": "",
    "text": "# Erasmus+ ICCT project (2018-1-SI01-KA203-047081)\n\n# Toggle cell visibility\n\nfrom IPython.display import HTML\ntag = HTML('''&lt;script&gt;\ncode_show=true; \nfunction code_toggle() {\n    if (code_show){\n        $('div.input').hide()\n    } else {\n        $('div.input').show()\n    }\n    code_show = !code_show\n} \n$( document ).ready(code_toggle);\n&lt;/script&gt;\nToggle cell visibility &lt;a href=\"javascript:code_toggle()\"&gt;here&lt;/a&gt;.''')\ndisplay(tag)\n\n# Hide the code completely\n\n# from IPython.display import HTML\n# tag = HTML('''&lt;style&gt;\n# div.input {\n#     display:none;\n# }\n# &lt;/style&gt;''')\n# display(tag)\n\n\nToggle cell visibility here.\n\n\n\n%matplotlib inline\nimport control\nimport numpy\nimport sympy as sym\nfrom IPython.display import display, Markdown\nimport ipywidgets as widgets\nimport matplotlib.pyplot as plt\n\n\n#print a matrix latex-like\ndef bmatrix(a):\n     \"\"\"Returns a LaTeX bmatrix - by Damir Arbula (ICCT project)\n\n     :a: numpy array\n     :returns: LaTeX bmatrix as a string\n     \"\"\"\n     if len(a.shape) &gt; 2:\n         raise ValueError('bmatrix can at most display two dimensions')\n     lines = str(a).replace('[', '').replace(']', '').splitlines()\n     rv = [r'\\begin{bmatrix}']\n     rv += ['  ' + ' & '.join(l.split()) + r'\\\\' for l in lines]\n     rv +=  [r'\\end{bmatrix}']\n     return '\\n'.join(rv)\n\n\n# Display formatted matrix: \ndef vmatrix(a):\n    if len(a.shape) &gt; 2:\n         raise ValueError('bmatrix can at most display two dimensions')\n    lines = str(a).replace('[', '').replace(']', '').splitlines()\n    rv = [r'\\begin{vmatrix}']\n    rv += ['  ' + ' & '.join(l.split()) + r'\\\\' for l in lines]\n    rv +=  [r'\\end{vmatrix}']\n    return '\\n'.join(rv)\n\n\n#matrixWidget is a matrix looking widget built with a VBox of HBox(es) that returns a numPy array as value !\nclass matrixWidget(widgets.VBox):\n    def updateM(self,change):\n        for irow in range(0,self.n):\n            for icol in range(0,self.m):\n                self.M_[irow,icol] = self.children[irow].children[icol].value\n                #print(self.M_[irow,icol])\n        self.value = self.M_\n\n    def dummychangecallback(self,change):\n        pass\n    \n    \n    def __init__(self,n,m):\n        self.n = n\n        self.m = m\n        self.M_ = numpy.matrix(numpy.zeros((self.n,self.m)))\n        self.value = self.M_\n        widgets.VBox.__init__(self,\n                             children = [\n                                 widgets.HBox(children = \n                                              [widgets.FloatText(value=0.0, layout=widgets.Layout(width='90px')) for i in range(m)]\n                                             ) \n                                 for j in range(n)\n                             ])\n        \n        #fill in widgets and tell interact to call updateM each time a children changes value\n        for irow in range(0,self.n):\n            for icol in range(0,self.m):\n                self.children[irow].children[icol].value = self.M_[irow,icol]\n                self.children[irow].children[icol].observe(self.updateM, names='value')\n        #value = Unicode('example@example.com', help=\"The email value.\").tag(sync=True)\n        self.observe(self.updateM, names='value', type= 'All')\n        \n    def setM(self, newM):\n        #disable callbacks, change values, and reenable\n        self.unobserve(self.updateM, names='value', type= 'All')\n        for irow in range(0,self.n):\n            for icol in range(0,self.m):\n                self.children[irow].children[icol].unobserve(self.updateM, names='value')\n        self.M_ = newM\n        self.value = self.M_\n        for irow in range(0,self.n):\n            for icol in range(0,self.m):\n                self.children[irow].children[icol].value = self.M_[irow,icol]\n        for irow in range(0,self.n):\n            for icol in range(0,self.m):\n                self.children[irow].children[icol].observe(self.updateM, names='value')\n        self.observe(self.updateM, names='value', type= 'All')        \n\n                #self.children[irow].children[icol].observe(self.updateM, names='value')\n\n             \n#overlaod class for state space systems that DO NOT remove \"useless\" states (what \"professor\" of automatic control would do this?)\nclass sss(control.StateSpace):\n    def __init__(self,*args):\n        #call base class init constructor\n        control.StateSpace.__init__(self,*args)\n    #disable function below in base class\n    def _remove_useless_states(self):\n        pass\n\n\nThe quadrotor lateral velocity \\(u\\) may be controlled by tilting the vehicle by the roll angle \\(\\theta\\). Assuming that the vehicle is equipped with an autopilot that regulates the roll angle \\(\\theta\\) to the desired value \\(\\theta_r\\), the closed-loop roll angle dynamics can be modelled as the response of a second-order system with poles in \\(-20\\pm25i\\) and unit gain. When the vehicle is tilted by the angle \\(\\theta\\), the propellers produce a lateral force approximately equal to \\(F_l = F\\sin{\\theta} \\approx mg\\theta\\), where \\(m=1800\\) g is vehicle mass, and \\(g = 9.81\\) m/\\(\\text{s}^2\\) gravity acceleration. The presence of wind acts as a lateral force \\(D = -cu = -0.8u\\). Roll angle must be within \\(\\pm20\\) degrees during all operations. Position is measured with GPS.\nWe want to develop a regulator that utilises \\(\\theta_r\\) as input and the lateral position \\(s\\) as output and meets following requirements: - settling time for 5% tolerance band less than 7 seconds; - no overshoot; - practically zero or no steady-state error in response to a step position request.\nThe lateral dynamics equations are \\[\nm\\dot{u} = -cu + mg\\theta\n\\]\nand\n\\[\n\\dot s = u\n\\]\nand a possible realisation for the roll dynamics is:\n\\[\\begin{cases}\n    \\dot{z} = \\begin{bmatrix} 0 & 1 \\\\ -\\omega_n^2 & -2\\xi\\omega_n \\end{bmatrix}z + \\begin{bmatrix} 0 \\\\ 1 \\end{bmatrix}\\theta_r \\\\\n    \\theta = \\begin{bmatrix} \\omega_n^2 & 0 \\end{bmatrix}z,\n\\end{cases}\\]\nwhere \\(z = \\begin{bmatrix} z_1 & z_2 \\end{bmatrix}^T\\), \\(\\omega_n=\\sqrt{(-20)^2+(25)^2} \\approx 32\\) and \\(\\xi = \\frac{20}{\\omega_n} \\approx 0.62\\).\nMerging the equations and defining the state vector as \\(x = \\begin{bmatrix} x_1 & x_2 & x_3 & x_4 \\end{bmatrix}^T= \\begin{bmatrix} s & u & z_1 & z_2 \\end{bmatrix}^T\\) we can write:\n\\[\\begin{cases}\n    \\dot{x} = \\begin{bmatrix} 0 & 1 & 0 & 0 \\\\ 0 & -c/m & g\\omega_n^2 & 0 \\\\ 0 & 0 & 0 & 1 \\\\ 0 & 0 & -\\omega_n^2 & -2\\xi\\omega_n \\end{bmatrix}x + \\begin{bmatrix} 0 \\\\ 0 \\\\ 0 \\\\ 1 \\end{bmatrix}\\theta_r \\\\\n    y = \\begin{bmatrix} 1 & 0 & 0 & 0 \\end{bmatrix}x\n\\end{cases}\\]\n\nRegulator design\n\nController design\nIn order to guarantee practically zero steady-state error we add a feedforward gain equal to the inverse of the closed-loop static gain. The poles of the roll dynamics are very fast and in order to keep the values of \\(\\theta\\) during the transient we set desired closed-loop poles to be 13 times smaller than the open-loop ones: (\\(-1.54\\pm1.92i\\)). For the remaining poles we slightly increase the speed of convergence of the pole \\(-c/m\\) (=&gt; \\(-0.7\\)) and we place the last pole in \\(-0.7\\).\n\n\nObserver design\nFor the observer we develop a full state estimator for the augmented system with poles close to \\(-30\\) in order to have a relatively fast convergence.\n\n\n\nHow to use this notebook?\n\nTest the system with errors in the initial estimated state and if necessary try to change the pole locations in order to meet the requirements.\n\n\n# Preparatory cell\n\nX0 = numpy.matrix('0.0; 0.0; 0.0; 0.0')\nK = numpy.matrix([0,0,0,0])\nL = numpy.matrix([[0],[0],[0],[0]])\n\nX0w = matrixWidget(4,1)\nX0w.setM(X0)\nKw = matrixWidget(1,4)\nKw.setM(K)\nLw = matrixWidget(4,1)\nLw.setM(L)\n\n\neig1c = matrixWidget(1,1)\neig2c = matrixWidget(2,1)\neig3c = matrixWidget(1,1)\neig4c = matrixWidget(2,1)\neig1c.setM(numpy.matrix([-0.7])) \neig2c.setM(numpy.matrix([[-1.54],[-1.92]]))\neig3c.setM(numpy.matrix([-0.7]))\neig4c.setM(numpy.matrix([[-1.],[-1.]]))\n\neig1o = matrixWidget(1,1)\neig2o = matrixWidget(2,1)\neig3o = matrixWidget(1,1)\neig4o = matrixWidget(2,1)\neig1o.setM(numpy.matrix([-30.])) \neig2o.setM(numpy.matrix([[-30.],[0.]]))\neig3o.setM(numpy.matrix([-30.1]))\neig4o.setM(numpy.matrix([[-30.2],[0.]]))\n\n\n# Misc\n\n#create dummy widget \nDW = widgets.FloatText(layout=widgets.Layout(width='0px', height='0px'))\n\n#create button widget\nSTART = widgets.Button(\n    description='Test',\n    disabled=False,\n    button_style='', # 'success', 'info', 'warning', 'danger' or ''\n    tooltip='Test',\n    icon='check'\n)\n                       \ndef on_start_button_clicked(b):\n    #This is a workaround to have intreactive_output call the callback:\n    #   force the value of the dummy widget to change\n    if DW.value&gt; 0 :\n        DW.value = -1\n    else: \n        DW.value = 1\n    pass\nSTART.on_click(on_start_button_clicked)\n\n# Define type of method \nselm = widgets.Dropdown(\n    options= ['Set K and L', 'Set the eigenvalues'],\n    value= 'Set the eigenvalues',\n    description='',\n    disabled=False\n)\n\n# Define the number of complex eigenvalues\nselec = widgets.Dropdown(\n    options= ['0 complex eigenvalues', '2 complex eigenvalues', '4 complex eigenvalues'],\n    value= '2 complex eigenvalues',\n    description='Eig controller:',\n    disabled=False\n)\nseleo = widgets.Dropdown(\n    options= ['0 complex eigenvalues', '2 complex eigenvalues'],\n    value= '0 complex eigenvalues',\n    description='Eig observer:',\n    disabled=False\n)\n\n#define type of ipout \nselu = widgets.Dropdown(\n    options=['impulse', 'step', 'sinusoid', 'square wave'],\n    value='step',\n    description='Type of reference:',\n    style = {'description_width': 'initial'},\n    disabled=False\n)\n# Define the values of the input\nu = widgets.FloatSlider(\n    value=10,\n    min=0,\n    max=20,\n    step=1,\n    description='',\n    disabled=False,\n    continuous_update=False,\n    orientation='horizontal',\n    readout=True,\n    readout_format='.1f',\n)\nperiod = widgets.FloatSlider(\n    value=0.5,\n    min=0.001,\n    max=10,\n    step=0.001,\n    description='Period: ',\n    disabled=False,\n    continuous_update=False,\n    orientation='horizontal',\n    readout=True,\n    readout_format='.3f',\n)\n\nsimTime = widgets.FloatText(\n    value=10,\n    description='',\n    disabled=False\n)\n\n\n# Support functions\n\ndef eigen_choice(selec,seleo):\n    if selec == '0 complex eigenvalues':\n        eig1c.children[0].children[0].disabled = False\n        eig2c.children[1].children[0].disabled = True\n        eig3c.children[0].children[0].disabled = False\n        eig4c.children[0].children[0].disabled = False\n        eig4c.children[1].children[0].disabled = True\n        eigc = 0\n    if seleo == '0 complex eigenvalues':\n        eig1o.children[0].children[0].disabled = False\n        eig2o.children[1].children[0].disabled = True\n        eig3o.children[0].children[0].disabled = False\n        eig4o.children[0].children[0].disabled = False\n        eig4o.children[1].children[0].disabled = True\n        eigo = 0\n    if selec == '2 complex eigenvalues':\n        eig1c.children[0].children[0].disabled = False\n        eig2c.children[1].children[0].disabled = False\n        eig3c.children[0].children[0].disabled = False\n        eig4c.children[0].children[0].disabled = True\n        eig4c.children[1].children[0].disabled = True\n        eigc = 2\n    if seleo == '2 complex eigenvalues':\n        eig1o.children[0].children[0].disabled = False\n        eig2o.children[1].children[0].disabled = False\n        eig3o.children[0].children[0].disabled = False\n        eig4o.children[0].children[0].disabled = True\n        eig4o.children[1].children[0].disabled = True\n        eigo = 2\n    if selec == '4 complex eigenvalues':\n        eig1c.children[0].children[0].disabled = True\n        eig2c.children[1].children[0].disabled = False\n        eig3c.children[0].children[0].disabled = True\n        eig4c.children[0].children[0].disabled = False\n        eig4c.children[1].children[0].disabled = False\n        eigc = 4\n    if seleo == '4 complex eigenvalues':\n        eig1o.children[0].children[0].disabled = True\n        eig2o.children[1].children[0].disabled = False\n        eig3o.children[0].children[0].disabled = True\n        eig4o.children[0].children[0].disabled = False\n        eig4o.children[1].children[0].disabled = False\n        eigo = 4\n    return eigc, eigo\n\ndef method_choice(selm):\n    if selm == 'Set K and L':\n        method = 1\n        selec.disabled = True\n        seleo.disabled = True\n    if selm == 'Set the eigenvalues':\n        method = 2\n        selec.disabled = False\n        seleo.disabled = False\n    return method\n\n\nc = 0.8\nm = 1.8\nomega = 32\nxi = 0.62\ng = 9.81\n\nA = numpy.matrix([[0, 1, 0, 0],\n                  [0, -c/m, g*omega**2, 0],\n                  [0, 0, 0, 1],\n                  [0, 0, -omega**2, -2*xi*omega]])\nB = numpy.matrix([[0],[0],[0],[1]])\nC = numpy.matrix([[1,0,0,0]])\nOLpoles, OLvectors = numpy.linalg.eig(A)\n\ndef main_callback2(X0w, K, L, eig1c, eig2c, eig3c, eig4c, eig1o, eig2o, eig3o, eig4o, u, period, selm, selec, seleo, selu, simTime, DW):\n    eigc, eigo = eigen_choice(selec,seleo)\n    method = method_choice(selm)\n    \n    if method == 1:\n        solc = numpy.linalg.eig(A-B*K)\n        solo = numpy.linalg.eig(A-L*C)\n    if method == 2:\n        #for bettere numerical stability of place\n        if eig1c[0,0]==eig2c[0,0] or eig1c[0,0]==eig3c[0,0] or eig1c[0,0]==eig4c[0,0]:\n            eig1c[0,0] *= 1.01\n        if eig2c[0,0]==eig3c[0,0] or eig2c[0,0]==eig4c[0,0]:\n            eig3c[0,0] *= 1.015\n        if eig1o[0,0]==eig2o[0,0] or eig1o[0,0]==eig3o[0,0] or eig1o[0,0]==eig4o[0,0]:\n            eig1o[0,0] *= 1.01\n        if eig2o[0,0]==eig3o[0,0] or eig2o[0,0]==eig4o[0,0]:\n            eig3o[0,0] *= 1.015\n            \n        if eigc == 0:\n            K = control.acker(A, B, [eig1c[0,0], eig2c[0,0], eig3c[0,0], eig4c[0,0]])\n            Kw.setM(K)\n        if eigc == 2:\n            K = control.acker(A, B, [eig3c[0,0],\n                                      eig1c[0,0],\n                                      numpy.complex(eig2c[0,0], eig2c[1,0]), \n                                      numpy.complex(eig2c[0,0],-eig2c[1,0])])\n            Kw.setM(K)\n        if eigc == 4:\n            K = control.acker(A, B, [numpy.complex(eig4c[0,0], eig4c[1,0]), \n                                      numpy.complex(eig4c[0,0],-eig4c[1,0]),\n                                      numpy.complex(eig2c[0,0], eig2c[1,0]), \n                                      numpy.complex(eig2c[0,0],-eig2c[1,0])])\n            Kw.setM(K)\n        if eigo == 0:\n            L = control.place(A.T, C.T, [eig1o[0,0], eig2o[0,0], eig3o[0,0], eig4o[0,0]]).T\n            Lw.setM(L)\n        if eigo == 2:\n            L = control.place(A.T, C.T, [eig3o[0,0],\n                                         eig1o[0,0],\n                                         numpy.complex(eig2o[0,0], eig2o[1,0]), \n                                         numpy.complex(eig2o[0,0],-eig2o[1,0])]).T\n            Lw.setM(L)\n        if eigo == 4:\n            L = control.place(A.T, C.T, [numpy.complex(eig4o[0,0], eig4o[1,0]), \n                                      numpy.complex(eig4o[0,0],-eig4o[1,0]),\n                                      numpy.complex(eig2o[0,0], eig2o[1,0]), \n                                      numpy.complex(eig2o[0,0],-eig2o[1,0])]).T\n            Lw.setM(L)\n            \n    sys = sss(A,B,[[1,0,0,0],[0,0,0,0]],[[0],[1]])\n    syse = sss(A-L*C,numpy.hstack((B,L)),numpy.eye(4),numpy.zeros((4,2)))\n    sysc = sss(0,[0,0,0,0],0,-K)\n    sys_append = control.append(sys,syse,sysc)\n    try:\n        sys_CL = control.connect(sys_append,\n                                 [[1,7],[2,2],[3,1],[4,3],[5,4],[6,5],[7,6]],\n                                 [1],\n                                 [1,2])\n    except:\n        sys_CL = control.connect(sys_append,\n                                 [[1,7],[2,2],[3,1],[4,3],[5,4],[6,5],[7,6]],\n                                 [1],\n                                 [1,2])\n\n    X0w1 = numpy.zeros((8,1))\n    X0w1[4,0] = X0w[0,0]\n    X0w1[5,0] = X0w[1,0]\n    X0w1[6,0] = X0w[2,0]\n    X0w1[7,0] = X0w[3,0]\n    \n    u1 = u\n    try:\n        DCgain = control.dcgain(sys_CL[0,0])\n        u = u/DCgain\n    except:\n        print(\"Error in the calculation of the dcgain of the closed loop controlled system. The feedforward gain is set to 1.\")\n        DCgain = 1\n        \n    if simTime != 0:\n        T = numpy.linspace(0, simTime, 10000)\n    else:\n        T = numpy.linspace(0, 1, 10000)\n      \n    if selu == 'impulse': #selu\n        U = [0 for t in range(0,len(T))]\n        U[0] = u\n        U1 = [0 for t in range(0,len(T))]\n        U1[0] = u1\n        T, yout, xout = control.forced_response(sys_CL,T,U,X0w1)\n    if selu == 'step':\n        U = [u for t in range(0,len(T))]\n        U1 = [u1 for t in range(0,len(T))]\n        T, yout, xout = control.forced_response(sys_CL,T,U,X0w1)\n    if selu == 'sinusoid':\n        U = u*numpy.sin(2*numpy.pi/period*T)\n        U1 = u1*numpy.sin(2*numpy.pi/period*T)\n        T, yout, xout = control.forced_response(sys_CL,T,U,X0w1)\n    if selu == 'square wave':\n        U = u*numpy.sign(numpy.sin(2*numpy.pi/period*T))\n        U1 = u1*numpy.sign(numpy.sin(2*numpy.pi/period*T))\n        T, yout, xout = control.forced_response(sys_CL,T,U,X0w1)\n    \n    try:\n        step_info_dict = control.step_info(sys_CL[0,0],SettlingTimeThreshold=0.05,T=T)\n        print('Open loop poles: ', numpy.round(OLpoles,3))\n        print('Closed Loop')\n        print('Step info: \\n\\tRise time =',step_info_dict['RiseTime'],'\\n\\tSettling time (5%) =',step_info_dict['SettlingTime'],'\\n\\tOvershoot (%)=',step_info_dict['Overshoot'])\n        print('')\n        print('Max theta value (% of 20°)=', max(abs(xout[2]*omega**2))/(numpy.pi/180*20)*100)\n    except:\n        print(\"Error in the calculation of step info.\")\n    print(\"Closed loop system's gain =\",DCgain)\n    \n    fig = plt.figure(num='Simulation1', figsize=(14,12))\n    \n    fig.add_subplot(221)\n    plt.title('Output response')\n    plt.ylabel('Output')\n    plt.plot(T,yout[0],T,U1,'r--')\n    plt.xlabel('$t$ [s]')\n    plt.axvline(x=0,color='black',linewidth=0.8)\n    plt.axhline(y=0,color='black',linewidth=0.8)\n    plt.legend(['$y$','Reference'])\n    plt.grid()\n    \n    fig.add_subplot(222)\n    plt.title('Input')\n    plt.ylabel('$u$')\n    plt.plot(T,yout[1])\n    plt.xlabel('$t$ [s]')\n    plt.axvline(x=0,color='black',linewidth=0.8)\n    plt.axhline(y=0,color='black',linewidth=0.8)\n    plt.grid()\n    \n    fig.add_subplot(223)\n    plt.title('Third state response')\n    plt.ylabel(r'$x_3$')\n    plt.plot(T,xout[2],\n             T,[20*numpy.pi/180/omega**2 for i in range(len(T))],'r--',\n             T,[-20*numpy.pi/180/omega**2 for i in range(len(T))],'r--')\n    plt.xlabel('$t$ [s]')\n    plt.axvline(x=0,color='black',linewidth=0.8)\n    plt.axhline(y=0,color='black',linewidth=0.8)\n    plt.grid()\n    \n    fig.add_subplot(224)\n    plt.title('Estimation errors')\n    plt.ylabel('Errors')\n    plt.plot(T,xout[4]-xout[0])\n    plt.plot(T,xout[5]-xout[1])\n    plt.plot(T,xout[6]-xout[2])\n    plt.plot(T,xout[7]-xout[3])\n    plt.xlabel('$t$ [s]')\n    plt.axvline(x=0,color='black',linewidth=0.8)\n    plt.axhline(y=0,color='black',linewidth=0.8)\n    plt.legend(['$e_{1}$','$e_{2}$','$e_{3}$','$e_{4}$'])\n    plt.grid()\n    #plt.tight_layout()\n   \nalltogether2 = widgets.VBox([widgets.HBox([selm, \n                                          selec,\n                                          seleo,\n                                          selu]),\n                            widgets.Label(' ',border=3),\n                            widgets.HBox([widgets.HBox([widgets.Label('K:',border=3), Kw, \n                                                        widgets.Label('Eigenvalues:',border=3),\n                                                        widgets.HBox([eig1c, \n                                                                      eig2c, \n                                                                      eig3c,\n                                                                      eig4c])])]),\n                            widgets.Label(' ',border=3),\n                            widgets.HBox([widgets.VBox([widgets.HBox([widgets.Label('L:',border=3), Lw, widgets.Label(' ',border=3),\n                                          widgets.Label(' ',border=3),\n                                          widgets.Label('Eigenvalues:',border=3), \n                                          eig1o, \n                                          eig2o,\n                                          eig3o, \n                                          eig4o,\n                                          widgets.Label(' ',border=3),\n                                          widgets.Label(' ',border=3),\n                                          widgets.Label('X0 est.:',border=3), X0w]),\n                                          widgets.Label(' ',border=3),\n                                                       widgets.HBox([\n                                          widgets.VBox([widgets.Label('Simulation time [s]:',border=3)]),\n                                          widgets.VBox([simTime])])]),\n                                          widgets.Label(' ',border=3)]),\n                            widgets.Label(' ',border=3),\n                            widgets.HBox([widgets.Label('Reference [m]:',border=3),\n                                          u,\n                                          period, \n                                          START])])\nout2 = widgets.interactive_output(main_callback2, {'X0w':X0w, 'K':Kw, 'L':Lw,\n                                                   'eig1c':eig1c, 'eig2c':eig2c, 'eig3c':eig3c, 'eig4c':eig4c, \n                                                   'eig1o':eig1o, 'eig2o':eig2o, 'eig3o':eig3o, 'eig4o':eig4o,  \n                                                   'u':u, 'period':period, 'selm':selm, 'selec':selec, 'seleo':seleo, 'selu':selu, 'simTime':simTime, 'DW':DW})\nout2.layout.height = '900px'\ndisplay(out2, alltogether2)"
  },
  {
    "objectID": "ICCT_en/examples/04/SS-44-Car_cruise_control.html",
    "href": "ICCT_en/examples/04/SS-44-Car_cruise_control.html",
    "title": "Car cruise control",
    "section": "",
    "text": "#remove cell visibility\nfrom IPython.display import HTML\ntag = HTML('''&lt;script&gt;\ncode_show=true; \nfunction code_toggle() {\n    if (code_show){\n        $('div.input').hide()\n    } else {\n        $('div.input').show()\n    }\n    code_show = !code_show\n} \n$( document ).ready(code_toggle);\n&lt;/script&gt;\nToggle cell visibility &lt;a href=\"javascript:code_toggle()\"&gt;here&lt;/a&gt;.''')\ndisplay(tag)\n\n\nToggle cell visibility here.\n\n\nThe velocity dynamics of a car can be modelled (see the accompanying manual on page. XX for a full derivation) as:\n\\[\n\\begin{cases}\n\\dot{x}=\\underbrace{\\begin{bmatrix}-\\frac{b}{m}&\\frac{\\tau_{\\text{max}}\\eta}{mr}\\\\0&-\\frac{1}{2}\\end{bmatrix}}_{A}x+\\underbrace{\\begin{bmatrix}0\\\\\\frac{1}{2}\\end{bmatrix}}_{B}t_r \\\\\ny = \\underbrace{\\begin{bmatrix}3.6&0\\end{bmatrix}}_{C}x\n\\end{cases}\n\\]\nwhere \\(y\\) is car speed (in km/h), the car mass \\(m\\) is \\(1000\\) kg, maximum motor torque \\(\\tau_{\\text{max}}\\) is 150 Nm, wheel radius \\(r\\) is 25 cm (with a gear ratio constant \\(\\eta\\) and 4:1 engine:wheel), the aerodynamic speed damping factor \\(b\\) is \\(60\\) Ns/m, and \\(\\tau_{\\%}\\) is throttle command (to be kept within 0 and 1). The system is controllable and observable.\nThe goal is to design a control system that regulates the car speed by acting on the motor throttle according to the following specifications: - zero steady-state error in response to a step-wise change of the desired speed, - no overshoot, or at least less than 1%, - settling time for 5% tolerance band of less than 4 seconds.\n\nRegulator design\nIt is important to notice that it is not possible to meet the requirement on the settling time for all possible reference speed values. This is easy to understand with physical reasoning: air drag is much larger at higher velocities, thus the car cannot accelerate at higher velocities as it can at lower speeds. Furthermore, it is easy to show that even if the air drag is negligible (\\(b=0\\)), the maximum speed change achievable at full throttle in 5 seconds is 43.2 km/h. Therefore, the control system will be developed in order to respect the first two requirements and to make the system as fast as possible.\n\nDesign of the state feedback control\nTo achieve zero steady-state error in response to a step, the system is augmented by adding a state \\(x_3 = v-v_{\\text{ref}}\\), where \\(v_{\\text{ref}}\\) becomes the reference input in km/h. The augmented system’s equations then become:\n\\[\n\\begin{cases}\n\\dot{x_a}=\\underbrace{\\begin{bmatrix}-\\frac{b}{m}&\\frac{\\tau_{\\text{max}}\\eta}{mr}&0\\\\0&-\\frac{1}{2}&0\\\\3.6&0&0\\end{bmatrix}}_{A_a}x_a+\\underbrace{\\begin{bmatrix}0\\\\\\frac{1}{2}\\\\0\\end{bmatrix}}_{B_a}t_r+\\underbrace{\\begin{bmatrix}0\\\\0\\\\-1\\end{bmatrix}}_{B_{\\text{ref}}}v_{\\text{ref}} \\\\\ny_a = \\underbrace{\\begin{bmatrix}3.6&0&0\\\\0&0&1\\end{bmatrix}}_{C_a}x_a\n\\end{cases}\n\\]\nNote that the system remains controllable.\nA possible solution is to set the eigenvalues of \\(A-BK\\) in \\(-0.06\\), \\(-2.43-2.41i\\) and \\(-2.43+2.41i\\) with \\(K_a=\\begin{bmatrix}9.75&8.73&0.15\\end{bmatrix}\\).\n\n\nObserver design\nThe observer is developed based on the initial system in order to estimate \\(x_1\\) and \\(x_2\\). The poles of the error’s dynamics (\\(A-LC\\)) are placed both in \\(-10\\)rad/s with \\(L=\\begin{bmatrix}5.4&10.45\\end{bmatrix}^T\\).\nThe system with the controller is simulated below. It is possible also to simulate it with saturation on the input.\n\n%matplotlib inline\nimport control as control\nimport numpy\nimport sympy as sym\nfrom IPython.display import display, Markdown\nimport ipywidgets as widgets\nimport matplotlib.pyplot as plt\n\n\n#print a matrix latex-like\ndef bmatrix(a):\n     \"\"\"Returns a LaTeX bmatrix - by Damir Arbula (ICCT project)\n\n     :a: numpy array\n     :returns: LaTeX bmatrix as a string\n     \"\"\"\n     if len(a.shape) &gt; 2:\n         raise ValueError('bmatrix can at most display two dimensions')\n     lines = str(a).replace('[', '').replace(']', '').splitlines()\n     rv = [r'\\begin{bmatrix}']\n     rv += ['  ' + ' & '.join(l.split()) + r'\\\\' for l in lines]\n     rv +=  [r'\\end{bmatrix}']\n     return '\\n'.join(rv)\n\n\n# Display formatted matrix: \ndef vmatrix(a):\n    if len(a.shape) &gt; 2:\n         raise ValueError('bmatrix can at most display two dimensions')\n    lines = str(a).replace('[', '').replace(']', '').splitlines()\n    rv = [r'\\begin{vmatrix}']\n    rv += ['  ' + ' & '.join(l.split()) + r'\\\\' for l in lines]\n    rv +=  [r'\\end{vmatrix}']\n    return '\\n'.join(rv)\n\n\n#matrixWidget is a matrix looking widget built with a VBox of HBox(es) that returns a numPy array as value !\nclass matrixWidget(widgets.VBox):\n    def updateM(self,change):\n        for irow in range(0,self.n):\n            for icol in range(0,self.m):\n                self.M_[irow,icol] = self.children[irow].children[icol].value\n                #print(self.M_[irow,icol])\n        self.value = self.M_\n\n    def dummychangecallback(self,change):\n        pass\n    \n    \n    def __init__(self,n,m):\n        self.n = n\n        self.m = m\n        self.M_ = numpy.matrix(numpy.zeros((self.n,self.m)))\n        self.value = self.M_\n        widgets.VBox.__init__(self,\n                             children = [\n                                 widgets.HBox(children = \n                                              [widgets.FloatText(value=0.0, layout=widgets.Layout(width='90px')) for i in range(m)]\n                                             ) \n                                 for j in range(n)\n                             ])\n        \n        #fill in widgets and tell interact to call updateM each time a children changes value\n        for irow in range(0,self.n):\n            for icol in range(0,self.m):\n                self.children[irow].children[icol].value = self.M_[irow,icol]\n                self.children[irow].children[icol].observe(self.updateM, names='value')\n        #value = Unicode('example@example.com', help=\"The email value.\").tag(sync=True)\n        self.observe(self.updateM, names='value', type= 'All')\n        \n    def setM(self, newM):\n        #disable callbacks, change values, and reenable\n        self.unobserve(self.updateM, names='value', type= 'All')\n        for irow in range(0,self.n):\n            for icol in range(0,self.m):\n                self.children[irow].children[icol].unobserve(self.updateM, names='value')\n        self.M_ = newM\n        self.value = self.M_\n        for irow in range(0,self.n):\n            for icol in range(0,self.m):\n                self.children[irow].children[icol].value = self.M_[irow,icol]\n        for irow in range(0,self.n):\n            for icol in range(0,self.m):\n                self.children[irow].children[icol].observe(self.updateM, names='value')\n        self.observe(self.updateM, names='value', type= 'All')        \n\n                #self.children[irow].children[icol].observe(self.updateM, names='value')\n\n             \n#overlaod class for state space systems that DO NOT remove \"useless\" states (what \"professor\" of automatic control would do this?)\nclass sss(control.StateSpace):\n    def __init__(self,*args):\n        #call base class init constructor\n        control.StateSpace.__init__(self,*args)\n    #disable function below in base class\n    def _remove_useless_states(self):\n        pass\n\n\n# Preparatory cell\n\nAa = numpy.matrix([[-3/50,2.4,0],[0,-0.5,0],[3.6,0,0]])\nBa = numpy.matrix('0; 0.5; 0')\nA = numpy.matrix([[-3/50, 2.4],[0,-0.5]])\nB = numpy.matrix('0; 0.5')\nC = numpy.matrix('3.6 0')\nX0 = numpy.matrix('0.; 0.')\nK = numpy.matrix([9.75,8.73,0.15])\nL = numpy.matrix([[5.4],[10.45]])\n\n# Aw = matrixWidget(3,3)\n# Aw.setM(A)\n# Bw = matrixWidget(3,1)\n# Bw.setM(B)\n# Cw = matrixWidget(1,3)\n# Cw.setM(C)\nX0w = matrixWidget(2,1)\nX0w.setM(X0)\nKw = matrixWidget(1,3)\nKw.setM(K)\nLw = matrixWidget(2,1)\nLw.setM(L)\n\n\neig1c = matrixWidget(1,1)\neig2c = matrixWidget(2,1)\neig3c = matrixWidget(1,1)\neig1c.setM(numpy.matrix([-0.06])) \neig2c.setM(numpy.matrix([[-2.43],[-2.41]]))\neig3c.setM(numpy.matrix([-0.06]))\n\neig1o = matrixWidget(1,1)\neig2o = matrixWidget(2,1)\neig1o.setM(numpy.matrix([-10.])) \neig2o.setM(numpy.matrix([[-10.],[0.]]))\n\n\n# Misc\n\n#create dummy widget \nDW = widgets.FloatText(layout=widgets.Layout(width='0px', height='0px'))\n\n#create button widget\nSTART = widgets.Button(\n    description='Test',\n    disabled=False,\n    button_style='', # 'success', 'info', 'warning', 'danger' or ''\n    tooltip='Test',\n    icon='check'\n)\n                       \ndef on_start_button_clicked(b):\n    #This is a workaround to have intreactive_output call the callback:\n    #   force the value of the dummy widget to change\n    if DW.value&gt; 0 :\n        DW.value = -1\n    else: \n        DW.value = 1\n    pass\nSTART.on_click(on_start_button_clicked)\n\n# Define type of method \nselm = widgets.Dropdown(\n    options= ['Set K and L', 'Set the eigenvalues'],\n    value= 'Set K and L',\n    description='',\n    disabled=False\n)\n\n# Define the number of complex eigenvalues\nsele = widgets.Dropdown(\n    options= ['0 complex eigenvalues', '2 complex eigenvalues'],\n    value= '2 complex eigenvalues',\n    description='Complex eigenvalues:',\n    style = {'description_width': 'initial'},\n    disabled=False\n)\n\n#define type of ipout \nselu = widgets.Dropdown(\n    options=['impulse', 'step', 'sinusoid', 'square wave'],\n    value='step',\n    description='Type of reference:',\n    style = {'description_width': 'initial'},\n    disabled=False\n)\n# Define the values of the input\nu = widgets.FloatSlider(\n    value=30.,\n    min=1.,\n    max=150.0,\n    step=1,\n    description='Reference:',\n    disabled=False,\n    continuous_update=False,\n    orientation='horizontal',\n    readout=True,\n    readout_format='.1f',\n)\nperiod = widgets.FloatSlider(\n    value=30,\n    min=1,\n    max=80,\n    step=1,\n    description='Period: ',\n    disabled=False,\n    continuous_update=False,\n    orientation='horizontal',\n    readout=True,\n    readout_format='.2f',\n)\ntime = widgets.BoundedIntText(\n    value=120,\n    min=1,\n    max=200,\n    step=1,\n    description='Time:',\n    disabled=False\n)\nsim = widgets.Checkbox(\n    value=False,\n    description='Saturation',\n    disabled=False,\n    indent=False\n)\n\n\n# Support functions\n\ndef eigen_choice(sele):\n    if sele == '0 complex eigenvalues':\n        eig1c.children[0].children[0].disabled = False\n        eig2c.children[1].children[0].disabled = True\n        eig1o.children[0].children[0].disabled = False\n        eig2o.children[1].children[0].disabled = True\n        eig = 0\n    if sele == '2 complex eigenvalues':\n        eig1c.children[0].children[0].disabled = True\n        eig2c.children[1].children[0].disabled = False\n        eig1o.children[0].children[0].disabled = True\n        eig2o.children[1].children[0].disabled = False\n        eig = 2\n    return eig\n\ndef method_choice(selm):\n    if selm == 'Set K and L':\n        method = 1\n        sele.disabled = True\n    if selm == 'Set the eigenvalues':\n        method = 2\n        sele.disabled = False\n    return method\n\ndef simulation(sys_G, sys_K, sys_int, x0, x0k, time, Ts, ref, lim):\n    '''Function that simulate a siso feedback system with a saturation in the actuator and integral action.\n       Input to sys_K [u_sys_G; y_sys_G].\n       sys_int must have k_3 as gain in output and B = [1, -1] associated to y and ref.'''\n    if len(time) != len(ref):\n        print('Error: T and ref must have the same size!')\n        return\n\n    # Initialization and preparation...\n    K_temp = control.append(sys_K,sys_int)\n    K = sss(K_temp.A, \n            K_temp.B*sym.Matrix([[1,0,0],[0,1,0],[0,1,0],[0,0,1]]), \n            sym.Matrix([1,1]).T*K_temp.C, \n            sym.Matrix([1,1]).T*K_temp.D*sym.Matrix([[1,0,0],[0,1,0],[0,1,0],[0,0,1]]))\n    sys_temp = control.append(sys_G,K)\n    sys_temp1 = sss(sys_temp.A, \n                    sys_temp.B*sym.Matrix([[1,0,0],[1,0,0],[0,1,0],[0,0,1]]),\n                    sys_temp.C,\n                    sys_temp.D*sym.Matrix([[1,0,0],[1,0,0],[0,1,0],[0,0,1]]))\n    #sys = control.connect(sys_temp1,[[2,1]],[1,3],[1,2])\n    sys = sss(sys_temp1.A+sys_temp1.B[:,1]*sys_temp1.C[0,:],\n              sym.Matrix(sys_temp1.B[:,0]).row_join(sym.Matrix(sys_temp1.B[:,2])),\n              sys_temp1.C,\n              [[0,0],[0,0]])\n    sys_d = control.c2d(sys,Ts)\n    A, B, C, D = sys_d.A, sys_d.B, sys_d.C, sys_d.D\n\n    # Initializing system's variables\n    x = [x0.col_join(x0k).col_join(sym.Matrix([0])) for t in range(0,len(time))]\n    yinit = C*x[0]\n    y = [yinit for t in range(0,len(time))]\n    Input = [sym.Matrix([yinit[1],ref[t]]) for t in range(0,len(time))]\n\n    for i in range(1,len(time)):\n        Input[i-1][0] = -y[i-1][1]\n        if Input[i-1][0] &gt; lim:\n            Input[i-1][0] = lim\n        elif Input[i-1][0] &lt; 0:\n            Input[i-1][0] = 0.\n    \n        x[i] = A*x[i-1] + B*Input[i-1]\n        y[i] = C*x[i-1] + D*Input[i-1]\n        \n    if Input[-1][0] &gt; lim:\n            Input[-1][0] = lim\n    elif Input[-1][0] &lt; 0:\n            Input[-1][0] = 0.\n            \n    y  = [y[t][0] for t in range(len(y))]\n    U  = [Input[t][0] for t in range(len(Input))]\n    x  = [[x[i][t] for i in range(len(x))] for t in range(A.shape[0])]\n    return (y, U, x)\n\ndef simulation_ideal(sys_G, sys_K, sys_int):\n    K_temp = control.append(sys_K,sys_int)\n    Ka = sss(K_temp.A, \n            K_temp.B*sym.Matrix([[1,0,0],[0,1,0],[0,1,0],[0,0,1]]), \n            sym.Matrix([1,1]).T*K_temp.C, \n            sym.Matrix([1,1]).T*K_temp.D*sym.Matrix([[1,0,0],[0,1,0],[0,1,0],[0,0,1]]))\n    sys_temp = control.append(sys_G,Ka)\n    sys_temp1 = sss(sys_temp.A, \n                    sys_temp.B*sym.Matrix([[1,0,0],[1,0,0],[0,1,0],[0,0,1]]),\n                    sys_temp.C,\n                    sys_temp.D*sym.Matrix([[1,0,0],[1,0,0],[0,1,0],[0,0,1]]))\n    #sys = control.connect(sys_temp1,[[2,1],[1,-2]],[3],[1,2])\n    sys = sss(sys_temp1.A+sys_temp1.B[:,1]*sys_temp1.C[0,:]-sys_temp1.B[:,0]*sys_temp1.C[1,:],\n              sys_temp1.B[:,2],\n              sys_temp1.C,\n              [[0],[0]])\n    return sys\n\n\nsols = numpy.linalg.eig(A)\nx0 = sym.Matrix([0,0])\nlim = 1.\n\ndef main_callback(X0w, K, L, eig1c, eig2c, eig3c, eig1o, eig2o, u, period, selm, sele, selu, sim, time, DW):\n    eige = eigen_choice(sele)\n    method = method_choice(selm)\n    \n    if method == 1:\n        solc = numpy.linalg.eig(Aa-Ba*K)\n        solo = numpy.linalg.eig(A-L*C)\n    if method == 2:\n        if eige == 0:\n            K = control.acker(Aa, Ba, [eig1c[0,0], eig2c[0,0], eig3c[0,0]])\n            Kw.setM(K)\n            L = control.acker(A.T, C.T, [eig1o[0,0], eig2o[0,0]]).T\n            Lw.setM(L)\n        if eige == 2:\n            K = control.acker(Aa, Ba, [eig3c[0,0], \n                                     numpy.complex(eig2c[0,0],eig2c[1,0]), \n                                     numpy.complex(eig2c[0,0],-eig2c[1,0])])\n            Kw.setM(K)\n            L = control.acker(A.T, C.T, [numpy.complex(eig2o[0,0],eig2o[1,0]), \n                                         numpy.complex(eig2o[0,0],-eig2o[1,0])]).T\n            Lw.setM(L)\n\n    # Simulation without saturation\n    sys_G   = sss(A,B,C,0)\n    sys_K   = sss(A-L*C,sym.Matrix(B).row_join(sym.Matrix(L)),K[0][0,:2],[0,0])\n    sys_int = sss(0,sym.Matrix([1,-1]).T,K[0][0,2],[0,0])\n    x0 = sym.Matrix([0.,0.])\n    sys = simulation_ideal(sys_G, sys_K, sys_int)\n    solc = sym.Matrix(sys.A).eigenvals(multiple=True,rational=False)\n    solc = numpy.matrix(solc,dtype=numpy.complex128)\n    print('The system\\'s eigenvalues are:', round(sols[0][0],2),'and', round(sols[0][1],2))\n    print('The controlled closed loop system\\'s eigenvalues are:', \n          round(solc[0,0],2),',', \n          round(solc[0,1],2),',', \n          round(solc[0,2],2),',',\n          round(solc[0,3],2),'and',\n          round(solc[0,4],2))\n    \n    X0w1 = [float(x0[0,0]),float(x0[1,0]),float(X0w[0,0]),float(X0w[1,0]),0.]\n    T, Td = numpy.linspace(0,time,1000,retstep=True)\n      \n    if selu == 'impulse': #selu\n        U = [0 for t in range(0,len(T))]\n        U[0] = u\n        if sim == False:\n            T, yout, xout = control.forced_response(sys,T,U,X0w1)\n    if selu == 'step':\n        U = [u for t in range(0,len(T))]\n        if sim == False:\n            T, yout, xout = control.forced_response(sys,T,U,X0w1)\n    if selu == 'sinusoid':\n        U = u*numpy.sin(2*numpy.pi/period*T)+u\n        if sim == False:\n            T, yout, xout = control.forced_response(sys,T,U,X0w1)\n    if selu == 'square wave':\n        U = u*numpy.sign(numpy.sin(2*numpy.pi/period*T))+u\n        if sim == False:\n            T, yout, xout = control.forced_response(sys,T,U,X0w1)\n    \n    if sim:\n        y_sat, U_sat, x_sat = simulation(sys_G, sys_K, sys_int, x0, sym.Matrix(X0w), T, Td, U, lim)\n    \n    fig = plt.figure(num='Simulation', figsize=(14,12))\n    fig.add_subplot(224)\n    plt.title('Output response')\n    plt.ylabel('Output')\n    if sim:\n        plt.plot(T,y_sat,T,U,'r--')\n        plt.legend(['$y_{sat}$','Reference'])\n    else:\n        plt.plot(T,yout[0],T,U,'r--')\n        plt.legend(['$y$','Reference'])\n    plt.xlabel('$t$ [s]')\n    plt.axvline(x=0,color='black',linewidth=0.8)\n    plt.axhline(y=0,color='black',linewidth=0.8)\n    plt.grid()\n    \n    fig.add_subplot(221)\n    plt.title('First state response')\n    plt.ylabel('$x_1$')\n    if sim:\n        plt.plot(T,x_sat[0],T,x_sat[2])\n        plt.legend(['$x_{1sat}$','$x_{1est}$'])\n    else:\n        plt.plot(T,xout[0],T,xout[2])\n        plt.legend(['$x_{1}$','$x_{1est}$'])\n    plt.xlabel('$t$ [s]')\n    plt.axvline(x=0,color='black',linewidth=0.8)\n    plt.axhline(y=0,color='black',linewidth=0.8)\n    plt.grid()\n    \n    fig.add_subplot(222)\n    plt.title('Second state response')\n    plt.ylabel('$x_2$')\n    if sim:\n        plt.plot(T,x_sat[1],T,x_sat[3])\n        plt.legend(['$x_{2sat}$','$x_{2est}$'])\n    else:\n        plt.plot(T,xout[1],T,xout[3])\n        plt.legend(['$x_{2}$','$x_{2est}$'])\n    plt.xlabel('$t$ [s]')\n    plt.axvline(x=0,color='black',linewidth=0.8)\n    plt.axhline(y=0,color='black',linewidth=0.8)\n    plt.grid()\n    \n    fig.add_subplot(223)\n    plt.title('Input')\n    plt.ylabel('Input')\n    if sim:\n        plt.plot(T[:-1],U_sat[:-1],T,[1 for t in range(len(T))],'r--')\n        plt.legend(['$Throttle$','$limit$'])\n    else:\n        plt.plot(T,-yout[1],T,[1 for t in range(len(T))],'r--')\n        plt.legend(['$Throttle$','$limit$'])\n    plt.xlabel('$t$ [s]')\n    plt.axvline(x=0,color='black',linewidth=0.8)\n    plt.axhline(y=0,color='black',linewidth=0.8)\n    plt.grid()\n    if selu == 'step':\n        if sim:\n            print('The maximum overshoot is:',round((max(y_sat)-U[0])/U[0]*100,3),'percent')\n        else:\n            print('The maximum overshoot is:',round((max(yout[0])-U[0])/U[0]*100,3),'percent')\n\n   \nalltogether = widgets.VBox([widgets.HBox([selm, \n                                          sele,\n                                          selu]),\n                            widgets.Label(' ',border=3),\n                            widgets.HBox([widgets.Label('K:',border=3), Kw, \n                                          widgets.Label(' ',border=3),\n                                          widgets.Label(' ',border=3),\n                                          widgets.Label('Eigenvalues:',border=3), \n                                          eig1c, \n                                          eig2c, \n                                          eig3c,\n                                          widgets.Label(' ',border=3),\n                                          widgets.Label(' ',border=3),\n                                          widgets.Label('X0 est.:',border=3), X0w]),\n                            widgets.Label(' ',border=3),\n                            widgets.HBox([widgets.Label('L:',border=3), Lw, \n                                          widgets.Label(' ',border=3),\n                                          widgets.Label(' ',border=3),\n                                          widgets.Label('Eigenvalues:',border=3), \n                                          eig1o, \n                                          eig2o, \n                                          widgets.Label(' ',border=3),\n                                          time]),\n                            widgets.Label(' ',border=3),\n                            widgets.HBox([u, \n                                          period,\n                                          widgets.Label(' ',border=3),widgets.Label(' ',border=3),sim]),\n                            widgets.HBox([widgets.Label('Click for K, L or eigenvalues -&gt;',border=3),\n                            START])])\nout = widgets.interactive_output(main_callback, {'X0w':X0w, 'K':Kw, 'L':Lw,\n                                                 'eig1c':eig1c, 'eig2c':eig2c, 'eig3c':eig3c, \n                                                 'eig1o':eig1o, 'eig2o':eig2o, \n                                                 'u':u, 'period':period, 'selm':selm, 'sele':sele, 'selu':selu,\n                                                 'sim':sim, 'time':time, 'DW':DW})\nout.layout.height = '840px'\ndisplay(out, alltogether)"
  },
  {
    "objectID": "ICCT_en/examples/04/SS-42-Missile_attitude_control.html",
    "href": "ICCT_en/examples/04/SS-42-Missile_attitude_control.html",
    "title": "Missile attitude control",
    "section": "",
    "text": "#remove cell visibility\nfrom IPython.display import HTML\ntag = HTML('''&lt;script&gt;\ncode_show=true; \nfunction code_toggle() {\n    if (code_show){\n        $('div.input').hide()\n    } else {\n        $('div.input').show()\n    }\n    code_show = !code_show\n} \n$( document ).ready(code_toggle);\n&lt;/script&gt;\nToggle cell visibility &lt;a href=\"javascript:code_toggle()\"&gt;here&lt;/a&gt;.''')\ndisplay(tag)\n\n\nToggle cell visibility here.\n\n\n\n%matplotlib inline\nimport control\nimport numpy\nimport sympy as sym\nfrom IPython.display import display, Markdown\nimport ipywidgets as widgets\nimport matplotlib.pyplot as plt\n\n\n#print a matrix latex-like\ndef bmatrix(a):\n     \"\"\"Returns a LaTeX bmatrix - by Damir Arbula (ICCT project)\n\n     :a: numpy array\n     :returns: LaTeX bmatrix as a string\n     \"\"\"\n     if len(a.shape) &gt; 2:\n         raise ValueError('bmatrix can at most display two dimensions')\n     lines = str(a).replace('[', '').replace(']', '').splitlines()\n     rv = [r'\\begin{bmatrix}']\n     rv += ['  ' + ' & '.join(l.split()) + r'\\\\' for l in lines]\n     rv +=  [r'\\end{bmatrix}']\n     return '\\n'.join(rv)\n\n\n# Display formatted matrix: \ndef vmatrix(a):\n    if len(a.shape) &gt; 2:\n         raise ValueError('bmatrix can at most display two dimensions')\n    lines = str(a).replace('[', '').replace(']', '').splitlines()\n    rv = [r'\\begin{vmatrix}']\n    rv += ['  ' + ' & '.join(l.split()) + r'\\\\' for l in lines]\n    rv +=  [r'\\end{vmatrix}']\n    return '\\n'.join(rv)\n\n\n#matrixWidget is a matrix looking widget built with a VBox of HBox(es) that returns a numPy array as value !\nclass matrixWidget(widgets.VBox):\n    def updateM(self,change):\n        for irow in range(0,self.n):\n            for icol in range(0,self.m):\n                self.M_[irow,icol] = self.children[irow].children[icol].value\n                #print(self.M_[irow,icol])\n        self.value = self.M_\n\n    def dummychangecallback(self,change):\n        pass\n    \n    \n    def __init__(self,n,m):\n        self.n = n\n        self.m = m\n        self.M_ = numpy.matrix(numpy.zeros((self.n,self.m)))\n        self.value = self.M_\n        widgets.VBox.__init__(self,\n                             children = [\n                                 widgets.HBox(children = \n                                              [widgets.FloatText(value=0.0, layout=widgets.Layout(width='90px')) for i in range(m)]\n                                             ) \n                                 for j in range(n)\n                             ])\n        \n        #fill in widgets and tell interact to call updateM each time a children changes value\n        for irow in range(0,self.n):\n            for icol in range(0,self.m):\n                self.children[irow].children[icol].value = self.M_[irow,icol]\n                self.children[irow].children[icol].observe(self.updateM, names='value')\n        #value = Unicode('example@example.com', help=\"The email value.\").tag(sync=True)\n        self.observe(self.updateM, names='value', type= 'All')\n        \n    def setM(self, newM):\n        #disable callbacks, change values, and reenable\n        self.unobserve(self.updateM, names='value', type= 'All')\n        for irow in range(0,self.n):\n            for icol in range(0,self.m):\n                self.children[irow].children[icol].unobserve(self.updateM, names='value')\n        self.M_ = newM\n        self.value = self.M_\n        for irow in range(0,self.n):\n            for icol in range(0,self.m):\n                self.children[irow].children[icol].value = self.M_[irow,icol]\n        for irow in range(0,self.n):\n            for icol in range(0,self.m):\n                self.children[irow].children[icol].observe(self.updateM, names='value')\n        self.observe(self.updateM, names='value', type= 'All')        \n\n                #self.children[irow].children[icol].observe(self.updateM, names='value')\n\n             \n#overlaod class for state space systems that DO NOT remove \"useless\" states (what \"professor\" of automatic control would do this?)\nclass sss(control.StateSpace):\n    def __init__(self,*args):\n        #call base class init constructor\n        control.StateSpace.__init__(self,*args)\n    #disable function below in base class\n    def _remove_useless_states(self):\n        pass\n\nMissile guidance is usually achieved by means of acceleration commands. The dynamic model of the missile of interest is given by the following equations obtained by system identification:\n\\[\\begin{cases}\n\\dot{\\textbf{X}}=\\begin{bmatrix}\\dot{x_1} \\\\ \\dot{x_2} \\\\ \\dot{x_3}\\end{bmatrix} =\\begin{bmatrix}-1.364 & −92.82 & −128.46 \\\\ 1 & −4.68 & −0.087 \\\\ 0 & 0 & -190 \\end{bmatrix} \\begin{bmatrix} x_1 \\\\x_2 \\\\ x_3 \\end{bmatrix}+\\begin{bmatrix}0 \\\\0 \\\\190\\end{bmatrix}u \\\\\na=\\begin{bmatrix}1.36 & −184.26 & 76.43\\end{bmatrix}\\textbf{X},\n\\end{cases}\\]\nwhere \\(x_1\\) is pitch rate in rad/s, \\(x_2\\) is angle of attack in rad, \\(x_3\\) is rudder angle in rad, \\(u\\) is rudder command in rad/s, and the output is lateral acceleration \\(a\\) in m/\\(\\text{s}^2\\). Aim is to design a flight control system that regulates missile acceleration to the desired value \\(a_d\\). The maximum rudder deflection is $$17 degrees.\nThe aim is to design a regulator that controls the missile acceleration by acting on rudder angle according to the following specifications: - steady-state error (in response to a desired acceleration step input equal to \\(3 G \\simeq 30\\) \\(\\text{m/s}^2\\)) is less than 1%, - max overshoot: 5%, - settling time for 5% tolerance band is less than 0.1 seconds.\n\nRegulator design\n\nController design\nThe system’s controllability matrix \\(\\mathcal{C}\\) is:\n\nA = numpy.matrix('-1.364 -92.82 -128.46; 1 -4.68 -0.087; 0 0 -190')\nB = numpy.matrix('0; 0; 190')\nC = numpy.matrix('1.36 -184.26 76.43')\nD = numpy.matrix('0')\nCtrb = control.ctrb(A,B)\ndisplay(Markdown(bmatrix(Ctrb)))\n# print(numpy.linalg.matrix_rank(Ctrb))\n\n\\[\\begin{bmatrix}\n  0.00000000e+00 & -2.44074000e+04 & 4.67223201e+06\\\\\n  0.00000000e+00 & -1.65300000e+01 & -2.11893396e+04\\\\\n  1.90000000e+02 & -3.61000000e+04 & 6.85900000e+06\\\\\n\\end{bmatrix}\\]\n\n\nthat has rank equal to 3, so the system is controllable.\nThe transfer function of the system is\n\nsys = sss(A,B,C,0)\nprint(control.ss2tf(sys))\n\n\n1.452e+04 s^2 + 5.762e+04 s + 5.789e+06\n---------------------------------------\n  s^3 + 196 s^2 + 1248 s + 1.885e+04\n\n\n\nand the poles and zeros are\n\nprint('Poles: ', sys.pole())\nprint('Zeros: ', sys.zero())\n\nPoles:  [  -3.022+9.49057617j   -3.022-9.49057617j -190.   +0.j        ]\nZeros:  [-1.98395879+19.86693768j -1.98395879-19.86693768j]\n\n\nWe find that placing 2 imaginary poles near the zeros results in a good response, so the poles that we choose are \\(-2+19.1i\\), \\(-2-19.1i\\) and \\(-45\\).\n\n\nObserver design\nThe system’s observability matrix \\(\\mathcal{O}\\) is:\n\nObsv = control.obsv(A,C) \ndisplay(Markdown(bmatrix(Obsv)))\n# print(numpy.linalg.matrix_rank(Obsv))\n\n\\[\\begin{bmatrix}\n  1.36000000e+00 & -1.84260000e+02 & 7.64300000e+01\\\\\n  -1.86115040e+02 & 7.36101600e+02 & -1.46803750e+04\\\\\n  9.89962515e+02 & 1.38302425e+04 & 2.81311554e+06\\\\\n\\end{bmatrix}\\]\n\n\nthat has rank equal to 3, so the system is observable.\nThe only requirement that we have for the observer is that the error dynamics converges in approximately less than 0.1 s. A good choice for the observer poles is \\(-50\\), \\(-50\\), and \\(-50\\).\n\n\n\nHow to use this notebook?\nTry to achieve the performance requirements with other locations of the poles and with errors in the initial state of the observer.\n\n# Preparatory cell\n\nX0 = numpy.matrix('0.0; 0.0; 0.0')\nK = numpy.matrix([8/15,-4.4,-4])\nL = numpy.matrix([[23],[66],[107/3]])\n\nAw = matrixWidget(3,3)\nAw.setM(A)\nBw = matrixWidget(3,1)\nBw.setM(B)\nCw = matrixWidget(1,3)\nCw.setM(C)\nX0w = matrixWidget(3,1)\nX0w.setM(X0)\nKw = matrixWidget(1,3)\nKw.setM(K)\nLw = matrixWidget(3,1)\nLw.setM(L)\n\n\neig1c = matrixWidget(1,1)\neig2c = matrixWidget(2,1)\neig3c = matrixWidget(1,1)\neig1c.setM(numpy.matrix([-60.])) \neig2c.setM(numpy.matrix([[-2.],[-19.1]]))\neig3c.setM(numpy.matrix([-45.]))\n\neig1o = matrixWidget(1,1)\neig2o = matrixWidget(2,1)\neig3o = matrixWidget(1,1)\neig1o.setM(numpy.matrix([-50.])) \neig2o.setM(numpy.matrix([[-50.],[0.]]))\neig3o.setM(numpy.matrix([-50.]))\n\n\n# Misc\n\n#create dummy widget \nDW = widgets.FloatText(layout=widgets.Layout(width='0px', height='0px'))\n\n#create button widget\nSTART = widgets.Button(\n    description='Test',\n    disabled=False,\n    button_style='', # 'success', 'info', 'warning', 'danger' or ''\n    tooltip='Test',\n    icon='check'\n)\n                       \ndef on_start_button_clicked(b):\n    #This is a workaround to have intreactive_output call the callback:\n    #   force the value of the dummy widget to change\n    if DW.value&gt; 0 :\n        DW.value = -1\n    else: \n        DW.value = 1\n    pass\nSTART.on_click(on_start_button_clicked)\n\n# Define type of method \nselm = widgets.Dropdown(\n    options= ['Set K and L', 'Set the eigenvalues'],\n    value= 'Set the eigenvalues',\n    description='',\n    disabled=False\n)\n\n# Define the number of complex eigenvalues\nsele = widgets.Dropdown(\n    options= ['0 complex eigenvalues', '2 complex eigenvalues'],\n    value= '2 complex eigenvalues',\n    description='Complex eigenvalues:',\n    style = {'description_width': 'initial'},\n    disabled=False\n)\n\n#define type of ipout \nselu = widgets.Dropdown(\n    options=['impulse', 'step', 'sinusoid', 'square wave'],\n    value='step',\n    description='Type of reference:',\n    style = {'description_width': 'initial'},\n    disabled=False\n)\n# Define the values of the input\nu = widgets.FloatSlider(\n    value=9.81*3,\n    min=0,\n    max=9.81*10,\n    step=0.1,\n    description='Reference:',\n    disabled=False,\n    continuous_update=False,\n    orientation='horizontal',\n    readout=True,\n    readout_format='.1f',\n)\nperiod = widgets.FloatSlider(\n    value=0.5,\n    min=0.001,\n    max=10,\n    step=0.001,\n    description='Period: ',\n    disabled=False,\n    continuous_update=False,\n    orientation='horizontal',\n    readout=True,\n    readout_format='.2f',\n)\n\ngain_w2 = widgets.FloatText(\n    value=1.,\n    description='',\n    disabled=True\n)\n\nsimTime = widgets.FloatText(\n    value=1.5,\n    description='',\n    disabled=False\n)\n\n\n# Support functions\n\ndef eigen_choice(sele):\n    if sele == '0 complex eigenvalues':\n        eig1c.children[0].children[0].disabled = False\n        eig2c.children[1].children[0].disabled = True\n        eig1o.children[0].children[0].disabled = False\n        eig2o.children[1].children[0].disabled = True\n        eig = 0\n    if sele == '2 complex eigenvalues':\n        eig1c.children[0].children[0].disabled = True\n        eig2c.children[1].children[0].disabled = False\n        eig1o.children[0].children[0].disabled = True\n        eig2o.children[1].children[0].disabled = False\n        eig = 2\n    return eig\n\ndef method_choice(selm):\n    if selm == 'Set K and L':\n        method = 1\n        sele.disabled = True\n    if selm == 'Set the eigenvalues':\n        method = 2\n        sele.disabled = False\n    return method\n\n\ndef main_callback2(Aw, Bw, X0w, K, L, eig1c, eig2c, eig3c, eig1o, eig2o, eig3o, u, period, selm, sele, selu, simTime, DW):\n    eige = eigen_choice(sele)\n    method = method_choice(selm)\n    \n    if method == 1:\n        solc = numpy.linalg.eig(A-B*K)\n        solo = numpy.linalg.eig(A-L*C)\n    if method == 2:\n        if eige == 0:\n            K = control.acker(A, B, [eig1c[0,0], eig2c[0,0], eig3c[0,0]])\n            Kw.setM(K)\n            L = control.acker(A.T, C.T, [eig1o[0,0], eig2o[0,0], eig3o[0,0]]).T\n            Lw.setM(L)\n        if eige == 2:\n            K = control.acker(A, B, [eig3c[0,0], \n                                     numpy.complex(eig2c[0,0],eig2c[1,0]), \n                                     numpy.complex(eig2c[0,0],-eig2c[1,0])])\n            Kw.setM(K)\n            L = control.acker(A.T, C.T, [eig3o[0,0], \n                                         numpy.complex(eig2o[0,0],eig2o[1,0]), \n                                         numpy.complex(eig2o[0,0],-eig2o[1,0])]).T\n            Lw.setM(L)\n            \n    \n    sys = control.ss(A,B,numpy.vstack((C,numpy.zeros((B.shape[1],C.shape[1])))),numpy.vstack((D,numpy.eye(B.shape[1]))))\n    sysC = control.ss(numpy.zeros((1,1)),\n                      numpy.zeros((1,numpy.shape(A)[0])),\n                      numpy.zeros((numpy.shape(B)[1],1)),\n                      -K)\n    \n    sysE = control.ss(A-L*C,\n                      numpy.hstack((L,B-L*D)),\n                      numpy.eye(numpy.shape(A)[0]),\n                      numpy.zeros((A.shape[0],C.shape[0]+B.shape[1])))\n    \n    sys_append = control.append(sys, sysE, sysC, control.ss(A,B,numpy.eye(A.shape[0]),numpy.zeros((A.shape[0],B.shape[1]))))\n    Q = []\n    # y in ingresso a sysE\n    for i in range(C.shape[0]):\n        Q.append([B.shape[1]+i+1, i+1])\n    # u in ingresso a sysE\n    for i in range(B.shape[1]):\n        Q.append([B.shape[1]+C.shape[0]+i+1, C.shape[0]+i+1])\n    # u in ingresso a sys\n    for i in range(B.shape[1]):\n        Q.append([i+1, C.shape[0]+B.shape[1]+A.shape[0]+i+1])\n    # u in ingresso al sistema che ha come uscite gli stati reali\n    for i in range(B.shape[1]):\n        Q.append([2*B.shape[1]+C.shape[0]+A.shape[0]+i+1, C.shape[0]+i+1])\n    # xe in ingresso a sysC\n    for i in range(A.shape[0]):\n        Q.append([2*B.shape[1]+C.shape[0]+i+1, C.shape[0]+B.shape[1]+i+1])\n        \n    inputv = [i+1 for i in range(B.shape[1])]\n    outputv = [i+1 for i in range(numpy.shape(sys_append.C)[0])]\n    sys_CL = control.connect(sys_append,\n                             Q,\n                             inputv,\n                             outputv)\n    \n    dcgain = control.dcgain(sys_CL[0,0])\n    gain_w2.value = dcgain\n    if dcgain != 0:\n        u1 = u/gain_w2.value\n    else:\n        print('The feedforward gain setted is 0 and it is changed to 1')\n        u1 = u/1\n    print('The static gain of the closed loop system (from the reference to the output) is: %.5f' %dcgain)\n    \n    X0w1 = numpy.zeros((A.shape[0],1))\n    for j in range(A.shape[0]):\n        X0w1 = numpy.vstack((X0w1,X0w[j]))\n    X0w1 = numpy.vstack((X0w1,numpy.zeros((A.shape[0],1))))\n    if simTime != 0:\n        T = numpy.linspace(0, simTime, 10000)\n    else:\n        T = numpy.linspace(0, 1, 10000)\n      \n    if selu == 'impulse': #selu\n        U = [0 for t in range(0,len(T))]\n        U[0] = u\n        U1 = [0 for t in range(0,len(T))]\n        U1[0] = u1\n        T, yout, xout = control.forced_response(sys_CL,T,U1,X0w1)\n    if selu == 'step':\n        U = [u for t in range(0,len(T))]\n        U1 = [u1 for t in range(0,len(T))]\n        T, yout, xout = control.forced_response(sys_CL,T,U1,X0w1)\n    if selu == 'sinusoid':\n        U = u*numpy.sin(2*numpy.pi/period*T)\n        U1 = u1*numpy.sin(2*numpy.pi/period*T)\n        T, yout, xout = control.forced_response(sys_CL,T,U1,X0w1)\n    if selu == 'square wave':\n        U = u*numpy.sign(numpy.sin(2*numpy.pi/period*T))\n        U1 = u1*numpy.sign(numpy.sin(2*numpy.pi/period*T))\n        T, yout, xout = control.forced_response(sys_CL,T,U1,X0w1)\n    # N.B. i primi 3 stati di xout sono quelli del sistema, mentre gli ultimi 3 sono quelli dell'osservatore\n    \n    step_info_dict = control.step_info(sys_CL[0,0],SettlingTimeThreshold=0.05,T=T)\n    print('Step info: \\n\\tRise time =',step_info_dict['RiseTime'],'\\n\\tSettling time (5%) =',step_info_dict['SettlingTime'],'\\n\\tOvershoot (%)=',step_info_dict['Overshoot'])\n    print('Max x3 value (%)=', max(abs(yout[C.shape[0]+2*B.shape[1]+A.shape[0]+2]))/(numpy.pi/180*17)*100)\n    \n    fig = plt.figure(num='Simulation1', figsize=(14,12))\n    \n    fig.add_subplot(221)\n    plt.title('Output response')\n    plt.ylabel('Output')\n    plt.plot(T,yout[0],T,U,'r--')\n    plt.xlabel('$t$ [s]')\n    plt.axvline(x=0,color='black',linewidth=0.8)\n    plt.axhline(y=0,color='black',linewidth=0.8)\n    plt.legend(['$y$','Reference'])\n    plt.grid()\n    \n    fig.add_subplot(222)\n    plt.title('Input')\n    plt.ylabel('$u$')\n    plt.plot(T,yout[C.shape[0]])\n    plt.xlabel('$t$ [s]')\n    plt.axvline(x=0,color='black',linewidth=0.8)\n    plt.axhline(y=0,color='black',linewidth=0.8)\n    plt.grid()\n    \n    fig.add_subplot(223)\n    plt.title('States response')\n    plt.ylabel('States')\n    plt.plot(T,yout[C.shape[0]+2*B.shape[1]+A.shape[0]],\n             T,yout[C.shape[0]+2*B.shape[1]+A.shape[0]+1],\n             T,yout[C.shape[0]+2*B.shape[1]+A.shape[0]+2],\n             T,[numpy.pi/180*17 for i in range(len(T))],'r--',\n             T,[-numpy.pi/180*17 for i in range(len(T))],'r--')\n    plt.xlabel('$t$ [s]')\n    plt.axvline(x=0,color='black',linewidth=0.8)\n    plt.axhline(y=0,color='black',linewidth=0.8)\n    plt.legend(['$x_{1}$','$x_{2}$','$x_{3}$','limit +$x_{3}$','limit -$x_{3}$'])\n    plt.grid()\n    \n    fig.add_subplot(224)\n    plt.title('Estimation errors')\n    plt.ylabel('Errors')\n    plt.plot(T,yout[C.shape[0]+2*B.shape[1]+A.shape[0]]-yout[C.shape[0]+B.shape[1]],\n             T,yout[C.shape[0]+2*B.shape[1]+A.shape[0]+1]-yout[C.shape[0]+B.shape[1]+1],\n             T,yout[C.shape[0]+2*B.shape[1]+A.shape[0]+2]-yout[C.shape[0]+B.shape[1]+2])\n    plt.xlabel('$t$ [s]')\n    plt.axvline(x=0,color='black',linewidth=0.8)\n    plt.axhline(y=0,color='black',linewidth=0.8)\n    plt.legend(['$e_{1}$','$e_{2}$','$e_{3}$'])\n    plt.grid()\n    #plt.tight_layout()\n   \nalltogether2 = widgets.VBox([widgets.HBox([selm, \n                                          sele,\n                                          selu]),\n                            widgets.Label(' ',border=3),\n                            widgets.HBox([widgets.Label('K:',border=3), Kw, \n                                          widgets.Label(' ',border=3),\n                                          widgets.Label(' ',border=3),\n                                          widgets.Label('Eigenvalues:',border=3), \n                                          eig1c, \n                                          eig2c, \n                                          eig3c,\n                                          widgets.Label(' ',border=3),\n                                          widgets.Label(' ',border=3),\n                                          widgets.Label('X0 est.:',border=3), X0w]),\n                            widgets.Label(' ',border=3),\n                            widgets.HBox([widgets.Label('L:',border=3), Lw, \n                                          widgets.Label(' ',border=3),\n                                          widgets.Label(' ',border=3),\n                                          widgets.Label('Eigenvalues:',border=3), \n                                          eig1o, \n                                          eig2o, \n                                          eig3o,\n                                          widgets.Label(' ',border=3),\n                                          widgets.VBox([widgets.Label('Inverse reference gain:',border=3),\n                                                        widgets.Label('Simulation time [s]:',border=3)]),\n                                          widgets.VBox([gain_w2,simTime])]),\n                            widgets.Label(' ',border=3),\n                            widgets.HBox([u, \n                                          period, \n                                          START])])\nout2 = widgets.interactive_output(main_callback2, {'Aw':Aw, 'Bw':Bw, 'X0w':X0w, 'K':Kw, 'L':Lw,\n                                                 'eig1c':eig1c, 'eig2c':eig2c, 'eig3c':eig3c, 'eig1o':eig1o, 'eig2o':eig2o, 'eig3o':eig3o, \n                                                 'u':u, 'period':period, 'selm':selm, 'sele':sele, 'selu':selu, 'simTime':simTime, 'DW':DW})\nout2.layout.height = '860px'\ndisplay(out2, alltogether2)"
  },
  {
    "objectID": "ICCT_en/examples/04/SS-40-Control_of_robotic_arm_with_flexible_joint.html",
    "href": "ICCT_en/examples/04/SS-40-Control_of_robotic_arm_with_flexible_joint.html",
    "title": "Control of robotic arm with flexible joint",
    "section": "",
    "text": "#remove cell visibility\nfrom IPython.display import HTML\ntag = HTML('''&lt;script&gt;\ncode_show=true; \nfunction code_toggle() {\n    if (code_show){\n        $('div.input').hide()\n    } else {\n        $('div.input').show()\n    }\n    code_show = !code_show\n} \n$( document ).ready(code_toggle);\n&lt;/script&gt;\nToggle cell visibility &lt;a href=\"javascript:code_toggle()\"&gt;here&lt;/a&gt;.''')\ndisplay(tag)\n\n\nToggle cell visibility here.\n\n\n\n%matplotlib inline\nimport control\nimport numpy\nimport sympy as sym\nfrom IPython.display import display, Markdown\nimport ipywidgets as widgets\nimport matplotlib.pyplot as plt\n\n\n#print a matrix latex-like\ndef bmatrix(a):\n     \"\"\"Returns a LaTeX bmatrix - by Damir Arbula (ICCT project)\n\n     :a: numpy array\n     :returns: LaTeX bmatrix as a string\n     \"\"\"\n     if len(a.shape) &gt; 2:\n         raise ValueError('bmatrix can at most display two dimensions')\n     lines = str(a).replace('[', '').replace(']', '').splitlines()\n     rv = [r'\\begin{bmatrix}']\n     rv += ['  ' + ' & '.join(l.split()) + r'\\\\' for l in lines]\n     rv +=  [r'\\end{bmatrix}']\n     return '\\n'.join(rv)\n\n\n# Display formatted matrix: \ndef vmatrix(a):\n    if len(a.shape) &gt; 2:\n         raise ValueError('bmatrix can at most display two dimensions')\n    lines = str(a).replace('[', '').replace(']', '').splitlines()\n    rv = [r'\\begin{vmatrix}']\n    rv += ['  ' + ' & '.join(l.split()) + r'\\\\' for l in lines]\n    rv +=  [r'\\end{vmatrix}']\n    return '\\n'.join(rv)\n\n\n#matrixWidget is a matrix looking widget built with a VBox of HBox(es) that returns a numPy array as value !\nclass matrixWidget(widgets.VBox):\n    def updateM(self,change):\n        for irow in range(0,self.n):\n            for icol in range(0,self.m):\n                self.M_[irow,icol] = self.children[irow].children[icol].value\n                #print(self.M_[irow,icol])\n        self.value = self.M_\n\n    def dummychangecallback(self,change):\n        pass\n    \n    \n    def __init__(self,n,m):\n        self.n = n\n        self.m = m\n        self.M_ = numpy.matrix(numpy.zeros((self.n,self.m)))\n        self.value = self.M_\n        widgets.VBox.__init__(self,\n                             children = [\n                                 widgets.HBox(children = \n                                              [widgets.FloatText(value=0.0, layout=widgets.Layout(width='90px')) for i in range(m)]\n                                             ) \n                                 for j in range(n)\n                             ])\n        \n        #fill in widgets and tell interact to call updateM each time a children changes value\n        for irow in range(0,self.n):\n            for icol in range(0,self.m):\n                self.children[irow].children[icol].value = self.M_[irow,icol]\n                self.children[irow].children[icol].observe(self.updateM, names='value')\n        #value = Unicode('example@example.com', help=\"The email value.\").tag(sync=True)\n        self.observe(self.updateM, names='value', type= 'All')\n        \n    def setM(self, newM):\n        #disable callbacks, change values, and reenable\n        self.unobserve(self.updateM, names='value', type= 'All')\n        for irow in range(0,self.n):\n            for icol in range(0,self.m):\n                self.children[irow].children[icol].unobserve(self.updateM, names='value')\n        self.M_ = newM\n        self.value = self.M_\n        for irow in range(0,self.n):\n            for icol in range(0,self.m):\n                self.children[irow].children[icol].value = self.M_[irow,icol]\n        for irow in range(0,self.n):\n            for icol in range(0,self.m):\n                self.children[irow].children[icol].observe(self.updateM, names='value')\n        self.observe(self.updateM, names='value', type= 'All')        \n\n                #self.children[irow].children[icol].observe(self.updateM, names='value')\n\n             \n#overlaod class for state space systems that DO NOT remove \"useless\" states (what \"professor\" of automatic control would do this?)\nclass sss(control.StateSpace):\n    def __init__(self,*args):\n        #call base class init constructor\n        control.StateSpace.__init__(self,*args)\n    #disable function below in base class\n    def _remove_useless_states(self):\n        pass\n\nA robotic arm link is driven by an electric motor via a flexible joint that behaves like a torsional spring. The system dynamics may be approximated with a third order linear time invariant system where the states are: - \\(x_1\\) : the difference between motor and arm angles (not zero because of the joint flexibility), - \\(x_2\\) : motor shaft angular speed, - \\(x_3\\) : link angular speed. The input \\(u\\) is the motor torque. The dynamic equations are:\n\\[\\begin{cases}\n\\dot{x} = \\begin{bmatrix} 0 & 1 & -1 \\\\ a-1 & -b_1 & b_1 \\\\ a & b_2 & -b_2 \\end{bmatrix}x + \\begin{bmatrix} 0 \\\\ b_3 \\\\ 0 \\end{bmatrix}u \\\\\ny = \\begin{bmatrix} 0 & 0 & 1 \\end{bmatrix}x\n\\end{cases}\\]\nwith \\(a=0.1\\), \\(b_1=0.09\\), \\(b_2=0.01\\) and \\(b_3=90\\).\nThe goal of the control system design is to regulate the link angular speed in order to have dominant poles with damping equal to 0.7 and natural frequency equal to 0.5 rad/s and zero steady-state error in response to reference velocity step.\nThe transfer function of the system is:\n\nA = numpy.matrix('0 1 -1; -0.9 -0.09 0.09; 0.1 0.01 -0.01')\nB = numpy.matrix('0; 90; 0')\nC = numpy.matrix('0 0 1')\nD = numpy.matrix('0')\nsys_tf = control.tf(sss(A,B,C,D))\nprint(sys_tf)\n\n\n  3.886e-16 s^2 + 0.9 s + 9\n-----------------------------\ns^3 + 0.1 s^2 + s - 8.674e-19\n\n\n\nwith poles\n\nimport warnings\n# In order to suppress the warning BadCoefficient\nwarnings.filterwarnings(\"ignore\")\nprint(numpy.round(sys_tf.pole(),3))\n\n[-0.05+0.999j -0.05-0.999j  0.  +0.j   ]\n\n\nand zeros\n\nprint(numpy.round(sys_tf.zero(),3),'.')\n\n[-2.31613695e+15 -1.00000000e+01] .\n\n\nFirst, we analyze the system in order to verify if it is controllable and observable. The controllability matrix \\(\\mathcal{C}\\) is\n\nCtrb = control.ctrb(A,B)\ndisplay(Markdown(bmatrix(Ctrb)))\n# print(numpy.linalg.matrix_rank(Ctrb))\n\n\\[\\begin{bmatrix}\n  0. & 90. & -9.\\\\\n  90. & -8.1 & -80.19\\\\\n  0. & 0.9 & 8.91\\\\\n\\end{bmatrix}\\]\n\n\nand has rank equal to 3 so the system is controllable. The observability matrix \\(\\mathcal{O}\\) is\n\nObsv = control.obsv(A,C)\ndisplay(Markdown(bmatrix(Obsv)))\n# print(numpy.linalg.matrix_rank(Obsv))\n\n\\[\\begin{bmatrix}\n  0. & 0. & 1.\\\\\n  0.1 & 0.01 & -0.01\\\\\n  -0.01 & 0.099 & -0.099\\\\\n\\end{bmatrix}\\]\n\n\nand has rank equal to 3 so the system is observable.\nThis could have been actually deduced from the fact that the denominator of the transfer function is of third order (equal to the state space vector dimension).\n\nRegulator design\n\nController design\nDue to the requirements, we know that we have to place 2 poles in \\(\\zeta \\omega_n \\pm \\sqrt{1-\\zeta^2}\\omega_n = -0.35\\pm0.357i\\) and place the remaining real pole at a frequency higher than that of the complex (dominant) poles. We can select to place the third pole at -3.5 rad/s. For the requirement of zero steady-state error we scale the reference signal with a gain equal to the inverse of the closed-loop system gain.\n\n\nDesign of the observer\nIn order to have an observer that quickly assists the controller we simply place the poles at about -10 rad/s.\n\n\n\nHow to use this notebook?\n\nVerify if the closed-loop system performs well in a case of an initial state estimation error. Try to improve its performance.\nReduce the frequency of the real pole of the controlled closed-loop system and watch how the response differs from the reference response.\n\n\n# Preparatory cell\n\nX0 = numpy.matrix('0.0; 0.0; 0.0')\nK = numpy.matrix([8/15,-4.4,-4])\nL = numpy.matrix([[23],[66],[107/3]])\n\nAw = matrixWidget(3,3)\nAw.setM(A)\nBw = matrixWidget(3,1)\nBw.setM(B)\nCw = matrixWidget(1,3)\nCw.setM(C)\nX0w = matrixWidget(3,1)\nX0w.setM(X0)\nKw = matrixWidget(1,3)\nKw.setM(K)\nLw = matrixWidget(3,1)\nLw.setM(L)\n\n\neig1c = matrixWidget(1,1)\neig2c = matrixWidget(2,1)\neig3c = matrixWidget(1,1)\neig1c.setM(numpy.matrix([-3.5])) \neig2c.setM(numpy.matrix([[-0.35],[-0.357]]))\neig3c.setM(numpy.matrix([-3.5]))\n\neig1o = matrixWidget(1,1)\neig2o = matrixWidget(2,1)\neig3o = matrixWidget(1,1)\neig1o.setM(numpy.matrix([-10.])) \neig2o.setM(numpy.matrix([[-10.],[0.]]))\neig3o.setM(numpy.matrix([-10.]))\n\n\n# Misc\n\n#create dummy widget \nDW = widgets.FloatText(layout=widgets.Layout(width='0px', height='0px'))\n\n#create button widget\nSTART = widgets.Button(\n    description='Test',\n    disabled=False,\n    button_style='', # 'success', 'info', 'warning', 'danger' or ''\n    tooltip='Test',\n    icon='check'\n)\n                       \ndef on_start_button_clicked(b):\n    #This is a workaround to have intreactive_output call the callback:\n    #   force the value of the dummy widget to change\n    if DW.value&gt; 0 :\n        DW.value = -1\n    else: \n        DW.value = 1\n    pass\nSTART.on_click(on_start_button_clicked)\n\n# Define type of method \nselm = widgets.Dropdown(\n    options= ['Set K and L', 'Set the eigenvalues'],\n    value= 'Set the eigenvalues',\n    description='',\n    disabled=False\n)\n\n# Define the number of complex eigenvalues\nsele = widgets.Dropdown(\n    options= ['0 complex eigenvalues', '2 complex eigenvalues'],\n    value= '2 complex eigenvalues',\n    description='Complex eigenvalues:',\n    style = {'description_width': 'initial'},\n    disabled=False\n)\n\n#define type of ipout \nselu = widgets.Dropdown(\n    options=['impulse', 'step', 'sinusoid', 'square wave'],\n    value='step',\n    description='Type of reference:',\n    style = {'description_width': 'initial'},\n    disabled=False\n)\n# Define the values of the input\nu = widgets.FloatSlider(\n    value=1,\n    min=0,\n    max=3,\n    step=0.1,\n    description='Reference:',\n    disabled=False,\n    continuous_update=False,\n    orientation='horizontal',\n    readout=True,\n    readout_format='.1f',\n)\nperiod = widgets.FloatSlider(\n    value=0.5,\n    min=0.001,\n    max=10,\n    step=0.001,\n    description='Period: ',\n    disabled=False,\n    continuous_update=False,\n    orientation='horizontal',\n    readout=True,\n    readout_format='.2f',\n)\n\ngain_w2 = widgets.FloatText(\n    value=1.,\n    description='',\n    disabled=True\n)\n\nsimTime = widgets.FloatText(\n    value=20,\n    description='',\n    disabled=False\n)\n\n\n# Support functions\n\ndef eigen_choice(sele):\n    if sele == '0 complex eigenvalues':\n        eig1c.children[0].children[0].disabled = False\n        eig2c.children[1].children[0].disabled = True\n        eig1o.children[0].children[0].disabled = False\n        eig2o.children[1].children[0].disabled = True\n        eig = 0\n    if sele == '2 complex eigenvalues':\n        eig1c.children[0].children[0].disabled = True\n        eig2c.children[1].children[0].disabled = False\n        eig1o.children[0].children[0].disabled = True\n        eig2o.children[1].children[0].disabled = False\n        eig = 2\n    return eig\n\ndef method_choice(selm):\n    if selm == 'Set K and L':\n        method = 1\n        sele.disabled = True\n    if selm == 'Set the eigenvalues':\n        method = 2\n        sele.disabled = False\n    return method\n\n\ns = control.tf('s')\nGref = (0.5)**2/(s**2 + 2*0.7*0.5*s + (0.5)**2)\n\ndef main_callback2(Aw, Bw, X0w, K, L, eig1c, eig2c, eig3c, eig1o, eig2o, eig3o, u, period, selm, sele, selu, simTime, DW):\n    eige = eigen_choice(sele)\n    method = method_choice(selm)\n    \n    if method == 1:\n        solc = numpy.linalg.eig(A-B*K)\n        solo = numpy.linalg.eig(A-L*C)\n    if method == 2:\n        if eige == 0:\n            K = control.acker(A, B, [eig1c[0,0], eig2c[0,0], eig3c[0,0]])\n            Kw.setM(K)\n            L = control.acker(A.T, C.T, [eig1o[0,0], eig2o[0,0], eig3o[0,0]]).T\n            Lw.setM(L)\n        if eige == 2:\n            K = control.acker(A, B, [eig3c[0,0], \n                                     numpy.complex(eig2c[0,0],eig2c[1,0]), \n                                     numpy.complex(eig2c[0,0],-eig2c[1,0])])\n            Kw.setM(K)\n            L = control.acker(A.T, C.T, [eig3o[0,0], \n                                         numpy.complex(eig2o[0,0],eig2o[1,0]), \n                                         numpy.complex(eig2o[0,0],-eig2o[1,0])]).T\n            Lw.setM(L)\n            \n    \n    sys = control.ss(A,B,numpy.vstack((C,numpy.zeros((B.shape[1],C.shape[1])))),numpy.vstack((D,numpy.eye(B.shape[1]))))\n    sysC = control.ss(numpy.zeros((1,1)),\n                      numpy.zeros((1,numpy.shape(A)[0])),\n                      numpy.zeros((numpy.shape(B)[1],1)),\n                      -K)\n    \n    sysE = control.ss(A-L*C,\n                      numpy.hstack((L,B-L*D)),\n                      numpy.eye(numpy.shape(A)[0]),\n                      numpy.zeros((A.shape[0],C.shape[0]+B.shape[1])))\n    \n    sys_append = control.append(sys, sysE, sysC, control.ss(A,B,numpy.eye(A.shape[0]),numpy.zeros((A.shape[0],B.shape[1]))))\n    Q = []\n    # y in ingresso a sysE\n    for i in range(C.shape[0]):\n        Q.append([B.shape[1]+i+1, i+1])\n    # u in ingresso a sysE\n    for i in range(B.shape[1]):\n        Q.append([B.shape[1]+C.shape[0]+i+1, C.shape[0]+i+1])\n    # u in ingresso a sys\n    for i in range(B.shape[1]):\n        Q.append([i+1, C.shape[0]+B.shape[1]+A.shape[0]+i+1])\n    # u in ingresso al sistema che ha come uscite gli stati reali\n    for i in range(B.shape[1]):\n        Q.append([2*B.shape[1]+C.shape[0]+A.shape[0]+i+1, C.shape[0]+i+1])\n    # xe in ingresso a sysC\n    for i in range(A.shape[0]):\n        Q.append([2*B.shape[1]+C.shape[0]+i+1, C.shape[0]+B.shape[1]+i+1])\n        \n    inputv = [i+1 for i in range(B.shape[1])]\n    outputv = [i+1 for i in range(numpy.shape(sys_append.C)[0])]\n    sys_CL = control.connect(sys_append,\n                             Q,\n                             inputv,\n                             outputv)\n    \n    t = numpy.linspace(0, 100000, 2)\n    t, yout = control.step_response(sys_CL[0,0],T=t)\n    dcgain = yout[-1]\n    gain_w2.value = dcgain\n    if dcgain != 0:\n        u1 = u/gain_w2.value\n    else:\n        print('The feedforward gain setted is 0 and it is changed to 1')\n        u1 = u/1\n    print('The static gain of the closed-loop system (from the reference to the output) is: %.5f' %dcgain)\n    \n    X0w1 = numpy.zeros((A.shape[0],1))\n    for j in range(A.shape[0]):\n        X0w1 = numpy.vstack((X0w1,X0w[j]))\n    X0w1 = numpy.vstack((X0w1,numpy.zeros((A.shape[0],1))))\n    if simTime != 0:\n        T = numpy.linspace(0, simTime, 10000)\n    else:\n        T = numpy.linspace(0, 1, 10000)\n      \n    if selu == 'impulse': #selu\n        U = [0 for t in range(0,len(T))]\n        U[0] = u\n        U1 = [0 for t in range(0,len(T))]\n        U1[0] = u1\n        T, yout, xout = control.forced_response(sys_CL,T,U1,X0w1)\n        T, yout_ref, xout_ref = control.forced_response(Gref,T,U,[0, 0])\n    if selu == 'step':\n        U = [u for t in range(0,len(T))]\n        U1 = [u1 for t in range(0,len(T))]\n        T, yout, xout = control.forced_response(sys_CL,T,U1,X0w1)\n        T, yout_ref, xout_ref = control.forced_response(Gref,T,U,[0, 0])\n    if selu == 'sinusoid':\n        U = u*numpy.sin(2*numpy.pi/period*T)\n        U1 = u1*numpy.sin(2*numpy.pi/period*T)\n        T, yout, xout = control.forced_response(sys_CL,T,U1,X0w1)\n        T, yout_ref, xout_ref = control.forced_response(Gref,T,U,[0, 0])\n    if selu == 'square wave':\n        U = u*numpy.sign(numpy.sin(2*numpy.pi/period*T))\n        U1 = u1*numpy.sign(numpy.sin(2*numpy.pi/period*T))\n        T, yout, xout = control.forced_response(sys_CL,T,U1,X0w1)\n        T, yout_ref, xout_ref = control.forced_response(Gref,T,U,[0, 0])\n    # N.B. i primi 3 stati di xout sono quelli del sistema, mentre gli ultimi 3 sono quelli dell'osservatore\n    \n    step_info_dict = control.step_info(sys_CL[0,0],SettlingTimeThreshold=0.05,T=T)\n    print('Step info: \\n\\tRise time =',step_info_dict['RiseTime'],'\\n\\tSettling time (5%) =',step_info_dict['SettlingTime'],'\\n\\tOvershoot (%)=',step_info_dict['Overshoot'])\n    # print('Max x3 value (%)=', max(abs(yout[C.shape[0]+2*B.shape[1]+A.shape[0]+2]))/(numpy.pi/180*17)*100)\n    \n    fig = plt.figure(num='Simulation1', figsize=(14,12))\n    \n    fig.add_subplot(221)\n    plt.title('Output response')\n    plt.ylabel('Output')\n    plt.plot(T,yout[0],T,yout_ref,T,U,'r--')\n    plt.xlabel('$t$ [s]')\n    plt.axvline(x=0,color='black',linewidth=0.8)\n    plt.axhline(y=0,color='black',linewidth=0.8)\n    plt.legend(['$y$','Second-order system reference','Reference'])\n    plt.grid()\n    \n    fig.add_subplot(222)\n    plt.title('Input')\n    plt.ylabel('$u$')\n    plt.plot(T,yout[C.shape[0]])\n    plt.xlabel('$t$ [s]')\n    plt.axvline(x=0,color='black',linewidth=0.8)\n    plt.axhline(y=0,color='black',linewidth=0.8)\n    plt.grid()\n    \n    fig.add_subplot(223)\n    plt.title('States response')\n    plt.ylabel('States')\n    plt.plot(T,yout[C.shape[0]+2*B.shape[1]+A.shape[0]],\n             T,yout[C.shape[0]+2*B.shape[1]+A.shape[0]+1],\n             T,yout[C.shape[0]+2*B.shape[1]+A.shape[0]+2])\n    plt.xlabel('$t$ [s]')\n    plt.axvline(x=0,color='black',linewidth=0.8)\n    plt.axhline(y=0,color='black',linewidth=0.8)\n    plt.legend(['$x_{1}$','$x_{2}$','$x_{3}$'])\n    plt.grid()\n    \n    fig.add_subplot(224)\n    plt.title('Estimation errors')\n    plt.ylabel('Errors')\n    plt.plot(T,yout[C.shape[0]+2*B.shape[1]+A.shape[0]]-yout[C.shape[0]+B.shape[1]],\n             T,yout[C.shape[0]+2*B.shape[1]+A.shape[0]+1]-yout[C.shape[0]+B.shape[1]+1],\n             T,yout[C.shape[0]+2*B.shape[1]+A.shape[0]+2]-yout[C.shape[0]+B.shape[1]+2])\n    plt.xlabel('$t$ [s]')\n    plt.axvline(x=0,color='black',linewidth=0.8)\n    plt.axhline(y=0,color='black',linewidth=0.8)\n    plt.legend(['$e_{1}$','$e_{2}$','$e_{3}$'])\n    plt.grid()\n    #plt.tight_layout()\n   \nalltogether2 = widgets.VBox([widgets.HBox([selm, \n                                          sele,\n                                          selu]),\n                            widgets.Label(' ',border=3),\n                            widgets.HBox([widgets.Label('K:',border=3), Kw, \n                                          widgets.Label(' ',border=3),\n                                          widgets.Label(' ',border=3),\n                                          widgets.Label('Eigenvalues:',border=3), \n                                          eig1c, \n                                          eig2c, \n                                          eig3c,\n                                          widgets.Label(' ',border=3),\n                                          widgets.Label(' ',border=3),\n                                          widgets.Label('X0 est.:',border=3), X0w]),\n                            widgets.Label(' ',border=3),\n                            widgets.HBox([widgets.Label('L:',border=3), Lw, \n                                          widgets.Label(' ',border=3),\n                                          widgets.Label(' ',border=3),\n                                          widgets.Label('Eigenvalues:',border=3), \n                                          eig1o, \n                                          eig2o, \n                                          eig3o,\n                                          widgets.Label(' ',border=3),\n                                          widgets.VBox([widgets.Label('Inverse reference gain:',border=3),\n                                                        widgets.Label('Simulation time [s]:',border=3)]),\n                                          widgets.VBox([gain_w2,simTime])]),\n                            widgets.Label(' ',border=3),\n                            widgets.HBox([u, \n                                          period, \n                                          START])])\nout2 = widgets.interactive_output(main_callback2, {'Aw':Aw, 'Bw':Bw, 'X0w':X0w, 'K':Kw, 'L':Lw,\n                                                 'eig1c':eig1c, 'eig2c':eig2c, 'eig3c':eig3c, 'eig1o':eig1o, 'eig2o':eig2o, 'eig3o':eig3o, \n                                                 'u':u, 'period':period, 'selm':selm, 'sele':sele, 'selu':selu, 'simTime':simTime, 'DW':DW})\nout2.layout.height = '860px'\ndisplay(out2, alltogether2)"
  },
  {
    "objectID": "ICCT_en/examples/04/SS-38-Lunar_lander_horizontal_position_control.html",
    "href": "ICCT_en/examples/04/SS-38-Lunar_lander_horizontal_position_control.html",
    "title": "Lunar lander lateral position control",
    "section": "",
    "text": "#remove cell visibility\nfrom IPython.display import HTML\ntag = HTML('''&lt;script&gt;\ncode_show=true; \nfunction code_toggle() {\n    if (code_show){\n        $('div.input').hide()\n    } else {\n        $('div.input').show()\n    }\n    code_show = !code_show\n} \n$( document ).ready(code_toggle);\n&lt;/script&gt;\nToggle cell visibility &lt;a href=\"javascript:code_toggle()\"&gt;here&lt;/a&gt;.''')\ndisplay(tag)\n\n\nToggle cell visibility here.\n\n\nThis example illustrates the development of a regulator (observer and controller in form of state feedback) for the lateral position of a lunar lander starting from the system’s equations.\n\nThe system is represented in the figure above, its vertical descent is slowed down using a vertical thruster that produces the constant force \\(F\\). Horizontal motion may be achieved by slightly tilting the lander by an angle \\(\\theta\\); tilting generates a lateral force that is approximately equal to \\(F\\theta\\). Tilting is achieved by generating the torque \\(T\\) using a set of controllable steer rockets (max torque = 500 Nm). Tilt angle must be within \\(\\pm15\\) degrees to avoid a dangerous increase of vertical descent speed. The measured quantities are lateral position and velocity. The atmospheric drag is assumed to be negligible and the parameters’ values are listed in the table below.\n\n\n\nParameter\nValue\n\n\n\n\n\\(m\\)\n1000 kg\n\n\n\\(J\\)\n1000 kg\\(\\text{m}^2\\)\n\n\n\\(F\\)\n1500 N\n\n\n\nThe goal of the control system design is to reach the following performance for regulation of the horizontal position \\(z\\): 1. Maximum overshoot of 30%. 2. Settling time (for 5% tolerance band) less than 15 seconds. 3. Angle \\(\\theta\\) always within its limits for desired maximum lateral change of 10 meters. 4. Zero error in response to a step command.\nThe system’s equations are:\n\\[\\begin{cases}\nJ\\ddot{\\theta}=T \\\\\nm\\ddot{z}=F\\theta\n\\end{cases}\\]\nand by defining \\(\\textbf{x}=[x_1,x_2,x_3,x_4]^T=[z,\\dot{z},\\theta,\\dot{\\theta}]^T\\) as states vector and \\(u=T\\) as input, in state space form they become:\n\\[\\begin{cases}\n\\dot{\\textbf{x}}=\\underbrace{\\begin{bmatrix}0&1&0&0 \\\\ 0&0&F/m&0 \\\\ 0&0&0&1 \\\\ 0&0&0&0\\end{bmatrix}}_{A}\\textbf{x}+\\underbrace{\\begin{bmatrix}0\\\\0\\\\0\\\\1/J\\end{bmatrix}}_{B}u \\\\ \\\\\n\\textbf{y}=\\underbrace{\\begin{bmatrix}1&0&0&0 \\\\ 0&1&0&0\\end{bmatrix}}_{C}\\textbf{x}.\n\\end{cases}\\]\n\nController design\nIn order to have zero error in response to a step reference, the system is augmented by adding a new state \\(\\dot{x_5}=y_1-y_d\\) where \\(y_1\\) is the measured lateral position and \\(y_d\\) is the desired position value. The augmented system is therefore:\n\\[\\begin{cases}\n\\dot{\\textbf{x}_a}=\\underbrace{\\begin{bmatrix}0&1&0&0&0 \\\\ 0&0&F/m&0&0 \\\\ 0&0&0&1&0 \\\\ 0&0&0&0&0 \\\\ 1&0&0&0&0 \\end{bmatrix}}_{A_a}\\textbf{x}_a+\\underbrace{\\begin{bmatrix} 0&0\\\\0&0\\\\0&0\\\\1/J&0\\\\0&-1 \\end{bmatrix}}_{B_a}\\underbrace{\\begin{bmatrix} u\\\\y_d \\end{bmatrix}}_{u_a} \\\\ \\\\\n\\textbf{y}_a=\\underbrace{\\begin{bmatrix}1&0&0&0&0\\\\0&1&0&0&0\\\\0&0&0&0&1\\end{bmatrix}}_{C_a}\\textbf{x}_a\n\\end{cases}\\]\nthat is controllable with the first column of \\(B_a\\), so it is possible to use the pole placement method. Note, that in order to maintain the observability of the system, a row in the matrix \\(C\\) was added because the new state \\(x_5\\) is known.\nThe gain matrix \\(K_a\\) that satisfies all the requirements is: \\[\nK_a=\\begin{bmatrix}2225.0&6244.0&13861.0&5275.0&316.0\\end{bmatrix}\n\\] that places the poles of \\((A_a-B_aK_a)\\) in \\(-0.28\\), \\(-2.24+2.23i\\), \\(-2.24-2.23i\\), \\(-0.26+0.32i\\) and \\(-0.26-0.32i\\).\n\n\nObserver design\nThe system is observable, and, since three states are measured, it is possible to design a reduced state observer (for \\(\\theta\\) and \\(\\dot{\\theta}\\)) that has the structure: \\[\n\\dot{\\hat{\\textbf{v}}}=(A_{11}+L_aA_{21})\\hat{\\textbf{v}}+(A_{12}+L_aA_{22}-A_{11}L_a-L_aA_{21}L_a)\\textbf{y}_a+(B_1+L_aB_2)u_a,\n\\] where \\[\nT^{-1}A_aT=\\begin{bmatrix}A_{11}&A_{12} \\\\ A_{21}&A_{22}\\end{bmatrix},\n\\quad T^{-1}B_a=\\begin{bmatrix}B_1 \\\\ B_2\\end{bmatrix},\n\\quad \\overline{\\textbf{x}_a}=T^{-1}\\textbf{x}_a=\\begin{bmatrix}V \\\\ C\\end{bmatrix}\\textbf{x}_a,\n\\quad V=\\begin{bmatrix}0&0&1&0&0 \\\\ 0&0&0&1&0\\end{bmatrix},\n\\quad \\hat{\\textbf{x}_a}=\\begin{bmatrix}\\hat{\\textbf{v}}-L_a\\textbf{y}_a \\\\ \\textbf{y}_a\\end{bmatrix}.\n\\]\nThe choice of the observer’s eigenvalues is made in order for the error dynamics to converge faster than the system’s dynamics specified by the requirements. The eigenvalues selected for \\(A_{11}+L_aA_{21}\\) are \\(\\lambda_i=-10\\)rad/s, \\(i=1,2\\) with \\[ L_a=\\begin{bmatrix}0&-\\frac{40}{3}&0 \\\\ 0&-\\frac{200}{3}&0\\end{bmatrix} \\]\n\n\nHow to use this notebook?\nYou can check the performance of the system with the developed regulator and directly modify the controller and the observer. The simulation starts with an initial error on the observer.\n\n#Preparatory Cell \n\n%matplotlib notebook\nimport control as ctrl\nimport numpy\nimport sympy as sym\nfrom IPython.display import display, Markdown\nimport ipywidgets as widgets\nimport matplotlib.pyplot as plt\nimport matplotlib.animation as animation\nimport matplotlib.patches as patches\nimport matplotlib.transforms as transforms\nimport matplotlib.lines as lines\n\n#print a matrix latex-like\ndef bmatrix(a):\n     \"\"\"Returns a LaTeX bmatrix - by Damir Arbula (ICCT project)\n\n     :a: numpy array\n     :returns: LaTeX bmatrix as a string\n     \"\"\"\n     if len(a.shape) &gt; 2:\n         raise ValueError('bmatrix can at most display two dimensions')\n     lines = str(a).replace('[', '').replace(']', '').splitlines()\n     rv = [r'\\begin{bmatrix}']\n     rv += ['  ' + ' & '.join(l.split()) + r'\\\\' for l in lines]\n     rv +=  [r'\\end{bmatrix}']\n     return '\\n'.join(rv)\n\n\n# Display formatted matrix: \ndef vmatrix(a):\n    if len(a.shape) &gt; 2:\n         raise ValueError('bmatrix can at most display two dimensions')\n    lines = str(a).replace('[', '').replace(']', '').splitlines()\n    rv = [r'\\begin{vmatrix}']\n    rv += ['  ' + ' & '.join(l.split()) + r'\\\\' for l in lines]\n    rv +=  [r'\\end{vmatrix}']\n    return '\\n'.join(rv)\n\n\n#matrixWidget is a matrix looking widget built with a VBox of HBox(es) that returns a numPy array as value !\nclass matrixWidget(widgets.VBox):\n    def updateM(self,change):\n        for irow in range(0,self.n):\n            for icol in range(0,self.m):\n                self.M_[irow,icol] = self.children[irow].children[icol].value\n                #print(self.M_[irow,icol])\n        self.value = self.M_\n\n    def dummychangecallback(self,change):\n        pass\n    \n    \n    def __init__(self,n,m):\n        self.n = n\n        self.m = m\n        self.M_ = numpy.matrix(numpy.zeros((self.n,self.m)))\n        self.value = self.M_\n        widgets.VBox.__init__(self,\n                             children = [\n                                 widgets.HBox(children = \n                                              [widgets.FloatText(value=0.0, layout=widgets.Layout(width='90px')) for i in range(m)]\n                                             ) \n                                 for j in range(n)\n                             ])\n        \n        #fill in widgets and tell interact to call updateM each time a children changes value\n        for irow in range(0,self.n):\n            for icol in range(0,self.m):\n                self.children[irow].children[icol].value = self.M_[irow,icol]\n                self.children[irow].children[icol].observe(self.updateM, names='value')\n        #value = Unicode('example@example.com', help=\"The email value.\").tag(sync=True)\n        self.observe(self.updateM, names='value', type= 'All')\n        \n    def setM(self, newM):\n        #disable callbacks, change values, and reenable\n        self.unobserve(self.updateM, names='value', type= 'All')\n        for irow in range(0,self.n):\n            for icol in range(0,self.m):\n                self.children[irow].children[icol].unobserve(self.updateM, names='value')\n        self.M_ = newM\n        self.value = self.M_\n        for irow in range(0,self.n):\n            for icol in range(0,self.m):\n                self.children[irow].children[icol].value = self.M_[irow,icol]\n        for irow in range(0,self.n):\n            for icol in range(0,self.m):\n                self.children[irow].children[icol].observe(self.updateM, names='value')\n        self.observe(self.updateM, names='value', type= 'All')        \n\n                #self.children[irow].children[icol].observe(self.updateM, names='value')\n\n             \n#overlaod class for state space systems that DO NOT remove \"useless\" states (what \"professor\" of automatic control would do this?)\nclass sss(ctrl.StateSpace):\n    def __init__(self,*args):\n        #call base class init constructor\n        ctrl.StateSpace.__init__(self,*args)\n    #disable function below in base class\n    def _remove_useless_states(self):\n        pass\n\n\n# Define matrixes\n\nA = numpy.matrix('0 1 0 0; 0 0 1.5 0; 0 0 0 1; 0 0 0 0')\nB = numpy.matrix('0;0;0;0.001')\nC = numpy.matrix('1 0 0 0; 0 1 0 0')\nAa = numpy.matrix('0 1 0 0 0; 0 0 1.5 0 0; 0 0 0 1 0; 0 0 0 0 0; 1 0 0 0 0')\nBa = numpy.matrix('0 0;0 0;0 0;0.001 0;0 -1')\nCa = numpy.matrix('1 0 0 0 0; 0 1 0 0 0; 0 0 0 0 1')\nKa1 = numpy.matrix('[2225.0, 6244.0, 13861.0, 5275.0, 316.0') #318.9333 835 2012.5 2000 59.6\nTa = (numpy.matrix('0 0 1 0 0; 0 0 0 1 0; 1 0 0 0 0;0 1 0 0 0; 0 0 0 0 1'))**(-1)\nAr = Ta**(-1)*Aa*Ta\nBr = Ta**(-1)*Ba\nA11 = Ar[0:2,0:2]\nA12 = Ar[0:2,2:5]\nA21 = Ar[2:5,0:2]\nA22 = Ar[2:5,2:5]\nB1 = Br[0:2,:]\nB2 = Br[2:5,:]\nLa1 = numpy.matrix([[0, -4*10/3, 0],[0, -3/8*(-4*10/3)**2, 0]])\nX0a = numpy.matrix('0;0;0;0;0;0;0;0;0;0;0.002;0.002;0;0;0;0;0;0.002;0.002;0;0;0;0;0')\n# X0a = numpy.matrix('0;0;0;0;0')\n# V0 = numpy.matrix('0;0')\n\n\n# Define matrixes widget\nKaw = matrixWidget(1,5)\nLaw = matrixWidget(2,3)\neig1 = matrixWidget(1,1)\neig2 = matrixWidget(2,1)\neig3 = matrixWidget(2,1)\neig4 = matrixWidget(1,1)\neig5 = matrixWidget(1,1)\neig1o = matrixWidget(1,1)\neig2o = matrixWidget(2,1)\n\nYdw = widgets.FloatSlider(\n                         value=10,\n                         min=0,\n                         max=10.0,\n                         step=0.1,\n                         description='$y_d$:',\n                         disabled=False,\n                         continuous_update=False,\n                         orientation='horizontal',\n                         readout=True,\n                         readout_format='.1f',\n                        )\n\n# Init matrix widgets\nKaw.setM(Ka1) \nLaw.setM(La1)\n#[-0.6,-0.5-0.35j,-0.5+0.35j,-0.2-0.6j,-0.2+0.6j]\neig1.setM(numpy.matrix([-0.28]))\neig2.setM(numpy.matrix([[-2.24],[-2.23]]))\neig3.setM(numpy.matrix([[-0.26],[-0.32]])) \neig4.setM(numpy.matrix([-1])) \neig5.setM(numpy.matrix([-1])) \neig1o.setM(numpy.matrix([-10])) \neig2o.setM(numpy.matrix([[-10],[0]])) \n\n\n# Support functions\n# Simulation function\ndef simulation(Aa, Baa, Ca, A11, A12, A21, A22, B1, B2, La, Ka, Ta):\n    Aa, Baa, Ca = sym.Matrix(Aa), sym.Matrix(Baa), sym.Matrix(Ca)\n    A11, A12, A21, A22 = sym.Matrix(A11), sym.Matrix(A12), sym.Matrix(A21), sym.Matrix(A22)\n    B1, B2 = sym.Matrix(B1), sym.Matrix(B2)\n    La, Ka = sym.Matrix(La), sym.Matrix(Ka)\n    Ta = sym.Matrix(Ta)\n    sysS = sss(Aa, Baa, Ca, sym.zeros(3,2))\n    sysX = sss(Aa, Baa, sym.eye(5), sym.zeros(5,2))\n    sysO1 = sss((A11+La*A21), (B1+La*B2).row_join(A12+La*A22-A11*La-La*A21*La), sym.eye(2), sym.zeros(2,5))\n    sysO2 = ctrl.append(sysO1, sysS)\n    sysO3 = ctrl.connect(sysO2, [[3, 3], [4, 4], [5, 5]], [1, 2, 6, 7], [1, 2, 3, 4, 5])\n    sysO = sss(sysO3.A,\n               sysO3.B*sym.eye(2).col_join(sym.eye(2)),\n               Ta*(sym.eye(2).row_join(-La)).col_join(sym.zeros(3, 2).row_join(sym.eye(3)))*sysO3.C,\n               sym.zeros(5,2))\n    sysU = sss(sysO.A, sysO.B, -Ka*sysO.C, sym.zeros(1,2))\n    sysT = ctrl.append(sysS, sysX, sysO, sysU)\n    sysT1 = ctrl.connect(sysT, [[1, 14], [3, 14], [5, 14], [7, 14]], [2, 4, 6, 8], [i for i in range(1, 15)])\n    sys = sss(sysT1.A, sysT1.B*sym.Matrix([1, 1, 1, 1]), sysT1.C, sym.zeros(14, 1))\n    return sys\n\n# check functions\ndef eigen_choice(selc,selo):\n    if selc == '0 complex eigenvalues':\n        eig2.children[1].children[0].disabled = True\n        eig3.children[1].children[0].disabled = True\n        eig3.children[0].children[0].disabled = False\n        eig4.children[0].children[0].disabled = False\n        eig5.children[0].children[0].disabled = False\n        eigc = 0\n    if selc == '2 complex eigenvalues':\n        eig2.children[1].children[0].disabled = False\n        eig3.children[1].children[0].disabled = True\n        eig3.children[0].children[0].disabled = True\n        eig4.children[0].children[0].disabled = False\n        eig5.children[0].children[0].disabled = False\n        eigc = 2\n    if selc == '4 complex eigenvalues':\n        eig2.children[1].children[0].disabled = False\n        eig3.children[1].children[0].disabled = False\n        eig3.children[0].children[0].disabled = False\n        eig4.children[0].children[0].disabled = True\n        eig5.children[0].children[0].disabled = True\n        eigc = 4\n    if selo == '0 complex eigenvalues':\n        eig1o.children[0].children[0].disabled = False\n        eig2o.children[1].children[0].disabled = True\n        eigo = 0\n    if selo == '2 complex eigenvalues':\n        eig1o.children[0].children[0].disabled = True\n        eig2o.children[1].children[0].disabled = False\n        eigo = 2\n    return (eigc, eigo)\n\ndef method_choice(selm):\n    if selm == 'Set Ka and La':\n        method = 1\n        selc.disabled = True\n        selo.disabled = True\n    if selm == 'Set the eigenvalues':\n        method = 2\n        selc.disabled = False\n        selo.disabled = False\n    return method\n\n# Animation functions\ndef fun_animation(index):\n    global Ydw, yout, T\n    yd = Ydw.value\n    frame = 1\n    \n    linez.set_data(T[0:index*frame],yd*yout[0][0:index*frame])\n    linezv.set_data(T[0:index*frame],yd*yout[1][0:index*frame])\n    lined.set_data(T,[yd for i in range(0,len(T))])\n    lineu.set_data(T[0:index*frame],yd*yout[13][0:index*frame])\n    linelimu1.set_data(T,[500 for j in range(0,len(T))])\n    linelimu2.set_data(T,[-500 for j in range(0,len(T))])\n    linethetaest.set_data(T[0:index*frame],yd*yout[10][0:index*frame]*180/numpy.pi)\n    linetheta.set_data(T[0:index*frame],yd*yout[5][0:index*frame]*180/numpy.pi)\n    \n    \n    rotation_transform.clear().translate(yd*yout[0][index*frame]*numpy.cos(float(yd*yout[6][index*frame])), yd*yout[0][index*frame]*numpy.sin(float(yd*yout[6][index*frame]))).rotate(float(-yd*yout[6][index*frame]))\n    \n    return (linez,linezv,lined,lineu,linelimu1,linelimu2,linethetaest,linetheta)\n\ndef anim_init():\n    linez.set_data([], [])\n    linezv.set_data([], [])\n    lined.set_data([], [])\n    lineu.set_data([], [])\n    linelimu1.set_data([], [])\n    linelimu2.set_data([], [])\n    linethetaest.set_data([], [])\n    linetheta.set_data([], [])\n    return (linez,linezv,lined,lineu,linelimu1,linelimu2,linethetaest,linetheta)\n\n\n# Main cell\n# Data\nglobal yd, T, yout\nyd = 10.\nT = []\nyout = []\n\n# Figures\nfig = plt.figure(num='Simulation of a lunar lander lateral position control system')\nfig.set_size_inches((9.8, 6))\nfig.set_tight_layout(True)\n\nax0 = fig.add_subplot(221)\nax0.set_title('Lunar lander')\nax0.set_xlim(-12,12)\nax0.set_ylim(-4,4)\nax0.grid()\n# ax0.axis('off')\n\nax1 = fig.add_subplot(222)\nlinez = ax1.plot([],[])[0]\nlinezv = ax1.plot([],[])[0]\nlined = ax1.plot([],[])[0]\nax1.set_title('Lateral position and velocity')\nax1.set_xlabel('$t$ [s]')\nax1.set_ylabel('y [m], $\\dot y$ [m/s]')\nax1.set_xlim([0,17])\nax1.axvline(x=0,color='black',linewidth=0.8)\nax1.axhline(y=0,color='black',linewidth=0.8)\nax1.grid()\nax1.legend(['Lateral position','Lateral velocity','Desired value'])\n\nax2 = fig.add_subplot(223)\nlineu = ax2.plot([],[])[0]\nlinelimu1 = ax2.plot([],[],'r')[0]\nlinelimu2 = ax2.plot([],[],'r')[0]\nax2.set_title('Input torque T')\nax2.set_xlabel('$t$ [s]')\nax2.set_ylabel('$T$ [Nm]')\nax2.set_xlim([0,17])\nax2.axvline(x=0,color='black',linewidth=0.8)\nax2.axhline(y=0,color='black',linewidth=0.8)\nax2.grid()\nax2.legend(['T','Limit'])\n\nax3 = fig.add_subplot(224)\nlinethetaest = ax3.plot([],[])[0]\nlinetheta = ax3.plot([],[])[0]\nax3.set_title(r'$\\theta_{est}$ vs $\\theta$')\nax3.set_xlabel('$t$ [s]')\nax3.set_ylabel(r'$\\theta$ [deg]')\nax3.axvline(x=0,color='black',linewidth=0.8)\nax3.axhline(y=0,color='black',linewidth=0.8)\nax3.set_xlim([0,17])\nax3.grid()\n\n# Patches\nrotation_transform = transforms.Affine2D()\ncircle = patches.Circle((0, 0.6), fill=True, radius=0.5, ec='black', fc='gray', lw=1, zorder=20, \n                        transform=rotation_transform + ax0.transData)\nrect = patches.Rectangle((-1, -0.4), 2, 0.5, fill=True, ec='black', fc='gray', lw=1, zorder=20, \n                         transform=rotation_transform + ax0.transData)\npoly = patches.Polygon(numpy.stack(([-0.25, -0.15, 0.15, 0.25], [-0.8, -0.4, -0.4, -0.8])).T, \n                       closed=True, fill=True, ec='black', fc='black', lw=1, zorder=20, \n                       transform=rotation_transform + ax0.transData)\nlleg = patches.Rectangle((-1, -1.2), 0.05, 1, angle=-15, fill=True, ec='black', fc='black', lw=1, zorder=10, \n                         transform=rotation_transform + ax0.transData)\nrleg = patches.Rectangle((1, -1.2), 0.05, 1, angle=15, fill=True, ec='black', fc='black', lw=1, zorder=10, \n                         transform=rotation_transform + ax0.transData)\nlfoot = patches.Rectangle((-1.1, -1.2), 0.2, 0.05, fill=True, ec='black', fc='black', lw=1, zorder=20, \n                         transform=rotation_transform + ax0.transData)\nrfoot = patches.Rectangle((0.9, -1.2), 0.2, 0.05, fill=True, ec='black', fc='black', lw=1, zorder=20, \n                         transform=rotation_transform + ax0.transData)\nax0.add_patch(circle)\nax0.add_patch(rect)\nax0.add_patch(poly)\nax0.add_patch(lleg)\nax0.add_patch(rleg)\nax0.add_patch(lfoot)\nax0.add_patch(rfoot)\nplt.show()\n\n# Functions\ndef main_function(Ka,La,Ydw,eig1,eig2,eig3,eig4,eig5,eig1o,eig2o,selm,selc,selo,DW):\n    global T, yout, yd, Aa, Ba, A11, A21\n    method = method_choice(selm)\n    eigc, eigo = eigen_choice(selc,selo)\n    yd = Ydw\n    ax1.set_ylim([-0.1*yd,yd*1.5])\n    ax2.set_ylim([-51*yd,51*yd])\n    ax3.set_ylim([-15,15])\n    \n    if method == 1: #Setted matrix gain\n        sol = numpy.linalg.eig((Aa-Ba[:,0]*Ka))\n        print('The eigenvalues of Aa are: '+str(round(sol[0][0],3))+', '+str(round(sol[0][1],3))+', '+str(round(sol[0][2],3))+', '+str(round(sol[0][3],3))+' and '+str(round(sol[0][4],3)))\n        sol = numpy.linalg.eig(A11+La*A21)\n        print('The eigenvalues of A11+La*A21 are: '+str(round(sol[0][0],3))+' and '+str(round(sol[0][1],3))) \n        sys = simulation(Aa, Ba, Ca, A11, A12, A21, A22, B1, B2, La, Ka, Ta)\n        T = numpy.linspace(0, 17, 100)\n        T, yout = ctrl.step_response(sys, T, X0a)\n    if method == 2: #Setted eigenvalues\n        if eigc == 0:\n            Ka = ctrl.acker(Aa, Ba[:,0], [eig1[0,0], eig2[0,0], eig3[0,0], eig4[0,0], eig5[0,0]])\n            Kaw.setM(Ka)\n        if eigc == 2:\n            Ka = ctrl.acker(Aa, Ba[:,0], [eig1[0,0], numpy.complex(eig2[0,0],eig2[1,0]), numpy.complex(eig2[0,0],-eig2[1,0]), eig4[0,0], eig5[0,0]])\n            Kaw.setM(Ka)\n        if eigc == 4:\n            Ka = ctrl.acker(Aa, Ba[:,0], [eig1[0,0], numpy.complex(eig2[0,0],eig2[1,0]), numpy.complex(eig2[0,0],-eig2[1,0]), numpy.complex(eig3[0,0],eig3[1,0]), numpy.complex(eig3[0,0],-eig3[1,0])])\n            Kaw.setM(Ka)\n        if eigo == 0:\n            La = numpy.matrix([[0, 2*eig1o[0,0]/3 + 2*eig2o[0,0]/3, 0], [0, -2*eig1o[0,0]*eig2o[0,0]/3, 0]])\n            Law.setM(La) \n        if eigo == 2:\n            La = numpy.matrix([[0, 2*numpy.complex(eig2o[0,0],eig2o[1,0])/3 + 2*numpy.complex(eig2o[0,0],-eig2o[1,0])/3, 0], [0, -2*numpy.complex(eig2o[0,0],eig2o[1,0])*numpy.complex(eig2o[0,0],-eig2o[1,0])/3, 0]])\n            Law.setM(La)\n        sol = numpy.linalg.eig((Aa-Ba[:,0]*Ka))\n        print('The eigenvalues of Aa are: '+str(round(sol[0][0],3))+', '+str(round(sol[0][1],3))+', '+str(round(sol[0][2],3))+', '+str(round(sol[0][3],3))+' and '+str(round(sol[0][4],3)))\n        sol = numpy.linalg.eig(A11+La*A21)\n        print('The eigenvalues of A11+La*A21 are: '+str(round(sol[0][0],3))+' and '+str(round(sol[0][1],3))) \n        sys = simulation(Aa, Ba, Ca, A11, A12, A21, A22, B1, B2, La, Ka, Ta)\n        T = numpy.linspace(0, 17, 100)\n        T, yout = ctrl.step_response(sys, T, X0a)\n\nani = animation.FuncAnimation(fig, fun_animation, init_func=anim_init, frames=100, repeat=True, interval=170, blit=True)\n\n\n#create dummy widget \nDW = widgets.FloatText(layout=widgets.Layout(width='0px', height='0px'))\n\n#create button widget\nSTART = widgets.Button(\n    description='Test',\n    disabled=False,\n    button_style='', # 'success', 'info', 'warning', 'danger' or ''\n    tooltip='Test',\n    icon='check'\n)\n                       \ndef on_start_button_clicked(b):\n    #This is a workaround to have intreactive_output call the callback:\n    #   force the value of the dummy widget to change\n    if DW.value&gt; 0 :\n        DW.value = -1\n    else: \n        DW.value = 1\n    pass\nSTART.on_click(on_start_button_clicked)\n\n# Define type of method \nselm = widgets.Dropdown(\n    options= ['Set Ka and La', 'Set the eigenvalues'],\n    value= 'Set Ka and La',\n    description='',\n    disabled=False\n)\n\n# Define the number of complex eigenvalues for the controller\nselc = widgets.Dropdown(\n    options= ['0 complex eigenvalues', '2 complex eigenvalues', '4 complex eigenvalues'],\n    value= '4 complex eigenvalues',\n    description='Aa:',\n    disabled=False\n)\n\n# Define the number of complex eigenvalues for the observer\nselo = widgets.Dropdown(\n    options= ['0 complex eigenvalues', '2 complex eigenvalues'],\n    value= '0 complex eigenvalues',\n    description='Aobs:',\n    disabled=False\n)\n\nalltogether = widgets.VBox([\n    widgets.HBox([\n        selm,\n        selc,\n        selo\n    ]),\n    widgets.Label('',border=3),\n    widgets.HBox([\n        widgets.Label('Ka:',border=3),\n        Kaw,\n        widgets.Label('',border=3),\n        widgets.Label('',border=3),\n        widgets.Label('La:',border=3),\n        Law\n    ]),\n    widgets.Label('',border=3),\n    widgets.HBox([\n        widgets.Label('Aa\\'s eigs:',border=3),\n        eig1, eig2, eig3, eig4, eig5,\n        widgets.Label('',border=3),\n        widgets.Label('',border=3),\n        widgets.Label('Aobs\\'s eigs:',border=3),\n        eig1o, eig2o\n    ]),\n    widgets.Label('',border=3),\n    widgets.HBox([\n        Ydw,\n        widgets.Label('',border=3),\n        widgets.Label('',border=3),\n        widgets.Label('',border=3),\n        START\n    ])\n])\n\nout = widgets.interactive_output(main_function,{'Ka':Kaw, 'La':Law, 'Ydw':Ydw, 'eig1':eig1, 'eig2':eig2, \n                                                'eig3':eig3, 'eig4':eig4, 'eig5':eig5,\n                                                'eig1o':eig1o, 'eig2o':eig2o,\n                                                'selm':selm, 'selc':selc, 'selo':selo, 'DW':DW})\ndisplay(out, alltogether)"
  },
  {
    "objectID": "ICCT_en/examples/04/SS-36-Satellite_orbit_control.html",
    "href": "ICCT_en/examples/04/SS-36-Satellite_orbit_control.html",
    "title": "Satellite orbit control",
    "section": "",
    "text": "#remove cell visibility\nfrom IPython.display import HTML\ntag = HTML('''&lt;script&gt;\ncode_show=true; \nfunction code_toggle() {\n    if (code_show){\n        $('div.input').hide()\n    } else {\n        $('div.input').show()\n    }\n    code_show = !code_show\n} \n$( document ).ready(code_toggle);\n&lt;/script&gt;\nToggle cell visibility &lt;a href=\"javascript:code_toggle()\"&gt;here&lt;/a&gt;.''')\ndisplay(tag)\n\n\nToggle cell visibility here.\n\n\n\n%matplotlib inline\nimport control\nimport numpy\nimport sympy as sym\nfrom IPython.display import display, Markdown\nimport ipywidgets as widgets\nimport matplotlib.pyplot as plt\n\n\n#print a matrix latex-like\ndef bmatrix(a):\n     \"\"\"Returns a LaTeX bmatrix - by Damir Arbula (ICCT project)\n\n     :a: numpy array\n     :returns: LaTeX bmatrix as a string\n     \"\"\"\n     if len(a.shape) &gt; 2:\n         raise ValueError('bmatrix can at most display two dimensions')\n     lines = str(a).replace('[', '').replace(']', '').splitlines()\n     rv = [r'\\begin{bmatrix}']\n     rv += ['  ' + ' & '.join(l.split()) + r'\\\\' for l in lines]\n     rv +=  [r'\\end{bmatrix}']\n     return '\\n'.join(rv)\n\n\n# Display formatted matrix: \ndef vmatrix(a):\n    if len(a.shape) &gt; 2:\n         raise ValueError('bmatrix can at most display two dimensions')\n    lines = str(a).replace('[', '').replace(']', '').splitlines()\n    rv = [r'\\begin{vmatrix}']\n    rv += ['  ' + ' & '.join(l.split()) + r'\\\\' for l in lines]\n    rv +=  [r'\\end{vmatrix}']\n    return '\\n'.join(rv)\n\n\n#matrixWidget is a matrix looking widget built with a VBox of HBox(es) that returns a numPy array as value !\nclass matrixWidget(widgets.VBox):\n    def updateM(self,change):\n        for irow in range(0,self.n):\n            for icol in range(0,self.m):\n                self.M_[irow,icol] = self.children[irow].children[icol].value\n                #print(self.M_[irow,icol])\n        self.value = self.M_\n\n    def dummychangecallback(self,change):\n        pass\n    \n    \n    def __init__(self,n,m):\n        self.n = n\n        self.m = m\n        self.M_ = numpy.matrix(numpy.zeros((self.n,self.m)))\n        self.value = self.M_\n        widgets.VBox.__init__(self,\n                             children = [\n                                 widgets.HBox(children = \n                                              [widgets.FloatText(value=0.0, layout=widgets.Layout(width='90px')) for i in range(m)]\n                                             ) \n                                 for j in range(n)\n                             ])\n        \n        #fill in widgets and tell interact to call updateM each time a children changes value\n        for irow in range(0,self.n):\n            for icol in range(0,self.m):\n                self.children[irow].children[icol].value = self.M_[irow,icol]\n                self.children[irow].children[icol].observe(self.updateM, names='value')\n        #value = Unicode('example@example.com', help=\"The email value.\").tag(sync=True)\n        self.observe(self.updateM, names='value', type= 'All')\n        \n    def setM(self, newM):\n        #disable callbacks, change values, and reenable\n        self.unobserve(self.updateM, names='value', type= 'All')\n        for irow in range(0,self.n):\n            for icol in range(0,self.m):\n                self.children[irow].children[icol].unobserve(self.updateM, names='value')\n        self.M_ = newM\n        self.value = self.M_\n        for irow in range(0,self.n):\n            for icol in range(0,self.m):\n                self.children[irow].children[icol].value = self.M_[irow,icol]\n        for irow in range(0,self.n):\n            for icol in range(0,self.m):\n                self.children[irow].children[icol].observe(self.updateM, names='value')\n        self.observe(self.updateM, names='value', type= 'All')        \n\n                #self.children[irow].children[icol].observe(self.updateM, names='value')\n\n             \n#overlaod class for state space systems that DO NOT remove \"useless\" states (what \"professor\" of automatic control would do this?)\nclass sss(control.StateSpace):\n    def __init__(self,*args):\n        #call base class init constructor\n        control.StateSpace.__init__(self,*args)\n    #disable function below in base class\n    def _remove_useless_states(self):\n        pass\n\nThe dynamics of a satellite in circular orbit around the Earth can be described by the following nonlinear dynamic equation: \\[\n    \\ddot{r} = f(r,\\tau,d) = r\\dot{\\theta}^2 - \\frac{K}{r^2} + \\tau + d \\, ,\n\\]\nwhere \\(r\\) is the radius of the orbit, \\(\\theta\\) is the angle describing the position of the satellite in the circular orbit, \\(K = 398600\\) km3/s2 is a constant, \\(\\tau\\) is the satellite radial thrust produced by an appropriate actuator (limit: \\(|\\tau|\\leq 100 \\mu\\text{N}\\)) and \\(d\\) is the gravity disturbance.\nWe want to design a regulator for the orbit radius according to the following specifications: - settling time for 5% tolerance band of less than 1 hour; - overshoot less than 40%; - no steady-state error in response to a step position request.\nIn order to have a linear dynamic system we linearize the equation at the equilibrium (\\(r_{eq} = 16763\\) km, \\(\\dot{r}_{eq}=0\\), \\(\\tau_{eq}=0\\), \\(d_{eq}=0\\)) considering \\(\\omega_{eq}=\\dot{\\theta}_{eq}= \\frac{2\\pi}{6\\times3600}\\). Defining \\(x=\\begin{bmatrix} x_1 & x_2 \\end{bmatrix}^T=\\begin{bmatrix} \\dot{r} & r \\end{bmatrix}^T\\) and \\(u=\\begin{bmatrix} \\tau & d \\end{bmatrix}^T\\) the equations in state space form become:\n\\[\\begin{cases}\n    \\dot{\\delta x} = \\frac{\\partial f(x,u)}{\\partial x}\\Bigr|_{\\substack{x=x_{eq}\\\\u=u_{eq}}}(x-x_{eq}) + \\frac{\\partial f(x,u)}{\\partial u}\\Bigr|_{\\substack{x=x_{eq}\\\\u=u_{eq}}}(u-u_{eq}) = A\\delta x+ B\\delta u = \\begin{bmatrix} 0 & \\omega_{eq}^2 + 2\\frac{K}{r_{eq}^3} \\\\ 1 & 0 \\end{bmatrix}\\delta x + \\begin{bmatrix} 1 & 1 \\\\ 0 & 0 \\end{bmatrix}\\delta u\\\\\n    y = C\\delta x = \\begin{bmatrix} 0 & 1 \\end{bmatrix}\\delta x \\, .\n\\end{cases}\\]\nThe poles of the system are \\(\\pm0.000504\\).\n\nDevelopment of the regulator\n\nController design\nWe assure zero steady-state error by adding a new state \\(\\dot{\\delta x_3} = \\delta x_2 - y_d\\)\n\\[\\begin{cases}\n    \\dot{x}_a = \\begin{bmatrix} 0 & \\omega_{eq}^2 + 2\\frac{K}{r_{eq}^3} & 0 \\\\ 1 & 0 & 0 \\\\ 0 & 1 & 0 \\end{bmatrix}x_a + \\begin{bmatrix} 1 & 1 & 0 \\\\ 0 & 0 & 0 \\\\ 0 & 0 & -1 \\end{bmatrix}\\begin{bmatrix} \\tau \\\\ d \\\\ y_d\\end{bmatrix}\\\\\n    y_a = \\begin{bmatrix} 0 & 1 & 0 \\\\ 0 & 0 & 1\\end{bmatrix}x_a \\, .\n\\end{cases}\\]\nA possible location for the poles of the closed-loop system is \\(-0.0504\\) and \\(-0.001\\pm0.003i\\).\n\n\nObserver design\nSince we measure directly \\(\\delta x_2\\) and \\(\\delta x_3\\) (see output matrix), it is possible to design an observer for \\(\\delta x_1\\) only. Working with the subsystem (\\(\\delta x_1\\), \\(\\delta x_2\\)) and defining \\(L=\\begin{bmatrix} l_1 & l_2 \\end{bmatrix}^T\\) we can write:\n\\[\n    \\dot{\\hat{\\delta x}} = \\left(A-LC\\right)\\hat{\\delta x} + \\begin{bmatrix} 1 \\\\ 0 \\end{bmatrix}\\tau + Ly \\, ,\n\\]\ntaking the Laplace transform and solving for \\(\\hat{\\delta x}_1(s)\\) gives:\n\\[\n    \\hat{\\delta x}_1(s) = \\frac{l_2  + s}{\\left(l_1 - \\frac{2K}{r_{eq}^3}- \\omega_{eq}^2\\right) + l_2s + s^2}\\tau + \\frac{l_2\\left(\\frac{2K}{r_{eq}^3} + \\omega_{eq}^2\\right) + l_1s}{\\left(l_1 - \\frac{2K}{r_{eq}^3}- \\omega_{eq}^2\\right) + l_2s + s^2}y \\, .\n\\]\nWe place both observer poles at \\(-1\\).\n\n\n\nHow to use this notebook?\n\nTry to change the response in order to achieve 0% overshoot with a relaxed requirement for the settling time (2 hours).\nVerify the performance of controlled system with a step and sinusoidal disturbance.\n\n\n# Preparatory cell\nom = 2*numpy.pi/3600/6\nK = 398600\nr = 16763\nAa = numpy.matrix([[0, om**2+2*K/r**3, 0],\n                   [1, 0, 0],\n                   [0, 1, 0]])\nBa = numpy.matrix([[1, 1, 0],\n                   [0, 0, 0],\n                   [0, 0, -1]])\nCa = numpy.matrix([[0, 1, 0],\n                   [0, 0, 1]])\n\nX0 = numpy.matrix('0.0')\nK = numpy.matrix([8/15,-4.4,-4])\nL = numpy.matrix([[23],[66],[107/3]])\n\nX0w = matrixWidget(1,1)\nX0w.setM(X0)\nKw = matrixWidget(1,3)\nKw.setM(K)\nLw = matrixWidget(2,1)\nLw.setM(L)\n\n\neig1c = matrixWidget(1,1)\neig2c = matrixWidget(2,1)\neig3c = matrixWidget(1,1)\neig1c.setM(numpy.matrix([-0.0504])) \neig2c.setM(numpy.matrix([[-0.001],[-0.003]]))\neig3c.setM(numpy.matrix([-1.0]))\n\neig1o = matrixWidget(1,1)\neig2o = matrixWidget(2,1)\neig1o.setM(numpy.matrix([-1.])) \neig2o.setM(numpy.matrix([[-1.],[0.]]))\n\n\n# Misc\n\n#create dummy widget \nDW = widgets.FloatText(layout=widgets.Layout(width='0px', height='0px'))\n\n#create button widget\nSTART = widgets.Button(\n    description='Test',\n    disabled=False,\n    button_style='', # 'success', 'info', 'warning', 'danger' or ''\n    tooltip='Test',\n    icon='check'\n)\n                       \ndef on_start_button_clicked(b):\n    #This is a workaround to have intreactive_output call the callback:\n    #   force the value of the dummy widget to change\n    if DW.value&gt; 0 :\n        DW.value = -1\n    else: \n        DW.value = 1\n    pass\nSTART.on_click(on_start_button_clicked)\n\n# Define type of method \nselm = widgets.Dropdown(\n    options= ['Set K and L', 'Set the eigenvalues'],\n    value= 'Set the eigenvalues',\n    description='',\n    disabled=False\n)\n\n# Define the number of complex eigenvalues\nsele = widgets.Dropdown(\n    options= ['0 complex eigenvalues', '2 complex eigenvalues'],\n    value= '2 complex eigenvalues',\n    description='Complex eigenvalues:',\n    style = {'description_width': 'initial'},\n    disabled=False\n)\n\n#define type of ipout \nselu = widgets.Dropdown(\n    options=['impulse', 'step', 'sinusoid', 'square wave'],\n    value='step',\n    description='Type of disturbance:',\n    style = {'description_width': 'initial'},\n    disabled=False\n)\n# Define the values of the input\nu = widgets.FloatSlider(\n    value=10,\n    min=0,\n    max=30,\n    step=1,\n    description='Reference [m]:',\n    style = {'description_width': 'initial'},\n    disabled=False,\n    continuous_update=False,\n    orientation='horizontal',\n    readout=True,\n    readout_format='.1f',\n)\nd = widgets.FloatSlider(\n    value=0,\n    min=-3,\n    max=3,\n    step=0.1,\n    description='Disturbance [µm/s^2]:',\n    style = {'description_width': 'initial'},\n    disabled=False,\n    continuous_update=False,\n    orientation='horizontal',\n    readout=True,\n    readout_format='.1f',\n)\nperiod = widgets.FloatSlider(\n    value=100,\n    min=1,\n    max=300,\n    step=1,\n    description='Period [µs]: ',\n    disabled=False,\n    continuous_update=False,\n    orientation='horizontal',\n    readout=True,\n    readout_format='.1f',\n)\nsimTime = widgets.FloatText(\n    value=3600*2,\n    description='',\n    disabled=False\n)\n\n\n# Support functions\n\ndef eigen_choice(sele):\n    if sele == '0 complex eigenvalues':\n        eig1c.children[0].children[0].disabled = False\n        eig2c.children[1].children[0].disabled = True\n        eig1o.children[0].children[0].disabled = False\n        eig2o.children[1].children[0].disabled = True\n        eig = 0\n    if sele == '2 complex eigenvalues':\n        eig1c.children[0].children[0].disabled = True\n        eig2c.children[1].children[0].disabled = False\n        eig1o.children[0].children[0].disabled = True\n        eig2o.children[1].children[0].disabled = False\n        eig = 2\n    return eig\n\ndef method_choice(selm):\n    if selm == 'Set K and L':\n        method = 1\n        sele.disabled = True\n    if selm == 'Set the eigenvalues':\n        method = 2\n        sele.disabled = False\n    return method\n\n\nA = Aa[0:2,0:2]\nB = Ba[0:2,0]\nC = Ca[0,0:2]\n\ndef main_callback2(d, X0w, K, L, eig1c, eig2c, eig3c, eig1o, eig2o, u, period, selm, sele, selu, simTime, DW):\n    eige = eigen_choice(sele)\n    method = method_choice(selm)\n    \n    if method == 1:\n        solc = numpy.linalg.eig(Aa-Ba[:,0]*K)\n        solo = numpy.linalg.eig(A-L*C)\n    if method == 2:\n        if eige == 0:\n            K = control.acker(Aa, Ba[:,0], [eig1c[0,0], eig2c[0,0], eig3c[0,0]])\n            Kw.setM(K)\n            L = control.acker(A.T, C.T, [eig1o[0,0], eig2o[0,0]]).T\n            Lw.setM(L)\n        if eige == 2:\n            K = control.acker(Aa, Ba[:,0], [eig3c[0,0], \n                                     numpy.complex(eig2c[0,0],eig2c[1,0]), \n                                     numpy.complex(eig2c[0,0],-eig2c[1,0])])\n            Kw.setM(K)\n            L = control.acker(A.T, C.T, [numpy.complex(eig2o[0,0],eig2o[1,0]), \n                                         numpy.complex(eig2o[0,0],-eig2o[1,0])]).T\n            Lw.setM(L)\n            \n    \n    sys = control.ss(Aa,Ba,numpy.vstack((Ca,[0,0,0])),[[0,0,0],[0,0,0],[1,0,0]])\n    sysE = control.ss(A-L*C,\n                      numpy.hstack((B,L)),\n                      [1,0],\n                      [0,0])\n    sysC = control.ss(numpy.zeros((1,1)),\n                      [0, 0, 0],\n                      0,\n                      -K)\n    \n    sys_append = control.append(sys, sysE, sysC)        \n    sys_CL = control.connect(sys_append,\n                             [[1,5],[4,3],[5,1],[6,4],[7,1],[8,2]],\n                             [3,2], # in\n                             [1,3]) # out\n    \n    \n    X0w1 = numpy.zeros((5,1))\n    X0w1[3,0] = X0w\n    if simTime != 0:\n        T = numpy.linspace(0, simTime, 10000)\n    else:\n        T = numpy.linspace(0, 1, 10000)\n    \n    d = d/1E6\n    period=period/1E6\n    U1 = [u for t in range(0,len(T))]\n    if selu == 'impulse': #selu\n        U = [0 for t in range(0,len(T))]\n        U[0] = d        \n        T, yout, xout = control.forced_response(sys_CL,T,[U1,U],X0w1)\n    if selu == 'step':\n        U = [d for t in range(0,len(T))]\n        T, yout, xout = control.forced_response(sys_CL,T,[U1,U],X0w1)\n    if selu == 'sinusoid':\n        U = d*numpy.sin(2*numpy.pi/period*T)\n        T, yout, xout = control.forced_response(sys_CL,T,[U1,U],X0w1)\n    if selu == 'square wave':\n        U = d*numpy.sign(numpy.sin(2*numpy.pi/period*T))\n        T, yout, xout = control.forced_response(sys_CL,T,[U1,U],X0w1)\n    \n    step_info_dict = control.step_info(sys_CL[0,0],SettlingTimeThreshold=0.05,T=T)\n    print('Step info: \\n\\tSettling time (5%) [hrs]=',step_info_dict['SettlingTime']/3600,'\\n\\tOvershoot (%)=',step_info_dict['Overshoot'])\n    print('Max u value (% of 100µN)=', max(abs(yout[1]))/(100E-06)*100)\n    \n    fig = plt.figure(num='Simulation1', figsize=(16,12))\n    \n    fig.add_subplot(221)\n    plt.title('Output response')\n    plt.ylabel('Output [m]')\n    plt.plot(T,yout[0])\n    plt.xlabel('$t$ [s]')\n    plt.legend(['$y$'])\n    plt.axvline(x=0,color='black',linewidth=0.8)\n    plt.axhline(y=0,color='black',linewidth=0.8)\n    plt.grid()\n    \n    fig.add_subplot(222)\n    plt.title('Input')\n    plt.ylabel('$u$ [N]')\n    plt.plot(T,yout[1])\n    plt.plot(T,[100/1E6 for t in range(len(T))],'r--')\n    plt.plot(T,[-100/1E6 for t in range(len(T))],'r--')\n    plt.xlabel('$t$ [s]')\n    plt.axvline(x=0,color='black',linewidth=0.8)\n    plt.axhline(y=0,color='black',linewidth=0.8)\n    plt.grid()\n    \n    fig.add_subplot(223)\n    plt.title('States response')\n    plt.ylabel('States')\n    plt.plot(T,xout[0],\n             T,xout[1],\n             T,xout[2])\n    plt.xlabel('$t$ [s]')\n    plt.legend(['$\\delta x_{1}$','$\\delta x_{2}$','$\\delta x_{3}$'])\n    plt.axvline(x=0,color='black',linewidth=0.8)\n    plt.axhline(y=0,color='black',linewidth=0.8)\n    plt.grid()\n    \n    fig.add_subplot(224)\n    plt.title('Estimation error')\n    plt.ylabel('Error')\n    plt.plot(T,xout[0]-xout[3])\n    plt.xlabel('$t$ [s]')\n    plt.legend(['$e_{1}$'])\n    plt.axvline(x=0,color='black',linewidth=0.8)\n    plt.axhline(y=0,color='black',linewidth=0.8)\n    plt.grid()\n    #plt.tight_layout()\n    \n    fig.tight_layout()\n   \nalltogether2 = widgets.VBox([widgets.HBox([selm, \n                                          sele,\n                                          selu]),\n                            widgets.Label(' ',border=3),\n                            widgets.HBox([widgets.Label('K:',border=3), Kw, \n                                          widgets.Label(' ',border=3),\n                                          widgets.Label(' ',border=3),\n                                          widgets.Label('Eigenvalues:',border=3), \n                                          eig1c, \n                                          eig2c, \n                                          eig3c,\n                                          widgets.Label(' ',border=3),\n                                          widgets.Label(' ',border=3),\n                                          widgets.Label('X0 est.:',border=3), X0w]),\n                            widgets.Label(' ',border=3),\n                            widgets.HBox([widgets.Label('L:',border=3), Lw, \n                                          widgets.Label(' ',border=3),\n                                          widgets.Label(' ',border=3),\n                                          widgets.Label('Eigenvalues:',border=3), \n                                          eig1o, \n                                          eig2o,\n                                          widgets.Label(' ',border=3),\n                                          widgets.VBox([widgets.Label('Simulation time (s):',border=3)]),\n                                          widgets.VBox([simTime])]),\n                            widgets.Label(' ',border=3),\n                            widgets.HBox([u,\n                                          d,\n                                          period, \n                                          START])])\nout2 = widgets.interactive_output(main_callback2, {'d':d, 'X0w':X0w, 'K':Kw, 'L':Lw,\n                                                 'eig1c':eig1c, 'eig2c':eig2c, 'eig3c':eig3c, 'eig1o':eig1o, 'eig2o':eig2o, \n                                                 'u':u, 'period':period, 'selm':selm, 'sele':sele, 'selu':selu, 'simTime':simTime, 'DW':DW})\nout2.layout.height = '850px'\ndisplay(out2, alltogether2)"
  },
  {
    "objectID": "ICCT_en/examples/04/SS-34-Regulator_design.html",
    "href": "ICCT_en/examples/04/SS-34-Regulator_design.html",
    "title": "Regulator Design: observer and state feedback",
    "section": "",
    "text": "# Erasmus+ ICCT project (2018-1-SI01-KA203-047081)\n\n# Toggle cell visibility\n\nfrom IPython.display import HTML\ntag = HTML('''&lt;script&gt;\ncode_show=true; \nfunction code_toggle() {\n    if (code_show){\n        $('div.input').hide()\n    } else {\n        $('div.input').show()\n    }\n    code_show = !code_show\n} \n$( document ).ready(code_toggle);\n&lt;/script&gt;\nToggle cell visibility &lt;a href=\"javascript:code_toggle()\"&gt;here&lt;/a&gt;.''')\ndisplay(tag)\n\n# Hide the code completely\n\n# from IPython.display import HTML\n# tag = HTML('''&lt;style&gt;\n# div.input {\n#     display:none;\n# }\n# &lt;/style&gt;''')\n# display(tag)\n\n\nToggle cell visibility here.\nThis example demonstrates the design of a regulator: a type of controller composed by an observer and a full-state feedback controller. It can be proven that, thanks to the separation principle, the controller and the observer can be designed independently - closed-loop eigenvalues and observer dynamics can be set separately without affecting each other.\nNonetheless, closed-loop transient performance depends on how fast the observer is with respect to the desired closed-loop dynamics.\nThis example shows the design of a regulator for the controllable and observable system:\nthat has the transfer function:\n\\[\nG(s) = C(sI-A)^{-1}B.\n\\]"
  },
  {
    "objectID": "ICCT_en/examples/04/SS-34-Regulator_design.html#implementation-as-transfer-function-controller",
    "href": "ICCT_en/examples/04/SS-34-Regulator_design.html#implementation-as-transfer-function-controller",
    "title": "Regulator Design: observer and state feedback",
    "section": "Implementation as transfer function controller",
    "text": "Implementation as transfer function controller\n\nsols = numpy.linalg.eig(A)\n\ndef main_callback(Aw, Bw, X0w, K, L, eig1c, eig2c, eig3c, eig1o, eig2o, eig3o, u, period, selm, sele, selu, DW):\n    eige = eigen_choice(sele)\n    method = method_choice(selm)\n    \n    if method == 1:\n        solc = numpy.linalg.eig(A-B*K)\n        solo = numpy.linalg.eig(A-L*C)\n    if method == 2:\n        if eige == 0:\n            K = control.acker(A, B, [eig1c[0,0], eig2c[0,0], eig3c[0,0]])\n            Kw.setM(K)\n            L = control.acker(A.T, C.T, [eig1o[0,0], eig2o[0,0], eig3o[0,0]]).T\n            Lw.setM(L)\n        if eige == 2:\n            K = control.acker(A, B, [eig3c[0,0], \n                                     numpy.complex(eig2c[0,0],eig2c[1,0]), \n                                     numpy.complex(eig2c[0,0],-eig2c[1,0])])\n            Kw.setM(K)\n            L = control.acker(A.T, C.T, [eig3o[0,0], \n                                         numpy.complex(eig2o[0,0],eig2o[1,0]), \n                                         numpy.complex(eig2o[0,0],-eig2o[1,0])]).T\n            Lw.setM(L)\n            \n    \n    Gs = sss(A,B,C,0)\n    Ks = sss(A-B*K-L*C,L,-K,0)\n    Fs = control.series(-Ks,Gs)\n    sys = control.feedback(Fs)\n    \n    Gs_id = sss(A,B,sym.eye(3),sym.zeros(3,1))\n    Fs_id = control.series(K,Gs_id)\n    A1 = numpy.matrix(Fs_id.A-Fs_id.B*Fs_id.C)\n    B1 = numpy.matrix(Fs_id.B*sym.Matrix([[1],[0],[0]]))\n    C1 = numpy.matrix(sym.Matrix([1,0,0]).T*Fs_id.C)\n    sys_id = sss(A1,B1,C1,0)\n    \n    sys_o = sss(A-L*C,numpy.hstack((L,B)),sym.eye(3),sym.zeros(3,2))\n    \n    dcgain = control.dcgain(sys)\n    t = numpy.linspace(0, 1000, 2)\n    t, y = control.step_response(sys_id,t)\n    dcgain_id = y[-1]\n    gain_w.value = dcgain\n    gain_id_w.value = dcgain_id\n    if dcgain != 0 and dcgain_id != 0:\n        u1 = u/gain_w.value\n        u2 = u/gain_id_w.value\n    else:\n        print('The inverse gain set is 0 and it is changed to 1')\n        u1 = u/1\n        u2 = u/1\n    \n    solc = numpy.linalg.eig(sys.A)\n    solo = numpy.linalg.eig(A-L*C-B*K)\n    print('The system\\'s eigenvalues are:', round(sols[0][0],2),',', round(sols[0][1],2),'and', round(sols[0][2],2))\n    print('The controlled closed loop system\\'s eigenvalues are:', \n          round(solc[0][0],2),',', \n          round(solc[0][1],2),',', \n          round(solc[0][2],2),',',\n          round(solc[0][3],2),',',\n          round(solc[0][4],2),'and',\n          round(solc[0][5],2))\n    print('The controller\\'s eigenvalues are:', round(solo[0][0],2),',', round(solo[0][1],2),'and', round(solo[0][2],2))\n    print('')\n    print('The static gain of the closed loop system (from the reference to the output) is: %.5f' %dcgain)\n    print('The static gain of the closed loop ideal system (from the reference to the output) is: %.5f' %dcgain_id)\n    \n    X0w1 = numpy.matrix([[X0w[0,0]],[X0w[1,0]],[X0w[2,0]],[0],[0],[0]])\n    T = numpy.linspace(0, 12, 1000)\n      \n    if selu == 'impulse': #selu\n        U = [0 for t in range(0,len(T))]\n        U[0] = u\n        U1 = [0 for t in range(0,len(T))]\n        U1[0] = u1\n        U2 = [0 for t in range(0,len(T))]\n        U2[0] = u2\n        T, yout, xout = control.forced_response(sys,T,U1,X0w1)\n        T, yout_id, xout_id = control.forced_response(sys_id,T,U2,[0, 0, 0])\n        T, yout_k, xout_k = control.forced_response(Ks,T,yout-U1,X0w)\n        T, yout_o, xout_o = control.forced_response(sys_o,T,[yout,yout_k],X0w)\n    if selu == 'step':\n        U = [u for t in range(0,len(T))]\n        U1 = [u1 for t in range(0,len(T))]\n        U2 = [u2 for t in range(0,len(T))]\n        T, yout, xout = control.forced_response(sys,T,U1,X0w1)\n        T, yout_id, xout_id = control.forced_response(sys_id,T,U2,[0, 0, 0])\n        T, yout_k, xout_k = control.forced_response(Ks,T,yout-U1,X0w)\n        T, yout_o, xout_o = control.forced_response(sys_o,T,[yout,yout_k],X0w)\n    if selu == 'sinusoid':\n        U = u*numpy.sin(2*numpy.pi/period*T)\n        U1 = u1*numpy.sin(2*numpy.pi/period*T)\n        U2 = u2*numpy.sin(2*numpy.pi/period*T)\n        T, yout, xout = control.forced_response(sys,T,U1,X0w1)\n        T, yout_id, xout_id = control.forced_response(sys_id,T,U2,[0, 0, 0])\n        T, yout_k, xout_k = control.forced_response(Ks,T,yout-U1,X0w)\n        T, yout_o, xout_o = control.forced_response(sys_o,T,[yout,yout_k],X0w)\n    if selu == 'square wave':\n        U = u*numpy.sign(numpy.sin(2*numpy.pi/period*T))\n        U1 = u1*numpy.sign(numpy.sin(2*numpy.pi/period*T))\n        U2 = u2*numpy.sign(numpy.sin(2*numpy.pi/period*T))\n        T, yout, xout = control.forced_response(sys,T,U1,X0w1)\n        T, yout_id, xout_id = control.forced_response(sys_id,T,U2,[0, 0, 0])\n        T, yout_k, xout_k = control.forced_response(Ks,T,yout-U1,X0w)\n        T, yout_o, xout_o = control.forced_response(sys_o,T,[yout,yout_k],X0w)\n    # N.B. i primi 3 stati di xout sono quelli dello stimatore, mentre gli ultimi 3 sono quelli del sistema \"reale\"\n    \n    fig = plt.figure(num='Simulation1', figsize=(16,17))\n    mag, phase, omega = control.bode_plot(sys,Plot = False)\n    mag = control.mag2db(mag)\n    phase = phase*180/numpy.pi\n    fig.add_subplot(321)\n    plt.title('Bode plot: magnitude')\n    plt.semilogx(omega,mag)\n    plt.xlabel('$\\omega$ [rad/s]')\n    plt.ylabel('Mag. [dB]')\n    plt.grid(True,which=\"both\")\n    \n    fig.add_subplot(323)\n    plt.title('Bode plot: phase')\n    plt.semilogx(omega,phase)\n    plt.xlabel('$\\omega$ [rad/s]')\n    plt.ylabel('Phase [deg]')\n    plt.grid(True,which=\"both\")\n    \n    fig.add_subplot(325)\n    plt.title('Output response')\n    plt.ylabel('Output')\n    plt.plot(T,yout,T,yout_id,'g',T,U,'r--')\n    plt.xlabel('$t$ [s]')\n    plt.legend(['$y$','$y_{ideal}$','Reference'])\n    plt.axvline(x=0,color='black',linewidth=0.8)\n    plt.axhline(y=0,color='black',linewidth=0.8)\n    plt.grid()\n    \n    fig.add_subplot(322)\n    plt.title('First state response')\n    plt.ylabel('$x_1$')\n    plt.plot(T,xout_o[0],T,xout[3],T,xout_id[0],'g')\n    plt.xlabel('$t$ [s]')\n    plt.legend(['$x_{1est}$','$x_{1real}$','$x_{1ideal}$'])\n    plt.axvline(x=0,color='black',linewidth=0.8)\n    plt.axhline(y=0,color='black',linewidth=0.8)\n    plt.grid()\n    \n    fig.add_subplot(324)\n    plt.title('Second state response')\n    plt.ylabel('$x_2$')\n    plt.plot(T,xout_o[1],T,xout[4],T,xout_id[1],'g')\n    plt.xlabel('$t$ [s]')\n    plt.legend(['$x_{2est}$','$x_{2real}$','$x_{2ideal}$'])\n    plt.axvline(x=0,color='black',linewidth=0.8)\n    plt.axhline(y=0,color='black',linewidth=0.8)\n    plt.grid()\n    \n    fig.add_subplot(326)\n    plt.title('Third state response')\n    plt.ylabel('$x_3$')\n    plt.plot(T,xout_o[2],T,xout[5],T,xout_id[2],'g')\n    plt.xlabel('$t$ [s]')\n    plt.legend(['$x_{3est}$','$x_{3real}$','$x_{3ideal}$'])\n    plt.axvline(x=0,color='black',linewidth=0.8)\n    plt.axhline(y=0,color='black',linewidth=0.8)\n    plt.grid()\n\n   \nalltogether = widgets.VBox([widgets.HBox([selm, \n                                          sele,\n                                          selu]),\n                            widgets.Label(' ',border=3),\n                            widgets.HBox([widgets.Label('K:',border=3), Kw, \n                                          widgets.Label(' ',border=3),\n                                          widgets.Label(' ',border=3),\n                                          widgets.Label('Eigenvalues:',border=3), \n                                          eig1c, \n                                          eig2c, \n                                          eig3c,\n                                          widgets.Label(' ',border=3),\n                                          widgets.Label(' ',border=3),\n                                          widgets.Label('X0 est.:',border=3), X0w]),\n                            widgets.Label(' ',border=3),\n                            widgets.HBox([widgets.Label('L:',border=3), Lw, \n                                          widgets.Label(' ',border=3),\n                                          widgets.Label(' ',border=3),\n                                          widgets.Label('Eigenvalues:',border=3), \n                                          eig1o, \n                                          eig2o, \n                                          eig3o,\n                                          widgets.Label(' ',border=3),\n                                          widgets.VBox([widgets.Label('Inverse reference gain:',border=3),\n                                                        widgets.Label('Inverse ideal reference gain:',border=3)]),\n                                          widgets.VBox([gain_w,gain_id_w])]),\n                            widgets.Label(' ',border=3),\n                            widgets.HBox([u, \n                                          period, \n                                          START])])\nout = widgets.interactive_output(main_callback, {'Aw':Aw, 'Bw':Bw, 'X0w':X0w, 'K':Kw, 'L':Lw,\n                                                 'eig1c':eig1c, 'eig2c':eig2c, 'eig3c':eig3c, 'eig1o':eig1o, 'eig2o':eig2o, 'eig3o':eig3o, \n                                                 'u':u, 'period':period, 'selm':selm, 'sele':sele, 'selu':selu, 'DW':DW})\nout.layout.height = '1120px'\ndisplay(out, alltogether)"
  },
  {
    "objectID": "ICCT_en/examples/04/SS-34-Regulator_design.html#implementation-as-observer",
    "href": "ICCT_en/examples/04/SS-34-Regulator_design.html#implementation-as-observer",
    "title": "Regulator Design: observer and state feedback",
    "section": "Implementation as observer",
    "text": "Implementation as observer\n\nsols = numpy.linalg.eig(A)\n\ndef main_callback2(Aw, Bw, X0w, K, L, eig1c, eig2c, eig3c, eig1o, eig2o, eig3o, u, period, selm, sele, selu, DW):\n    eige = eigen_choice(sele)\n    method = method_choice(selm)\n    \n    if method == 1:\n        solc = numpy.linalg.eig(A-B*K)\n        solo = numpy.linalg.eig(A-L*C)\n    if method == 2:\n        if eige == 0:\n            K = control.acker(A, B, [eig1c[0,0], eig2c[0,0], eig3c[0,0]])\n            Kw.setM(K)\n            L = control.acker(A.T, C.T, [eig1o[0,0], eig2o[0,0], eig3o[0,0]]).T\n            Lw.setM(L)\n        if eige == 2:\n            K = control.acker(A, B, [eig3c[0,0], \n                                     numpy.complex(eig2c[0,0],eig2c[1,0]), \n                                     numpy.complex(eig2c[0,0],-eig2c[1,0])])\n            Kw.setM(K)\n            L = control.acker(A.T, C.T, [eig3o[0,0], \n                                         numpy.complex(eig2o[0,0],eig2o[1,0]), \n                                         numpy.complex(eig2o[0,0],-eig2o[1,0])]).T\n            Lw.setM(L)\n            \n    \n    Gs = sss(A,B,numpy.vstack((numpy.eye(3),[0,0,0])),[[0],[0],[0],[1]])\n    Os = sss(A-L*C,numpy.hstack((L,B)),numpy.vstack((-K,numpy.eye(3))),[[0,0],[0,0],[0,0],[0,0]])\n    Gas = control.append(Gs,Os)\n    sys = control.connect(Gas,[[2,1],[3,4],[1,5]],[1],[1,2,3,6,7,8])\n    \n    Gs_id = sss(A,B,sym.eye(3),sym.zeros(3,1))\n    Fs_id = control.series(K,Gs_id)\n    A1 = numpy.matrix(Fs_id.A-Fs_id.B*Fs_id.C)\n    B1 = numpy.matrix(Fs_id.B*sym.Matrix([[1],[0],[0]]))\n    C1 = numpy.matrix(sym.Matrix([1,0,0]).T*Fs_id.C)\n    sys_id = sss(A1,B1,C1,0)\n\n    \n    dcgain = control.dcgain(sys[0,0])\n    t = numpy.linspace(0, 1000, 2)\n    t, y = control.step_response(sys_id,t)\n    dcgain_id = y[-1]\n    gain_w2.value = dcgain\n    gain_id_w2.value = dcgain_id\n    if dcgain != 0 and dcgain_id != 0:\n        u1 = u/gain_w2.value\n        u2 = u/gain_id_w2.value\n    else:\n        print('The inverse gain setted is 0 and it is changed to 1')\n        u1 = u/1\n        u2 = u/1\n    \n    solc = numpy.linalg.eig(sys.A)\n    print('The system\\'s eigenvalues are:', round(sols[0][0],2),',', round(sols[0][1],2),'and', round(sols[0][2],2))\n    print('The controlled closed loop system\\'s eigenvalues are:', \n          round(solc[0][0],2),',', \n          round(solc[0][1],2),',', \n          round(solc[0][2],2),',',\n          round(solc[0][3],2),',',\n          round(solc[0][4],2),'and',\n          round(solc[0][5],2))\n    print('')\n    print('The static gain of the closed loop system (from the reference to the output) is: %.5f' %dcgain)\n    print('The static gain of the closed loop ideal system (from the reference to the output) is: %.5f' %dcgain_id)\n    \n    X0w1 = numpy.matrix([[0],[0],[0],[X0w[0,0]],[X0w[1,0]],[X0w[2,0]]])\n    T = numpy.linspace(0, 12, 1000)\n      \n    if selu == 'impulse': #selu\n        U = [0 for t in range(0,len(T))]\n        U[0] = u\n        U1 = [0 for t in range(0,len(T))]\n        U1[0] = u1\n        U2 = [0 for t in range(0,len(T))]\n        U2[0] = u2\n        T, yout, xout = control.forced_response(sys,T,U1,X0w1)\n        T, yout_id, xout_id = control.forced_response(sys_id,T,U2,[0, 0, 0])\n    if selu == 'step':\n        U = [u for t in range(0,len(T))]\n        U1 = [u1 for t in range(0,len(T))]\n        U2 = [u2 for t in range(0,len(T))]\n        T, yout, xout = control.forced_response(sys,T,U1,X0w1)\n        T, yout_id, xout_id = control.forced_response(sys_id,T,U2,[0, 0, 0])\n    if selu == 'sinusoid':\n        U = u*numpy.sin(2*numpy.pi/period*T)\n        U1 = u1*numpy.sin(2*numpy.pi/period*T)\n        U2 = u2*numpy.sin(2*numpy.pi/period*T)\n        T, yout, xout = control.forced_response(sys,T,U1,X0w1)\n        T, yout_id, xout_id = control.forced_response(sys_id,T,U2,[0, 0, 0])\n    if selu == 'square wave':\n        U = u*numpy.sign(numpy.sin(2*numpy.pi/period*T))\n        U1 = u1*numpy.sign(numpy.sin(2*numpy.pi/period*T))\n        U2 = u2*numpy.sign(numpy.sin(2*numpy.pi/period*T))\n        T, yout, xout = control.forced_response(sys,T,U1,X0w1)\n        T, yout_id, xout_id = control.forced_response(sys_id,T,U2,[0, 0, 0])\n    # N.B. i primi 3 stati di xout sono quelli del sistema, mentre gli ultimi 3 sono quelli dell'osservatore\n    \n    fig = plt.figure(num='Simulation1', figsize=(16,17))\n    mag, phase, omega = control.bode_plot(sys[0,0],Plot = False)\n    mag = control.mag2db(mag)\n    phase = phase*180/numpy.pi\n    fig.add_subplot(321)\n    plt.title('Bode plot: magnitude')\n    plt.semilogx(omega,mag)\n    plt.xlabel('$\\omega$ [rad/s]')\n    plt.ylabel('Mag. [dB]')\n    plt.grid(True,which=\"both\")\n    \n    fig.add_subplot(323)\n    plt.semilogx(omega,phase)\n    plt.title('Bode plot: phase')\n    plt.xlabel('$\\omega$ [rad/s]')\n    plt.ylabel('Phase [deg]')\n    plt.grid(True,which=\"both\")\n    \n    fig.add_subplot(325)\n    plt.title('Output response')\n    plt.ylabel('Output')\n    plt.plot(T,yout[0],T,yout_id,'g',T,U,'r--')\n    plt.xlabel('$t$ [s]')\n    plt.legend(['$y$','$y_{ideal}$','Reference'])\n    plt.axvline(x=0,color='black',linewidth=0.8)\n    plt.axhline(y=0,color='black',linewidth=0.8)\n    plt.grid()\n    \n    fig.add_subplot(322)\n    plt.title('First state response')\n    plt.ylabel('$x_1$')\n    plt.plot(T,yout[3],T,yout[0],T,xout_id[0],'g')\n    plt.xlabel('$t$ [s]')\n    plt.legend(['$x_{1est}$','$x_{1real}$','$x_{1ideal}$'])\n    plt.axvline(x=0,color='black',linewidth=0.8)\n    plt.axhline(y=0,color='black',linewidth=0.8)\n    plt.grid()\n    \n    fig.add_subplot(324)\n    plt.title('Second state response')\n    plt.ylabel('$x_2$')\n    plt.plot(T,yout[4],T,yout[1],T,xout_id[1],'g')\n    plt.xlabel('$t$ [s]')\n    plt.legend(['$x_{2est}$','$x_{2real}$','$x_{2ideal}$'])\n    plt.axvline(x=0,color='black',linewidth=0.8)\n    plt.axhline(y=0,color='black',linewidth=0.8)\n    plt.grid()\n    \n    fig.add_subplot(326)\n    plt.title('Third state response')\n    plt.ylabel('$x_3$')\n    plt.plot(T,yout[5],T,yout[2],T,xout_id[2],'g')\n    plt.xlabel('$t$ [s]')\n    plt.legend(['$x_{3est}$','$x_{3real}$','$x_{3ideal}$'])\n    plt.axvline(x=0,color='black',linewidth=0.8)\n    plt.axhline(y=0,color='black',linewidth=0.8)\n    plt.grid()\n   \nalltogether2 = widgets.VBox([widgets.HBox([selm, \n                                          sele,\n                                          selu]),\n                            widgets.Label(' ',border=3),\n                            widgets.HBox([widgets.Label('K:',border=3), Kw, \n                                          widgets.Label(' ',border=3),\n                                          widgets.Label(' ',border=3),\n                                          widgets.Label('Eigenvalues:',border=3), \n                                          eig1c, \n                                          eig2c, \n                                          eig3c,\n                                          widgets.Label(' ',border=3),\n                                          widgets.Label(' ',border=3),\n                                          widgets.Label('X0 est.:',border=3), X0w]),\n                            widgets.Label(' ',border=3),\n                            widgets.HBox([widgets.Label('L:',border=3), Lw, \n                                          widgets.Label(' ',border=3),\n                                          widgets.Label(' ',border=3),\n                                          widgets.Label('Eigenvalues:',border=3), \n                                          eig1o, \n                                          eig2o, \n                                          eig3o,\n                                          widgets.Label(' ',border=3),\n                                          widgets.VBox([widgets.Label('Inverse reference gain:',border=3),\n                                                        widgets.Label('Inverse ideal reference gain:',border=3)]),\n                                          widgets.VBox([gain_w2,gain_id_w2])]),\n                            widgets.Label(' ',border=3),\n                            widgets.HBox([u, \n                                          period, \n                                          START])])\nout2 = widgets.interactive_output(main_callback2, {'Aw':Aw, 'Bw':Bw, 'X0w':X0w, 'K':Kw, 'L':Lw,\n                                                 'eig1c':eig1c, 'eig2c':eig2c, 'eig3c':eig3c, 'eig1o':eig1o, 'eig2o':eig2o, 'eig3o':eig3o, \n                                                 'u':u, 'period':period, 'selm':selm, 'sele':sele, 'selu':selu, 'DW':DW})\nout2.layout.height = '1120px'\ndisplay(out2, alltogether2)"
  },
  {
    "objectID": "ICCT_en/examples/04/SS-32-State_feedback_control-tracking_specifications.html",
    "href": "ICCT_en/examples/04/SS-32-State_feedback_control-tracking_specifications.html",
    "title": "State feedback control - Tracking specification",
    "section": "",
    "text": "# Erasmus+ ICCT project (2018-1-SI01-KA203-047081)\n\n# Toggle cell visibility\n\nfrom IPython.display import HTML\ntag = HTML('''&lt;script&gt;\ncode_show=true; \nfunction code_toggle() {\n    if (code_show){\n        $('div.input').hide()\n    } else {\n        $('div.input').show()\n    }\n    code_show = !code_show\n} \n$( document ).ready(code_toggle);\n&lt;/script&gt;\nToggle cell visibility &lt;a href=\"javascript:code_toggle()\"&gt;here&lt;/a&gt;.''')\ndisplay(tag)\n\n# Hide the code completely\n\n# from IPython.display import HTML\n# tag = HTML('''&lt;style&gt;\n# div.input {\n#     display:none;\n# }\n# &lt;/style&gt;''')\n# display(tag)\n\n\nToggle cell visibility here.\n\n\nGiven the system described by the equation:\n\\[\n\\dot{x}=\\underbrace{\\begin{bmatrix}-3&4\\\\0&2\\end{bmatrix}}_{A}x+\\underbrace{\\begin{bmatrix}0\\\\1\\end{bmatrix}}_{B}u,\n\\]\nit is required that the first state tracks a sinusoidal reference with a frequency equal to 6 rad/s (\\(\\approx 1\\) Hz), with practically zero error in amplitude.\nIn the first step an integrator is added (using a fictitious state as explained in the example State feedback control - Performance by verifying that the augmented system still remains controllable, in order to have a closed-loop transfer function from the reference to \\(x_1\\) that starts from 0 dB. The resulting augmented system is therefore:\n\\[\n\\dot{x}_a=\\underbrace{\\begin{bmatrix}-3&4&0\\\\0&2&0\\\\1&0&0\\end{bmatrix}}_{A_a}x_a+\\underbrace{\\begin{bmatrix}0\\\\1\\\\0\\end{bmatrix}}_{B_a}u+\\underbrace{\\begin{bmatrix}0\\\\0\\\\-1\\end{bmatrix}}_{B_{\\text{ref}}}x_{1r}\\,.\n\\]\nTo solve the performance specification, it is helpful to think at the shape of the transfer function that would ensure the required behaviour, that is 0 dB from \\(\\omega=0\\) to, at least, \\(\\omega=6\\) rad/s and 0 deg phase in the same interval of frequencies. Having this shape in mind, the solution of the problem, taking into account the effect of the poles in the frequencies before them, is simple - it is enough to make pole placement at frequencies higher than 65 rad/s.\nThe chosen poles are thus \\(\\lambda_{1,2,3}= 65\\) rad/s with the gain matrix \\(K_a = \\begin{bmatrix}3024.75&194&68656.25\\end{bmatrix}^T\\). The controlled system results:\n\\[\n\\dot{x}_a=\\underbrace{\\begin{bmatrix}-3&4&0\\\\-3024.75&-192&-68656.25\\\\1&0&0\\end{bmatrix}}_{A_a-B_aK_a}x_a+\\underbrace{\\begin{bmatrix}0\\\\1\\\\0\\end{bmatrix}}_{B_a}v+\\underbrace{\\begin{bmatrix}0\\\\0\\\\-1\\end{bmatrix}}_{B_{\\text{ref}}}x_{1r}\n\\]\nand the simulation is shown below with the Bode plot of the transfer function from the reference \\(x_{1r}\\) to the state \\(x_1\\).\n\nHow to use this notebook?\nIt can be interesting to try to reach zero error also for the phase part of the signal. How far the poles need to be placed?\n\n%matplotlib inline\nimport control as control\nimport numpy\nimport sympy as sym\nfrom IPython.display import display, Markdown\nimport ipywidgets as widgets\nimport matplotlib.pyplot as plt\n\n\n#print a matrix latex-like\ndef bmatrix(a):\n     \"\"\"Returns a LaTeX bmatrix - by Damir Arbula (ICCT project)\n\n     :a: numpy array\n     :returns: LaTeX bmatrix as a string\n     \"\"\"\n     if len(a.shape) &gt; 2:\n         raise ValueError('bmatrix can at most display two dimensions')\n     lines = str(a).replace('[', '').replace(']', '').splitlines()\n     rv = [r'\\begin{bmatrix}']\n     rv += ['  ' + ' & '.join(l.split()) + r'\\\\' for l in lines]\n     rv +=  [r'\\end{bmatrix}']\n     return '\\n'.join(rv)\n\n\n# Display formatted matrix: \ndef vmatrix(a):\n    if len(a.shape) &gt; 2:\n         raise ValueError('bmatrix can at most display two dimensions')\n    lines = str(a).replace('[', '').replace(']', '').splitlines()\n    rv = [r'\\begin{vmatrix}']\n    rv += ['  ' + ' & '.join(l.split()) + r'\\\\' for l in lines]\n    rv +=  [r'\\end{vmatrix}']\n    return '\\n'.join(rv)\n\n\n#matrixWidget is a matrix looking widget built with a VBox of HBox(es) that returns a numPy array as value !\nclass matrixWidget(widgets.VBox):\n    def updateM(self,change):\n        for irow in range(0,self.n):\n            for icol in range(0,self.m):\n                self.M_[irow,icol] = self.children[irow].children[icol].value\n                #print(self.M_[irow,icol])\n        self.value = self.M_\n\n    def dummychangecallback(self,change):\n        pass\n    \n    \n    def __init__(self,n,m):\n        self.n = n\n        self.m = m\n        self.M_ = numpy.matrix(numpy.zeros((self.n,self.m)))\n        self.value = self.M_\n        widgets.VBox.__init__(self,\n                             children = [\n                                 widgets.HBox(children = \n                                              [widgets.FloatText(value=0.0, layout=widgets.Layout(width='90px')) for i in range(m)]\n                                             ) \n                                 for j in range(n)\n                             ])\n        \n        #fill in widgets and tell interact to call updateM each time a children changes value\n        for irow in range(0,self.n):\n            for icol in range(0,self.m):\n                self.children[irow].children[icol].value = self.M_[irow,icol]\n                self.children[irow].children[icol].observe(self.updateM, names='value')\n        #value = Unicode('example@example.com', help=\"The email value.\").tag(sync=True)\n        self.observe(self.updateM, names='value', type= 'All')\n        \n    def setM(self, newM):\n        #disable callbacks, change values, and reenable\n        self.unobserve(self.updateM, names='value', type= 'All')\n        for irow in range(0,self.n):\n            for icol in range(0,self.m):\n                self.children[irow].children[icol].unobserve(self.updateM, names='value')\n        self.M_ = newM\n        self.value = self.M_\n        for irow in range(0,self.n):\n            for icol in range(0,self.m):\n                self.children[irow].children[icol].value = self.M_[irow,icol]\n        for irow in range(0,self.n):\n            for icol in range(0,self.m):\n                self.children[irow].children[icol].observe(self.updateM, names='value')\n        self.observe(self.updateM, names='value', type= 'All')        \n\n                #self.children[irow].children[icol].observe(self.updateM, names='value')\n\n             \n#overlaod class for state space systems that DO NOT remove \"useless\" states (what \"professor\" of automatic control would do this?)\nclass sss(control.StateSpace):\n    def __init__(self,*args):\n        #call base class init constructor\n        control.StateSpace.__init__(self,*args)\n    #disable function below in base class\n    def _remove_useless_states(self):\n        pass\n\n\n# Preparatory cell\n\nA = numpy.matrix('-3 4 0; 0 2 0; 1 0 0')\nB = numpy.matrix('0; 1; 0')\nBr = numpy.matrix('0; 0; -1')\nC = numpy.matrix('1 0 0')\nX0 = numpy.matrix('0; 0; 0')\nK = numpy.matrix([842.25,104,10718.75])\n\nAw = matrixWidget(3,3)\nAw.setM(A)\nBw = matrixWidget(3,1)\nBw.setM(B)\nBrw = matrixWidget(3,1)\nBrw.setM(Br)\nCw = matrixWidget(1,3)\nCw.setM(C)\nX0w = matrixWidget(3,1)\nX0w.setM(X0)\nKw = matrixWidget(1,3)\nKw.setM(K)\n\n\neig1c = matrixWidget(1,1)\neig2c = matrixWidget(2,1)\neig3c = matrixWidget(1,1)\neig1c.setM(numpy.matrix([-65])) \neig2c.setM(numpy.matrix([[-65],[0]]))\neig3c.setM(numpy.matrix([-65]))\n\n\n# Misc\n\n#create dummy widget \nDW = widgets.FloatText(layout=widgets.Layout(width='0px', height='0px'))\n\n#create button widget\nSTART = widgets.Button(\n    description='Test',\n    disabled=False,\n    button_style='', # 'success', 'info', 'warning', 'danger' or ''\n    tooltip='Test',\n    icon='check'\n)\n                       \ndef on_start_button_clicked(b):\n    #This is a workaround to have intreactive_output call the callback:\n    #   force the value of the dummy widget to change\n    if DW.value&gt; 0 :\n        DW.value = -1\n    else: \n        DW.value = 1\n    pass\nSTART.on_click(on_start_button_clicked)\n\n# Define type of method \nselm = widgets.Dropdown(\n    options= ['Set K', 'Set the eigenvalues'],\n    value= 'Set the eigenvalues',\n    description='',\n    disabled=False\n)\n\n# Define the number of complex eigenvalues for the observer\nselc = widgets.Dropdown(\n    options= ['0 complex eigenvalues', '2 complex eigenvalues'],\n    value= '0 complex eigenvalues',\n    description='Eigenvalues:',\n    disabled=False\n)\n\n#define type of ipout \nselu = widgets.Dropdown(\n    options=['impulse', 'step', 'sinusoid', 'square wave'],\n    value='sinusoid',\n    description='Type of reference:',\n    disabled=False,\n    style = {'description_width': 'initial'}\n)\n# Define the values of the input\nu = widgets.FloatSlider(\n    value=1,\n    min=0,\n    max=20.0,\n    step=0.1,\n    description='Reference:',\n    disabled=False,\n    continuous_update=False,\n    orientation='horizontal',\n    readout=True,\n    readout_format='.1f',\n)\nperiod = widgets.FloatSlider(\n    value=1,\n    min=0.01,\n    max=4,\n    step=0.01,\n    description='Period: ',\n    disabled=False,\n    continuous_update=False,\n    orientation='horizontal',\n    readout=True,\n    readout_format='.2f',\n)\n\n\n# Support functions\n\ndef eigen_choice(selc):\n    if selc == '0 complex eigenvalues':\n        eig1c.children[0].children[0].disabled = False\n        eig2c.children[1].children[0].disabled = True\n        eigc = 0\n    if selc == '2 complex eigenvalues':\n        eig1c.children[0].children[0].disabled = True\n        eig2c.children[1].children[0].disabled = False\n        eigc = 2\n    return eigc\n\ndef method_choice(selm):\n    if selm == 'Set K':\n        method = 1\n        selc.disabled = True\n    if selm == 'Set the eigenvalues':\n        method = 2\n        selc.disabled = False\n    return method\n\n\ndef main_callback(Aw, Bw, Brw, X0w, K, eig1c, eig2c, eig3c, u, period, selm, selc, selu, DW):\n    A, B, Br = Aw, Bw, Brw \n    sols = numpy.linalg.eig(A)\n    eigc = eigen_choice(selc)\n    method = method_choice(selm)\n    \n    if method == 1:\n        sol = numpy.linalg.eig(A-B*K)\n    if method == 2:\n        if eigc == 0:\n            K = control.acker(A, B, [eig1c[0,0], eig2c[0,0], eig3c[0,0]])\n            Kw.setM(K) \n        if eigc == 2:\n            K = control.acker(A, B, [eig1c[0,0], \n                                      numpy.complex(eig2c[0,0],eig2c[1,0]), \n                                      numpy.complex(eig2c[0,0],-eig2c[1,0])])\n            Kw.setM(K)\n        sol = numpy.linalg.eig(A-B*K)\n    print('The system\\'s eigenvalues are:',round(sols[0][0],4),',',round(sols[0][1],4),'and',round(sols[0][2],4))\n    print('The controlled system\\'s eigenvalues are:',round(sol[0][0],4),',',round(sol[0][1],4),'and',round(sol[0][2],4))\n    \n    sys = sss(A-B*K,Br,C,0)\n    T = numpy.linspace(0, 6, 1000)\n      \n    if selu == 'impulse': #selu\n        U = [0 for t in range(0,len(T))]\n        U[0] = u\n        T, yout, xout = control.forced_response(sys,T,U,X0w)\n    if selu == 'step':\n        U = [u for t in range(0,len(T))]\n        T, yout, xout = control.forced_response(sys,T,U,X0w)\n    if selu == 'sinusoid':\n        U = u*numpy.sin(2*numpy.pi/period*T)\n        T, yout, xout = control.forced_response(sys,T,U,X0w)\n    if selu == 'square wave':\n        U = u*numpy.sign(numpy.sin(2*numpy.pi/period*T))\n        T, yout, xout = control.forced_response(sys,T,U,X0w)\n    \n    fig = plt.figure(num='Bode plot', figsize=(16,10))\n    control.bode_plot(sys)\n    fig.suptitle('Bode plot', fontsize=16)\n    \n    plt.figure(num='Simulation', figsize=(16,4))\n    plt.title('First state input response')\n    plt.ylabel('$X_1$ vs ref')\n    plt.plot(T,xout[0],T,U,'r--')\n    plt.xlabel('$t$ [s]')\n    plt.legend(['$x_1$','Reference'])\n    plt.axvline(x=0,color='black',linewidth=0.8)\n    plt.axhline(y=0,color='black',linewidth=0.8)\n    plt.grid()\n\n    \nalltogether = widgets.VBox([widgets.HBox([selm, \n                                          selc, \n                                          selu]),\n                            widgets.Label(' ',border=3),\n                            widgets.HBox([widgets.Label('K:',border=3), Kw, \n                                          widgets.Label(' ',border=3),\n                                          widgets.Label(' ',border=3),\n                                          widgets.Label('Eigenvalues:',border=3), \n                                          eig1c, \n                                          eig2c, \n                                          eig3c,\n                                          widgets.Label(' ',border=3),\n                                          widgets.Label(' ',border=3),\n                                          widgets.Label('X0:',border=3), X0w]),\n                            widgets.Label(' ',border=3),\n                            widgets.HBox([u, \n                                          period, \n                                          START]),\n                            widgets.Label(' ',border=3),\n                            widgets.HBox([widgets.Label('Dynamics matrix Aa:',border=3),\n                                          Aw,\n                                          widgets.Label('Input matrix Ba:',border=3),\n                                          Bw,\n                                          widgets.Label('Reference matrix Br:',border=3),\n                                          Brw])])\nout = widgets.interactive_output(main_callback, {'Aw':Aw, 'Bw':Bw, 'Brw':Brw, 'X0w':X0w, 'K':Kw, 'eig1c':eig1c, 'eig2c':eig2c, 'eig3c':eig3c, \n                                                 'u':u, 'period':period, 'selm':selm, 'selc':selc, 'selu':selu, 'DW':DW})\nout.layout.height = '1050px'\ndisplay(out, alltogether)"
  },
  {
    "objectID": "ICCT_en/examples/04/SS-30-State_feedback_control.html",
    "href": "ICCT_en/examples/04/SS-30-State_feedback_control.html",
    "title": "State feedback control",
    "section": "",
    "text": "# Erasmus+ ICCT project (2018-1-SI01-KA203-047081)\n\n# Toggle cell visibility\n\nfrom IPython.display import HTML\ntag = HTML('''&lt;script&gt;\ncode_show=true; \nfunction code_toggle() {\n    if (code_show){\n        $('div.input').hide()\n    } else {\n        $('div.input').show()\n    }\n    code_show = !code_show\n} \n$( document ).ready(code_toggle);\n&lt;/script&gt;\nToggle cell visibility &lt;a href=\"javascript:code_toggle()\"&gt;here&lt;/a&gt;.''')\ndisplay(tag)\n\n# Hide the code completely\n\n# from IPython.display import HTML\n# tag = HTML('''&lt;style&gt;\n# div.input {\n#     display:none;\n# }\n# &lt;/style&gt;''')\n# display(tag)\n\n\nToggle cell visibility here.\n\n\nThis example shows the effect of full state feedback.\nGiven the linear time invariant system:\n\\[\\begin{cases}\n\\dot{\\textbf{x}}=A\\textbf{x}+B\\textbf{u} \\\\\n\\textbf{y}=C\\textbf{x},\n\\end{cases}\\]\nand the control law:\n\\(\\textbf{u}=-K\\textbf{x}+\\textbf{v},\\)\nthis example shows the free and forced responses of the close loop system:\n\\[\n\\dot{\\textbf{x}}=A\\textbf{x}-BK\\textbf{x}+B\\textbf{v} = (A-BK)\\textbf{x}+B\\textbf{v}.\n\\]\n\nHow to use this notebook?\nTry to change the values of \\(K\\) or directly set the eigenvalues of \\((A-BK)\\) and get the corresponding controller gains: - Create an unstable system and make it stable with full state feedback. - Create a system with a slow response and make it faster with full state feedback. - Create a system that is not fully controllable try to change all its eigenvalues in closed loop. Is it possible to achieve that? - Create a system that is not fully controllable and unstable and try to make it stable with full state feedback. Can you tell in which cases it is possible to stabilize it with closed-loop control?\n\n%matplotlib inline\nimport control as control\nimport numpy\nimport sympy as sym\nfrom IPython.display import display, Markdown\nimport ipywidgets as widgets\nimport matplotlib.pyplot as plt\n\n\n#print a matrix latex-like\ndef bmatrix(a):\n     \"\"\"Returns a LaTeX bmatrix - by Damir Arbula (ICCT project)\n\n     :a: numpy array\n     :returns: LaTeX bmatrix as a string\n     \"\"\"\n     if len(a.shape) &gt; 2:\n         raise ValueError('bmatrix can at most display two dimensions')\n     lines = str(a).replace('[', '').replace(']', '').splitlines()\n     rv = [r'\\begin{bmatrix}']\n     rv += ['  ' + ' & '.join(l.split()) + r'\\\\' for l in lines]\n     rv +=  [r'\\end{bmatrix}']\n     return '\\n'.join(rv)\n\n\n# Display formatted matrix: \ndef vmatrix(a):\n    if len(a.shape) &gt; 2:\n         raise ValueError('bmatrix can at most display two dimensions')\n    lines = str(a).replace('[', '').replace(']', '').splitlines()\n    rv = [r'\\begin{vmatrix}']\n    rv += ['  ' + ' & '.join(l.split()) + r'\\\\' for l in lines]\n    rv +=  [r'\\end{vmatrix}']\n    return '\\n'.join(rv)\n\n\n#matrixWidget is a matrix looking widget built with a VBox of HBox(es) that returns a numPy array as value !\nclass matrixWidget(widgets.VBox):\n    def updateM(self,change):\n        for irow in range(0,self.n):\n            for icol in range(0,self.m):\n                self.M_[irow,icol] = self.children[irow].children[icol].value\n                #print(self.M_[irow,icol])\n        self.value = self.M_\n\n    def dummychangecallback(self,change):\n        pass\n    \n    \n    def __init__(self,n,m):\n        self.n = n\n        self.m = m\n        self.M_ = numpy.matrix(numpy.zeros((self.n,self.m)))\n        self.value = self.M_\n        widgets.VBox.__init__(self,\n                             children = [\n                                 widgets.HBox(children = \n                                              [widgets.FloatText(value=0.0, layout=widgets.Layout(width='90px')) for i in range(m)]\n                                             ) \n                                 for j in range(n)\n                             ])\n        \n        #fill in widgets and tell interact to call updateM each time a children changes value\n        for irow in range(0,self.n):\n            for icol in range(0,self.m):\n                self.children[irow].children[icol].value = self.M_[irow,icol]\n                self.children[irow].children[icol].observe(self.updateM, names='value')\n        #value = Unicode('example@example.com', help=\"The email value.\").tag(sync=True)\n        self.observe(self.updateM, names='value', type= 'All')\n        \n    def setM(self, newM):\n        #disable callbacks, change values, and reenable\n        self.unobserve(self.updateM, names='value', type= 'All')\n        for irow in range(0,self.n):\n            for icol in range(0,self.m):\n                self.children[irow].children[icol].unobserve(self.updateM, names='value')\n        self.M_ = newM\n        self.value = self.M_\n        for irow in range(0,self.n):\n            for icol in range(0,self.m):\n                self.children[irow].children[icol].value = self.M_[irow,icol]\n        for irow in range(0,self.n):\n            for icol in range(0,self.m):\n                self.children[irow].children[icol].observe(self.updateM, names='value')\n        self.observe(self.updateM, names='value', type= 'All')        \n\n                #self.children[irow].children[icol].observe(self.updateM, names='value')\n\n             \n#overlaod class for state space systems that DO NOT remove \"useless\" states (what \"professor\" of automatic control would do this?)\nclass sss(control.StateSpace):\n    def __init__(self,*args):\n        #call base class init constructor\n        control.StateSpace.__init__(self,*args)\n    #disable function below in base class\n    def _remove_useless_states(self):\n        pass\n\n\n# Preparatory cell\n\nA = numpy.matrix('0 1 0; 0 0 1; 0 2 -3')\nB = numpy.matrix('0; 0; 1')\nC = numpy.matrix('1 0 0; 0 1 0; 0 0 1')\nX0 = numpy.matrix('2; 2; 2')\nK = numpy.matrix([8,14,3])\nsol1 = numpy.linalg.eig(A)\n\nAw = matrixWidget(3,3)\nAw.setM(A)\nBw = matrixWidget(3,1)\nBw.setM(B)\nCw = matrixWidget(3,3)\nCw.setM(C)\nX0w = matrixWidget(3,1)\nX0w.setM(X0)\nKw = matrixWidget(1,3)\nKw.setM(K)\n\n\neig1c = matrixWidget(1,1)\neig2c = matrixWidget(2,1)\neig3c = matrixWidget(1,1)\neig1c.setM(numpy.matrix([-2])) \neig2c.setM(numpy.matrix([[-2],[0]]))\neig3c.setM(numpy.matrix([-2]))\n\n\n# Misc\n\n#create dummy widget \nDW = widgets.FloatText(layout=widgets.Layout(width='0px', height='0px'))\n\n#create button widget\nSTART = widgets.Button(\n    description='Test',\n    disabled=False,\n    button_style='', # 'success', 'info', 'warning', 'danger' or ''\n    tooltip='Test',\n    icon='check'\n)\n                       \ndef on_start_button_clicked(b):\n    #This is a workaround to have intreactive_output call the callback:\n    #   force the value of the dummy widget to change\n    if DW.value&gt; 0 :\n        DW.value = -1\n    else: \n        DW.value = 1\n    pass\nSTART.on_click(on_start_button_clicked)\n\n# Define type of method \nselm = widgets.Dropdown(\n    options= ['Set K', 'Set the eigenvalues'],\n    value= 'Set K',\n    description='',\n    disabled=False\n)\n\n# Define the number of complex eigenvalues for the observer\nselc = widgets.Dropdown(\n    options= ['0 complex eigenvalues', '2 complex eigenvalues'],\n    value= '0 complex eigenvalues',\n    description='Eigenvalues:',\n    disabled=False\n)\n\n#define type of ipout \nselu = widgets.Dropdown(\n    options=['impulse', 'step', 'sinusoid', 'square wave'],\n    value='impulse',\n    description='Type of input:',\n    disabled=False\n)\n# Define the values of the input\nu = widgets.FloatSlider(\n    value=1,\n    min=0,\n    max=20.0,\n    step=0.1,\n    description='input u:',\n    disabled=False,\n    continuous_update=False,\n    orientation='horizontal',\n    readout=True,\n    readout_format='.1f',\n)\nperiod = widgets.FloatSlider(\n    value=0.5,\n    min=0.05,\n    max=1,\n    step=0.05,\n    description='Period: ',\n    disabled=False,\n    continuous_update=False,\n    orientation='horizontal',\n    readout=True,\n    readout_format='.2f',\n)\n\n\n# Support functions\n\ndef eigen_choice(selc):\n    if selc == '0 complex eigenvalues':\n        eig1c.children[0].children[0].disabled = False\n        eig2c.children[1].children[0].disabled = True\n        eigc = 0\n    if selc == '2 complex eigenvalues':\n        eig1c.children[0].children[0].disabled = True\n        eig2c.children[1].children[0].disabled = False\n        eigc = 2\n    return eigc\n\ndef method_choice(selm):\n    if selm == 'Set K':\n        method = 1\n        selc.disabled = True\n    if selm == 'Set the eigenvalues':\n        method = 2\n        selc.disabled = False\n    return method\n\n\ndef main_callback(Aw, Bw, X0w, K, eig1c, eig2c, eig3c, u, period, selm, selc, selu, DW):\n    A, B = Aw, Bw\n    sols = numpy.linalg.eig(A)\n    eigc = eigen_choice(selc)\n    method = method_choice(selm)\n    \n    if method == 1:\n        sol = numpy.linalg.eig(A-B*K)\n    if method == 2:\n        if eigc == 0:\n            K = control.acker(A, B, [eig1c[0,0], eig2c[0,0], eig3c[0,0]])\n            Kw.setM(K) \n        if eigc == 2:\n            K = control.acker(A, B, [eig1c[0,0], \n                                      numpy.complex(eig2c[0,0],eig2c[1,0]), \n                                      numpy.complex(eig2c[0,0],-eig2c[1,0])])\n            Kw.setM(K)\n        sol = numpy.linalg.eig(A-B*K)\n    print('The system\\'s eigenvalues are:',round(sols[0][0],4),',',round(sols[0][1],4),'and',round(sols[0][2],4))\n    print('The controlled system\\'s eigenvalues are:',round(sol[0][0],4),',',round(sol[0][1],4),'and',round(sol[0][2],4))\n    \n    sys = sss(A,B,C,sym.zeros(3,1))\n    sysc = sss(A-B*K, B, numpy.eye(3), numpy.zeros(3).reshape((3,1)))\n    T = numpy.linspace(0, 6, 1000)\n      \n    if selu == 'impulse': #selu\n        U = [0 for t in range(0,len(T))]\n        U[0] = u\n        T, yout, xout = control.forced_response(sys,T,U,X0w)\n        T, youtc, xoutc = control.forced_response(sysc,T,U,X0w)\n    if selu == 'step':\n        U = [u for t in range(0,len(T))]\n        T, yout, xout = control.forced_response(sys,T,U,X0w)\n        T, youtc, xoutc = control.forced_response(sysc,T,U,X0w)\n    if selu == 'sinusoid':\n        U = u*numpy.sin(2*numpy.pi/period*T)\n        T, yout, xout = control.forced_response(sys,T,U,X0w)\n        T, youtc, xoutc = control.forced_response(sysc,T,U,X0w)\n    if selu == 'square wave':\n        U = u*numpy.sign(numpy.sin(2*numpy.pi/period*T))\n        T, yout, xout = control.forced_response(sys,T,U,X0w)\n        T, youtc, xoutc = control.forced_response(sysc,T,U,X0w)\n    \n    fig = plt.figure(num='Simulation', figsize=(16,10))\n    \n    fig.add_subplot(311)\n    plt.ylabel('$X_1$ vs $X_{1f}$')\n    plt.plot(T,xout[0])\n    plt.plot(T,xoutc[0])\n    plt.xlabel('time [s]')\n    plt.legend(['Open Loop','State Feedback'])\n    plt.axvline(x=0,color='black',linewidth=0.8)\n    plt.axhline(y=0,color='black',linewidth=0.8)\n    plt.grid()\n    \n    fig.add_subplot(312)\n    plt.ylabel('$X_2$ vs $X_{2f}$')\n    plt.plot(T,xout[1])\n    plt.plot(T,xoutc[1])\n    plt.xlabel('time [s]')\n    plt.legend(['Open Loop','State Feedback'])\n    plt.axvline(x=0,color='black',linewidth=0.8)\n    plt.axhline(y=0,color='black',linewidth=0.8)\n    plt.grid()\n    \n    fig.add_subplot(313)\n    plt.ylabel('$X_3$ vs $X_{3f}$')\n    plt.plot(T,xout[2])\n    plt.plot(T,xoutc[2])\n    plt.xlabel('time [s]')\n    plt.legend(['Open Loop','State Feedback'])\n    plt.axvline(x=0,color='black',linewidth=0.8)\n    plt.axhline(y=0,color='black',linewidth=0.8)\n    plt.grid()\n    \nalltogether = widgets.VBox([widgets.HBox([selm, \n                                          selc, \n                                          selu]),\n                            widgets.Label(' ',border=3),\n                            widgets.HBox([widgets.Label('K:',border=3), Kw, \n                                          widgets.Label(' ',border=3),\n                                          widgets.Label(' ',border=3),\n                                          widgets.Label('Eigenvalues:',border=3), \n                                          eig1c, \n                                          eig2c, \n                                          eig3c,\n                                          widgets.Label(' ',border=3),\n                                          widgets.Label(' ',border=3),\n                                          widgets.Label('X0:',border=3), X0w]),\n                            widgets.Label(' ',border=3),\n                            widgets.HBox([u, \n                                          period, \n                                          START]),\n                            widgets.Label(' ',border=3),\n                            widgets.HBox([widgets.Label('Dynamics matrix A:',border=3),\n                                          Aw,\n                                          widgets.Label('Input matrix B:',border=3),\n                                          Bw])])\nout = widgets.interactive_output(main_callback, {'Aw':Aw, 'Bw':Bw, 'X0w':X0w, 'K':Kw, 'eig1c':eig1c, 'eig2c':eig2c, 'eig3c':eig3c, \n                                                 'u':u, 'period':period, 'selm':selm, 'selc':selc, 'selu':selu, 'DW':DW})\nout.layout.height = '680px'\ndisplay(out, alltogether)"
  },
  {
    "objectID": "ICCT_en/examples/04/SS-28-Observer_for_the_mass-spring-damper_system.html",
    "href": "ICCT_en/examples/04/SS-28-Observer_for_the_mass-spring-damper_system.html",
    "title": "Building an observer for the mass-spring-damper system",
    "section": "",
    "text": "# Erasmus+ ICCT project (2018-1-SI01-KA203-047081)\n\n# Toggle cell visibility\n\nfrom IPython.display import HTML\ntag = HTML('''&lt;script&gt;\ncode_show=true; \nfunction code_toggle() {\n    if (code_show){\n        $('div.input').hide()\n    } else {\n        $('div.input').show()\n    }\n    code_show = !code_show\n} \n$( document ).ready(code_toggle);\n&lt;/script&gt;\nToggle cell visibility &lt;a href=\"javascript:code_toggle()\"&gt;here&lt;/a&gt;.''')\ndisplay(tag)\n\n# Hide the code completely\n\n# from IPython.display import HTML\n# tag = HTML('''&lt;style&gt;\n# div.input {\n#     display:none;\n# }\n# &lt;/style&gt;''')\n# display(tag)\n\n\nToggle cell visibility here.\n\n\nThis example shows how to develop an observer for the mass-spring-damper system. The equations in state space form (see example Modal Analysis of Mass-Spring-Damper System for more details) are:\n\\[\\begin{cases}\n\\begin{bmatrix}\n\\dot{x_1} \\\\\n\\dot{x_2}\n\\end{bmatrix}=\\underbrace{\\begin{bmatrix}\n0 && 1 \\\\\n-\\frac{k}{m} && -\\frac{c}{m}\n\\end{bmatrix}}_{A}\\begin{bmatrix}\nx_1 \\\\\nx_2\n\\end{bmatrix}+\\underbrace{\\begin{bmatrix}\n0 \\\\\n\\frac{1}{m}\n\\end{bmatrix}}_{B}u \\\\\ny = \\underbrace{\\begin{bmatrix}1&0\\end{bmatrix}}_{C}\\begin{bmatrix}\nx_1 \\\\\nx_2\n\\end{bmatrix}\n\\end{cases}\\]\nwith \\(m=1\\,\\)kg, \\(k=2\\,\\)N/m and \\(c=1\\,\\)Ns/m. The corresponding eigenvalues are \\(\\lambda_{1,2} = -\\frac{c}{2m} \\pm \\frac{\\sqrt{c^2 - 4km}}{2m} = -\\frac{1}{2} \\pm i\\frac{\\sqrt{7}}{2}\\).\nThe observability matrix has full rank and is equal to: \\[\n\\begin{bmatrix}C\\\\CA\\end{bmatrix} = \\begin{bmatrix}1&0\\\\0&1\\end{bmatrix},\n\\] so the system is observable and it is possible to develop a state observer. In order to have a convergence of the estimate in a reasonable time, it is convenient to set the error dynamics faster or at least equal to 10 times the dynamics of the system. The selected eigenvalues are \\(\\lambda_{\\text{err} 1,2}=-10\\sqrt{\\left(\\frac{1}{2}\\right)^2+\\left(\\frac{\\sqrt{7}}{2}\\right)^2}=-10\\sqrt{2}\\).\nThe observer structure is equal to:\n\\[\n\\dot{\\hat{\\textbf{x}}}=A\\hat{\\textbf{x}}+B\\textbf{u}+L\\textbf{y},\n\\]\nwith the matrix \\(L\\) defined as \\(L = \\begin{bmatrix}l_1&l_2\\end{bmatrix}^T\\). The necessary values to have the proper convergence (of \\(\\dot{\\textbf{e}}=(A-LC)\\textbf{e}\\)) are thus:\n\\[\\begin{cases}\nl_1 = -c/m + 20\\sqrt{2} = -1+20\\sqrt{2}\\\\\nl_2 = \\frac{c^2}{m^2} - 20\\sqrt{2}\\frac{c}{m} - \\frac{k}{m} + 200 = 197-20\\sqrt{2}\n\\end{cases}\\]\nobtained by imposing \\(\\text{det}(\\lambda I_{2\\text{x}2}-A+LC) = \\left(\\lambda+10\\sqrt{2}\\right)^2\\).\n\nHow to use this notebook?\nThe developed observer is simulated below and the interactive interface allows to change all the values and display the behaviour changes.\n\n%matplotlib inline\nimport control as control\nimport numpy\nimport sympy as sym\nfrom IPython.display import display, Markdown\nimport ipywidgets as widgets\nimport matplotlib.pyplot as plt\n\n\n#print a matrix latex-like\ndef bmatrix(a):\n     \"\"\"Returns a LaTeX bmatrix - by Damir Arbula (ICCT project)\n\n     :a: numpy array\n     :returns: LaTeX bmatrix as a string\n     \"\"\"\n     if len(a.shape) &gt; 2:\n         raise ValueError('bmatrix can at most display two dimensions')\n     lines = str(a).replace('[', '').replace(']', '').splitlines()\n     rv = [r'\\begin{bmatrix}']\n     rv += ['  ' + ' & '.join(l.split()) + r'\\\\' for l in lines]\n     rv +=  [r'\\end{bmatrix}']\n     return '\\n'.join(rv)\n\n\n# Display formatted matrix: \ndef vmatrix(a):\n    if len(a.shape) &gt; 2:\n         raise ValueError('bmatrix can at most display two dimensions')\n    lines = str(a).replace('[', '').replace(']', '').splitlines()\n    rv = [r'\\begin{vmatrix}']\n    rv += ['  ' + ' & '.join(l.split()) + r'\\\\' for l in lines]\n    rv +=  [r'\\end{vmatrix}']\n    return '\\n'.join(rv)\n\n\n#matrixWidget is a matrix looking widget built with a VBox of HBox(es) that returns a numPy array as value !\nclass matrixWidget(widgets.VBox):\n    def updateM(self,change):\n        for irow in range(0,self.n):\n            for icol in range(0,self.m):\n                self.M_[irow,icol] = self.children[irow].children[icol].value\n                #print(self.M_[irow,icol])\n        self.value = self.M_\n\n    def dummychangecallback(self,change):\n        pass\n    \n    \n    def __init__(self,n,m):\n        self.n = n\n        self.m = m\n        self.M_ = numpy.matrix(numpy.zeros((self.n,self.m)))\n        self.value = self.M_\n        widgets.VBox.__init__(self,\n                             children = [\n                                 widgets.HBox(children = \n                                              [widgets.FloatText(value=0.0, layout=widgets.Layout(width='90px')) for i in range(m)]\n                                             ) \n                                 for j in range(n)\n                             ])\n        \n        #fill in widgets and tell interact to call updateM each time a children changes value\n        for irow in range(0,self.n):\n            for icol in range(0,self.m):\n                self.children[irow].children[icol].value = self.M_[irow,icol]\n                self.children[irow].children[icol].observe(self.updateM, names='value')\n        #value = Unicode('example@example.com', help=\"The email value.\").tag(sync=True)\n        self.observe(self.updateM, names='value', type= 'All')\n        \n    def setM(self, newM):\n        #disable callbacks, change values, and reenable\n        self.unobserve(self.updateM, names='value', type= 'All')\n        for irow in range(0,self.n):\n            for icol in range(0,self.m):\n                self.children[irow].children[icol].unobserve(self.updateM, names='value')\n        self.M_ = newM\n        self.value = self.M_\n        for irow in range(0,self.n):\n            for icol in range(0,self.m):\n                self.children[irow].children[icol].value = self.M_[irow,icol]\n        for irow in range(0,self.n):\n            for icol in range(0,self.m):\n                self.children[irow].children[icol].observe(self.updateM, names='value')\n        self.observe(self.updateM, names='value', type= 'All')        \n\n                #self.children[irow].children[icol].observe(self.updateM, names='value')\n\n             \n#overlaod class for state space systems that DO NOT remove \"useless\" states (what \"professor\" of automatic control would do this?)\nclass sss(control.StateSpace):\n    def __init__(self,*args):\n        #call base class init constructor\n        control.StateSpace.__init__(self,*args)\n    #disable function below in base class\n    def _remove_useless_states(self):\n        pass\n\n\n# Preparatory cell\n\nA = numpy.matrix('0 1; -2 -1')\nB = numpy.matrix('0; 1')\nC = numpy.matrix('1 0')\nX0 = numpy.matrix('2; 2')\nL = numpy.matrix([[-1+20*numpy.sqrt(2)],[197-20*numpy.sqrt(2)]])\nsol1 = numpy.linalg.eig(A)\n\nAw = matrixWidget(2,2)\nAw.setM(A)\nBw = matrixWidget(2,1)\nBw.setM(B)\nCw = matrixWidget(1,2)\nCw.setM(C)\nX0w = matrixWidget(2,1)\nX0w.setM(X0)\nLw = matrixWidget(2,1)\nLw.setM(L)\n\n\neig1o = matrixWidget(1,1)\neig2o = matrixWidget(2,1)\neig1o.setM(numpy.matrix([-10*numpy.sqrt(2)])) \neig2o.setM(numpy.matrix([[-10*numpy.sqrt(2)],[0]]))\n\n\n# Interactive widgets\n\nm = widgets.FloatSlider(\n    value=1,\n    min=0.1,\n    max=10.0,\n    step=0.1,\n    description='m [kg]:',\n    disabled=False,\n    continuous_update=False,\n    orientation='horizontal',\n    readout=True,\n    readout_format='.1f',\n)\nk = widgets.FloatSlider(\n    value=2,\n    min=0,\n    max=10.0,\n    step=0.1,\n    description='k [N/m]:',\n    disabled=False,\n    continuous_update=False,\n    orientation='horizontal',\n    readout=True,\n    readout_format='.1f',\n)\nc = widgets.FloatSlider(\n    value=1,\n    min=0,\n    max=10.0,\n    step=0.1,\n    description='c [Ns/m]:',\n    disabled=False,\n    continuous_update=False,\n    orientation='horizontal',\n    readout=True,\n    readout_format='.1f',\n)\n# Define the values of the input\nu = widgets.FloatSlider(\n    value=1,\n    min=0,\n    max=20.0,\n    step=0.1,\n    description='input u:',\n    disabled=False,\n    continuous_update=False,\n    orientation='horizontal',\n    readout=True,\n    readout_format='.1f',\n)\nperiod = widgets.FloatSlider(\n    value=0.5,\n    min=0.0,\n    max=1,\n    step=0.05,\n    description='Period: ',\n    disabled=False,\n    continuous_update=False,\n    orientation='horizontal',\n    readout=True,\n    readout_format='.2f',\n)\n\n#create dummy widget \nDW = widgets.FloatText(layout=widgets.Layout(width='0px', height='0px'))\n\n#create button widget\nSTART = widgets.Button(\n    description='Test',\n    disabled=False,\n    button_style='', # 'success', 'info', 'warning', 'danger' or ''\n    tooltip='Test',\n    icon='check'\n)\n                       \ndef on_start_button_clicked(b):\n    #This is a workaround to have intreactive_output call the callback:\n    #   force the value of the dummy widget to change\n    if DW.value&gt; 0 :\n        DW.value = -1\n    else: \n        DW.value = 1\n    pass\nSTART.on_click(on_start_button_clicked)\n\n# Define type of method \nselm = widgets.Dropdown(\n    options= ['Set L', 'Set the eigenvalues'],\n    value= 'Set L',\n    description='',\n    disabled=False\n)\n\n# Define the number of complex eigenvalues for the observer\nselo = widgets.Dropdown(\n    options= ['0 complex eigenvalues', '2 complex eigenvalues'],\n    value= '0 complex eigenvalues',\n    description='Eigenvalues:',\n    disabled=False\n)\n\n#define type of ipout \nselu = widgets.Dropdown(\n    options=['impulse', 'step', 'sinusoid', 'square wave'],\n    value='impulse',\n    description='Type of input:',\n    disabled=False\n)\n\n\n# Support functions\n\ndef eigen_choice(selo):\n    if selo == '0 complex eigenvalues':\n        eig1o.children[0].children[0].disabled = False\n        eig2o.children[1].children[0].disabled = True\n        eigo = 0\n    if selo == '2 complex eigenvalues':\n        eig1o.children[0].children[0].disabled = True\n        eig2o.children[1].children[0].disabled = False\n        eigo = 2\n    return eigo\n\ndef method_choice(selm):\n    if selm == 'Set L':\n        method = 1\n        selo.disabled = True\n    if selm == 'Set the eigenvalues':\n        method = 2\n        selo.disabled = False\n    return method\n\n\ndef main_callback(m, k, c, X0w, L, eig1o, eig2o, u, period, selm, selo, selu, DW):\n    A = numpy.matrix([[0,1],[-k/m,-c/m]])\n    eigo = eigen_choice(selo)\n    method = method_choice(selm)\n    \n    if method == 1:\n        sol = numpy.linalg.eig(A-L*C)\n    if method == 2:\n        if eigo == 0:\n            L = control.acker(A.T, C.T, [eig1o[0,0], eig2o[0,0]]).T\n            Lw.setM(L) \n        if eigo == 2:\n            L = control.acker(A.T, C.T, [numpy.complex(eig2o[0,0],eig2o[1,0]), \n                                         numpy.complex(eig2o[0,0],-eig2o[1,0])]).T\n            Lw.setM(L)\n        sol = numpy.linalg.eig(A-L*C)\n    print('The system\\'s eigenvalues are:',round(sol1[0][0],4),'and',round(sol1[0][1],4)) \n    print('The observer\\'s eigenvalues are:',round(sol[0][0],4),'and',round(sol[0][1],4))\n    \n    sys = sss(A,B,C,0)\n    syso = sss(A-L*C, numpy.concatenate((B,L),axis=1), numpy.eye(2), numpy.zeros(4).reshape((2,2)))\n    T = numpy.linspace(0, 6, 1000)\n      \n    if selu == 'impulse': #selu\n        U = [0 for t in range(0,len(T))]\n        U[0] = u\n        T, yout, xout = control.forced_response(sys,T,U,X0w)\n        T, youto, xouto = control.forced_response(syso,T,numpy.matrix([U,yout]),[[0],[0]])\n    if selu == 'step':\n        U = [u for t in range(0,len(T))]\n        T, yout, xout = control.forced_response(sys,T,U,X0w)\n        T, youto, xouto = control.forced_response(syso,T,numpy.matrix([U,yout]),[[0],[0]])\n    if selu == 'sinusoid':\n        U = u*numpy.sin(2*numpy.pi/period*T)\n        T, yout, xout = control.forced_response(sys,T,U,X0w)\n        T, youto, xouto = control.forced_response(syso,T,numpy.matrix([U,yout]),[[0],[0]])\n    if selu == 'square wave':\n        U = u*numpy.sign(numpy.sin(2*numpy.pi/period*T))\n        T, yout, xout = control.forced_response(sys,T,U,X0w)\n        T, youto, xouto = control.forced_response(syso,T,numpy.matrix([U,yout]),[[0],[0]])\n    \n    fig = plt.figure(num='Simulation', figsize=(16,10))\n    \n    fig.add_subplot(211)\n    plt.ylabel('Position vs Position_est (output of the system)')\n    plt.plot(T,xout[0])\n    plt.plot(T,xouto[0])\n    plt.xlabel('time [s]')\n    plt.legend(['Real','Estimated'])\n    plt.axvline(x=0,color='black',linewidth=0.8)\n    plt.axhline(y=0,color='black',linewidth=0.8)\n    plt.grid()\n    \n    fig.add_subplot(212)\n    plt.ylabel('Velocity vs Velocity_est')\n    plt.plot(T,xout[1])\n    plt.plot(T,xouto[1])\n    plt.xlabel('time [s]')\n    plt.legend(['Real','Estimated'])\n    plt.axvline(x=0,color='black',linewidth=0.8)\n    plt.axhline(y=0,color='black',linewidth=0.8)\n    plt.grid()\n    \nalltogether = widgets.VBox([widgets.HBox([m, \n                                          k, \n                                          c]),\n                            widgets.HBox([selm, \n                                          selo, \n                                          selu]),\n                            widgets.Label(' ',border=3),\n                            widgets.HBox([widgets.Label('L:',border=3), Lw, \n                                          widgets.Label(' ',border=3),\n                                          widgets.Label(' ',border=3),\n                                          widgets.Label('Eigenvalues:',border=3), \n                                          eig1o, \n                                          eig2o,\n                                          widgets.Label(' ',border=3),\n                                          widgets.Label(' ',border=3),\n                                          widgets.Label('X0:',border=3), X0w]),\n                            widgets.Label(' ',border=3),\n                            widgets.HBox([u, \n                                          period, \n                                          START])])\nout = widgets.interactive_output(main_callback, {'m':m, 'k':k, 'c':c, 'X0w':X0w, 'L':Lw, 'eig1o':eig1o, 'eig2o':eig2o, \n                                                 'u':u, 'period':period, 'selm':selm, 'selo':selo, 'selu':selu, 'DW':DW})\nout.layout.height = '640px'\ndisplay(out, alltogether)"
  },
  {
    "objectID": "ICCT_en/examples/04/SS-26-Asymptotic_observer.html",
    "href": "ICCT_en/examples/04/SS-26-Asymptotic_observer.html",
    "title": "Asymptotic observers",
    "section": "",
    "text": "# Erasmus+ ICCT project (2018-1-SI01-KA203-047081)\n\n# Toggle cell visibility\n\nfrom IPython.display import HTML\ntag = HTML('''&lt;script&gt;\ncode_show=true; \nfunction code_toggle() {\n    if (code_show){\n        $('div.input').hide()\n    } else {\n        $('div.input').show()\n    }\n    code_show = !code_show\n} \n$( document ).ready(code_toggle);\n&lt;/script&gt;\nToggle cell visibility &lt;a href=\"javascript:code_toggle()\"&gt;here&lt;/a&gt;.''')\ndisplay(tag)\n\n# Hide the code completely\n\n# from IPython.display import HTML\n# tag = HTML('''&lt;style&gt;\n# div.input {\n#     display:none;\n# }\n# &lt;/style&gt;''')\n# display(tag)\n\nGiven the linear time invariant system:\n\\[\\begin{cases}\n\\dot{\\textbf{x}}=A\\textbf{x}+B\\textbf{u}= \\begin{bmatrix}-1&0&3\\\\0&-2&-1\\\\0&1&-2\\end{bmatrix}\\textbf{x}+\\begin{bmatrix}0\\\\0\\\\1\\end{bmatrix}\\textbf{u} \\\\ \\\\\n\\textbf{y}=C\\textbf{x}=\\begin{bmatrix}1&0&0\\end{bmatrix}\\textbf{x}\n\\end{cases}\\]\nand the Luenberger-asymptotic observer:\n\\[\\begin{cases}\n\\dot{\\hat{\\textbf{x}}}=(A-LC)\\hat{\\textbf{x}}+B\\textbf{u}+L\\textbf{y} \\\\\n\\hat{\\textbf{y}}=C\\hat{\\hat{\\textbf{x}}}+D\\textbf{u}\n\\end{cases}\\]\nthis example shows the effect of gain \\(L\\) on the eigenvalues of the observer’s dynamic matrix \\(F=A-LC\\) and the estimation transient starting from arbitrary initial conditions.\n\nHow to use this notebook?\nKnowing that \\(A\\) eigenvalues are in \\(-2+i\\), \\(-2-i\\) and in \\(-1\\), change the values of the gains or the estimator eigenvalues and watch the estimation transient change.\n\n#Preparatory Cell \n\n%matplotlib inline\nimport control as control\nimport numpy\nimport sympy as sym\nfrom IPython.display import display, Markdown\nimport ipywidgets as widgets\nimport matplotlib.pyplot as plt\n\n\n#print a matrix latex-like\ndef bmatrix(a):\n     \"\"\"Returns a LaTeX bmatrix - by Damir Arbula (ICCT project)\n\n     :a: numpy array\n     :returns: LaTeX bmatrix as a string\n     \"\"\"\n     if len(a.shape) &gt; 2:\n         raise ValueError('bmatrix can at most display two dimensions')\n     lines = str(a).replace('[', '').replace(']', '').splitlines()\n     rv = [r'\\begin{bmatrix}']\n     rv += ['  ' + ' & '.join(l.split()) + r'\\\\' for l in lines]\n     rv +=  [r'\\end{bmatrix}']\n     return '\\n'.join(rv)\n\n\n# Display formatted matrix: \ndef vmatrix(a):\n    if len(a.shape) &gt; 2:\n         raise ValueError('bmatrix can at most display two dimensions')\n    lines = str(a).replace('[', '').replace(']', '').splitlines()\n    rv = [r'\\begin{vmatrix}']\n    rv += ['  ' + ' & '.join(l.split()) + r'\\\\' for l in lines]\n    rv +=  [r'\\end{vmatrix}']\n    return '\\n'.join(rv)\n\n\n#matrixWidget is a matrix looking widget built with a VBox of HBox(es) that returns a numPy array as value !\nclass matrixWidget(widgets.VBox):\n    def updateM(self,change):\n        for irow in range(0,self.n):\n            for icol in range(0,self.m):\n                self.M_[irow,icol] = self.children[irow].children[icol].value\n                #print(self.M_[irow,icol])\n        self.value = self.M_\n\n    def dummychangecallback(self,change):\n        pass\n    \n    \n    def __init__(self,n,m):\n        self.n = n\n        self.m = m\n        self.M_ = numpy.matrix(numpy.zeros((self.n,self.m)))\n        self.value = self.M_\n        widgets.VBox.__init__(self,\n                             children = [\n                                 widgets.HBox(children = \n                                              [widgets.FloatText(value=0.0, layout=widgets.Layout(width='90px')) for i in range(m)]\n                                             ) \n                                 for j in range(n)\n                             ])\n        \n        #fill in widgets and tell interact to call updateM each time a children changes value\n        for irow in range(0,self.n):\n            for icol in range(0,self.m):\n                self.children[irow].children[icol].value = self.M_[irow,icol]\n                self.children[irow].children[icol].observe(self.updateM, names='value')\n        #value = Unicode('example@example.com', help=\"The email value.\").tag(sync=True)\n        self.observe(self.updateM, names='value', type= 'All')\n        \n    def setM(self, newM):\n        #disable callbacks, change values, and reenable\n        self.unobserve(self.updateM, names='value', type= 'All')\n        for irow in range(0,self.n):\n            for icol in range(0,self.m):\n                self.children[irow].children[icol].unobserve(self.updateM, names='value')\n        self.M_ = newM\n        self.value = self.M_\n        for irow in range(0,self.n):\n            for icol in range(0,self.m):\n                self.children[irow].children[icol].value = self.M_[irow,icol]\n        for irow in range(0,self.n):\n            for icol in range(0,self.m):\n                self.children[irow].children[icol].observe(self.updateM, names='value')\n        self.observe(self.updateM, names='value', type= 'All')        \n\n                #self.children[irow].children[icol].observe(self.updateM, names='value')\n\n             \n#overlaod class for state space systems that DO NOT remove \"useless\" states (what \"professor\" of automatic control would do this?)\nclass sss(control.StateSpace):\n    def __init__(self,*args):\n        #call base class init constructor\n        control.StateSpace.__init__(self,*args)\n    #disable function below in base class\n    def _remove_useless_states(self):\n        pass\n\n\n# Preparatory cell\n\nA = numpy.matrix('-1 0 3; 0 -2 -1; 0 1 -2')\nB = numpy.matrix('0; 0; 1')\nC = numpy.matrix('1 0 0')\nX0 = numpy.matrix('2; 2; 2')\nF = numpy.matrix('-1 0 3; 0 -2 -1; 0 1 -2')\nG = numpy.matrix('0; 0; 1')\nL = numpy.matrix([[4],[-2/3],[2/3]])\nsol1 = numpy.linalg.eig(A)\n\nAw = matrixWidget(3,3)\nAw.setM(A)\nBw = matrixWidget(3,1)\nBw.setM(B)\nCw = matrixWidget(1,3)\nCw.setM(C)\nX0w = matrixWidget(3,1)\nX0w.setM(X0)\nFw = matrixWidget(3,3)\nFw.setM(F)\nGw = matrixWidget(3,1)\nGw.setM(G)\nLw = matrixWidget(3,1)\nLw.setM(L)\n\n\neig1o = matrixWidget(1,1)\neig2o = matrixWidget(2,1)\neig3o = matrixWidget(1,1)\neig1o.setM(numpy.matrix([-3])) \neig2o.setM(numpy.matrix([[-3],[0]]))\neig3o.setM(numpy.matrix([-3]))\n\n\n# Misc\n\n#create dummy widget \nDW = widgets.FloatText(layout=widgets.Layout(width='0px', height='0px'))\n\n#create button widget\nSTART = widgets.Button(\n    description='Test',\n    disabled=False,\n    button_style='', # 'success', 'info', 'warning', 'danger' or ''\n    tooltip='Test',\n    icon='check'\n)\n                       \ndef on_start_button_clicked(b):\n    #This is a workaround to have intreactive_output call the callback:\n    #   force the value of the dummy widget to change\n    if DW.value&gt; 0 :\n        DW.value = -1\n    else: \n        DW.value = 1\n    pass\nSTART.on_click(on_start_button_clicked)\n\n# Define type of method \nselm = widgets.Dropdown(\n    options= ['Set L', 'Set the eigenvalues'],\n    value= 'Set L',\n    description='',\n    disabled=False\n)\n\n# Define the number of complex eigenvalues for the observer\nselo = widgets.Dropdown(\n    options= ['0 complex eigenvalues', '2 complex eigenvalues'],\n    value= '0 complex eigenvalues',\n    description='Eigenvalues:',\n    disabled=False\n)\n\n#define type of ipout \nselu = widgets.Dropdown(\n    options=['impulse', 'step', 'sinusoid', 'square wave'],\n    value='impulse',\n    description='Type of input:',\n    disabled=False\n)\n# Define the values of the input\nu = widgets.FloatSlider(\n    value=1,\n    min=0,\n    max=20.0,\n    step=0.1,\n    description='input u:',\n    disabled=False,\n    continuous_update=False,\n    orientation='horizontal',\n    readout=True,\n    readout_format='.1f',\n)\nperiod = widgets.FloatSlider(\n    value=0.5,\n    min=0.0,\n    max=1,\n    step=0.05,\n    description='Period: ',\n    disabled=False,\n    continuous_update=False,\n    orientation='horizontal',\n    readout=True,\n    readout_format='.2f',\n)\n\n\n# Support functions\n\ndef eigen_choice(selo):\n    if selo == '0 complex eigenvalues':\n        eig1o.children[0].children[0].disabled = False\n        eig2o.children[1].children[0].disabled = True\n        eigo = 0\n    if selo == '2 complex eigenvalues':\n        eig1o.children[0].children[0].disabled = True\n        eig2o.children[1].children[0].disabled = False\n        eigo = 2\n    return eigo\n\ndef method_choice(selm):\n    if selm == 'Set L':\n        method = 1\n        selo.disabled = True\n    if selm == 'Set the eigenvalues':\n        method = 2\n        selo.disabled = False\n    return method\n\n\ndef main_callback(X0w, L, eig1o, eig2o, eig3o, u, period, selm, selo, selu, DW):\n    eigo = eigen_choice(selo)\n    method = method_choice(selm)\n    \n    if method == 1:\n        sol = numpy.linalg.eig(A-L*C)\n    if method == 2:\n        if eigo == 0:\n            L = control.acker(A.T, C.T, [eig1o[0,0], eig2o[0,0], eig3o[0,0]]).T\n            Lw.setM(L) \n        if eigo == 2:\n            L = control.acker(A.T, C.T, [eig1o[0,0], \n                                      numpy.complex(eig2o[0,0],eig2o[1,0]), \n                                      numpy.complex(eig2o[0,0],-eig2o[1,0])]).T\n            Lw.setM(L)\n        sol = numpy.linalg.eig(A-L*C)\n    print('The system\\'s eigenvalues are:',round(sol1[0][0],4),',',round(sol1[0][1],4),'and',round(sol1[0][2],4)) \n    print('The observer\\'s eigenvalues are:',round(sol[0][0],4),',',round(sol[0][1],4),'and',round(sol[0][2],4))\n\n    \n    sys = sss(A,B,C,0)\n    syso = sss(A-L*C, numpy.concatenate((B,L),axis=1), numpy.eye(3), numpy.zeros(6).reshape((3,2)))\n    T = numpy.linspace(0, 10, 1000)\n      \n    if selu == 'impulse': #selu\n        U = [0 for t in range(0,len(T))]\n        U[0] = u\n        T, yout, xout = control.forced_response(sys,T,U,X0w)\n        T, youto, xouto = control.forced_response(syso,T,numpy.matrix([U,yout]),[[0],[0],[0]])\n    if selu == 'step':\n        U = [u for t in range(0,len(T))]\n        T, yout, xout = control.forced_response(sys,T,U,X0w)\n        T, youto, xouto = control.forced_response(syso,T,numpy.matrix([U,yout]),[[0],[0],[0]])\n    if selu == 'sinusoid':\n        U = u*numpy.sin(2*numpy.pi/period*T)\n        T, yout, xout = control.forced_response(sys,T,U,X0w)\n        T, youto, xouto = control.forced_response(syso,T,numpy.matrix([U,yout]),[[0],[0],[0]])\n    if selu == 'square wave':\n        U = u*numpy.sign(numpy.sin(2*numpy.pi/period*T))\n        T, yout, xout = control.forced_response(sys,T,U,X0w)\n        T, youto, xouto = control.forced_response(syso,T,numpy.matrix([U,yout]),[[0],[0],[0]])\n    \n    fig = plt.figure(num='Simulation', figsize=(16,10))\n    \n    fig.add_subplot(311)\n    plt.ylabel('$X_1$ vs $X_{1est}$ (output of the system)')\n    plt.plot(T,xout[0])\n    plt.plot(T,xouto[0])\n    plt.xlabel('time [s]')\n    plt.legend(['Real','Estimated'])\n    plt.grid()\n    \n    fig.add_subplot(312)\n    plt.ylabel('$X_2$ vs $X_{2est}$')\n    plt.plot(T,xout[1])\n    plt.plot(T,xouto[1])\n    plt.xlabel('time [s]')\n    plt.legend(['Real','Estimated'])\n    plt.grid()\n    \n    fig.add_subplot(313)\n    plt.ylabel('$X_3$ vs $X_{3est}$')\n    plt.plot(T,xout[2])\n    plt.plot(T,xouto[2])\n    plt.xlabel('time [s]')\n    plt.legend(['Real','Estimated'])\n    plt.grid()\n    \nalltogether = widgets.VBox([widgets.HBox([selm, \n                                          selo, \n                                          selu]),\n                            widgets.Label(' ',border=3),\n                            widgets.HBox([widgets.Label('L:',border=3), Lw, \n                                          widgets.Label(' ',border=3),\n                                          widgets.Label(' ',border=3),\n                                          widgets.Label('Eigenvalues:',border=3), \n                                          eig1o, \n                                          eig2o, \n                                          eig3o,\n                                          widgets.Label(' ',border=3),\n                                          widgets.Label(' ',border=3),\n                                          widgets.Label('X0:',border=3), X0w]),\n                            widgets.Label(' ',border=3),\n                            widgets.HBox([u, \n                                          period, \n                                          START])])\nout = widgets.interactive_output(main_callback, {'X0w':X0w, 'L':Lw, 'eig1o':eig1o, 'eig2o':eig2o, 'eig3o':eig3o, \n                                                 'u':u, 'period':period, 'selm':selm, 'selo':selo, 'selu':selu, 'DW':DW})\nout.layout.height = '680px'\ndisplay(out, alltogether)"
  },
  {
    "objectID": "ICCT_en/examples/04/SS-24-State_Space_Formulation_and_Transfer_Function.html",
    "href": "ICCT_en/examples/04/SS-24-State_Space_Formulation_and_Transfer_Function.html",
    "title": "State Space Formulation and Transfer Function",
    "section": "",
    "text": "# Erasmus+ ICCT project (2018-1-SI01-KA203-047081)\n\n# Toggle cell visibility\n\nfrom IPython.display import HTML\ntag = HTML('''&lt;script&gt;\ncode_show=true; \nfunction code_toggle() {\n    if (code_show){\n        $('div.input').hide()\n    } else {\n        $('div.input').show()\n    }\n    code_show = !code_show\n} \n$( document ).ready(code_toggle);\n&lt;/script&gt;\nToggle cell visibility &lt;a href=\"javascript:code_toggle()\"&gt;here&lt;/a&gt;.''')\ndisplay(tag)\n\n# Hide the code completely\n\n# from IPython.display import HTML\n# tag = HTML('''&lt;style&gt;\n# div.input {\n#     display:none;\n# }\n# &lt;/style&gt;''')\n# display(tag)\n\n\nToggle cell visibility here.\n\n\nThis example lets you explore the effects of structural properties (Controllability and Observability) on the transfer function and the system response to input and initial conditions.\n\nHow to use this notebook?\nRecalling the Kalman decomposition matrix structure:\n\\[\\begin{cases}\n\\underbrace{\\begin{bmatrix} \\dot{z}_{ro} \\\\ \\dot{z}_{r\\bar{o}} \\\\ \\dot{z}_{no} \\\\ \\dot{z}_{n\\bar{o}} \\end{bmatrix}}_{\\dot{\\textbf{z}}} =\n\\begin{bmatrix} A_{ro} & 0 & A_{no,ro} & 0 \\\\ A_{ro,r\\bar{o}} & A_{r\\bar{o}} & A_{no,r\\bar{o}} & A_{n\\bar{o},r\\bar{o}} \\\\ 0 & 0 & A_{no} & 0 \\\\ 0 & 0 & A_{no,n\\bar{o}} & A_{n\\bar{o}} \\end{bmatrix} \\underbrace{\\begin{bmatrix} z_{ro} \\\\ z_{r\\bar{o}} \\\\ z_{no} \\\\ z_{n\\bar{o}} \\end{bmatrix}}_{\\textbf{z}} +\n\\begin{bmatrix} B_{ro} \\\\ B_{r,\\bar{o}} \\\\ 0 \\\\ 0 \\end{bmatrix} \\textbf{u} \\\\\n\\textbf{y} = \\begin{bmatrix} C_{ro} & 0 & C_{no} & 0 \\end{bmatrix} \\textbf{z}\n\\end{cases}\\]\nmodify matrices \\(A\\),\\(B\\),\\(C\\),and \\(D\\) below and: * look at the eigenvalues to see if the system is stable or not; * look at the transfer function to see if pole-zero cancellations have occurred; * look at how a system may have a divergent free response but a convergent output; * try to figure out if full observability or controllability have been lost;\nand try to create: * a system with an observable/non observable unstable mode; * a system with an unreachable state that is unstable but does not produce a divergent free response for any possible initial conditions.\n\n#Preparatory Cell \n\n%matplotlib inline\nimport control\nimport control.matlab as cm\nimport numpy\nfrom IPython.display import display, Markdown\nimport ipywidgets as widgets\nimport matplotlib.pyplot as plt\n\n#print a matrix latex-like\ndef bmatrix(a):\n     \"\"\"Returns a LaTeX bmatrix - by Damir Arbula (ICCT project)\n\n     :a: numpy array\n     :returns: LaTeX bmatrix as a string\n     \"\"\"\n     if len(a.shape) &gt; 2:\n         raise ValueError('bmatrix can at most display two dimensions')\n     lines = str(a).replace('[', '').replace(']', '').splitlines()\n     rv = [r'\\begin{bmatrix}']\n     rv += ['  ' + ' & '.join(l.split()) + r'\\\\' for l in lines]\n     rv +=  [r'\\end{bmatrix}']\n     return ''.join(rv) #'\\n'.join(rv)\n\n#matrixWidget is a matrix looking widget built with a VBox of HBox(es) that returns a numPy array as value !\nclass matrixWidget(widgets.VBox):\n    def updateM(self,change):\n        for irow in range(0,self.n):\n            for icol in range(0,self.m):\n                self.M_[irow,icol] = self.children[irow].children[icol].value\n                #print(self.M_[irow,icol])\n        self.value = self.M_\n\n    def dummychangecallback(self,change):\n        pass\n    \n    \n    def __init__(self,n,m):\n        self.n = n\n        self.m = m\n        self.M_ = numpy.matrix(numpy.zeros((self.n,self.m)))\n        self.value = self.M_\n        widgets.VBox.__init__(self,\n                             children = [\n                                 widgets.HBox(children = \n                                              [widgets.FloatText(value=0.0, layout=widgets.Layout(width='90px')) for i in range(m)]\n                                             ) \n                                 for j in range(n)\n                             ])\n        \n        #fill in widgets and tell interact to call updateM each time a children changes value\n        for irow in range(0,self.n):\n            for icol in range(0,self.m):\n                self.children[irow].children[icol].value = self.M_[irow,icol]\n                self.children[irow].children[icol].observe(self.updateM, names='value')\n        #value = Unicode('example@example.com', help=\"The email value.\").tag(sync=True)\n        self.observe(self.updateM, names='value', type= 'All')\n        \n    def setM(self, newM):\n        #disable callbacks, change values, and reenable\n        self.unobserve(self.updateM, names='value', type= 'All')\n        for irow in range(0,self.n):\n            for icol in range(0,self.m):\n                self.children[irow].children[icol].unobserve(self.updateM, names='value')\n        self.M_ = newM\n        self.value = self.M_\n        for irow in range(0,self.n):\n            for icol in range(0,self.m):\n                self.children[irow].children[icol].value = self.M_[irow,icol]\n        for irow in range(0,self.n):\n            for icol in range(0,self.m):\n                self.children[irow].children[icol].observe(self.updateM, names='value')\n        self.observe(self.updateM, names='value', type= 'All')        \n\n                #self.children[irow].children[icol].observe(self.updateM, names='value')\n\n             \n#overlaod class for state space systems that DO NOT remove \"useless\" states (what \"professor\" of automatic control would do this?)\nclass sss(control.StateSpace):\n    def __init__(self,*args):\n        #call base class init constructor\n        control.StateSpace.__init__(self,*args)\n    #disable function below in base class\n    def _remove_useless_states(self):\n        pass\n\n\n# Preparatory cell\nimport warnings\n# In order to suppress the warning BadCoefficient\nwarnings.filterwarnings(\"ignore\")\n\ndef MINREAL(A,B,C,D):\n    ''' Trick in order to have a right cancellations without very small numbers '''\n    sys = control.ss2tf(sss(A,B,C,D))\n    sys = control.minreal(sys, verbose=False)\n    z, p, k = cm.tf2zpk(sys.num[0][0],sys.den[0][0])\n    num, den = cm.zpk2tf(z, p, k)\n    sys = control.tf(num, den)\n    return sys\n    \nA = numpy.matrix('-1 1 0 0; 0 -1 1 0; 0 0 -1 0; 0 1 -1 0')\nB = numpy.matrix('0; 0; 1; -1')\nC = numpy.matrix('1 0 0 1')\nD = numpy.matrix('0')\nX0 = numpy.matrix('0; 0; 0; 0')\n\nAdef = [numpy.matrix('-1 1 4 0; 0 -0.5 3 0; 0 0 -2 0; 0 0 0 2'),\n        numpy.matrix('-1 1 4 0; 0 -0.5 3 0; 0 0 -2 0; 0 0 -2 2'),\n        numpy.matrix('-3 2 0 0; 0 -1 0 0; 0 1 1 0; 0 0 0 -1')] \nBdef = [numpy.matrix('0; 0; 1; 0'),\n        numpy.matrix('0; 0; 1; 0'),\n        numpy.matrix('0; 1; 0; 0')] \nCdef = [numpy.matrix('1 0 0 1'),\n        numpy.matrix('1 0 0 0'),\n        numpy.matrix('1 0 0 1')]\n\nAw = matrixWidget(4,4)\nAw.setM(A)\nBw = matrixWidget(4,1)\nBw.setM(B)\nCw = matrixWidget(1,4)\nCw.setM(C)\nDw = matrixWidget(1,1)\nDw.setM(D)\nX0w = matrixWidget(4,1)\nX0w.setM(X0)\n\n\n# Misc\n# default systems\nsel_system = widgets.Dropdown(\n                              options=['Manual', 'One unreachable state', 'One unobservable state', 'One unobservable state and one unreachable state'],\n                              value='One unreachable state',\n                              description='',\n                              disabled=False\n)\n#define type of ipout \nselu = widgets.Dropdown(\n    options=['impulse', 'step', 'sinusoid', 'square wave'],\n    value='step',\n    description='Type of input:',\n    disabled=False\n)\n# Define the values of the input\nu = widgets.FloatSlider(\n    value=1,\n    min=0,\n    max=20.0,\n    step=0.1,\n    description=r'$u$:',\n    disabled=False,\n    continuous_update=False,\n    orientation='horizontal',\n    readout=True,\n    readout_format='.1f',\n)\nperiod = widgets.FloatSlider(\n    value=1,\n    min=0.001,\n    max=4,\n    step=0.001,\n    description='Period: ',\n    disabled=False,\n    continuous_update=False,\n    orientation='horizontal',\n    readout=True,\n    readout_format='.2f',\n)\n\n#create dummy widget \nDW = widgets.FloatText(layout=widgets.Layout(width='0px', height='0px'))\n\n#create button widget\nSTART = widgets.Button(\n    description='Test',\n    disabled=False,\n    button_style='', # 'success', 'info', 'warning', 'danger' or ''\n    tooltip='Test',\n    icon='check'\n)\n                       \ndef on_start_button_clicked(b):\n    #This is a workaround to have intreactive_output call the callback:\n    #   force the value of the dummy widget to change\n    if DW.value&gt; 0 :\n        DW.value = -1\n    else: \n        DW.value = 1\n    pass\nSTART.on_click(on_start_button_clicked)\n\n\ndef main_callback(A, B, C, D, X0, u, period, selu, sel_system, DW):\n    global Aw, Bw, Cw, Dw, X0w, Adef, Bdef, Cdef\n\n    if sel_system == 'One unreachable state':\n        A = Adef[0]\n        Aw.setM(A)\n        B = Bdef[0]\n        Bw.setM(B)\n        C = Cdef[0]\n        Cw.setM(C)\n        D = 0\n        Dw.setM(numpy.matrix('0'))\n        X0w.setM(numpy.matrix([0, 0, 0, 0]).T)\n        X0 = numpy.matrix([0, 0, 0, 0]).T\n    elif sel_system == 'One unobservable state':\n        A = Adef[1]\n        Aw.setM(A)\n        B = Bdef[1]\n        Bw.setM(B)\n        C = Cdef[1]\n        Cw.setM(C)\n        D = 0\n        Dw.setM(numpy.matrix('0'))\n        X0w.setM(numpy.matrix([0, 0, 0, 0]).T)\n        X0 = numpy.matrix([0, 0, 0, 0]).T\n    elif sel_system == 'One unobservable state and one unreachable state':\n        A = Adef[2]\n        Aw.setM(A)\n        B = Bdef[2]\n        Bw.setM(B)\n        C = Cdef[2]\n        Cw.setM(C)\n        D = 0\n        Dw.setM(numpy.matrix('0'))\n        X0w.setM(numpy.matrix([0, 0, 0, 0]).T)\n        X0 = numpy.matrix([0, 0, 0, 0]).T\n        \n        \n    eig = numpy.linalg.eig(A)[0]\n    R = control.ctrb(A,B)\n    O = control.obsv(A,C)\n    rankR = numpy.linalg.matrix_rank(R)\n    rankO = numpy.linalg.matrix_rank(O)\n    \n    text = r'The eigenvalues of the system are ' + str(eig[0]) + r', ' + str(eig[1])+ r', ' + str(eig[2]) + r' and ' + str(eig[3]) + '. '\n    if rankO == 4:\n        text = text + r'The system is observable and '\n    else:\n        text = text + r'The system is unobservable and '\n    if rankR == 4:\n        text = text + r' reachable.'\n    else:\n        text = text + r' unreachable. '\n    \n    \n    sys = MINREAL(A,B,C,D)\n    text = text + 'The transfer function is: \\n '\n    display(Markdown(text))\n    print(sys) #, tol=1e-3\n    \n    \n    sys = sss(A,B,C,D)\n    \n    if (numpy.real([eig[0],eig[1],eig[2],eig[3]]) == [0, 0, 0, 0]).all():\n        T = numpy.linspace(0,20,1000)\n    else:\n        if min(numpy.abs(numpy.real([eig[0],eig[1],eig[2],eig[3]]))) != 0:\n            T = numpy.linspace(0,7*1/min(numpy.abs(numpy.real([eig[0],eig[1],eig[2],eig[3]]))),1000)\n        else:\n            T = numpy.linspace(0,7*1/max(numpy.abs(numpy.real([eig[0],eig[1],eig[2],eig[3]]))),1000)\n    \n    if selu == 'impulse': #selu\n        U = [0 for t in range(0,len(T))]\n        U[0] = u\n        T, Y, X = control.forced_response(sys,T=T,U=U,X0=X0)\n    if selu == 'step':\n        U = [u for t in range(0,len(T))]\n        T, Y, X = control.forced_response(sys,T=T,U=U,X0=X0)\n    if selu == 'sinusoid':\n        U = u*numpy.sin(2*numpy.pi/period*T)\n        T, Y, X = control.forced_response(sys,T=T,U=U,X0=X0)\n    if selu == 'square wave':\n        U = u*numpy.sign(numpy.sin(2*numpy.pi/period*T))\n        T, Y, X = control.forced_response(sys,T=T,U=U,X0=X0)\n    \n    fig = plt.figure(figsize=(16,5))\n    \n    fig.add_subplot(121)\n    plt.title('Initial response: states')\n    plt.plot(T,X[0])\n    plt.plot(T,X[1])\n    plt.plot(T,X[2])\n    plt.plot(T,X[3])\n    plt.ylabel('States')\n    plt.xlabel('time [s]')\n    plt.legend([r'$x_1$',r'$x_2$',r'$x_3$',r'$x_4$'])\n    plt.grid()\n    \n    fig.add_subplot(122)\n    plt.ylabel(r'$y$')\n    plt.plot(T,Y)\n    plt.xlabel('time [s]')\n    plt.title('Initial response: output')\n    plt.grid()\n    \n    \nalltogether = widgets.VBox([sel_system,\n                            widgets.Label('   ',border=3),\n                            widgets.HBox([widgets.Label('A:',border=3),  Aw, widgets.Label('   ',border=3),\n                                          widgets.Label('B:',border=3),  Bw, widgets.Label('   ',border=3),\n                                          widgets.Label('x0:',border=3),X0w,widgets.Label('   ',border=3)]),\n                            widgets.Label('   ',border=3),\n                            widgets.HBox([widgets.Label('C:',border=3),\n                                          Cw,widgets.Label('   ',border=3),\n                                          widgets.Label('D:',border=3),\n                                          Dw,widgets.Label('   ',border=3),\n                                          START]),\n                            widgets.Label('   ',border=3),\n                            widgets.HBox([selu, u, period])])\nout = widgets.interactive_output(main_callback, {'A':Aw, 'B':Bw, 'C':Cw, 'D':Dw, 'X0':X0w, 'u':u, 'period':period, 'selu':selu, 'sel_system':sel_system, 'DW':DW})\nout.layout.height = '520px'\ndisplay(out, alltogether)"
  },
  {
    "objectID": "ICCT_en/examples/04/SS-22-Observability.html",
    "href": "ICCT_en/examples/04/SS-22-Observability.html",
    "title": "Observability",
    "section": "",
    "text": "# Erasmus+ ICCT project (2018-1-SI01-KA203-047081)\n\n# Toggle cell visibility\n\nfrom IPython.display import HTML\ntag = HTML('''&lt;script&gt;\ncode_show=true; \nfunction code_toggle() {\n    if (code_show){\n        $('div.input').hide()\n    } else {\n        $('div.input').show()\n    }\n    code_show = !code_show\n} \n$( document ).ready(code_toggle);\n&lt;/script&gt;\nToggle cell visibility &lt;a href=\"javascript:code_toggle()\"&gt;here&lt;/a&gt;.''')\ndisplay(tag)\n\n# Hide the code completely\n\n# from IPython.display import HTML\n# tag = HTML('''&lt;style&gt;\n# div.input {\n#     display:none;\n# }\n# &lt;/style&gt;''')\n# display(tag)\n\n\nToggle cell visibility here.\n\n\nGiven a linear system of the type\n\\[\\begin{cases}\n\\dot{\\textbf{x}}=A\\textbf{x}+B\\textbf{u} \\\\\n\\textbf{y}=C\\textbf{x}\n\\end{cases}\\]\nwe want to know if, by measuring the time history of the output \\(y(t)\\) and of the input \\(u(t)\\), it is possible to distinguish the initial state of the system that has generated the measured output. This kind of information about the system is related with the property called Observability.\nFirst of all let us introduce the concept of indistinguishability for two states. &gt;Two states \\(\\bar{x_1}\\) and \\(\\hat{x_1}\\) are indistinguishable in the future (here \\(\\bar{x_1}I_{t_2}\\hat{x_1}\\)) if and only if \\(\\forall u \\in U \\quad y(t,t_1,\\bar{x_1},u)=y(t,t_1,\\hat{x_1},u) \\quad \\forall t\\in [t_1,t_2]\\). Where \\(U\\) is the set of the input values.\nIn other words: two states are indistinguishable in the future if and only if the system, starting from them and evolving with the same input \\(u(t)\\) applied, produce exactly the same output \\(y(t)\\) in the time window considered. It can be shown that for continuous-time linear time invariant systems, indistinguishability (and observability) is independent of the time window.\nIt is worth noting that the indistinguishability between two states (between \\(x_1\\) and \\(x_2\\)) is the same as the indistinguishability for the difference of the two states with the state origin (between \\(x_1-x_2\\) and \\(0\\)). Mathematically, equating the output response starting from the two initial conditions yields:\n\\[\\begin{cases}\n\\bar{y}(t) = Ce^{At}\\bar{x_1} + C\\int_{t_1}^{t}e^{A(t-\\tau)}Bu(\\tau)d\\tau \\\\\n\\hat{y}(t) = Ce^{At}\\hat{x_1} + C\\int_{t_1}^{t}e^{A(t-\\tau)}Bu(\\tau)d\\tau\n\\end{cases}\\]\n\\[\nCe^{At}\\bar{x_1} = Ce^{At}\\hat{x_1} \\rightarrow Ce^{At}\\underbrace{(\\bar{x_1}-\\hat{x_1})}_{\\widetilde{x_1}} = Ce^{At}0 \\,.\n\\]\nThis implies that we can talk about indistinguishability from the origin, and if a state is undistinguishable from the origin it is said to be unobservable.\nA measure of observability of a system can be introduced using the observability Graminan \\(G_o(0,t_f)=\\int_{0}^{t_f}e^{A^T\\tau}C^TCe^{A\\tau}d\\tau\\). It can be demonstrated that the space of the non observable states of a system is the nullspace of \\(G_o\\); so, a linear system is observable if and only if \\(\\text{ker}(G_o)=\\{0\\}\\) or, equivalently if it’s true that \\(\\widetilde{x}I_{t}0 \\Rightarrow \\widetilde{x}=\\{0\\}\\).\nDefining the observability matrix as \\[\n\\mathcal{O} = \\begin{bmatrix}C \\\\ CA \\\\ CA^2 \\\\ \\vdots \\\\ CA^{n-1} \\end{bmatrix}\n\\] it can be demonstrated that \\(\\text{ker}(G_o)=\\text{ker}(\\mathcal{O})\\) so, the observability of a system can be investigated by studying the rank of the observability matrix i.e. if \\(\\text{rank}(\\mathcal{O})=n\\) where \\(n: \\, x\\in \\mathbb{R}^n\\) the system is said to be observable.\nKnowledge of observability of a system and of single states is fundamental beacuse it impacts which modes of the system appear on the output and which do not. If a system is Observable, all its modes can appear on the putput depending on initial conditions and input functions. If a system is not observable, that is if \\(\\mathcal{O}\\) is not full rank, then some modes of the system cannot be seen on the output.\nNOTE: A concept analogous to observability is reconstructability. This derives from the request to be able to reconstruct the final state in which the system is located instead of the initial state. For continuous-time linear systems, a system is reconstructable if and only if it is observable, in discrete time this property no longer holds. This can be easily proven by realizing that once the initial state has been observed, than the current state can be recosntructed using the Lagrange Equation (since the input \\(u\\) is known). Conversely, if the current state is known, the initial state can be obtained by integrating back in time.\n\nHow to use this notebook?\nPresented below is an interactive example in which the matrices \\(A\\) and \\(C\\) can be edited. - Try to make unobservable, if possible, only the third state \\(x_1\\) of the default couple \\((A,C)\\) by changing only \\(C\\). - Try to make unobservable, if possible, the state \\(x_2\\) of the default couple \\((A,C)\\) by changing only \\(C\\). - Try to make the couple \\((A,C)\\) unobservable by changing only \\(C\\) and leaving the default \\(A\\). Once done, think at the structure of \\(A\\) and answer: Why it became unobservable? For what/which state(s) it the observability lost? - With \\(C=[1, 1, 1]\\) change \\(A\\) in order to make \\((A,C)\\) unobservable (help yourself by thinking about the \\(\\mathcal{O}\\) matrix). - Try to write a couple \\((A,C)\\) that has one positive eigenvalue that is associated to an unobservable state. How does the output behaves in the free response?\n\n#Preparatory Cell \n\n%matplotlib inline\nimport control\nimport numpy\nfrom IPython.display import display, Markdown\nimport ipywidgets as widgets\nimport matplotlib.pyplot as plt\n\n#print a matrix latex-like\ndef bmatrix(a):\n     \"\"\"Returns a LaTeX bmatrix - by Damir Arbula (ICCT project)\n\n     :a: numpy array\n     :returns: LaTeX bmatrix as a string\n     \"\"\"\n     if len(a.shape) &gt; 2:\n         raise ValueError('bmatrix can at most display two dimensions')\n     lines = str(a).replace('[', '').replace(']', '').splitlines()\n     rv = [r'$\\begin{bmatrix}']\n     rv += ['  ' + ' & '.join(l.split()) + r'\\\\' for l in lines]\n     rv +=  [r'\\end{bmatrix}$']\n     return ''.join(rv) #'\\n'.join(rv)\n\n#matrixWidget is a matrix looking widget built with a VBox of HBox(es) that returns a numPy array as value !\nclass matrixWidget(widgets.VBox):\n    def updateM(self,change):\n        for irow in range(0,self.n):\n            for icol in range(0,self.m):\n                self.M_[irow,icol] = self.children[irow].children[icol].value\n                #print(self.M_[irow,icol])\n        self.value = self.M_\n\n    def dummychangecallback(self,change):\n        pass\n    \n    \n    def __init__(self,n,m):\n        self.n = n\n        self.m = m\n        self.M_ = numpy.matrix(numpy.zeros((self.n,self.m)))\n        self.value = self.M_\n        widgets.VBox.__init__(self,\n                             children = [\n                                 widgets.HBox(children = \n                                              [widgets.FloatText(value=0.0, layout=widgets.Layout(width='90px')) for i in range(m)]\n                                             ) \n                                 for j in range(n)\n                             ])\n        \n        #fill in widgets and tell interact to call updateM each time a children changes value\n        for irow in range(0,self.n):\n            for icol in range(0,self.m):\n                self.children[irow].children[icol].value = self.M_[irow,icol]\n                self.children[irow].children[icol].observe(self.updateM, names='value')\n        #value = Unicode('example@example.com', help=\"The email value.\").tag(sync=True)\n        self.observe(self.updateM, names='value', type= 'All')\n        \n    def setM(self, newM):\n        #disable callbacks, change values, and reenable\n        self.unobserve(self.updateM, names='value', type= 'All')\n        for irow in range(0,self.n):\n            for icol in range(0,self.m):\n                self.children[irow].children[icol].unobserve(self.updateM, names='value')\n        self.M_ = newM\n        self.value = self.M_\n        for irow in range(0,self.n):\n            for icol in range(0,self.m):\n                self.children[irow].children[icol].value = self.M_[irow,icol]\n        for irow in range(0,self.n):\n            for icol in range(0,self.m):\n                self.children[irow].children[icol].observe(self.updateM, names='value')\n        self.observe(self.updateM, names='value', type= 'All')        \n\n                #self.children[irow].children[icol].observe(self.updateM, names='value')\n\n             \n#overlaod class for state space systems that DO NOT remove \"useless\" states (what \"professor\" of automatic control would do this?)\nclass sss(control.StateSpace):\n    def __init__(self,*args):\n        #call base class init constructor\n        control.StateSpace.__init__(self,*args)\n    #disable function below in base class\n    def _remove_useless_states(self):\n        pass\n\n\n# Preparatory cell\nA = numpy.matrix('-1 1 0; 0 -1 1; 0 0 -1')\nB = numpy.matrix('0; 0; 1')\nC = numpy.matrix('1 0 0')\nX0 = numpy.matrix('2; 2; 2')\n\nAw = matrixWidget(3,3)\nAw.setM(A)\nBw = matrixWidget(3,1)\nBw.setM(B)\nCw = matrixWidget(1,3)\nCw.setM(C)\nX0w = matrixWidget(3,1)\nX0w.setM(X0)\n\n\n# Misc\n#define type of ipout \nselu = widgets.Dropdown(\n    options=['impulse', 'step', 'sinusoid', 'square wave'],\n    value='step',\n    description='Type of input:',\n    disabled=False\n)\n# Define the values of the input\nu = widgets.FloatSlider(\n    value=0,\n    min=0,\n    max=20.0,\n    step=0.1,\n    description=r'$u$:',\n    disabled=False,\n    continuous_update=False,\n    orientation='horizontal',\n    readout=True,\n    readout_format='.1f',\n)\nperiod = widgets.FloatSlider(\n    value=1,\n    min=0.01,\n    max=4,\n    step=0.01,\n    description='Period: ',\n    disabled=False,\n    continuous_update=False,\n    orientation='horizontal',\n    readout=True,\n    readout_format='.2f',\n)\n\n#create dummy widget \nDW = widgets.FloatText(layout=widgets.Layout(width='0px', height='0px'))\n\n#create button widget\nSTART = widgets.Button(\n    description='Test',\n    disabled=False,\n    button_style='', # 'success', 'info', 'warning', 'danger' or ''\n    tooltip='Test',\n    icon='check'\n)\n                       \ndef on_start_button_clicked(b):\n    #This is a workaround to have intreactive_output call the callback:\n    #   force the value of the dummy widget to change\n    if DW.value&gt; 0 :\n        DW.value = -1\n    else: \n        DW.value = 1\n    pass\nSTART.on_click(on_start_button_clicked)\n\n\ndef main_callback(A, B, C, X0, u, period, selu, DW):\n    eig = numpy.linalg.eig(A)[0]\n    O = control.obsv(A,C)\n    rankO = numpy.linalg.matrix_rank(O)\n    \n    text = r'The eigenvalues of the system are ' + str(eig[0]) + r', ' + str(eig[1])+ r' and ' + str(eig[2]) + r'. '\n    if rankO == 3:\n        text = text + r'Since $\\text{rank}(\\mathcal{O})=3$ the system is observable. ' + '\\n\\n' + 'The observability matrix is: ' + r'$\\mathcal{O}=$' + bmatrix(O) #+ r'$'\n    else:\n        text = text + r'Since $\\text{rank}(\\mathcal{O})=' + str(rankO) + r'$ the system is unobservable. ' + '\\n\\n' + 'The observability matrix is: ' + r'$\\mathcal{O}=' + bmatrix(O) + r'$'\n    display(Markdown(text))\n    \n    \n    sys = sss(A,B,C,0)\n    if numpy.real([eig[0],eig[1],eig[2]])[0] == 0 and numpy.real([eig[0],eig[1],eig[2]])[1] == 0 and numpy.real([eig[0],eig[1],eig[2]])[2] == 0:\n        T = numpy.linspace(0,20,1000)\n    else:\n        if min(numpy.abs(numpy.real([eig[0],eig[1],eig[2]]))) != 0:\n            T = numpy.linspace(0,7*1/min(numpy.abs(numpy.real([eig[0],eig[1],eig[2]]))),1000)\n        else:\n            T = numpy.linspace(0,7*1/max(numpy.abs(numpy.real([eig[0],eig[1],eig[2]]))),1000)\n    \n    if selu == 'impulse': #selu\n        U = [0 for t in range(0,len(T))]\n        U[0] = u\n        T, Y, X = control.forced_response(sys,T=T,U=U,X0=X0)\n    if selu == 'step':\n        U = [u for t in range(0,len(T))]\n        T, Y, X = control.forced_response(sys,T=T,U=U,X0=X0)\n    if selu == 'sinusoid':\n        U = u*numpy.sin(2*numpy.pi/period*T)\n        T, Y, X = control.forced_response(sys,T=T,U=U,X0=X0)\n    if selu == 'square wave':\n        U = u*numpy.sign(numpy.sin(2*numpy.pi/period*T))\n        T, Y, X = control.forced_response(sys,T=T,U=U,X0=X0)\n    \n    fig = plt.figure(figsize=(16,5))\n    \n    fig.add_subplot(121)\n    plt.title('Initial response: states')\n    plt.plot(T,X[0])\n    plt.plot(T,X[1])\n    plt.plot(T,X[2])\n    plt.ylabel('States')\n    plt.xlabel('time [s]')\n    plt.legend([r'$x_1$',r'$x_2$',r'$x_3$'])\n    plt.grid()\n    \n    fig.add_subplot(122)\n    plt.ylabel(r'$y$')\n    plt.plot(T,Y)\n    plt.xlabel('time [s]')\n    plt.title('Initial response: output')\n    plt.grid()\n    \n    \nalltogether = widgets.VBox([widgets.HBox([widgets.Label('A:',border=3),  Aw, widgets.Label('   ',border=3),\n                                          widgets.Label('B:',border=3),  Bw, widgets.Label('   ',border=3),\n                                          widgets.Label('x0:',border=3),X0w,widgets.Label('   ',border=3),\n                                          START]),\n                            widgets.Label('   ',border=3),\n                            widgets.HBox([widgets.Label('C:',border=3),Cw,widgets.Label('   ',border=3)]),\n                            widgets.Label('   ',border=3),\n                            widgets.HBox([selu, u, period])])\nout = widgets.interactive_output(main_callback, {'A':Aw, 'B':Bw, 'C':Cw, 'X0':X0w, 'u':u, 'period':period, 'selu':selu, 'DW':DW})\nout.layout.height = '460px'\ndisplay(out, alltogether)\n\n\n\n\n\n\n\n\n%%js\nJupyter.notebook.execute_cells([5])"
  },
  {
    "objectID": "ICCT_en/examples/04/SS-20-Internal_stability_example_3.html",
    "href": "ICCT_en/examples/04/SS-20-Internal_stability_example_3.html",
    "title": "Internal stability example 3",
    "section": "",
    "text": "# Erasmus+ ICCT project (2018-1-SI01-KA203-047081)\n\n# Toggle cell visibility\n\nfrom IPython.display import HTML\ntag = HTML('''&lt;script&gt;\ncode_show=true; \nfunction code_toggle() {\n    if (code_show){\n        $('div.input').hide()\n    } else {\n        $('div.input').show()\n    }\n    code_show = !code_show\n} \n$( document ).ready(code_toggle);\n&lt;/script&gt;\nToggle cell visibility &lt;a href=\"javascript:code_toggle()\"&gt;here&lt;/a&gt;.''')\ndisplay(tag)\n\n# Hide the code completely\n\n# from IPython.display import HTML\n# tag = HTML('''&lt;style&gt;\n# div.input {\n#     display:none;\n# }\n# &lt;/style&gt;''')\n# display(tag)\n\n\nToggle cell visibility here.\n\n\n\nHow to use this notebook?\nTry to change the dynamic matrix \\(A\\) of the stable linear system below in order to obtain a system with both a convergent and divergent mode and then change the initial conditions in order to hide the divergent one.\n\\[\n\\dot{x} = \\underbrace{\\begin{bmatrix}0&1\\\\-1&-2\\end{bmatrix}}_{A}x\n\\]\nTry to answer: - How can a suitable initial state be built?\n\n%matplotlib inline\nimport control as control\nimport numpy\nimport sympy as sym\nfrom IPython.display import display, Markdown\nimport ipywidgets as widgets\nimport matplotlib.pyplot as plt\n\n#matrixWidget is a matrix looking widget built with a VBox of HBox(es) that returns a numPy array as value !\nclass matrixWidget(widgets.VBox):\n    def updateM(self,change):\n        for irow in range(0,self.n):\n            for icol in range(0,self.m):\n                self.M_[irow,icol] = self.children[irow].children[icol].value\n                #print(self.M_[irow,icol])\n        self.value = self.M_\n\n    def dummychangecallback(self,change):\n        pass\n    \n    \n    def __init__(self,n,m):\n        self.n = n\n        self.m = m\n        self.M_ = numpy.matrix(numpy.zeros((self.n,self.m)))\n        self.value = self.M_\n        widgets.VBox.__init__(self,\n                             children = [\n                                 widgets.HBox(children = \n                                              [widgets.FloatText(value=0.0, layout=widgets.Layout(width='90px')) for i in range(m)]\n                                             ) \n                                 for j in range(n)\n                             ])\n        \n        #fill in widgets and tell interact to call updateM each time a children changes value\n        for irow in range(0,self.n):\n            for icol in range(0,self.m):\n                self.children[irow].children[icol].value = self.M_[irow,icol]\n                self.children[irow].children[icol].observe(self.updateM, names='value')\n        #value = Unicode('example@example.com', help=\"The email value.\").tag(sync=True)\n        self.observe(self.updateM, names='value', type= 'All')\n        \n    def setM(self, newM):\n        #disable callbacks, change values, and reenable\n        self.unobserve(self.updateM, names='value', type= 'All')\n        for irow in range(0,self.n):\n            for icol in range(0,self.m):\n                self.children[irow].children[icol].unobserve(self.updateM, names='value')\n        self.M_ = newM\n        self.value = self.M_\n        for irow in range(0,self.n):\n            for icol in range(0,self.m):\n                self.children[irow].children[icol].value = self.M_[irow,icol]\n        for irow in range(0,self.n):\n            for icol in range(0,self.m):\n                self.children[irow].children[icol].observe(self.updateM, names='value')\n        self.observe(self.updateM, names='value', type= 'All')        \n\n                #self.children[irow].children[icol].observe(self.updateM, names='value')\n\n             \n#overlaod class for state space systems that DO NOT remove \"useless\" states (what \"professor\" of automatic control would do this?)\nclass sss(control.StateSpace):\n    def __init__(self,*args):\n        #call base class init constructor\n        control.StateSpace.__init__(self,*args)\n    #disable function below in base class\n    def _remove_useless_states(self):\n        pass\n\n\n# Preparatory cell\n\nA = numpy.matrix([[0.,1.],[-1.,-2.]])\nX0 = numpy.matrix([[0.],[0.]])\n\nAw = matrixWidget(2,2)\nAw.setM(A)\nX0w = matrixWidget(2,1)\nX0w.setM(X0)\n\n\n# Misc\n\n#create dummy widget \nDW = widgets.FloatText(layout=widgets.Layout(width='0px', height='0px'))\n\n#create button widget\nSTART = widgets.Button(\n    description='Test',\n    disabled=False,\n    button_style='', # 'success', 'info', 'warning', 'danger' or ''\n    tooltip='Test',\n    icon='check'\n)\n                       \ndef on_start_button_clicked(b):\n    #This is a workaround to have intreactive_output call the callback:\n    #   force the value of the dummy widget to change\n    if DW.value&gt; 0 :\n        DW.value = -1\n    else: \n        DW.value = 1\n    pass\nSTART.on_click(on_start_button_clicked)\n\n\n# Main cell\n\ndef main_callback(A, X0, DW):\n    sols = numpy.linalg.eig(A)\n    sys = sss(A,[[0],[1]],[1,0],0)\n    pole = control.pole(sys)\n    if numpy.real(pole[0]) != 0:\n        p1r = abs(numpy.real(pole[0]))\n    else:\n        p1r = 1\n    if numpy.real(pole[1]) != 0:\n        p2r = abs(numpy.real(pole[1]))\n    else:\n        p2r = 1\n    if numpy.imag(pole[0]) != 0:\n        p1i = abs(numpy.imag(pole[0]))\n    else:\n        p1i = 1\n    if numpy.imag(pole[1]) != 0:\n        p2i = abs(numpy.imag(pole[1]))\n    else:\n        p2i = 1\n    \n    print('A\\'s eigenvalues are:',round(sols[0][0],4),'and',round(sols[0][1],4))\n    \n    #T = numpy.linspace(0, 60, 1000)\n    T, yout, xout = control.initial_response(sys,X0=X0,return_x=True)\n    \n    fig = plt.figure(\"Free response\", figsize=(16,5))\n    ax = fig.add_subplot(121)\n    plt.plot(T,xout[0])\n    plt.grid()\n    ax.set_xlabel('time [s]')\n    ax.set_ylabel(r'$x_1$')\n\n    ax1 = fig.add_subplot(122)\n    plt.plot(T,xout[1])\n    plt.grid()\n    ax1.set_xlabel('time [s]')\n    ax1.set_ylabel(r'$x_2$')\n\n    \n\n    \nalltogether = widgets.HBox([widgets.VBox([widgets.Label('$A$:',border=3),\n                                          Aw]),\n                                          widgets.Label('   ',border=3),\n                            widgets.VBox([widgets.Label('$X_0$:',border=3),\n                                          X0w]),\n                                          START])\nout = widgets.interactive_output(main_callback, {'A':Aw, 'X0':X0w, 'DW':DW})\nout.layout.height = '400px'\ndisplay(out, alltogether)\n\n\n\n\n\n\n\n\n#create dummy widget 2\nDW2 = widgets.FloatText(layout=widgets.Layout(width='0px', height='0px'))\nDW2.value = -1\n\n#create button widget\nSTART2 = widgets.Button(\n    description='Show answers',\n    disabled=False,\n    button_style='', # 'success', 'info', 'warning', 'danger' or ''\n    tooltip='Click for view the answers',\n    icon='check'\n)\n                       \ndef on_start_button_clicked2(b):\n    #This is a workaround to have intreactive_output call the callback:\n    #   force the value of the dummy widget to change\n    if DW2.value&gt; 0 :\n        DW2.value = -1\n    else: \n        DW2.value = 1\n    pass\nSTART2.on_click(on_start_button_clicked2)\n\ndef main_callback2(DW2):\n    if DW2 &gt; 0:\n        display(Markdown(r'''&gt;Answer: The initial state must be a linear combination of only the eigenvectors associated to the stable poles.\n        $$ $$\n        Example:\n        $$\n        A = \\begin{bmatrix} 3 & 1 \\\\ 0 & -2 \\end{bmatrix}, \\quad x_0 = \\begin{bmatrix} -\\frac{1}{5} \\\\ 1 \\end{bmatrix} \\text{where $x_0$ is the eigenvector associated to the stable pole $-2$ .}\n        $$'''))\n    else:\n        display(Markdown(''))\n\n#create a graphic structure to hold all widgets \nalltogether2 =  widgets.VBox([START2])\n\nout2 = widgets.interactive_output(main_callback2,{'DW2':DW2})\n#out.layout.height = '300px'\ndisplay(out2,alltogether2)"
  },
  {
    "objectID": "ICCT_en/examples/04/SS-18-Internal_stability_example_1.html",
    "href": "ICCT_en/examples/04/SS-18-Internal_stability_example_1.html",
    "title": "Internal stability example 1",
    "section": "",
    "text": "# Erasmus+ ICCT project (2018-1-SI01-KA203-047081)\n\n# Toggle cell visibility\n\nfrom IPython.display import HTML\ntag = HTML('''&lt;script&gt;\ncode_show=true; \nfunction code_toggle() {\n    if (code_show){\n        $('div.input').hide()\n    } else {\n        $('div.input').show()\n    }\n    code_show = !code_show\n} \n$( document ).ready(code_toggle);\n&lt;/script&gt;\nToggle cell visibility &lt;a href=\"javascript:code_toggle()\"&gt;here&lt;/a&gt;.''')\ndisplay(tag)\n\n# Hide the code completely\n\n# from IPython.display import HTML\n# tag = HTML('''&lt;style&gt;\n# div.input {\n#     display:none;\n# }\n# &lt;/style&gt;''')\n# display(tag)\n\n\nToggle cell visibility here.\n\n\n\nHow to use this notebook?\nGiven the stable system below, try to obtain a divergent response by changing only the initial conditions.\n\\[\n\\dot{x} = \\underbrace{\\begin{bmatrix}0&1\\\\-0.8&-0.5\\end{bmatrix}}_{A}x\n\\]\nTry to answer: - Is it possible to achieve divergent response for this system? - Is it possible to achieve it for any other stable system?\n\n%matplotlib inline\nimport control as control\nimport numpy\nimport sympy as sym\nfrom IPython.display import display, Markdown\nimport ipywidgets as widgets\nimport matplotlib.pyplot as plt\n\n#matrixWidget is a matrix looking widget built with a VBox of HBox(es) that returns a numPy array as value !\nclass matrixWidget(widgets.VBox):\n    def updateM(self,change):\n        for irow in range(0,self.n):\n            for icol in range(0,self.m):\n                self.M_[irow,icol] = self.children[irow].children[icol].value\n                #print(self.M_[irow,icol])\n        self.value = self.M_\n\n    def dummychangecallback(self,change):\n        pass\n    \n    \n    def __init__(self,n,m):\n        self.n = n\n        self.m = m\n        self.M_ = numpy.matrix(numpy.zeros((self.n,self.m)))\n        self.value = self.M_\n        widgets.VBox.__init__(self,\n                             children = [\n                                 widgets.HBox(children = \n                                              [widgets.FloatText(value=0.0, layout=widgets.Layout(width='90px')) for i in range(m)]\n                                             ) \n                                 for j in range(n)\n                             ])\n        \n        #fill in widgets and tell interact to call updateM each time a children changes value\n        for irow in range(0,self.n):\n            for icol in range(0,self.m):\n                self.children[irow].children[icol].value = self.M_[irow,icol]\n                self.children[irow].children[icol].observe(self.updateM, names='value')\n        #value = Unicode('example@example.com', help=\"The email value.\").tag(sync=True)\n        self.observe(self.updateM, names='value', type= 'All')\n        \n    def setM(self, newM):\n        #disable callbacks, change values, and reenable\n        self.unobserve(self.updateM, names='value', type= 'All')\n        for irow in range(0,self.n):\n            for icol in range(0,self.m):\n                self.children[irow].children[icol].unobserve(self.updateM, names='value')\n        self.M_ = newM\n        self.value = self.M_\n        for irow in range(0,self.n):\n            for icol in range(0,self.m):\n                self.children[irow].children[icol].value = self.M_[irow,icol]\n        for irow in range(0,self.n):\n            for icol in range(0,self.m):\n                self.children[irow].children[icol].observe(self.updateM, names='value')\n        self.observe(self.updateM, names='value', type= 'All')        \n\n                #self.children[irow].children[icol].observe(self.updateM, names='value')\n\n             \n#overlaod class for state space systems that DO NOT remove \"useless\" states (what \"professor\" of automatic control would do this?)\nclass sss(control.StateSpace):\n    def __init__(self,*args):\n        #call base class init constructor\n        control.StateSpace.__init__(self,*args)\n    #disable function below in base class\n    def _remove_useless_states(self):\n        pass\n\n\n# Preparatory cell\n\nA = numpy.matrix([[0.,1.],[-4.0/5.0,-5.0/10.0]])\nX0 = numpy.matrix([[0.0],[0.0]])\n\nAw = matrixWidget(2,2)\nAw.setM(A)\nX0w = matrixWidget(2,1)\nX0w.setM(X0)\n\n\n# Misc\n\n#create dummy widget \nDW = widgets.FloatText(layout=widgets.Layout(width='0px', height='0px'))\n\n#create button widget\nSTART = widgets.Button(\n    description='Test',\n    disabled=False,\n    button_style='', # 'success', 'info', 'warning', 'danger' or ''\n    tooltip='Test',\n    icon='check'\n)\n                       \ndef on_start_button_clicked(b):\n    #This is a workaround to have intreactive_output call the callback:\n    #   force the value of the dummy widget to change\n    if DW.value&gt; 0 :\n        DW.value = -1\n    else: \n        DW.value = 1\n    pass\nSTART.on_click(on_start_button_clicked)\n\n\n# Main cell\n\ndef main_callback(A, X0, DW):\n    sols = numpy.linalg.eig(A)\n    sys = sss(A,[[1],[0]],[0,1],0)\n    pole = control.pole(sys)\n    if numpy.real(pole[0]) != 0:\n        p1r = abs(numpy.real(pole[0]))\n    else:\n        p1r = 1\n    if numpy.real(pole[1]) != 0:\n        p2r = abs(numpy.real(pole[1]))\n    else:\n        p2r = 1\n    if numpy.imag(pole[0]) != 0:\n        p1i = abs(numpy.imag(pole[0]))\n    else:\n        p1i = 1\n    if numpy.imag(pole[1]) != 0:\n        p2i = abs(numpy.imag(pole[1]))\n    else:\n        p2i = 1\n    \n    print('A\\'s eigenvalues are:',round(sols[0][0],4),'and',round(sols[0][1],4))\n    \n    #T = numpy.linspace(0, 60, 1000)\n    T, yout, xout = control.initial_response(sys,X0=X0,return_x=True)\n    \n    fig = plt.figure(\"Free response\", figsize=(16,5))\n    ax = fig.add_subplot(121)\n    plt.plot(T,xout[0])\n    plt.grid()\n    ax.set_xlabel('time [s]')\n    ax.set_ylabel(r'$x_1$')\n\n    ax1 = fig.add_subplot(122)\n    plt.plot(T,xout[1])\n    plt.grid()\n    ax1.set_xlabel('time [s]')\n    ax1.set_ylabel(r'$x_2$')\n\n    \n\n    \nalltogether = widgets.HBox([widgets.VBox([widgets.Label('$A$:',border=3),\n                                          Aw]),\n                                          widgets.Label('   ',border=3),\n                            widgets.VBox([widgets.Label('$X_0$:',border=3),\n                                          X0w]),\n                                          START])\nout = widgets.interactive_output(main_callback, {'A':Aw, 'X0':X0w, 'DW':DW})\nout.layout.height = '350px'\ndisplay(out, alltogether)\n\n\n\n\n\n\n\n\n#create dummy widget 2\nDW2 = widgets.FloatText(layout=widgets.Layout(width='0px', height='0px'))\nDW2.value = -1\n\n#create button widget\nSTART2 = widgets.Button(\n    description='Show answers',\n    disabled=False,\n    button_style='', # 'success', 'info', 'warning', 'danger' or ''\n    tooltip='Click for view the answers',\n    icon='check'\n)\n                       \ndef on_start_button_clicked2(b):\n    #This is a workaround to have intreactive_output call the callback:\n    #   force the value of the dummy widget to change\n    if DW2.value&gt; 0 :\n        DW2.value = -1\n    else: \n        DW2.value = 1\n    pass\nSTART2.on_click(on_start_button_clicked2)\n\ndef main_callback2(DW2):\n    if DW2 &gt; 0:\n        display(Markdown(r'''&gt;Answer: System Free response depends only on the eigenvalues of the $A$ matrix and is a linear combination of its modes. Since the system is stable, it has only limited and convergent modes, so, whatever the initial conditions are, the response remains limited in time.'''))\n    else:\n        display(Markdown(''))\n\n#create a graphic structure to hold all widgets \nalltogether2 =  widgets.VBox([START2])\n\nout2 = widgets.interactive_output(main_callback2,{'DW2':DW2})\n#out.layout.height = '300px'\ndisplay(out2,alltogether2)"
  },
  {
    "objectID": "ICCT_en/examples/04/SS-16-Equilibrium_points_example_3.html",
    "href": "ICCT_en/examples/04/SS-16-Equilibrium_points_example_3.html",
    "title": "Infinite Equilibrium Points 3",
    "section": "",
    "text": "# Erasmus+ ICCT project (2018-1-SI01-KA203-047081)\n\n# Toggle cell visibility\n\nfrom IPython.display import HTML\ntag = HTML('''&lt;script&gt;\ncode_show=true; \nfunction code_toggle() {\n    if (code_show){\n        $('div.input').hide()\n    } else {\n        $('div.input').show()\n    }\n    code_show = !code_show\n} \n$( document ).ready(code_toggle);\n&lt;/script&gt;\nToggle cell visibility &lt;a href=\"javascript:code_toggle()\"&gt;here&lt;/a&gt;.''')\ndisplay(tag)\n\n# Hide the code completely\n\n# from IPython.display import HTML\n# tag = HTML('''&lt;style&gt;\n# div.input {\n#     display:none;\n# }\n# &lt;/style&gt;''')\n# display(tag)\n\n\nToggle cell visibility here.\n\n\nThis interactive example shows a \\(2\\times2\\) system that has the equilibrium points lying on the line \\(x_1=-x_2\\) (for the underlying theory refer to example Equilibrium points).\nIn order to have the line \\(x_1=-x_2\\) as equilibrium points’ space, it is necessary that: \\[\nA\\bar{x}=0 \\quad \\forall \\, \\bar{x}\\in\\begin{bmatrix} \\alpha \\\\ -\\alpha\\end{bmatrix} \\, \\text{with} \\, \\alpha\\in\\mathbb{R},\n\\] thus, \\(\\begin{bmatrix} \\alpha \\\\ -\\alpha\\end{bmatrix}\\) has to belong to the \\(A\\)’s nullspace.\n\nHow to use this notebook?\n\nModify matrix \\(A\\) directly to see how the equilibrium points change.\nTry to modify \\(A\\) so that the equilibrium points lie on the requested set.\n\n\n#Preparatory Cell \n\nimport control\nimport numpy\nfrom IPython.display import display, Markdown\nimport ipywidgets as widgets\nimport matplotlib.pyplot as plt\nimport sympy as sym\n\n#print a matrix latex-like\ndef bmatrix(a):\n     \"\"\"Returns a LaTeX bmatrix - by Damir Arbula (ICCT project)\n\n     :a: numpy array\n     :returns: LaTeX bmatrix as a string\n     \"\"\"\n     if len(a.shape) &gt; 2:\n         raise ValueError('bmatrix can at most display two dimensions')\n     lines = str(a).replace('[', '').replace(']', '').splitlines()\n     rv = [r'\\begin{bmatrix}']\n     rv += ['  ' + ' & '.join(l.split()) + r'\\\\' for l in lines]\n     rv +=  [r'\\end{bmatrix}']\n     return '\\n'.join(rv)\n\n\n# Display formatted matrix: \ndef vmatrix(a):\n    if len(a.shape) &gt; 2:\n         raise ValueError('bmatrix can at most display two dimensions')\n    lines = str(a).replace('[', '').replace(']', '').splitlines()\n    rv = [r'\\begin{vmatrix}']\n    rv += ['  ' + ' & '.join(l.split()) + r'\\\\' for l in lines]\n    rv +=  [r'\\end{vmatrix}']\n    return '\\n'.join(rv)\n\n\n#create a NxM matrix widget \ndef createMatrixWidget(n,m):\n    M = widgets.GridBox(children=[widgets.FloatText(layout=widgets.Layout(width='100px', height='40px'),\n    value=0.0, disabled=False, label=i) for i in range(n*m)],\n    layout=widgets.Layout(\n        #width='50%',\n        grid_template_columns= ''.join(['100px ' for i in range(m)]),\n        #grid_template_rows='80px 80px 80px',\n        grid_row_gap='0px',\n        track_size='0px')\n    )\n    return M\n\n\n#extract matrix from widgets and convert to numpy matrix\ndef getNumpyMatFromWidget(M,n,m):\n    #get W gridbox dims\n    M_ = numpy.matrix(numpy.zeros((n,m)))\n    for irow in range(0,n):\n        for icol in range(0,m):\n            M_[irow,icol] = M.children[irow*3+icol].value\n\n            \n#this is a simple derived class from FloatText used to experience with interact             \nclass floatWidget(widgets.FloatText):\n    def __init__(self,**kwargs):\n        #self.n = n\n        self.value = 30.0\n        #self.M = \n        widgets.FloatText.__init__(self, **kwargs)\n\n#    def value(self):\n#        return 0 #self.FloatText.value\n\nfrom traitlets import Unicode\nfrom ipywidgets import register \n\n\n#matrixWidget is a matrix looking widget built with a VBox of HBox(es) that returns a numPy array as value !\nclass matrixWidget(widgets.VBox):\n    def updateM(self,change):\n        for irow in range(0,self.n):\n            for icol in range(0,self.m):\n                self.M_[irow,icol] = self.children[irow].children[icol].value\n                #print(self.M_[irow,icol])\n        self.value = self.M_\n\n    def dummychangecallback(self,change):\n        pass\n    \n    \n    def __init__(self,n,m):\n        self.n = n\n        self.m = m\n        self.M_ = numpy.matrix(numpy.zeros((self.n,self.m)))\n        self.value = self.M_\n        widgets.VBox.__init__(self,\n                             children = [\n                                 widgets.HBox(children = \n                                              [widgets.FloatText(value=0.0, layout=widgets.Layout(width='90px')) for i in range(m)]\n                                             ) \n                                 for j in range(n)\n                             ])\n        \n        #fill in widgets and tell interact to call updateM each time a children changes value\n        for irow in range(0,self.n):\n            for icol in range(0,self.m):\n                self.children[irow].children[icol].value = self.M_[irow,icol]\n                self.children[irow].children[icol].observe(self.updateM, names='value')\n        #value = Unicode('example@example.com', help=\"The email value.\").tag(sync=True)\n        self.observe(self.updateM, names='value', type= 'All')\n        \n    def setM(self, newM):\n        #disable callbacks, change values, and reenable\n        self.unobserve(self.updateM, names='value', type= 'All')\n        for irow in range(0,self.n):\n            for icol in range(0,self.m):\n                self.children[irow].children[icol].unobserve(self.updateM, names='value')\n        self.M_ = newM\n        self.value = self.M_\n        for irow in range(0,self.n):\n            for icol in range(0,self.m):\n                self.children[irow].children[icol].value = self.M_[irow,icol]\n        for irow in range(0,self.n):\n            for icol in range(0,self.m):\n                self.children[irow].children[icol].observe(self.updateM, names='value')\n        self.observe(self.updateM, names='value', type= 'All')        \n\n                #self.children[irow].children[icol].observe(self.updateM, names='value')\n\n        \n\n        \n#overlaod class for state space systems that DO NOT remove \"useless\" states (what \"professor\" of automatic control would do this?)\nclass sss(control.StateSpace):\n    def __init__(self,*args):\n        #call base class init constructor\n        control.StateSpace.__init__(self,*args)\n    #disable function below in base class\n    def _remove_useless_states(self):\n        pass\n\n\n#define the matrixes\nA=matrixWidget(2,2)\nA.setM(numpy.matrix('1. 0.; 0. 1.'))\n\ndef main_callback(matA,DW):\n    \n    As = sym.Matrix(matA)\n    NAs = As.nullspace()\n    \n    t = numpy.linspace(-10,10,1000)\n    if len(NAs) == 1:\n        eq1 = [t[i]*numpy.matrix(NAs[0]) for i in range(0,len(t))]\n        x1 = [eq1[i][0,0] for i in range(0,len(t))]\n        x2 = [eq1[i][1,0] for i in range(0,len(t))]\n    \n    fig = plt.figure(figsize=(6,6))\n    if len(NAs) == 0:\n        plt.plot(0,0,'bo')\n    if len(NAs) == 1:\n        plt.plot(x1,x2)\n    if len(NAs) == 2:\n        plt.fill((-5,-5,5,5),(-5,5,5,-5),alpha=0.5)\n        plt.xlim(left=-5,right=5)\n        plt.ylim(top=5,bottom=-5)\n    plt.grid()\n    plt.xlabel('$x_1$')\n    plt.ylabel('$x_2$')\n    print('A base for A\\'s nullspace (by row) is %s. \\nThe eigenvalues are %s' %(str(numpy.array(NAs)),\n                                                                          str(numpy.linalg.eig(matA)[0])))\n\n\n#create dummy widget \nDW = widgets.FloatText(layout=widgets.Layout(width='0px', height='0px'))\n\n#create button widget\nSTART = widgets.Button(\n    description='Test',\n    disabled=False,\n    button_style='', # 'success', 'info', 'warning', 'danger' or ''\n    tooltip='Test',\n    icon='check'\n)\n                       \ndef on_start_button_clicked(b):\n    #This is a workaround to have intreactive_output call the callback:\n    #   force the value of the dummy widget to change\n    if DW.value&gt; 0 :\n        DW.value = -1\n    else: \n        DW.value = 1\n    pass\nSTART.on_click(on_start_button_clicked)\n\nout = widgets.interactive_output(main_callback,{'matA':A,'DW':DW})\nout1 = widgets.HBox([out,\n                     widgets.VBox([widgets.Label(''),widgets.Label(''),widgets.Label(''),widgets.Label('$\\qquad \\qquad A=$')]),\n                     widgets.VBox([widgets.Label(''),widgets.Label(''),widgets.Label(''),A,START])])\nout.layout.height = '450px'\ndisplay(out1)\n\n\n\n\n\n#create dummy widget 2\nDW2 = widgets.FloatText(layout=widgets.Layout(width='0px', height='0px'))\nDW2.value = -1\n\n#create button widget\nSTART2 = widgets.Button(\n    description='Show answers',\n    disabled=False,\n    button_style='', # 'success', 'info', 'warning', 'danger' or ''\n    tooltip='Click for view the answers',\n    icon='check'\n)\n                       \ndef on_start_button_clicked2(b):\n    #This is a workaround to have intreactive_output call the callback:\n    #   force the value of the dummy widget to change\n    if DW2.value&gt; 0 :\n        DW2.value = -1\n    else: \n        DW2.value = 1\n    pass\nSTART2.on_click(on_start_button_clicked2)\n\ndef main_callback2(DW2):\n    if DW2 &gt; 0:\n        display(Markdown(r'''Answer:\nTo construct the matrix, it is possible to choose row vectors that are orthogonal with respect to the nullspace. A possible matrix is therefore:\n$$\nA=\\begin{bmatrix} 1 & 1 \\\\ 2 & 2 \\end{bmatrix}.\n$$'''))\n    else:\n        display(Markdown(''))\n\n#create a graphic structure to hold all widgets \nalltogether2 =  widgets.VBox([START2])\n\nout2 = widgets.interactive_output(main_callback2,{'DW2':DW2})\n#out.layout.height = '300px'\ndisplay(out2,alltogether2)"
  },
  {
    "objectID": "ICCT_en/examples/04/SS-14-Equilibrium_points_example_1.html",
    "href": "ICCT_en/examples/04/SS-14-Equilibrium_points_example_1.html",
    "title": "Infinite Equilibrium Points 1",
    "section": "",
    "text": "# Erasmus+ ICCT project (2018-1-SI01-KA203-047081)\n\n# Toggle cell visibility\n\nfrom IPython.display import HTML\ntag = HTML('''&lt;script&gt;\ncode_show=true; \nfunction code_toggle() {\n    if (code_show){\n        $('div.input').hide()\n    } else {\n        $('div.input').show()\n    }\n    code_show = !code_show\n} \n$( document ).ready(code_toggle);\n&lt;/script&gt;\nToggle cell visibility &lt;a href=\"javascript:code_toggle()\"&gt;here&lt;/a&gt;.''')\ndisplay(tag)\n\n# Hide the code completely\n\n# from IPython.display import HTML\n# tag = HTML('''&lt;style&gt;\n# div.input {\n#     display:none;\n# }\n# &lt;/style&gt;''')\n# display(tag)\n\n\nToggle cell visibility here.\n\n\nThis interactive example shows a \\(2\\times2\\) system that has infinite equilibrium points lying on the \\(x_1\\) axis (for the underlying theory refer to example Equilibrium points).\nIn order to have the line \\(x_2=0\\) as equilibrium points’ space, it is necessary that: \\[\nA\\bar{x}=0 \\quad \\forall \\, \\bar{x}\\in\\begin{bmatrix} \\alpha \\\\ 0\\end{bmatrix} \\, \\text{with} \\, \\alpha\\in\\mathbb{R},\n\\] thus, \\(\\begin{bmatrix} \\alpha \\\\ 0\\end{bmatrix}\\) has to belong to the \\(A\\)’s nullspace.\n\nHow to use this notebook?\n\nModify matrix \\(A\\) directly to see how the equilibrium points change.\nTry to modify \\(A\\) so that the equilibrium points lie on the \\(x_1\\) axis.\nLook at the eigenvalues of \\(A\\). Can you obtain infinite equilibrium points without having an eigenvalue in 0 ?\n\n\n#Preparatory Cell \n\nimport control\nimport numpy\nfrom IPython.display import display, Markdown\nimport ipywidgets as widgets\nimport matplotlib.pyplot as plt\nimport sympy as sym\n\n#print a matrix latex-like\ndef bmatrix(a):\n     \"\"\"Returns a LaTeX bmatrix - by Damir Arbula (ICCT project)\n\n     :a: numpy array\n     :returns: LaTeX bmatrix as a string\n     \"\"\"\n     if len(a.shape) &gt; 2:\n         raise ValueError('bmatrix can at most display two dimensions')\n     lines = str(a).replace('[', '').replace(']', '').splitlines()\n     rv = [r'\\begin{bmatrix}']\n     rv += ['  ' + ' & '.join(l.split()) + r'\\\\' for l in lines]\n     rv +=  [r'\\end{bmatrix}']\n     return '\\n'.join(rv)\n\n\n# Display formatted matrix: \ndef vmatrix(a):\n    if len(a.shape) &gt; 2:\n         raise ValueError('bmatrix can at most display two dimensions')\n    lines = str(a).replace('[', '').replace(']', '').splitlines()\n    rv = [r'\\begin{vmatrix}']\n    rv += ['  ' + ' & '.join(l.split()) + r'\\\\' for l in lines]\n    rv +=  [r'\\end{vmatrix}']\n    return '\\n'.join(rv)\n\n\n#create a NxM matrix widget \ndef createMatrixWidget(n,m):\n    M = widgets.GridBox(children=[widgets.FloatText(layout=widgets.Layout(width='100px', height='40px'),\n    value=0.0, disabled=False, label=i) for i in range(n*m)],\n    layout=widgets.Layout(\n        #width='50%',\n        grid_template_columns= ''.join(['100px ' for i in range(m)]),\n        #grid_template_rows='80px 80px 80px',\n        grid_row_gap='0px',\n        track_size='0px')\n    )\n    return M\n\n\n#extract matrix from widgets and convert to numpy matrix\ndef getNumpyMatFromWidget(M,n,m):\n    #get W gridbox dims\n    M_ = numpy.matrix(numpy.zeros((n,m)))\n    for irow in range(0,n):\n        for icol in range(0,m):\n            M_[irow,icol] = M.children[irow*3+icol].value\n\n            \n#this is a simple derived class from FloatText used to experience with interact             \nclass floatWidget(widgets.FloatText):\n    def __init__(self,**kwargs):\n        #self.n = n\n        self.value = 30.0\n        #self.M = \n        widgets.FloatText.__init__(self, **kwargs)\n\n#    def value(self):\n#        return 0 #self.FloatText.value\n\nfrom traitlets import Unicode\nfrom ipywidgets import register \n\n\n#matrixWidget is a matrix looking widget built with a VBox of HBox(es) that returns a numPy array as value !\nclass matrixWidget(widgets.VBox):\n    def updateM(self,change):\n        for irow in range(0,self.n):\n            for icol in range(0,self.m):\n                self.M_[irow,icol] = self.children[irow].children[icol].value\n                #print(self.M_[irow,icol])\n        self.value = self.M_\n\n    def dummychangecallback(self,change):\n        pass\n    \n    \n    def __init__(self,n,m):\n        self.n = n\n        self.m = m\n        self.M_ = numpy.matrix(numpy.zeros((self.n,self.m)))\n        self.value = self.M_\n        widgets.VBox.__init__(self,\n                             children = [\n                                 widgets.HBox(children = \n                                              [widgets.FloatText(value=0.0, layout=widgets.Layout(width='90px')) for i in range(m)]\n                                             ) \n                                 for j in range(n)\n                             ])\n        \n        #fill in widgets and tell interact to call updateM each time a children changes value\n        for irow in range(0,self.n):\n            for icol in range(0,self.m):\n                self.children[irow].children[icol].value = self.M_[irow,icol]\n                self.children[irow].children[icol].observe(self.updateM, names='value')\n        #value = Unicode('example@example.com', help=\"The email value.\").tag(sync=True)\n        self.observe(self.updateM, names='value', type= 'All')\n        \n    def setM(self, newM):\n        #disable callbacks, change values, and reenable\n        self.unobserve(self.updateM, names='value', type= 'All')\n        for irow in range(0,self.n):\n            for icol in range(0,self.m):\n                self.children[irow].children[icol].unobserve(self.updateM, names='value')\n        self.M_ = newM\n        self.value = self.M_\n        for irow in range(0,self.n):\n            for icol in range(0,self.m):\n                self.children[irow].children[icol].value = self.M_[irow,icol]\n        for irow in range(0,self.n):\n            for icol in range(0,self.m):\n                self.children[irow].children[icol].observe(self.updateM, names='value')\n        self.observe(self.updateM, names='value', type= 'All')        \n\n                #self.children[irow].children[icol].observe(self.updateM, names='value')\n\n        \n\n        \n#overlaod class for state space systems that DO NOT remove \"useless\" states (what \"professor\" of automatic control would do this?)\nclass sss(control.StateSpace):\n    def __init__(self,*args):\n        #call base class init constructor\n        control.StateSpace.__init__(self,*args)\n    #disable function below in base class\n    def _remove_useless_states(self):\n        pass\n\n\n\n#define the matrixes\nA=matrixWidget(2,2)\nA.setM(numpy.matrix('1. 0.; 0. 1.'))\n\ndef main_callback(matA,DW):\n    \n    As = sym.Matrix(matA)\n    NAs = As.nullspace()\n    \n    t = numpy.linspace(-10,10,1000)\n    if len(NAs) == 1:\n        eq1 = [t[i]*numpy.matrix(NAs[0]) for i in range(0,len(t))]\n        x1 = [eq1[i][0,0] for i in range(0,len(t))]\n        x2 = [eq1[i][1,0] for i in range(0,len(t))]\n    \n    fig = plt.figure(figsize=(6,6))\n    if len(NAs) == 0:\n        plt.plot(0,0,'bo')\n    if len(NAs) == 1:\n        plt.plot(x1,x2)\n    if len(NAs) == 2:\n        plt.fill((-5,-5,5,5),(-5,5,5,-5),alpha=0.5)\n        plt.xlim(left=-5,right=5)\n        plt.ylim(top=5,bottom=-5)\n    plt.grid()\n    plt.xlabel('$x_1$')\n    plt.ylabel('$x_2$')\n    print('A base for A\\'s nullspace (by row) is %s. \\nThe eigenvalues are %s' %(str(numpy.array(NAs)),\n                                                                          str(numpy.linalg.eig(matA)[0])))\n\n\n#create dummy widget \nDW = widgets.FloatText(layout=widgets.Layout(width='0px', height='0px'))\n\n#create button widget\nSTART = widgets.Button(\n    description='Test',\n    disabled=False,\n    button_style='', # 'success', 'info', 'warning', 'danger' or ''\n    tooltip='Test',\n    icon='check'\n)\n                       \ndef on_start_button_clicked(b):\n    #This is a workaround to have intreactive_output call the callback:\n    #   force the value of the dummy widget to change\n    if DW.value&gt; 0 :\n        DW.value = -1\n    else: \n        DW.value = 1\n    pass\nSTART.on_click(on_start_button_clicked)\n\nout = widgets.interactive_output(main_callback,{'matA':A,'DW':DW})\nout1 = widgets.HBox([out,\n                     widgets.VBox([widgets.Label(''),widgets.Label(''),widgets.Label(''),widgets.Label('$\\qquad \\qquad A=$')]),\n                     widgets.VBox([widgets.Label(''),widgets.Label(''),widgets.Label(''),A,START])])\nout.layout.height = '450px'\ndisplay(out1)\n\n\n\n\n\n#create dummy widget 2\nDW2 = widgets.FloatText(layout=widgets.Layout(width='0px', height='0px'))\nDW2.value = -1\n\n#create button widget\nSTART2 = widgets.Button(\n    description='Show answers',\n    disabled=False,\n    button_style='', # 'success', 'info', 'warning', 'danger' or ''\n    tooltip='Click for view the answers',\n    icon='check'\n)\n                       \ndef on_start_button_clicked2(b):\n    #This is a workaround to have intreactive_output call the callback:\n    #   force the value of the dummy widget to change\n    if DW2.value&gt; 0 :\n        DW2.value = -1\n    else: \n        DW2.value = 1\n    pass\nSTART2.on_click(on_start_button_clicked2)\n\ndef main_callback2(DW2):\n    if DW2 &gt; 0:\n        display(Markdown(r'''Answer: \nTo construct the matrix it is possible to choose row vectors that are orthogonal with respect to the nullspace. A possible matrix is therefore:  \n\n$$\nA=\\begin{bmatrix} 0 & 1 \\\\ 0 & 1 \\end{bmatrix}.\n$$'''))\n    else:\n        display(Markdown(''))\n\n#create a graphic structure to hold all widgets \nalltogether2 =  widgets.VBox([START2])\n\nout2 = widgets.interactive_output(main_callback2,{'DW2':DW2})\n#out.layout.height = '300px'\ndisplay(out2,alltogether2)"
  },
  {
    "objectID": "ICCT_en/examples/04/SS-12-Modal_analysis_of_the_lunar_lander.html",
    "href": "ICCT_en/examples/04/SS-12-Modal_analysis_of_the_lunar_lander.html",
    "title": "Modal analysis of the lunar lander",
    "section": "",
    "text": "# Erasmus+ ICCT project (2018-1-SI01-KA203-047081)\n\n# Toggle cell visibility\n\nfrom IPython.display import HTML\ntag = HTML('''&lt;script&gt;\ncode_show=true; \nfunction code_toggle() {\n    if (code_show){\n        $('div.input').hide()\n    } else {\n        $('div.input').show()\n    }\n    code_show = !code_show\n} \n$( document ).ready(code_toggle);\n&lt;/script&gt;\nToggle cell visibility &lt;a href=\"javascript:code_toggle()\"&gt;here&lt;/a&gt;.''')\ndisplay(tag)\n\n# Hide the code completely\n\n# from IPython.display import HTML\n# tag = HTML('''&lt;style&gt;\n# div.input {\n#     display:none;\n# }\n# &lt;/style&gt;''')\n# display(tag)\n\n\nToggle cell visibility here.\n\n\nThe dynamic matrix \\(A\\) that represents the Lunar Lander dynamics is (see example Lunar lander lateral position dynamics for more details):\n\\[\nA=\\begin{bmatrix}0&1&0&0 \\\\ 0&0&F/m&0 \\\\ 0&0&0&1 \\\\ 0&0&0&0\\end{bmatrix},\n\\]\nwhere \\(F\\) is the thrust force and \\(m\\) the mass of the lander. The state of the system is \\(x=[z,\\dot{z},\\theta,\\dot{\\theta}]^T\\), where \\(z\\) is the lateral position, \\(\\dot{z}\\) the time variation of the lateral position, \\(\\theta\\) the orientation angle of the lander with respect the vertical and \\(\\dot{\\theta}\\) its variation in time.\nThe dynamic matrix in this form shows four eigenvalues, all equal to 0. Eigenvalues 0 are often called integrators (recall the Laplace Transform of a the integral of a signal: what is the root of the denominator of its expression?), thus this system is said to have 4 integrators. With \\(F\\neq0\\) (\\(m\\neq0\\)) the system presents a structure that is similar to a \\(4\\times4\\) Jordan block, so the eigenvalue 0, in this case, has a geometrical multiplicity equal to 1. With \\(F=0\\) the eigenvalue remains the same with the same algebraic multiplicity but with a geometrical multiplicity equal to 2.\nPresented below is an example with \\(F\\neq0\\).\n\nHow to use this notebook?\n\nTry to set \\(F=0\\) and try to explain what physically implies this case for the lander, specially for the \\(z\\) and \\(\\theta\\) dynamics and their relationship.\n\n\n#Preparatory Cell \nimport control\nimport numpy\nfrom IPython.display import display, Markdown\nimport ipywidgets as widgets\nimport matplotlib.pyplot as plt\n\n%matplotlib inline\n\n#matrixWidget is a matrix looking widget built with a VBox of HBox(es) that returns a numPy array as value !\nclass matrixWidget(widgets.VBox):\n    def updateM(self,change):\n        for irow in range(0,self.n):\n            for icol in range(0,self.m):\n                self.M_[irow,icol] = self.children[irow].children[icol].value\n                #print(self.M_[irow,icol])\n        self.value = self.M_\n\n    def dummychangecallback(self,change):\n        pass\n    \n    \n    def __init__(self,n,m):\n        self.n = n\n        self.m = m\n        self.M_ = numpy.matrix(numpy.zeros((self.n,self.m)))\n        self.value = self.M_\n        widgets.VBox.__init__(self,\n                             children = [\n                                 widgets.HBox(children = \n                                              [widgets.FloatText(value=0.0, layout=widgets.Layout(width='90px')) for i in range(m)]\n                                             ) \n                                 for j in range(n)\n                             ])\n        \n        #fill in widgets and tell interact to call updateM each time a children changes value\n        for irow in range(0,self.n):\n            for icol in range(0,self.m):\n                self.children[irow].children[icol].value = self.M_[irow,icol]\n                self.children[irow].children[icol].observe(self.updateM, names='value')\n        #value = Unicode('example@example.com', help=\"The email value.\").tag(sync=True)\n        self.observe(self.updateM, names='value', type= 'All')\n        \n    def setM(self, newM):\n        #disable callbacks, change values, and reenable\n        self.unobserve(self.updateM, names='value', type= 'All')\n        for irow in range(0,self.n):\n            for icol in range(0,self.m):\n                self.children[irow].children[icol].unobserve(self.updateM, names='value')\n        self.M_ = newM\n        self.value = self.M_\n        for irow in range(0,self.n):\n            for icol in range(0,self.m):\n                self.children[irow].children[icol].value = self.M_[irow,icol]\n        for irow in range(0,self.n):\n            for icol in range(0,self.m):\n                self.children[irow].children[icol].observe(self.updateM, names='value')\n        self.observe(self.updateM, names='value', type= 'All')        \n\n                #self.children[irow].children[icol].observe(self.updateM, names='value')\n\n             \n#overlaod class for state space systems that DO NOT remove \"useless\" states (what \"professor\" of automatic control would do this?)\nclass sss(control.StateSpace):\n    def __init__(self,*args):\n        #call base class init constructor\n        control.StateSpace.__init__(self,*args)\n    #disable function below in base class\n    def _remove_useless_states(self):\n        pass\n\n\n#define the sliders for m, k and c\nm = widgets.FloatSlider(\n    value=1000,\n    min=400,\n    max=2000,\n    step=1,\n    description='$m$ [kg]:',\n    disabled=False,\n    continuous_update=False,\n    orientation='horizontal',\n    readout=True,\n    readout_format='.1f',\n)\nF = widgets.FloatSlider(\n    value=1500,\n    min=0,\n    max=5000,\n    step=10,\n    description='$F$ [N]:',\n    disabled=False,\n    continuous_update=False,\n    orientation='horizontal',\n    readout=True,\n    readout_format='.1f',\n)\n\n\n#function that make all the computations\ndef main_callback(m, F):\n    eig1 = 0\n    eig2 = 0\n    eig3 = 0\n    eig4 = 0\n    \n    if numpy.real([eig1,eig2,eig3,eig4])[0] == 0 and numpy.real([eig1,eig2,eig3,eig4])[1] == 0:\n        T = numpy.linspace(0,20,1000)\n    else:\n        if min(numpy.abs(numpy.real([eig1,eig2,eig3,eig4]))) != 0:\n            T = numpy.linspace(0,7*1/min(numpy.abs(numpy.real([eig1,eig2,eig3,eig4]))),1000)\n        else:\n            T = numpy.linspace(0,7*1/max(numpy.abs(numpy.real([eig1,eig2,eig3,eig4]))),1000)\n    if F==0:\n        mode1 = numpy.exp(eig1*T)\n        mode2 = T*mode1\n        mode3 = mode1\n        mode4 = mode2\n    else:\n        mode1 = numpy.exp(eig1*T)\n        mode2 = T*mode1\n        mode3 = T*mode2\n        mode4 = T*mode3\n    \n    fig = plt.figure(figsize=[16, 10])\n    fig.set_label('Modes')\n    g1 = fig.add_subplot(221)\n    g2 = fig.add_subplot(222)\n    g3 = fig.add_subplot(223)\n    g4 = fig.add_subplot(224)\n    \n    g1.plot(T,mode1)\n    g1.grid()\n    g1.set_xlabel('Time [s]')\n    g1.set_ylabel('First mode')\n    \n    g2.plot(T,mode2)\n    g2.grid()\n    g2.set_xlabel('Time [s]')\n    g2.set_ylabel('Second mode')\n    \n    g3.plot(T,mode3)\n    g3.grid()\n    g3.set_xlabel('Time [s]')\n    g3.set_ylabel('Third mode')\n    \n    g4.plot(T,mode4)\n    g4.grid()\n    g4.set_xlabel('Time [s]')\n    g4.set_ylabel('Fourth mode')\n    \n    modesString = r'The eigenvalue is equal to 0 with algebraic multiplicity equal to 4. '\n    if F==0:\n        modesString = modesString + r'The corresponding modes are $k$ and $t$.'\n    else:\n        modesString = modesString + r'The corresponding modes are $k$, $t$, $\\frac{t^2}{2}$ and $\\frac{t^3}{6}$.'\n    display(Markdown(modesString))\n\n        \nout = widgets.interactive_output(main_callback,{'m':m,'F':F})\nsliders = widgets.HBox([m,F])\ndisplay(out,sliders)"
  },
  {
    "objectID": "ICCT_en/examples/04/SS-10-Modal_analysis_of_car_speed_dynamics.html",
    "href": "ICCT_en/examples/04/SS-10-Modal_analysis_of_car_speed_dynamics.html",
    "title": "Modal analysis of a car speed dynamics",
    "section": "",
    "text": "# Erasmus+ ICCT project (2018-1-SI01-KA203-047081)\n\n# Toggle cell visibility\n\nfrom IPython.display import HTML\ntag = HTML('''&lt;script&gt;\ncode_show=true; \nfunction code_toggle() {\n    if (code_show){\n        $('div.input').hide()\n    } else {\n        $('div.input').show()\n    }\n    code_show = !code_show\n} \n$( document ).ready(code_toggle);\n&lt;/script&gt;\nToggle cell visibility &lt;a href=\"javascript:code_toggle()\"&gt;here&lt;/a&gt;.''')\ndisplay(tag)\n\n# Hide the code completely\n\n# from IPython.display import HTML\n# tag = HTML('''&lt;style&gt;\n# div.input {\n#     display:none;\n# }\n# &lt;/style&gt;''')\n# display(tag)\n\n\nToggle cell visibility here.\n\n\nThe dynamic matrix \\(A\\) that represents the model is (see Example SS-09):\n\\[\nA = \\begin{bmatrix}-\\frac{b}{m}&\\frac{\\tau_{\\text{max}}\\eta}{mr}\\\\0&-\\frac{1}{2}\\end{bmatrix},\n\\]\nwhere \\(m\\) is the car’s mass, \\(r\\) the wheel radius, \\(b\\) the drag coefficient, \\(\\eta\\) the gear ratio and \\(\\tau_{\\text{max}}\\) the maximum motor torque. The system’s state is \\(x=[v, \\tau_{\\text{%}}]^T\\) where \\(v\\) is the velocity and \\(\\tau_{\\text{%}}\\) is the % of maximum torque applied. Due to the particular structure of \\(A\\) (upper triangular) the eigenvalues are \\(-\\frac{b}{m}\\) and \\(-\\frac{1}{2}\\) thus, since \\(b\\ge0\\) and \\(m&gt;0\\), the system is asymptotically stable for all parameter values.\nIt’s worth noting that when \\(b=\\frac{m}{2}\\) the \\(A\\) matrix assumes a form equal to a Jordan block scaled by a factor \\(\\frac{\\tau_{\\text{max}}\\eta}{mr}\\) so the system has one eigenvalue with algebraic multiplicity 2 and geometric multiplicity 1.\n\nHow to use this notebook?\n\nVerify the dependence of the first eigenvalue by only \\(m\\) and \\(b\\) by changing the parameters value.\nTry to achieve \\(b=\\frac{m}{2}\\) and check the resulting modes.\n\n\n#Preparatory Cell \nimport control\nimport numpy\nfrom IPython.display import display, Markdown\nimport ipywidgets as widgets\nimport matplotlib.pyplot as plt\n\n%matplotlib inline\n\n#matrixWidget is a matrix looking widget built with a VBox of HBox(es) that returns a numPy array as value !\nclass matrixWidget(widgets.VBox):\n    def updateM(self,change):\n        for irow in range(0,self.n):\n            for icol in range(0,self.m):\n                self.M_[irow,icol] = self.children[irow].children[icol].value\n                #print(self.M_[irow,icol])\n        self.value = self.M_\n\n    def dummychangecallback(self,change):\n        pass\n    \n    \n    def __init__(self,n,m):\n        self.n = n\n        self.m = m\n        self.M_ = numpy.matrix(numpy.zeros((self.n,self.m)))\n        self.value = self.M_\n        widgets.VBox.__init__(self,\n                             children = [\n                                 widgets.HBox(children = \n                                              [widgets.FloatText(value=0.0, layout=widgets.Layout(width='90px')) for i in range(m)]\n                                             ) \n                                 for j in range(n)\n                             ])\n        \n        #fill in widgets and tell interact to call updateM each time a children changes value\n        for irow in range(0,self.n):\n            for icol in range(0,self.m):\n                self.children[irow].children[icol].value = self.M_[irow,icol]\n                self.children[irow].children[icol].observe(self.updateM, names='value')\n        #value = Unicode('example@example.com', help=\"The email value.\").tag(sync=True)\n        self.observe(self.updateM, names='value', type= 'All')\n        \n    def setM(self, newM):\n        #disable callbacks, change values, and reenable\n        self.unobserve(self.updateM, names='value', type= 'All')\n        for irow in range(0,self.n):\n            for icol in range(0,self.m):\n                self.children[irow].children[icol].unobserve(self.updateM, names='value')\n        self.M_ = newM\n        self.value = self.M_\n        for irow in range(0,self.n):\n            for icol in range(0,self.m):\n                self.children[irow].children[icol].value = self.M_[irow,icol]\n        for irow in range(0,self.n):\n            for icol in range(0,self.m):\n                self.children[irow].children[icol].observe(self.updateM, names='value')\n        self.observe(self.updateM, names='value', type= 'All')        \n\n                #self.children[irow].children[icol].observe(self.updateM, names='value')\n\n             \n#overlaod class for state space systems that DO NOT remove \"useless\" states (what \"professor\" of automatic control would do this?)\nclass sss(control.StateSpace):\n    def __init__(self,*args):\n        #call base class init constructor\n        control.StateSpace.__init__(self,*args)\n    #disable function below in base class\n    def _remove_useless_states(self):\n        pass\n\n\n#define the sliders for m, k and c\nm = widgets.FloatSlider(\n    value=1000,\n    min=400,\n    max=2000,\n    step=1,\n    description='m [kg]:',\n    disabled=False,\n    continuous_update=False,\n    orientation='horizontal',\n    readout=True,\n    readout_format='.1f',\n)\neta = widgets.FloatSlider(\n    value=4,\n    min=0.8,\n    max=10.0,\n    step=0.1,\n    description='$\\eta$:',\n    disabled=False,\n    continuous_update=False,\n    orientation='horizontal',\n    readout=True,\n    readout_format='.1f',\n)\ntau_max = widgets.FloatSlider(\n    value=150,\n    min=50,\n    max=900,\n    step=1,\n    description=r'$\\tau_{\\text{max}}$ [Nm]:',\n    disabled=False,\n    continuous_update=False,\n    orientation='horizontal',\n    readout=True,\n    readout_format='.1f',\n)\nb_air = widgets.FloatSlider(\n    value=60,\n    min=0,\n    max=800,\n    step=1,\n    description=r'$b$ [Ns/m]:',\n    disabled=False,\n    continuous_update=False,\n    orientation='horizontal',\n    readout=True,\n    readout_format='.1f',\n)\n\n\n#function that make all the computations\ndef main_callback(m, eta, tau_max, b_air):\n    eig1 = -b_air/m\n    eig2 = -1/2\n    \n    if numpy.real([eig1,eig2])[0] == 0 and numpy.real([eig1,eig2])[1] == 0:\n        T = numpy.linspace(0,20,1000)\n    else:\n        if min(numpy.abs(numpy.real([eig1,eig2]))) != 0:\n            T = numpy.linspace(0,7*1/min(numpy.abs(numpy.real([eig1,eig2]))),1000)\n        else:\n            T = numpy.linspace(0,7*1/max(numpy.abs(numpy.real([eig1,eig2]))),1000)\n    if eig1 == eig2:\n        mode1 = numpy.exp(eig1*T)\n        mode2 = T*mode1\n    else:\n        mode1 = numpy.exp(eig1*T)\n        mode2 = numpy.exp(eig2*T)\n    \n    fig = plt.figure(figsize=[16, 5])\n    fig.set_label('Modes')\n    g1 = fig.add_subplot(121)\n    g2 = fig.add_subplot(122)\n    \n    g1.plot(T,mode1)\n    g1.grid()\n    g1.set_xlabel('Time [s]')\n    g1.set_ylabel('First mode')\n    \n    g2.plot(T,mode2)\n    g2.grid()\n    g2.set_xlabel('Time [s]')\n    g2.set_ylabel('Second mode')\n    \n    # print('The eigenvalues are: -%.3f+%.3fj -%.3f-%.3fj' %(abs(eig1.real),abs(eig1.imag),abs(eig2.real),abs(eig2.imag)))\n    modesString = 'The eigenvalues are $' + str(numpy.around(eig1,decimals=3)) + '$ and $' + str(numpy.around(eig2,decimals=3)) + '$ '\n    if eig1 == eig2:\n        modesString = modesString + 'with the corresponding modes $e^{' + str(numpy.around(eig1,decimals=3))\\\n                        + ' t}$ and $te^{' + str(numpy.around(eig2,decimals=3)) + ' t}$.'\n    else:\n        modesString = modesString + 'with the corresponding modes $e^{' + str(numpy.around(eig1,decimals=3))\\\n                        + ' t}$ and $e^{' + str(numpy.around(eig2,decimals=3)) + ' t}$.'\n    display(Markdown(modesString))\n\n        \nout = widgets.interactive_output(main_callback,{'m':m,'eta':eta,'tau_max':tau_max,'b_air':b_air})\nsliders = widgets.VBox([widgets.HBox([m,eta]),\n                        widgets.HBox([tau_max,b_air])])\ndisplay(out,sliders)"
  },
  {
    "objectID": "ICCT_en/examples/04/SS-08-Modal_analysis_of_the_Mass-Spring-Damper_system.html",
    "href": "ICCT_en/examples/04/SS-08-Modal_analysis_of_the_Mass-Spring-Damper_system.html",
    "title": "Modal Analysis of the Mass-Spring-Damper system",
    "section": "",
    "text": "from IPython.display import HTML\ntag = HTML('''&lt;script&gt;\ncode_show=true; \nfunction code_toggle() {\n    if (code_show){\n        $('div.input').hide()\n    } else {\n        $('div.input').show()\n    }\n    code_show = !code_show\n} \n$( document ).ready(code_toggle);\n&lt;/script&gt;\nToggle cell visibility &lt;a href=\"javascript:code_toggle()\"&gt;here&lt;/a&gt;.''')\ndisplay(tag)\n\n# Hide the code completely\n\n# from IPython.display import HTML\n# tag = HTML('''&lt;style&gt;\n# div.input {\n#     display:none;\n# }\n# &lt;/style&gt;''')\n# display(tag)\n\n\nToggle cell visibility here.\n\n\nReferring to the mass-spring-damper system introduced in the example Modal Analysis, this example presents and shows graphically the modes that represent its behavior. The dynamic matrix is\n\\[ A=\n\\begin{bmatrix}\n0 && 1 \\\\\n-\\frac{k}{m} && -\\frac{c}{m}\n\\end{bmatrix}\\]\nand it’s characteristic polynomial (the matrix \\(A\\) is in canonical controllability form) is\n\\[\\lambda^2+\\frac{c}{m}\\lambda+\\frac{k}{m}\\]\nthus the eigenvalues and the associated modes are\n\\[\\lambda_{1,2}=-\\frac{c}{m}\\pm\\frac{1}{m}\\sqrt{c^2-4km}.\\]\nThe term under the square root is critical because it discriminates the behavior of the system, oscillatory or not. In particular with a value of \\(c\\ge2\\sqrt{km}\\) the system has only real eigenvalues and does not present oscillations.\nThe interactive example allows to see the system modes at the change of all parameters.\n\n#Preparatory Cell \nimport control\nimport numpy\nfrom IPython.display import display, Markdown\nimport ipywidgets as widgets\nimport matplotlib.pyplot as plt\nfrom matplotlib import animation\n\n%matplotlib inline\n\n#print a matrix latex-like\ndef bmatrix(a):\n     \"\"\"Returns a LaTeX bmatrix - by Damir Arbula (ICCT project)\n\n     :a: numpy array\n     :returns: LaTeX bmatrix as a string\n     \"\"\"\n     if len(a.shape) &gt; 2:\n         raise ValueError('bmatrix can at most display two dimensions')\n     lines = str(a).replace('[', '').replace(']', '').splitlines()\n     rv = [r'\\begin{bmatrix}']\n     rv += ['  ' + ' & '.join(l.split()) + r'\\\\' for l in lines]\n     rv +=  [r'\\end{bmatrix}']\n     return '\\n'.join(rv)\n\n\n# Display formatted matrix: \ndef vmatrix(a):\n    if len(a.shape) &gt; 2:\n         raise ValueError('bmatrix can at most display two dimensions')\n    lines = str(a).replace('[', '').replace(']', '').splitlines()\n    rv = [r'\\begin{vmatrix}']\n    rv += ['  ' + ' & '.join(l.split()) + r'\\\\' for l in lines]\n    rv +=  [r'\\end{vmatrix}']\n    return '\\n'.join(rv)\n\n\n#matrixWidget is a matrix looking widget built with a VBox of HBox(es) that returns a numPy array as value !\nclass matrixWidget(widgets.VBox):\n    def updateM(self,change):\n        for irow in range(0,self.n):\n            for icol in range(0,self.m):\n                self.M_[irow,icol] = self.children[irow].children[icol].value\n                #print(self.M_[irow,icol])\n        self.value = self.M_\n\n    def dummychangecallback(self,change):\n        pass\n    \n    \n    def __init__(self,n,m):\n        self.n = n\n        self.m = m\n        self.M_ = numpy.matrix(numpy.zeros((self.n,self.m)))\n        self.value = self.M_\n        widgets.VBox.__init__(self,\n                             children = [\n                                 widgets.HBox(children = \n                                              [widgets.FloatText(value=0.0, layout=widgets.Layout(width='90px')) for i in range(m)]\n                                             ) \n                                 for j in range(n)\n                             ])\n        \n        #fill in widgets and tell interact to call updateM each time a children changes value\n        for irow in range(0,self.n):\n            for icol in range(0,self.m):\n                self.children[irow].children[icol].value = self.M_[irow,icol]\n                self.children[irow].children[icol].observe(self.updateM, names='value')\n        #value = Unicode('example@example.com', help=\"The email value.\").tag(sync=True)\n        self.observe(self.updateM, names='value', type= 'All')\n        \n    def setM(self, newM):\n        #disable callbacks, change values, and reenable\n        self.unobserve(self.updateM, names='value', type= 'All')\n        for irow in range(0,self.n):\n            for icol in range(0,self.m):\n                self.children[irow].children[icol].unobserve(self.updateM, names='value')\n        self.M_ = newM\n        self.value = self.M_\n        for irow in range(0,self.n):\n            for icol in range(0,self.m):\n                self.children[irow].children[icol].value = self.M_[irow,icol]\n        for irow in range(0,self.n):\n            for icol in range(0,self.m):\n                self.children[irow].children[icol].observe(self.updateM, names='value')\n        self.observe(self.updateM, names='value', type= 'All')        \n\n                #self.children[irow].children[icol].observe(self.updateM, names='value')\n\n             \n#overlaod class for state space systems that DO NOT remove \"useless\" states (what \"professor\" of automatic control would do this?)\nclass sss(control.StateSpace):\n    def __init__(self,*args):\n        #call base class init constructor\n        control.StateSpace.__init__(self,*args)\n    #disable function below in base class\n    def _remove_useless_states(self):\n        pass\n\n\n#define the sliders for m, k and c\nm = widgets.FloatSlider(\n    value=4,\n    min=0.1,\n    max=10.0,\n    step=0.1,\n    description='$m$ [kg]:',\n    disabled=False,\n    continuous_update=False,\n    orientation='horizontal',\n    readout=True,\n    readout_format='.1f',\n)\nk = widgets.FloatSlider(\n    value=1,\n    min=0,\n    max=10.0,\n    step=0.1,\n    description='$k$ [N/m]:',\n    disabled=False,\n    continuous_update=False,\n    orientation='horizontal',\n    readout=True,\n    readout_format='.1f',\n)\nc = widgets.FloatSlider(\n    value=4,\n    min=0,\n    max=10.0,\n    step=0.1,\n    description='$c$ [Ns/m]:',\n    disabled=False,\n    continuous_update=False,\n    orientation='horizontal',\n    readout=True,\n    readout_format='.1f',\n)\n\n\n#function that make all the computations\ndef main_callback(m, k, c):\n    if c**2-4*k*m &gt;= 0:\n        eig1 = -c/m+1/m*numpy.sqrt(c**2-4*k*m)\n        eig2 = -c/m-1/m*numpy.sqrt(c**2-4*k*m)\n    else:\n        eig1 = -c/m+1j*(1/m*numpy.sqrt(-c**2+4*k*m))\n        eig2 = -c/m-1j*(1/m*numpy.sqrt(-c**2+4*k*m))\n    \n    if numpy.real([eig1,eig2])[0] == 0 and numpy.real([eig1,eig2])[1] == 0:\n        T = numpy.linspace(0,20,1000)\n    else:\n        if min(numpy.abs(numpy.real([eig1,eig2]))) != 0:\n            T = numpy.linspace(0,7*1/min(numpy.abs(numpy.real([eig1,eig2]))),1000)\n        else:\n            T = numpy.linspace(0,7*1/max(numpy.abs(numpy.real([eig1,eig2]))),1000)\n    if numpy.isreal(eig1):\n        if eig1 == eig2:\n            mode1 = numpy.exp(eig1*T)\n            mode2 = T*numpy.exp(eig2*T)\n        else:\n            mode1 = numpy.exp(eig1*T)\n            mode2 = numpy.exp(eig2*T)\n    else:\n        mode1 = numpy.exp(eig1.real*T)*numpy.cos(abs(eig1.imag)*T)\n        mode2 = numpy.exp(eig2.real*T)*numpy.sin(abs(eig2.imag)*T)\n    \n    fig = plt.figure(figsize=[16, 5])\n    fig.set_label('Modes')\n    g1 = fig.add_subplot(121)\n    g2 = fig.add_subplot(122)\n    \n    g1.plot(T,mode1)\n    g1.grid()\n    g1.set_xlabel('Time [s]')\n    g1.set_ylabel('First mode')\n    \n    g2.plot(T,mode2)\n    g2.grid()\n    g2.set_xlabel('Time [s]')\n    g2.set_ylabel('Second mode')\n    \n    # print('The eigenvalues are: -%.3f+%.3fj -%.3f-%.3fj' %(abs(eig1.real),abs(eig1.imag),abs(eig2.real),abs(eig2.imag)))\n    modesString = 'The eigenvalues are $' + str(numpy.around(eig1,decimals=3)) + '$ and $' + str(numpy.around(eig2,decimals=3)) + '$ '\n    if numpy.isreal(eig1):\n        if eig1 == eig2:\n            modesString = modesString + 'with the corresponding modes $e^{' + str(numpy.around(eig1,decimals=3))\\\n                            + ' t}$ and $te^{' + str(numpy.around(eig2,decimals=3)) + ' t}$.'\n        else:\n            modesString = modesString + 'with the corresponding modes $e^{' + str(numpy.around(eig1,decimals=3))\\\n                            + ' t}$ and $e^{' + str(numpy.around(eig2,decimals=3)) + ' t}$.'\n    else:\n        modesString = modesString + 'with the corresponding modes $e^{' + str(numpy.around(numpy.real(eig1),decimals=3))\\\n                        + ' t} \\cos{(' + str(numpy.around(abs(numpy.imag(eig1)),decimals=3)) + 't)}$ and $e^{'\\\n                        + str(numpy.around(numpy.real(eig2),decimals=3)) + ' t} \\sin{(' + str(numpy.around(abs(numpy.imag(eig2)),decimals=3)) + 't)}$.'\n    \n    display(Markdown(modesString))\n\n        \nout = widgets.interactive_output(main_callback,{'m':m,'k':k,'c':c})\nsliders = widgets.HBox([k,m,c])\ndisplay(out,sliders)"
  },
  {
    "objectID": "ICCT_en/examples/04/SS-06-Jordan_form_with_complex_eigenvalues.html",
    "href": "ICCT_en/examples/04/SS-06-Jordan_form_with_complex_eigenvalues.html",
    "title": "Jordan Form - Complex Eigenvalues",
    "section": "",
    "text": "#remove cell visibility\nfrom IPython.display import HTML\ntag = HTML('''&lt;script&gt;\ncode_show=true; \nfunction code_toggle() {\n    if (code_show){\n        $('div.input').hide()\n    } else {\n        $('div.input').show()\n    }\n    code_show = !code_show\n} \n$( document ).ready(code_toggle);\n&lt;/script&gt;\nToggle cell visibility &lt;a href=\"javascript:code_toggle()\"&gt;here&lt;/a&gt;.''')\ndisplay(tag)\n\n\nToggle cell visibility here.\n\n\nThis example shows how the basic Jordan Form can be modified when the matrix \\(A\\) has complex eigenvalues in order for its Jordan form \\(J\\) to be composed by real numbers only.\nWhen matrix \\(A\\) has a complex eigenvalue \\(\\lambda\\), it has also its complex conjugate \\(\\bar \\lambda\\) as eigenvalue. It can be shown that if the eigenvector \\(v\\) is associated with the eigenvalue \\(\\lambda\\), then the eigenvector associated with the eigenvalue \\(\\bar \\lambda\\) is the complex conjugate of \\(v\\): \\(\\bar v\\).\nThis important result allows us to change the \\(V\\) matrix (namely by substituting the columns of \\(v\\) and \\(\\bar v\\) with their linear combinations \\((v+\\bar v)\\) and \\((v-\\bar v)\\)) obtaining a different form of the Jordan Matrix where the complex conjugate pair of eigenvalues \\(\\lambda\\) and \\(\\bar \\lambda\\) generates a Jordan element of the form:\n\\[\nJ = \\begin{bmatrix}\n\\sigma & \\omega \\\\\n-\\omega & \\sigma \\\\\n\\end{bmatrix},\n\\]\nwith \\(\\lambda = \\sigma + i \\omega\\).\n\nHow to use this notebook?\n\nDefine a matrix and watch its Jordan form; experiment with both real and complex eigenvalues.\nTry to build a matrix with complex eigenvalues and multiplicity equal to 2.\nExplore the effects of changing the values of the matrix \\(A\\) or load example matrices.\n\n\n#Preparatory Cell \n\nimport control\nimport numpy\nimport sympy\nfrom IPython.display import display, Markdown\nimport ipywidgets as widgets\nimport matplotlib.pyplot as plt\n\nfrom sympy import Matrix \n\n\n\n#print a matrix latex-like\ndef bmatrix(a):\n     \"\"\"Returns a LaTeX bmatrix - by Damir Arbula (ICCT project)\n\n     :a: numpy array\n     :returns: LaTeX bmatrix as a string\n     \"\"\"\n     if len(a.shape) &gt; 2:\n         raise ValueError('bmatrix can at most display two dimensions')\n     lines = str(a).replace('[', '').replace(']', '').splitlines()\n     rv = [r'\\begin{bmatrix}']\n     rv += ['  ' + ' & '.join(l.split()) + r'\\\\' for l in lines]\n     rv +=  [r'\\end{bmatrix}']\n     return '\\n'.join(rv)\n\n\n# Display formatted matrix: \ndef vmatrix(a):\n    if len(a.shape) &gt; 2:\n         raise ValueError('bmatrix can at most display two dimensions')\n    lines = str(a).replace('[', '').replace(']', '').splitlines()\n    rv = [r'\\begin{vmatrix}']\n    rv += ['  ' + ' & '.join(l.split()) + r'\\\\' for l in lines]\n    rv +=  [r'\\end{vmatrix}']\n    return '\\n'.join(rv)\n\n\n#create a NxM matrix widget \ndef createMatrixWidget(n,m):\n    M = widgets.GridBox(children=[widgets.FloatText(layout=widgets.Layout(width='100px', height='40px'),\n    value=0.0, disabled=False, label=i) for i in range(n*m)],\n    layout=widgets.Layout(\n        #width='50%',\n        grid_template_columns= ''.join(['100px ' for i in range(m)]),\n        #grid_template_rows='80px 80px 80px',\n        grid_row_gap='0px',\n        track_size='0px')\n    )\n    return M\n\n\n#extract matrix from widgets and convert to numpy matrix\ndef getNumpyMatFromWidget(M,n,m):\n    #get W gridbox dims\n    M_ = numpy.matrix(numpy.zeros((n,m)))\n    for irow in range(0,n):\n        for icol in range(0,m):\n            M_[irow,icol] = M.children[irow*3+icol].value\n\n            \n#this is a simple derived class from FloatText used to experience with interact             \nclass floatWidget(widgets.FloatText):\n    def __init__(self,**kwargs):\n        #self.n = n\n        self.value = 30.0\n        #self.M = \n        widgets.FloatText.__init__(self, **kwargs)\n\n#    def value(self):\n#        return 0 #self.FloatText.value\n\nfrom traitlets import Unicode\nfrom ipywidgets import register \n\n\n#matrixWidget is a matrix looking widget built with a VBox of HBox(es) that returns a numPy array as value !\nclass matrixWidget(widgets.VBox):\n    def updateM(self,change):\n        for irow in range(0,self.n):\n            for icol in range(0,self.m):\n                self.M_[irow,icol] = self.children[irow].children[icol].value\n                #print(self.M_[irow,icol])\n        self.value = self.M_\n\n    def dummychangecallback(self,change):\n        pass\n    \n    \n    def __init__(self,n,m):\n        self.n = n\n        self.m = m\n        self.M_ = numpy.matrix(numpy.zeros((self.n,self.m)))\n        self.value = self.M_\n        widgets.VBox.__init__(self,\n                             children = [\n                                 widgets.HBox(children = \n                                              [widgets.FloatText(value=0.0, layout=widgets.Layout(width='90px')) for i in range(m)]\n                                             ) \n                                 for j in range(n)\n                             ])\n        \n        #fill in widgets and tell interact to call updateM each time a children changes value\n        for irow in range(0,self.n):\n            for icol in range(0,self.m):\n                self.children[irow].children[icol].value = self.M_[irow,icol]\n                self.children[irow].children[icol].observe(self.updateM, names='value')\n        #value = Unicode('example@example.com', help=\"The email value.\").tag(sync=True)\n        self.observe(self.updateM, names='value', type= 'All')\n        \n    def setM(self, newM):\n        #disable callbacks, change values, and reenable\n        self.unobserve(self.updateM, names='value', type= 'All')\n        for irow in range(0,self.n):\n            for icol in range(0,self.m):\n                self.children[irow].children[icol].unobserve(self.updateM, names='value')\n        self.M_ = newM\n        self.value = self.M_\n        for irow in range(0,self.n):\n            for icol in range(0,self.m):\n                self.children[irow].children[icol].value = self.M_[irow,icol]\n        for irow in range(0,self.n):\n            for icol in range(0,self.m):\n                self.children[irow].children[icol].observe(self.updateM, names='value')\n        self.observe(self.updateM, names='value', type= 'All')        \n\n                #self.children[irow].children[icol].observe(self.updateM, names='value')\n\n        \n\n        \n#overlaod class for state space systems that DO NOT remove \"useless\" states (what \"professor\" of automatic control would do this?)\nclass sss(control.StateSpace):\n    def __init__(self,*args):\n        #call base class init constructor\n        control.StateSpace.__init__(self,*args)\n    #disable function below in base class\n    def _remove_useless_states(self):\n        pass\n\n\n\n#define matrices\nA = matrixWidget(4,4)\n\n#this is the main callback and does all the computations and plots \ndef main_callback(matA,DW,sel):\n    #check if a specific matrix is requested or is manual \n    if sel=='manual definition of the system' :\n        pass\n    elif sel == 'stable system - no complex congjugate poles':\n        matA = numpy.zeros((4,4))\n        matA[0,0] = -1\n        matA[1,1] = -2\n        matA[2,2] = -3\n        matA[3,3] = -4\n        A.setM(matA)\n    elif sel == 'stable system - w/ complex conjugate pair':\n        matA = numpy.zeros((4,4))\n        matA[0,0] = -1\n        matA[0,1] = 3\n        matA[1,0] = -3\n        matA[1,1] = -1\n        matA[2,2] = -3\n        matA[3,3] = -4\n        A.setM(matA)\n    elif sel == 'unstable system - unstable real pole unstable':\n        matA = numpy.zeros((4,4))\n        matA[0,0] = 1\n        matA[1,1] = -2\n        matA[2,2] = -3\n        matA[3,3] = -4\n        A.setM(matA)\n    elif sel ==  'unstable system - unstable complex conjugate pair ':\n        matA = numpy.zeros((4,4))\n        matA[0,0] = 1\n        matA[0,1] = 3\n        matA[1,0] = -3\n        matA[1,1] = 1\n        matA[2,2] = -3\n        matA[3,3] = -4\n        A.setM(matA)\n    else : \n        matA = numpy.zeros((4,4))\n        A.setM(matA)\n    \n    # Work with symbolic matrix\n    matAs = sympy.Matrix(matA)\n    dictEig = matAs.eigenvals()\n    eigs = list(dictEig.keys())\n    algMult = list(dictEig.values())\n    \n    # check dimension of jordan blocks\n    dimJblock = []\n    for i in range(len(eigs)):\n        dimJblock.append(algMult[i]-len((matAs-eigs[i]*sympy.eye(4)).nullspace())+1)\n        \n    # jordan form with real numbers\n    matAs_P, matAs_J = matAs.jordan_form(chop=True)\n    zeroV = Matrix([0,0,0,0])\n    cols = []\n    for i in range(4):\n        RE, IM = matAs_P.col(i).as_real_imag()\n        if IM == zeroV:\n            cols.append(RE)\n        elif not any([matAs_P.col(i).conjugate() == matAs_P.col(j) for j in range(i+1)]):\n            cols.append(RE)\n            cols.append(IM)\n    matAs_P = cols[0].row_join(cols[1]).row_join(cols[2]).row_join(cols[3])\n    matAs_J = matAs_P.inv()*matAs*matAs_P\n    \n    timeVectors = []\n    modeVectors = []\n    # compute modes simulations and prepare modestring\n    modestring = ''\n    for i in range(len(eigs)):\n        sim = []\n        if sympy.re(eigs[i]) &gt;= 0:\n            # instable or integral like\n            time = numpy.linspace(0,10,1000)\n            for n in range(dimJblock[i]):\n                if n==0:\n                    if sympy.im(eigs[i]) != 0 and (sympy.conjugate(eigs[i]) not in eigs[0:i]):\n                        sim.append(time**n*numpy.exp(float(sympy.re(eigs[i]))*time)*numpy.cos(float(sympy.im(eigs[i]))*time))\n                        modestring = modestring + \"$e^{%s t} cos(%s t + \\phi)$  \" % (str(float(sympy.re(eigs[i]))), str(float(sympy.im(eigs[i]))))\n                    elif sympy.im(eigs[i]) == 0:\n                        sim.append(time**n*numpy.exp(float(sympy.re(eigs[i]))*time))\n                        modestring = modestring + \"$e^{%s t}$  \" % (str(float(sympy.re(eigs[i]))))\n                else:\n                    if sympy.im(eigs[i]) != 0 and (sympy.conjugate(eigs[i]) not in eigs[0:i]):\n                        sim.append(time**n*numpy.exp(float(sympy.re(eigs[i]))*time)*numpy.cos(float(sympy.im(eigs[i]))*time))\n                        modestring = modestring + \"$t^{%s}e^{%s t} cos(%s t + \\phi)$  \" % (str(n), str(float(sympy.re(eigs[i]))), str(float(sympy.im(eigs[i]))))\n                    elif sympy.im(eigs[i]) == 0:\n                        sim.append(time**n*numpy.exp(float(sympy.re(eigs[i]))*time))\n                        modestring = modestring + \"$t^{%s}e^{%s t}$  \" % (str(n), str(float(sympy.re(eigs[i]))))\n        else:\n            # stable mode\n            time = numpy.linspace(0,10*(1/float(sympy.Abs(eigs[i]))),1000)\n            for n in range(dimJblock[i]):\n                if n==0:\n                    if sympy.im(eigs[i]) != 0 and (sympy.conjugate(eigs[i]) not in eigs[0:i]):\n                        sim.append(time**n*numpy.exp(float(sympy.re(eigs[i]))*time)*numpy.cos(float(sympy.im(eigs[i]))*time))\n                        modestring = modestring + \"$e^{%s t} cos(%s t + \\phi)$  \" % (str(float(sympy.re(eigs[i]))), str(float(sympy.im(eigs[i]))))\n                    elif sympy.im(eigs[i]) == 0:\n                        sim.append(time**n*numpy.exp(float(sympy.re(eigs[i]))*time))\n                        modestring = modestring + \"$e^{%s t}$  \" % (str(float(sympy.re(eigs[i]))))\n                else:\n                    if sympy.im(eigs[i]) != 0 and (sympy.conjugate(eigs[i]) not in eigs[0:i]):\n                        sim.append(time**n*numpy.exp(float(sympy.re(eigs[i]))*time)*numpy.cos(float(sympy.im(eigs[i]))*time))\n                        modestring = modestring + \"$t^{%s}e^{%s t} cos(%s t + \\phi)$  \" % (str(n), str(float(sympy.re(eigs[i]))), str(float(sympy.im(eigs[i]))))\n                    elif sympy.im(eigs[i]) == 0:\n                        sim.append(time**n*numpy.exp(float(sympy.re(eigs[i]))*time))\n                        modestring = modestring + \"$t^{%s}e^{%s t}$  \" % (str(n), str(float(sympy.re(eigs[i]))))\n        if len(sim) != 0:\n            timeVectors.append(time)\n            modeVectors.append(sim)\n    \n    #print(dimJblock)\n    #print(len(modeVectors))\n    \n    #create textual output            \n    display(Markdown('Matrix: $%s$ has eigenvalues $%s$' % (vmatrix(matA), vmatrix(numpy.array(numpy.linalg.eig(matA)[0])))))\n    #for better visualization\n    matJlist = []\n    for i in range(4):\n        temp = []\n        for j in range(4):\n            if sympy.im(matAs_J[i,j]) != 0:\n                temp.append(numpy.complex(matAs_J[i,j]))\n            else:\n                temp.append(numpy.real(matAs_J[i,j]))\n        matJlist.append(temp)\n    matJ = numpy.matrix(matJlist)\n    display(Markdown('and the Jordan form equal to: $%s$' %str(vmatrix(matJ))))\n    #for better visualization\n    matPlist = []\n    for i in range(4):\n        temp = []\n        for j in range(4):\n            if sympy.im(matAs_P[i,j]) != 0:\n                temp.append(numpy.complex(matAs_P[i,j]))\n            else:\n                temp.append(numpy.real(matAs_P[i,j]))\n        matPlist.append(temp)\n    matP = numpy.matrix(matPlist)\n    display(Markdown('with generalized real eigenvectors $%s$.' %str(vmatrix(matP))))\n    display(Markdown('The modes are: %s' % modestring))\n    \n    #compute total number of figures\n    totfig=0\n    for i in range(len(modeVectors)):\n            totfig = totfig + len(modeVectors[i])\n            \n    #plot each single mode\n    fig = plt.figure(figsize=(20, 4))\n    idx = 1\n    for i in range(len(timeVectors)):\n        for j in range(len(modeVectors[i])):\n            sf = fig.add_subplot(1,totfig,idx)\n            idx = idx + 1\n            sf.plot(timeVectors[i],modeVectors[i][j])\n            sf.grid(True)\n            plt.xlabel(r'$t$ [s]')\n            plt.axvline(x=0,color='black',linewidth=0.8)\n            plt.axhline(y=0,color='black',linewidth=0.8)\n    \n    \n#create dummy widget \nDW = widgets.FloatText(layout=widgets.Layout(width='0px', height='0px'))\n\n#create button widget\nSTART = widgets.Button(\n    description='Test',\n    disabled=False,\n    button_style='', # 'success', 'info', 'warning', 'danger' or ''\n    tooltip='Test',\n    icon='check'\n)\n                       \ndef on_start_button_clicked(b):\n    #This is a workaround to have intreactive_output call the callback:\n    #   force the value of the dummy widget to change\n    if DW.value&gt; 0 :\n        DW.value = -1\n    else: \n        DW.value = 1\n    pass\nSTART.on_click(on_start_button_clicked)\n\n#define type of ipout \nSELECT = widgets.Dropdown(\n    options=['manual definition of the system', 'reset', 'stable system - no complex congjugate poles', \n             'stable system - w/ complex conjugate pair', \n             'unstable system - unstable real pole unstable', \n             'unstable system - unstable complex conjugate pair '],\n    value='manual definition of the system',\n    description='Examples:',\n    disabled=False,\n)\n\n\n#create a graphic structure to hold all widgets \nalltogether =  widgets.VBox([SELECT, widgets.Label(''), widgets.HBox([widgets.Label('$\\dot{x}(t) = $',border=3), A,widgets.Label('$x(t)$',border=3), START])] )\n    \n\nout = widgets.interactive_output(main_callback,{'matA': A, 'DW': DW, 'sel': SELECT})\nout.layout.height = '620px'\ndisplay(alltogether,out)"
  },
  {
    "objectID": "ICCT_en/examples/04/SS-04-Diagonal_matrices_divergent_modes.html",
    "href": "ICCT_en/examples/04/SS-04-Diagonal_matrices_divergent_modes.html",
    "title": "Diagonal matrix: Divergent mode",
    "section": "",
    "text": "# Erasmus+ ICCT project (2018-1-SI01-KA203-047081)\n\n# Toggle cell visibility\n\nfrom IPython.display import HTML\ntag = HTML('''&lt;script&gt;\ncode_show=true; \nfunction code_toggle() {\n    if (code_show){\n        $('div.input').hide()\n    } else {\n        $('div.input').show()\n    }\n    code_show = !code_show\n} \n$( document ).ready(code_toggle);\n&lt;/script&gt;\nToggle cell visibility &lt;a href=\"javascript:code_toggle()\"&gt;here&lt;/a&gt;.''')\ndisplay(tag)\n\n# Hide the code completely\n\n# from IPython.display import HTML\n# tag = HTML('''&lt;style&gt;\n# div.input {\n#     display:none;\n# }\n# &lt;/style&gt;''')\n# display(tag)\n\n\nToggle cell visibility here.\n\n\nThis example shows a diagonal matrix with at least one divergent mode. It is possible to change any element of the matrix and analyze if the new matrix has divergent modes (unstable matrix) or not.\nExplore the various possibilities: * diagonal matrices with divergent (unstable) modes, * diagonal matrices with stable modes, * diagonal matrices with both stable and divergent (unstable) modes.\nCan you easily tell if a matrix has divergent modes when it is in diagonal form?\n\n%matplotlib notebook\nimport control\nimport numpy\nimport sympy\nfrom IPython.display import display, Markdown\nimport ipywidgets as widgets\nimport matplotlib.pyplot as plt\n\n#print a matrix latex-like\ndef bmatrix(a):\n     \"\"\"Returns a LaTeX bmatrix - by Damir Arbula (ICCT project)\n\n     :a: numpy array\n     :returns: LaTeX bmatrix as a string\n     \"\"\"\n     if len(a.shape) &gt; 2:\n         raise ValueError('bmatrix can at most display two dimensions')\n     lines = str(a).replace('[', '').replace(']', '').splitlines()\n     rv = [r'\\begin{bmatrix}']\n     rv += ['  ' + ' & '.join(l.split()) + r'\\\\' for l in lines]\n     rv +=  [r'\\end{bmatrix}']\n     return '\\n'.join(rv)\n\n\n# Display formatted matrix: \ndef vmatrix(a):\n    if len(a.shape) &gt; 2:\n         raise ValueError('bmatrix can at most display two dimensions')\n    lines = str(a).replace('[', '').replace(']', '').splitlines()\n    rv = [r'\\begin{vmatrix}']\n    rv += ['  ' + ' & '.join(l.split()) + r'\\\\' for l in lines]\n    rv +=  [r'\\end{vmatrix}']\n    return '\\n'.join(rv)\n\n\n#matrixWidget is a matrix looking widget built with a VBox of HBox(es) that returns a numPy array as value !\nclass matrixWidget(widgets.VBox):\n    def updateM(self,change):\n        for irow in range(0,self.n):\n            for icol in range(0,self.m):\n                self.M_[irow,icol] = self.children[irow].children[icol].value\n                #print(self.M_[irow,icol])\n        self.value = self.M_\n\n    #def dummychangecallback(self,change):\n        #pass\n    \n    \n    def __init__(self,n,m):\n        self.n = n\n        self.m = m\n        self.M_ = numpy.matrix(numpy.zeros((self.n,self.m)))\n        self.value = self.M_\n        widgets.VBox.__init__(self,\n                             children = [\n                                 widgets.HBox(children = \n                                              [widgets.FloatText(value=0.0, layout=widgets.Layout(width='90px')) for i in range(m)]\n                                             ) \n                                 for j in range(n)\n                             ])\n        \n        #fill in widgets and tell interact to call updateM each time a children changes value\n        for irow in range(0,self.n):\n            for icol in range(0,self.m):\n                self.children[irow].children[icol].value = self.M_[irow,icol]\n                self.children[irow].children[icol].observe(self.updateM, names='value')\n        #value = Unicode('example@example.com', help=\"The email value.\").tag(sync=True)\n        self.observe(self.updateM, names='value', type= 'All')\n        \n    def setM(self, newM):\n        #disable callbacks, change values, and reenable\n        self.unobserve(self.updateM, names='value', type= 'All')\n        for irow in range(0,self.n):\n            for icol in range(0,self.m):\n                self.children[irow].children[icol].unobserve(self.updateM, names='value')\n        self.M_ = newM\n        self.value = self.M_\n        for irow in range(0,self.n):\n            for icol in range(0,self.m):\n                self.children[irow].children[icol].value = self.M_[irow,icol]\n        for irow in range(0,self.n):\n            for icol in range(0,self.m):\n                self.children[irow].children[icol].observe(self.updateM, names='value')\n        self.observe(self.updateM, names='value', type= 'All')        \n\n                #self.children[irow].children[icol].observe(self.updateM, names='value')\n\n             \n#overlaod class for state space systems that DO NOT remove \"useless\" states (what \"professor\" of automatic control would do this?)\nclass sss(control.StateSpace):\n    def __init__(self,*args):\n        #call base class init constructor\n        control.StateSpace.__init__(self,*args)\n    #disable function below in base class\n    def _remove_useless_states(self):\n        pass\n\n\nA=matrixWidget(4,4)\nA.setM(numpy.matrix('1,0,0,0;0,-2,0,0;0,0,-3,0;0,0,0,-4'))\n\ndef main_callback(matA,DW):\n    (r,c) = numpy.shape(matA)\n    sol = numpy.linalg.eig(matA)[0]\n    print('The eigenvalues are: %s' %str(sol))\n    \n    matAs = sympy.Matrix(matA)\n    eig = matAs.eigenvals()\n    eigvals = list(eig.keys())\n    Amul = list(eig.values())\n    \n    diag = True\n    for i in range(r):\n        for j in range(c):\n            if i != j:\n                if matA[i,j] != 0:\n                    diag = False\n    \n    if diag:\n        for i in range(len(eigvals)):\n            if numpy.real(eigvals[i]) &gt; 0:\n                print('Ok! The matrix is unstable')\n                return\n            elif numpy.real(eigvals[i]) == 0:\n                if Amul[i] &gt; 1:\n                    if len((matAs-eigvals[i]*sympy.eye(4)).nullspace()) &lt; Amul[i]:\n                        print('Ok! The matrix is unstable')\n                        return\n        print('The matrix isn\\'t unstable')\n    else:\n        for i in range(len(eigvals)):\n            if numpy.real(eigvals[i]) &gt; 0:\n                print('The matrix is unstable but isn\\'t diagonal')\n                return\n            elif numpy.real(eigvals[i]) == 0:\n                if Amul[i] &gt; 1:\n                    if len((matAs-eigvals[i]*sympy.eye(4)).nullspace()) &lt; Amul[i]:\n                        print('The matrix is unstable but isn\\'t diagonal')\n                        return\n        print('The matrix isn\\'t unstable and isn\\'t diagonal')\n    \n\n#create dummy widget \nDW = widgets.FloatText(layout=widgets.Layout(width='0px', height='0px'))\n\n#create button widget\nSTART = widgets.Button(\n    description='Test',\n    disabled=False,\n    button_style='', # 'success', 'info', 'warning', 'danger' or ''\n    tooltip='Test',\n    icon='check'\n)\n                       \ndef on_start_button_clicked(b):\n    #This is a workaround to have intreactive_output call the callback:\n    #   force the value of the dummy widget to change\n    if DW.value&gt; 0 :\n        DW.value = -1\n    else: \n        DW.value = 1\n    pass\nSTART.on_click(on_start_button_clicked)\n\nout = widgets.interactive_output(main_callback,{'matA':A,'DW':DW})\ndisplay(A,START,out)"
  },
  {
    "objectID": "ICCT_en/examples/04/SS-02-Modal_Analysis.html",
    "href": "ICCT_en/examples/04/SS-02-Modal_Analysis.html",
    "title": "Modal Analysis: Dig Into Matrix Modes",
    "section": "",
    "text": "# Erasmus+ ICCT project (2018-1-SI01-KA203-047081)\n\n# Toggle cell visibility\n\nfrom IPython.display import HTML\ntag = HTML('''&lt;script&gt;\ncode_show=true; \nfunction code_toggle() {\n    if (code_show){\n        $('div.input').hide()\n    } else {\n        $('div.input').show()\n    }\n    code_show = !code_show\n} \n$( document ).ready(code_toggle);\n&lt;/script&gt;\nToggle cell visibility &lt;a href=\"javascript:code_toggle()\"&gt;here&lt;/a&gt;.''')\ndisplay(tag)\n\n# Hide the code completely\n\n# from IPython.display import HTML\n# tag = HTML('''&lt;style&gt;\n# div.input {\n#     display:none;\n# }\n# &lt;/style&gt;''')\n# display(tag)\n\n\nToggle cell visibility here.\n\n\nThis example shows what the modes of Linear Time Invariant (LTI) systems are. The free response of the system (for this example we can assume, without loss of generality, that the system is autonomous) equals:\n\\[\n\\dot{x}(t)=Ax(t).\n\\]\nIt can be computed from the initial time \\(t_0\\), with initial condition \\(x(t_0)\\) as:\n\\[\nx(t) = e^{A(t-t_0)}x(t_0)\n\\]\nRecall that the matrix \\(e^{A(t-t_0)}x(t_0)\\) is composed of linear combinations of functions of time \\(t\\) of the type:\n\\[e^{\\lambda t},\\]\nwhere the \\(\\lambda\\)(s) are the eigenvalues of the matrix \\(A\\).\n\nHow to use this notebook?\n\nUse this example to figure out how the system modes look like and how their characteristics depend on the position of the eigenvalues on the complex plane.\nNote how modes corresponding to eigenvalues with positive real part diverge as time increases, and how modes corresponding to eigenvalues with negative real part converge to 0 when time increases.\nNote also how converging modes with larger absolute real parts converge faster than modes with lower absolute real part.\nFinally, note how the frequency of oscillation of the modes associated to pairs of complex conjugate poles depend on the value of the imaginary part of the poles, and the tendency of the oscillations to fade depend on the vicinity of complex poles to the imaginary axis.\nExplore the effects of changing matrix \\(A\\) values or load example matrices.\n\n\n#Preparatory Cell \n\nimport control\nimport numpy\nimport sympy\nfrom IPython.display import display, Markdown\nimport ipywidgets as widgets\nimport matplotlib.pyplot as plt\n\n#print a matrix latex-like\ndef bmatrix(a):\n     \"\"\"Returns a LaTeX bmatrix - by Damir Arbula (ICCT project)\n\n     :a: numpy array\n     :returns: LaTeX bmatrix as a string\n     \"\"\"\n     if len(a.shape) &gt; 2:\n         raise ValueError('bmatrix can at most display two dimensions')\n     lines = str(a).replace('[', '').replace(']', '').splitlines()\n     rv = [r'\\begin{bmatrix}']\n     rv += ['  ' + ' & '.join(l.split()) + r'\\\\' for l in lines]\n     rv +=  [r'\\end{bmatrix}']\n     return '\\n'.join(rv)\n\n\n# Display formatted matrix: \ndef vmatrix(a):\n    if len(a.shape) &gt; 2:\n         raise ValueError('bmatrix can at most display two dimensions')\n    lines = str(a).replace('[', '').replace(']', '').splitlines()\n    rv = [r'\\begin{vmatrix}']\n    rv += ['  ' + ' & '.join(l.split()) + r'\\\\' for l in lines]\n    rv +=  [r'\\end{vmatrix}']\n    return '\\n'.join(rv)\n\n\n#create a NxM matrix widget \ndef createMatrixWidget(n,m):\n    M = widgets.GridBox(children=[widgets.FloatText(layout=widgets.Layout(width='100px', height='40px'),\n    value=0.0, disabled=False, label=i) for i in range(n*m)],\n    layout=widgets.Layout(\n        #width='50%',\n        grid_template_columns= ''.join(['100px ' for i in range(m)]),\n        #grid_template_rows='80px 80px 80px',\n        grid_row_gap='0px',\n        track_size='0px')\n    )\n    return M\n\n\n#extract matrix from widgets and convert to numpy matrix\ndef getNumpyMatFromWidget(M,n,m):\n    #get W gridbox dims\n    M_ = numpy.matrix(numpy.zeros((n,m)))\n    for irow in range(0,n):\n        for icol in range(0,m):\n            M_[irow,icol] = M.children[irow*3+icol].value\n\n            \n#this is a simple derived class from FloatText used to experience with interact             \nclass floatWidget(widgets.FloatText):\n    def __init__(self,**kwargs):\n        #self.n = n\n        self.value = 30.0\n        #self.M = \n        widgets.FloatText.__init__(self, **kwargs)\n\n#    def value(self):\n#        return 0 #self.FloatText.value\n\nfrom traitlets import Unicode\nfrom ipywidgets import register \n\n\n#matrixWidget is a matrix looking widget built with a VBox of HBox(es) that returns a numPy array as value !\nclass matrixWidget(widgets.VBox):\n    def updateM(self,change):\n        for irow in range(0,self.n):\n            for icol in range(0,self.m):\n                self.M_[irow,icol] = self.children[irow].children[icol].value\n                #print(self.M_[irow,icol])\n        self.value = self.M_\n\n    def dummychangecallback(self,change):\n        pass\n    \n    \n    def __init__(self,n,m):\n        self.n = n\n        self.m = m\n        self.M_ = numpy.matrix(numpy.zeros((self.n,self.m)))\n        self.value = self.M_\n        widgets.VBox.__init__(self,\n                             children = [\n                                 widgets.HBox(children = \n                                              [widgets.FloatText(value=0.0, layout=widgets.Layout(width='90px')) for i in range(m)]\n                                             ) \n                                 for j in range(n)\n                             ])\n        \n        #fill in widgets and tell interact to call updateM each time a children changes value\n        for irow in range(0,self.n):\n            for icol in range(0,self.m):\n                self.children[irow].children[icol].value = self.M_[irow,icol]\n                self.children[irow].children[icol].observe(self.updateM, names='value')\n        #value = Unicode('example@example.com', help=\"The email value.\").tag(sync=True)\n        self.observe(self.updateM, names='value', type= 'All')\n        \n    def setM(self, newM):\n        #disable callbacks, change values, and reenable\n        self.unobserve(self.updateM, names='value', type= 'All')\n        for irow in range(0,self.n):\n            for icol in range(0,self.m):\n                self.children[irow].children[icol].unobserve(self.updateM, names='value')\n        self.M_ = newM\n        self.value = self.M_\n        for irow in range(0,self.n):\n            for icol in range(0,self.m):\n                self.children[irow].children[icol].value = self.M_[irow,icol]\n        for irow in range(0,self.n):\n            for icol in range(0,self.m):\n                self.children[irow].children[icol].observe(self.updateM, names='value')\n        self.observe(self.updateM, names='value', type= 'All')        \n\n                #self.children[irow].children[icol].observe(self.updateM, names='value')\n\n        \n\n        \n#overlaod class for state space systems that DO NOT remove \"useless\" states (what \"professor\" of automatic control would do this?)\nclass sss(control.StateSpace):\n    def __init__(self,*args):\n        #call base class init constructor\n        control.StateSpace.__init__(self,*args)\n    #disable function below in base class\n    def _remove_useless_states(self):\n        pass\n\n\n\n#define matrices\nA = matrixWidget(4,4)\n\n#this is the main callback and does all the computations and plots \ndef main_callback(matA,DW,sel):\n    #check if a specific matrix is requested or is manual \n    if sel=='manual definition of the system' :\n        pass\n    elif sel == 'stable system - no complex congjugate poles':\n        matA = numpy.zeros((4,4))\n        matA[0,0] = -1\n        matA[1,1] = -2\n        matA[2,2] = -3\n        matA[3,3] = -4\n        A.setM(matA)\n    elif sel == 'stable system - w/ complex conjugate pair':\n        matA = numpy.zeros((4,4))\n        matA[0,0] = -1\n        matA[0,1] = 3\n        matA[1,0] = -3\n        matA[1,1] = -1\n        matA[2,2] = -3\n        matA[3,3] = -4\n        A.setM(matA)\n    elif sel == 'unstable system - unstable real pole unstable':\n        matA = numpy.zeros((4,4))\n        matA[0,0] = 1\n        matA[1,1] = -2\n        matA[2,2] = -3\n        matA[3,3] = -4\n        A.setM(matA)\n    elif sel ==  'unstable system - unstable complex conjugate pair ':\n        matA = numpy.zeros((4,4))\n        matA[0,0] = 1\n        matA[0,1] = 3\n        matA[1,0] = -3\n        matA[1,1] = 1\n        matA[2,2] = -3\n        matA[3,3] = -4\n        A.setM(matA)\n    else : \n        matA = numpy.zeros((4,4))\n        A.setM(matA)\n\n        \n    # Work with symbolic matrix\n    matAs = sympy.Matrix(matA)\n    dictEig = matAs.eigenvals()\n    eigs = list(dictEig.keys())\n    algMult = list(dictEig.values())\n    \n    # check dimension of jordan blocks\n    dimJblock = []\n    for i in range(len(eigs)):\n        dimJblock.append(algMult[i]-len((matAs-eigs[i]*sympy.eye(4)).nullspace())+1)\n    \n    timeVectors = []\n    modeVectors = []\n    # compute modes simulations and prepare modestring\n    modestring = ''\n    for i in range(len(eigs)):\n        sim = []\n        if sympy.re(eigs[i]) &gt;= 0:\n            # instable or integral like\n            time = numpy.linspace(0,10,1000)\n            for n in range(dimJblock[i]):\n                if n==0:\n                    if sympy.im(eigs[i]) != 0 and (sympy.conjugate(eigs[i]) not in eigs[0:i]):\n                        sim.append(time**n*numpy.exp(float(sympy.re(eigs[i]))*time)*numpy.cos(float(sympy.im(eigs[i]))*time))\n                        modestring = modestring + \"$e^{%s t} cos(%s t + \\phi)$  \" % (str(float(sympy.re(eigs[i]))), str(float(sympy.im(eigs[i]))))\n                    elif sympy.im(eigs[i]) == 0:\n                        sim.append(time**n*numpy.exp(float(sympy.re(eigs[i]))*time))\n                        modestring = modestring + \"$e^{%s t}$  \" % (str(float(sympy.re(eigs[i]))))\n                else:\n                    if sympy.im(eigs[i]) != 0 and (sympy.conjugate(eigs[i]) not in eigs[0:i]):\n                        sim.append(time**n*numpy.exp(float(sympy.re(eigs[i]))*time)*numpy.cos(float(sympy.im(eigs[i]))*time))\n                        modestring = modestring + \"$t^{%s}e^{%s t} cos(%s t + \\phi)$  \" % (str(n), str(float(sympy.re(eigs[i]))), str(float(sympy.im(eigs[i]))))\n                    elif sympy.im(eigs[i]) == 0:\n                        sim.append(time**n*numpy.exp(float(sympy.re(eigs[i]))*time))\n                        modestring = modestring + \"$t^{%s}e^{%s t}$  \" % (str(n), str(float(sympy.re(eigs[i]))))\n        else:\n            # stable mode\n            time = numpy.linspace(0,10*(1/float(sympy.Abs(eigs[i]))),1000)\n            for n in range(dimJblock[i]):\n                if n==0:\n                    if sympy.im(eigs[i]) != 0 and (sympy.conjugate(eigs[i]) not in eigs[0:i]):\n                        sim.append(time**n*numpy.exp(float(sympy.re(eigs[i]))*time)*numpy.cos(float(sympy.im(eigs[i]))*time))\n                        modestring = modestring + \"$e^{%s t} cos(%s t + \\phi)$  \" % (str(float(sympy.re(eigs[i]))), str(float(sympy.im(eigs[i]))))\n                    elif sympy.im(eigs[i]) == 0:\n                        sim.append(time**n*numpy.exp(float(sympy.re(eigs[i]))*time))\n                        modestring = modestring + \"$e^{%s t}$  \" % (str(float(sympy.re(eigs[i]))))\n                else:\n                    if sympy.im(eigs[i]) != 0 and (sympy.conjugate(eigs[i]) not in eigs[0:i]):\n                        sim.append(time**n*numpy.exp(float(sympy.re(eigs[i]))*time)*numpy.cos(float(sympy.im(eigs[i]))*time))\n                        modestring = modestring + \"$t^{%s}e^{%s t} cos(%s t + \\phi)$  \" % (str(n), str(float(sympy.re(eigs[i]))), str(float(sympy.im(eigs[i]))))\n                    elif sympy.im(eigs[i]) == 0:\n                        sim.append(time**n*numpy.exp(float(sympy.re(eigs[i]))*time))\n                        modestring = modestring + \"$t^{%s}e^{%s t}$  \" % (str(n), str(float(sympy.re(eigs[i]))))\n        if len(sim) != 0:\n            timeVectors.append(time)\n            modeVectors.append(sim)\n    \n    #print(dimJblock)\n    #print(len(modeVectors))\n    \n    #create textual output            \n    display(Markdown('Matrix: $%s$ has the eigenvalues $%s$' % (vmatrix(matA), vmatrix(numpy.array(numpy.linalg.eig(matA)[0])))))\n    display(Markdown('that correspond to the modes: %s' % modestring))  \n    \n    #compute total number of figures\n    totfig=0\n    for i in range(len(modeVectors)):\n            totfig = totfig + len(modeVectors[i])\n            \n    #plot each single mode\n    fig = plt.figure(figsize=(20, 4))\n    idx = 1\n    for i in range(len(timeVectors)):\n        for j in range(len(modeVectors[i])):\n            sf = fig.add_subplot(1,totfig,idx)\n            idx = idx + 1\n            sf.plot(timeVectors[i],modeVectors[i][j])\n            sf.grid(True)\n            plt.xlabel(r'$t$ [s]')\n            plt.axvline(x=0,color='black',linewidth=0.8)\n            plt.axhline(y=0,color='black',linewidth=0.8)\n    \n    #plot pzmap (poles only)    \n    pzmap = plt.figure(figsize=(6,6))\n    sf = pzmap.add_subplot(111)\n    sf.grid(True)\n    sf.set_xlabel('$Re$')\n    sf.set_ylabel('$Im$')\n    realVals = [float(sympy.re(i)) for i in eigs]\n    imagVals = [float(sympy.im(i)) for i in eigs]\n    sf.set_xlim([min(realVals)*1.1-0.1, max(realVals)*1.1+0.1])\n    sf.set_ylim([min(imagVals)*1.1-0.1, max(imagVals)*1.1+0.1])\n    sf.set_aspect('equal', adjustable='datalim')\n    sf.axvline(0,color='black')\n    sf.axhline(0,color='black')\n\n    sf.scatter(realVals, imagVals, marker='x')\n    \n    \n#create dummy widget \nDW = widgets.FloatText(layout=widgets.Layout(width='0px', height='0px'))\n\n#create button widget\nSTART = widgets.Button(\n    description='Test',\n    disabled=False,\n    button_style='', # 'success', 'info', 'warning', 'danger' or ''\n    tooltip='Test',\n    icon='check'\n)\n                       \ndef on_start_button_clicked(b):\n    #This is a workaround to have intreactive_output call the callback:\n    #   force the value of the dummy widget to change\n    if DW.value&gt; 0 :\n        DW.value = -1\n    else: \n        DW.value = 1\n    pass\nSTART.on_click(on_start_button_clicked)\n\n#define type of ipout \nSELECT = widgets.Dropdown(\n    options=['manual definition of the system', 'reset', 'stable system - no complex congjugate poles', \n             'stable system - w/ complex conjugate pair', \n             'unstable system - unstable real pole unstable', \n             'unstable system - unstable complex conjugate pair '],\n    value='manual definition of the system',\n    description='Examples:',\n    disabled=False,\n)\n\n\n#create a graphic structure to hold all widgets \nalltogether =  widgets.VBox([SELECT, widgets.Label(''), widgets.HBox([widgets.Label('$\\dot{x}(t) = $',border=3), A,widgets.Label('$x(t)$',border=3), START])] )\n    \n\nout = widgets.interactive_output(main_callback,{'matA': A, 'DW': DW, 'sel': SELECT})\nout.layout.height = '770px'\ndisplay(alltogether,out)"
  },
  {
    "objectID": "ICCT_en/examples/03/FD-24_Pendulum_on_a_Cart.html",
    "href": "ICCT_en/examples/03/FD-24_Pendulum_on_a_Cart.html",
    "title": "Control design for a Pendulum on a Cart system",
    "section": "",
    "text": "%matplotlib notebook\nimport control as c\nimport ipywidgets as w\nimport numpy as np\n\nfrom IPython.display import display, HTML\nimport matplotlib.pyplot as plt\nimport matplotlib.patches as patches\nimport matplotlib.transforms as transforms\nimport matplotlib.animation as animation\n\ndisplay(HTML('&lt;script&gt; $(document).ready(function() { $(\"div.input\").hide(); }); &lt;/script&gt;'))\n\n\n\n\nThe following example is a control design task for a Pendulum on Cart system. The structure consists of an inverted pendulum balanced atop of a cart that can freely move in a pool of oil (the latter serves as damping).   \nThe model is nonlinear and has two degrees of freedom. In order to control it with a single PID controller, we have to linearize it around the balanced position and detach the linear movement from the positioning. Therefore the results are only valid for really small angular movement, and the cart will also drift uncontrollably.\nThe linearized equations of motion are:  \\[(J+mL^2)\\cdot\\ddot{\\varphi}-mgL\\cdot\\varphi=mL\\cdot\\ddot{x}\\] \\[(M+m)\\cdot\\ddot{x}+b\\cdot x-mL\\cdot\\ddot{\\varphi}=F\\]  Where:  \\[J=\\frac{1}{12}m(2L)^2\\]  The transfer function can be expressed as:  \\[G(s)=\\frac{\\frac{mL}{q}s^2}{s^4+\\frac{b(J+mL^2)}{q}s^3-\\frac{(M+m)mgL}{q}s^2-\\frac{bmgL}{q}s}\\]  Where:  \\[q=(M+m)(J+mL^2)-(mL)^2\\] \nYour task is to choose a controller type, and tune it to acceptable levels of performance!\nFirst, choose a system model! Toggle between different realistic models with randomly preselected values (buttons Model 1 - Model 6). By clicking the Preset button default, valid predetermined controller parameters are set and cannot be tuned further.\n\n# System parameters\n\ng = 9.81   # m/s^2 - gravitational acceleration\n\n# Figure definition\n\nfig1, ((f1_ax1), (f1_ax2)) = plt.subplots(2, 1)\nfig1.set_size_inches((9.8, 5))\nfig1.set_tight_layout(True)\n\nf1_line1, = f1_ax1.plot([], [])\nf1_line2, = f1_ax2.plot([], [])  \n\nf1_ax1.grid(which='both', axis='both', color='lightgray')\nf1_ax2.grid(which='both', axis='both', color='lightgray')\n\nf1_ax1.autoscale(enable=True, axis='both', tight=True)\nf1_ax2.autoscale(enable=True, axis='both', tight=True)\n\nf1_ax1.set_title('Bode magnitude plot', fontsize=11)\nf1_ax1.set_xscale('log')\nf1_ax1.set_xlabel(r'$f\\/$[Hz]', labelpad=0, fontsize=10)\nf1_ax1.set_ylabel(r'$A\\/$[dB]', labelpad=0, fontsize=10)\nf1_ax1.tick_params(axis='both', which='both', pad=0, labelsize=8)\n\nf1_ax2.set_title('Bode phase plot', fontsize=11)\nf1_ax2.set_xscale('log')\nf1_ax2.set_xlabel(r'$f\\/$[Hz]', labelpad=0, fontsize=10)\nf1_ax2.set_ylabel(r'$\\phi\\/$[°]', labelpad=0, fontsize=10)\nf1_ax2.tick_params(axis='both', which='both', pad=0, labelsize=8)\n\ndef build_base_model(M, m, L, b):\n   \n    J=1/3*m*L*L\n    C=(M+m)*(J+m*L*L)-(m*m*L*L)\n    W_sys = c.tf([m*L/C, 0, 0], [1, b*(J+m*L*L)/C,-(M+m)*m*g*L/C, -b*m*g*L/C, 0])\n    \n    print('System transfer function:')\n    print(W_sys)\n    \n    # System analysis\n    \n    poles = c.pole(W_sys)     # Poles\n    \n    print('System poles:\\n')\n    print(poles)\n    \n    global f1_line1, f1_line2\n    \n    f1_ax1.lines.remove(f1_line1)\n    f1_ax2.lines.remove(f1_line2)\n    \n    mag, phase, omega = c.bode_plot(W_sys, Plot=False)   # Bode-plot\n    \n    f1_line1, = f1_ax1.plot(omega/2/np.pi, 20*np.log10(mag), lw=1, color='blue')\n    f1_line2, = f1_ax2.plot(omega/2/np.pi, phase*180/np.pi, lw=1, color='blue')   \n    \n    f1_ax1.relim()\n    f1_ax2.relim()\n    f1_ax1.autoscale_view()\n    f1_ax2.autoscale_view()\n    \n# GUI widgets\n\ntypeSelect = w.ToggleButtons(\n    options=[('Model 1', 0), ('Model 2', 1), ('Model 3', 2), ('Model 4', 3), ('Model 5', 4), ('Model 6', 5), ('Preset', -1)],\n    value=-1, description='System: ', layout=w.Layout(width='60%'))\n\nM_slider = w.FloatLogSlider(value=2, base=10, min=-1, max=2, description='M [kg] :', continuous_update=False,\n                            layout=w.Layout(width='auto', flex='5 5 auto'))\nm_slider = w.FloatLogSlider(value=0.1, base=10, min=-1, max=2, description='m [kg] :', continuous_update=False,\n                            layout=w.Layout(width='auto', flex='5 5 auto'))\nL_slider = w.FloatLogSlider(value=0.125, base=10, min=-2, max=1, description='L [m] :', continuous_update=False,\n                            layout=w.Layout(width='auto', flex='5 5 auto'))\nb_slider = w.FloatLogSlider(value=0.002, base=10, min=-3, max=1, description='b [Ns/m] :', continuous_update=False,\n                            layout=w.Layout(width='auto', flex='5 5 auto'))\n\ninput_data = w.interactive_output(build_base_model, {'M':M_slider, 'm':m_slider, 'L':L_slider, 'b':b_slider})\n\ndef update_sliders(index):\n    global M_slider, m_slider, L_slider, b_slider\n    \n    Mval = [0.5, 0.5, 1, 1, 5, 10, 2]\n    mval = [0.1, 0.5, 0.5, 0.5, 1, 3, 0.5]\n    Lval = [0.1, 0.2, 0.1, 0.5, 0.5, 1, 0.2]\n    bval = [0.015, 0.015, 0.03, 0.1, 0.5, 0.5, 0.015]\n    \n    M_slider.value = Mval[index]\n    m_slider.value = mval[index]\n    L_slider.value = Lval[index]\n    b_slider.value = bval[index]\n    \n    if index == -1:\n        M_slider.disabled = True\n        m_slider.disabled = True\n        L_slider.disabled = True\n        b_slider.disabled = True\n    else:\n        M_slider.disabled = False\n        m_slider.disabled = False\n        L_slider.disabled = False\n        b_slider.disabled = False\n    \ninput_data2 = w.interactive_output(update_sliders, {'index':typeSelect})\n\ndisplay(typeSelect, input_data2)\ndisplay(w.HBox([w.VBox([M_slider, m_slider], layout=w.Layout(width='45%')),\n                w.VBox([L_slider, b_slider], layout=w.Layout(width='45%'))]), input_data)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nThe system contains an unstable pole, which has to be countered properly; otherwise, the pendulum can not be balanced. Select an appropriate controller configuration! Which one is the best for your system? Why? Set up your controller so that it settles to zero without significant outswing!\nYou can turn on/off each of the I and D components, and if D is active, you can apply the first-order filter as well, based on the derivating time constant.\n\n# PID balancer\n\nfig2, ((f2_ax1, f2_ax2, f2_ax3), (f2_ax4, f2_ax5, f2_ax6)) = plt.subplots(2, 3)\nfig2.set_size_inches((9.8, 5))\nfig2.set_tight_layout(True)\n\nf2_line1, = f2_ax1.plot([], [])\nf2_line2, = f2_ax2.plot([], []) \nf2_line3, = f2_ax3.plot([], [])\nf2_line4, = f2_ax4.plot([], [])  \nf2_line5, = f2_ax5.plot([], [])\nf2_line6, = f2_ax6.plot([], [])\n\nf2_ax1.grid(which='both', axis='both', color='lightgray')\nf2_ax2.grid(which='both', axis='both', color='lightgray')\nf2_ax3.grid(which='both', axis='both', color='lightgray')\nf2_ax4.grid(which='both', axis='both', color='lightgray')\nf2_ax5.grid(which='both', axis='both', color='lightgray')\nf2_ax6.grid(which='both', axis='both', color='lightgray')\n\nf2_ax1.autoscale(enable=True, axis='both', tight=True)\nf2_ax2.autoscale(enable=True, axis='both', tight=True)\nf2_ax3.autoscale(enable=True, axis='both', tight=True)\nf2_ax4.autoscale(enable=True, axis='both', tight=True)\nf2_ax5.autoscale(enable=True, axis='both', tight=True)\nf2_ax6.autoscale(enable=True, axis='both', tight=True)\n\n\nf2_ax1.set_title('Closed loop step response', fontsize=9)\nf2_ax1.set_xlabel(r'$t\\/$[s]', labelpad=0, fontsize=8)\nf2_ax1.set_ylabel(r'$\\theta\\/$[rad]', labelpad=0, fontsize=8)\nf2_ax1.tick_params(axis='both', which='both', pad=0, labelsize=6)\n\nf2_ax2.set_title('Nyquist diagram', fontsize=9)\nf2_ax2.set_xlabel(r'Re', labelpad=0, fontsize=8)\nf2_ax2.set_ylabel(r'Im', labelpad=0, fontsize=8)\nf2_ax2.tick_params(axis='both', which='both', pad=0, labelsize=6)\n\nf2_ax3.set_title('Bode magniture plot', fontsize=9)\nf2_ax3.set_xscale('log')\nf2_ax3.set_xlabel(r'$f\\/$[Hz]', labelpad=0, fontsize=8)\nf2_ax3.set_ylabel(r'$A\\/$[dB]', labelpad=0, fontsize=8)\nf2_ax3.tick_params(axis='both', which='both', pad=0, labelsize=6)\n\nf2_ax4.set_title('Closed loop impulse response', fontsize=9)\nf2_ax4.set_xlabel(r'$t\\/$[s]', labelpad=0, fontsize=8)\nf2_ax4.set_ylabel(r'$\\theta\\/$[rad]', labelpad=0, fontsize=8)\nf2_ax4.tick_params(axis='both', which='both', pad=0, labelsize=6)\n\nf2_ax5.set_title('Load transfer step response', fontsize=9)\nf2_ax5.set_xlabel(r'$t\\/$[s]', labelpad=0, fontsize=8)\nf2_ax5.set_ylabel(r'$\\theta\\/$[rad]', labelpad=0, fontsize=8)\nf2_ax5.tick_params(axis='both', which='both', pad=0, labelsize=6)\n\nf2_ax6.set_title('Bode phase plot', fontsize=9)\nf2_ax6.set_xscale('log')\nf2_ax6.set_xlabel(r'$f\\/$[Hz]', labelpad=0, fontsize=8)\nf2_ax6.set_ylabel(r'$\\phi\\/$[°]', labelpad=0, fontsize=8)\nf2_ax6.tick_params(axis='both', which='both', pad=0, labelsize=6)\n\ndef position_control(Kp, Ti, Td, Fd, Ti0, Td0, Fd0, M, m, L, b):\n    \n    J=1/3*m*L*L\n    C=(M+m)*(J+m*L*L)-(m*m*L*L)\n    W_sys = c.tf([m*L/C, 0, 0], [1, b*(J+m*L*L)/C,-(M+m)*m*g*L/C, -b*m*g*L/C, 0])\n    \n    # PID Controller\n    \n    P = Kp             # Proportional term\n    I = Kp / Ti        # Integral term\n    D = Kp * Td        # Derivative term\n    Td_f = Td / Fd     # Derivative term filter\n    \n    W_PID = c.parallel(c.tf([P], [1]),\n                       c.tf([I * Ti0], [1 * Ti0, 1 * (not Ti0)]),\n                       c.tf([D * Td0, 0], [Td_f * Td0 * Fd0, 1]))  # PID controller in time constant format\n    \n    W_open = c.series(W_PID, W_sys)         # Open loop \n    W_closed = c.feedback(W_open, 1, -1)    # Closed loop with negative feedback\n    \n    W_load = c.feedback(W_sys, W_PID, -1)   # Transfer function of the disturbance based errors  \n                        \n    # Display\n\n    global f2_line1, f2_line2, f2_line3, f2_line4, f2_line5, f2_line6\n    \n    f2_ax1.lines.remove(f2_line1)\n    f2_ax2.lines.remove(f2_line2)\n    f2_ax3.lines.remove(f2_line3)\n    f2_ax4.lines.remove(f2_line4)\n    f2_ax5.lines.remove(f2_line5)\n    f2_ax6.lines.remove(f2_line6)\n    \n    tout, yout = c.step_response(W_closed)\n    f2_line1, = f2_ax1.plot(tout, yout, lw=1, color='blue') \n    \n    _, _, ob = c.nyquist_plot(W_open, Plot=False)   # Small resolution plot to determine bounds        \n    real, imag, freq = c.nyquist_plot(W_open, omega=np.logspace(np.log10(ob[0]), np.log10(ob[-1]), 1000), Plot=False)\n    f2_line2, = f2_ax2.plot(real, imag, lw=1, color='blue')\n    \n    mag, phase, omega = c.bode_plot(W_open, Plot=False)\n    f2_line3, = f2_ax3.plot(omega/2/np.pi, 20*np.log10(mag), lw=1, color='blue')\n    f2_line6, = f2_ax6.plot(omega/2/np.pi, phase*180/np.pi, lw=1, color='blue')\n    \n    tout, yout = c.impulse_response(W_closed)\n    f2_line4, = f2_ax4.plot(tout, yout, lw=1, color='blue')   \n    \n    tout, yout = c.step_response(W_load)\n    f2_line5, = f2_ax5.plot(tout, yout, lw=1, color='blue') \n    \n    f2_ax1.relim()\n    f2_ax2.relim()\n    f2_ax3.relim()\n    f2_ax4.relim()\n    f2_ax5.relim()\n    f2_ax6.relim()\n    f2_ax1.autoscale_view()\n    f2_ax2.autoscale_view()\n    f2_ax3.autoscale_view()\n    f2_ax4.autoscale_view()\n    f2_ax5.autoscale_view()\n    f2_ax6.autoscale_view()\n    \ndef update_controller(index):\n    global Kp_slider, Ti_slider, Td_slider, Fd_slider, Ti_button, Td_button\n    \n    if index == -1:\n        Kp_slider.value = 500\n        Ti_slider.value = 0.5\n        Td_slider.value = 0.05\n        Fd_slider.value = 10\n        Ti_button.value = True\n        Td_button.value = True\n        Fd_button.value = True\n        \n        Kp_slider.disabled = True\n        Ti_slider.disabled = True\n        Td_slider.disabled = True\n        Fd_slider.disabled = True\n        Ti_button.disabled = True\n        Td_button.disabled = True\n        Fd_button.disabled = True\n    else:\n        Kp_slider.disabled = False\n        Ti_slider.disabled = False\n        Td_slider.disabled = False\n        Fd_slider.disabled = False\n        Ti_button.disabled = False\n        Td_button.disabled = False\n        Fd_button.disabled = False\n\n# GUI widgets\n\nKp_slider = w.FloatLogSlider(value=500, base=10, min=-3, max=5, description='Kp:', continuous_update=False,\n                             layout=w.Layout(width='auto', flex='5 5 auto'))\nTi_slider = w.FloatLogSlider(value=0.0125, base=10, min=-4, max=1, description='', continuous_update=False,\n                             layout=w.Layout(width='auto', flex='5 5 auto'))\nTd_slider = w.FloatLogSlider(value=0.16, base=10, min=-4, max=1, description='', continuous_update=False,\n                             layout=w.Layout(width='auto', flex='5 5 auto'))\nFd_slider = w.FloatLogSlider(value=1, base=10, min=0, max=3, description='', continuous_update=False,\n                             layout=w.Layout(width='auto', flex='5 5 auto'))\n\nTi_button = w.ToggleButton(value=True, description='Ti',\n                           layout=w.Layout(width='auto', flex='1 1 0%'))\nTd_button = w.ToggleButton(value=True, description='Td',\n                           layout=w.Layout(width='auto', flex='1 1 0%'))\nFd_button = w.ToggleButton(value=False, description='Fd',\n                           layout=w.Layout(width='auto', flex='1 1 0%'))\n\ninput_data = w.interactive_output(position_control, {'Kp': Kp_slider, 'Ti': Ti_slider, 'Td': Td_slider,\n                                                     'Fd': Fd_slider, 'Ti0' : Ti_button, 'Td0': Td_button,\n                                                     'Fd0': Fd_button, 'M':M_slider, 'm':m_slider,\n                                                     'L':L_slider, 'b':b_slider})\n\nw.interactive_output(update_controller, {'index':typeSelect})\n\ndisplay(w.HBox([Kp_slider, Ti_button, Ti_slider, Td_button, Td_slider, Fd_button, Fd_slider]), input_data)\n\n\n\n\n\n\n\n\n\n\n\n\n\nIn the following simulation, you can observe the movement of your system based on your controller setup. You can apply some disturbance and see how the system reacts.\nCan the controller really balance the pendulum? For how long? Are the input and the cart movement realistic?  (The animations are scaled to fit the frame through the whole simulation. Because of this, unstable solutions might not seem to move until the very last second.)\n\n# Simulation\n\nanim_fig = plt.figure()\nanim_fig.set_size_inches((9.8, 6))\nanim_fig.set_tight_layout(True)\n\nanim_ax1 = anim_fig.add_subplot(211)\nanim_ax2 = anim_ax1.twinx()\nanim_ax3 = anim_ax1.twinx()\n\nframe_count=1000\n\nl1 = anim_ax1.plot([], [], lw=2, color='red')\nl2 = anim_ax2.plot([], [], lw=1, color='grey')\nl3 = anim_ax3.plot([], [], lw=1, color='blue')\n\nline1 = l1[0]\nline2 = l2[0]\nline3 = l3[0]\n\nanim_ax1.legend(l1+l2+l3, ['Angle [rad]', 'Disturbance [N]', 'Position [m]'], loc=1)\n\nanim_ax1.set_title('Time response simulation', fontsize=12)\nanim_ax1.set_xlabel(r'$t\\/$[s]', labelpad=0, fontsize=10)\nanim_ax1.set_ylabel(r'$\\theta\\/$[rad]', labelpad=0, fontsize=10)\nanim_ax1.tick_params(axis='both', which='both', pad=0, labelsize=8)\nanim_ax2.set_ylabel(r'$F\\/$[N]', labelpad=0, fontsize=10)\nanim_ax2.tick_params(axis='both', which='both', pad=0, labelsize=8)\nanim_ax3.set_ylabel(r'$x\\/$[m]', labelpad=0, fontsize=10)\nanim_ax3.tick_params(axis='both', which='both', pad=0, labelsize=8)\n\nanim_ax1.grid(which='both', axis='both', color='lightgray')\n\nanim_ax3.spines[\"right\"].set_position((\"axes\", 1.075))\n\nT_plot = []\nR_plot = []\nF_plot = []\nX_plot = []\n\n# Scene data\n\nscene_ax = anim_fig.add_subplot(212)\nscene_ax.set_xlim((-3, 3))\nscene_ax.set_ylim((-1, 1))\n#scene_ax.axis('off')\n\n\nscene_ax.add_patch(patches.Rectangle((-2.9, -0.9), 5.8, 0.5, fill=False, ec='black', lw=0, hatch='////', zorder=0))\nscene_ax.add_patch(patches.Rectangle((-2.8, -0.8), 5.6, 0.4, fill=True, fc='black', lw=0, zorder=5))\nscene_ax.add_patch(patches.Rectangle((-2.9, -0.4), 5.8, 0.05, fill=True, fc='black', lw=0, zorder=5))\nscene_ax.add_patch(patches.Rectangle((-2.75, -0.75), 5.5, 0.5, fill=True, fc='white', lw=0, zorder=10))\n\nscene_ax.add_patch(patches.Rectangle((-2.75, -0.75), 5.5, 0.2, fill=True, fc='goldenrod', alpha=0.5, lw=0, zorder=30))\n\nwheel_1 = patches.Circle((-0.2, -0.675), radius=0.075, fill=True, ec='black', fc='gray', lw=1, zorder=15)\nwheel_2 = patches.Circle((0.2, -0.675), radius=0.075, fill=True, ec='black', fc='gray', lw=1, zorder=15)\nwheel_1_p = patches.Circle((-0.2, -0.675), radius=0.01, fill=True, ec='black', fc='lightgray', lw=1, zorder=25)\nwheel_2_p = patches.Circle((0.2, -0.675), radius=0.01, fill=True, ec='black', fc='lightgray', lw=1, zorder=25)\ncart = patches.Rectangle((-0.35, -0.6), 0.7, 0.4, fill=True, ec='black', fc='slategray', lw=1, zorder=25)\njoint = patches.Polygon(np.stack(([-0.075, 0.075, 0, -0.075], [-0.2, -0.2, -0.075, -0.2])).T,\n                        fill=True, lw=1, ec='black', fc='black', zorder=40)\njoint_p = patches.Circle((0, -0.1), radius=0.025, fill=True, ec='black', fc='lightgray', lw=1, zorder=45)\n\nscene_ax.add_patch(wheel_1)\nscene_ax.add_patch(wheel_2)\nscene_ax.add_patch(wheel_1_p)\nscene_ax.add_patch(wheel_2_p)\nscene_ax.add_patch(cart)\nscene_ax.add_patch(joint)\nscene_ax.add_patch(joint_p)\n\ntilt_transform = transforms.Affine2D()\n\nrod_outline, = scene_ax.plot([0, 0], [-0.1, 0.9], color='black', solid_capstyle='round', lw=9, zorder=30,\n                             transform=tilt_transform  + scene_ax.transData)\nrod, = scene_ax.plot([0, 0], [-0.1, 0.9], color='saddlebrown', solid_capstyle='round', lw=7, zorder=35,\n                     transform=tilt_transform  + scene_ax.transData)\n\ncart_pos = []\n\n\ndef simulation(Kp, Ti, Td, Fd, Ti0, Td0, Fd0, M, m, L, b, T, dt, F, Ff, Fa, Fo):\n    \n    # Controller\n    P = Kp                      # Proportional term\n    I = Kp / Ti                 # Integral term\n    D = Kp * Td                 # Derivative term\n    Td_f = Td / Fd              # Derivative term filter\n    \n    W_PID = c.parallel(c.tf([P], [1]),\n                       c.tf([I * Ti0], [1 * Ti0, 1 * (not Ti0)]),\n                       c.tf([D * Td0, 0], [Td_f * Td0 * Fd0, 1]))  # PID controller\n    \n    # System model    \n    \n    J=1/12*m*L*L\n    C=(M+m)*(J+m*L*L)-(m*m*L*L)\n    W_sys = c.tf([m*L/C, 0, 0], [1, b*(J+m*L*L)/C,-(M+m)*m*g*L/C, -b*m*g*L/C, 0])    # System for angular positioning\n    \n    W_x = c.tf([J+m*L*L, 0, -m*g*L],\n               [M*(J+m*L*L)+m*J, (J+m*L*L)*b, -(M+m)*m*g*L, -m*g*L*b, 0])   # System for the linear position  \n    \n    # Controlled model\n    \n    W_open = c.series(W_PID, W_sys)         # Open loop\n    W_closed = c.feedback(W_open, 1, -1)    # Closed loop with negative feedback\n    W_load = c.feedback(W_sys, W_PID, -1)   # Transfer function of the disturbance based errors  \n    \n    W_fpos = c.series(c.feedback(W_PID, W_sys, -1), W_x)   # Reference induced position change\n    W_lpos = c.series(c.feedback(1, W_open, -1), W_x)      # Load induced position change\n    \n    # Reference and disturbance signals\n\n    T_sim = np.arange(0, T_slider.value, dt_slider.value, dtype=np.float64)\n    \n    A_sim = np.full_like(T_sim, 0)  # Constant reference to 0°\n        \n    if F == 0:     # Constant disturbance\n        F_sim = np.full_like(T_sim, Fa * Fo)\n    elif F == 1:   # Sine wave disturbance\n        F_sim = (np.sin(2 * np.pi * Ff * T_sim) + Fo) * Fa\n    elif F == 2:   # Square wave disturbance\n        F_sim = (np.sign(np.sin(2 * np.pi * Ff * T_sim)) + Fo) * Fa\n    elif F == 3:   # Noise form disturbance\n        F_sim = np.interp(T_sim, np.linspace(0, T, int(T * Ff) + 2),\n                          np.random.normal(loc=(Fo * Fa), scale=Fa, size=int(T * Ff) + 2))\n    \n    # System response for angular position\n        \n    Ta, youta, xouta = c.forced_response(W_closed, T_sim, A_sim)\n    Tf, youtf, xoutf = c.forced_response(W_load, T_sim, F_sim)\n    R_sim = np.nan_to_num(youta + youtf)\n    \n    # System response for linear position\n    \n    Tx, youtx, xoulx = c.forced_response(W_fpos, T_sim, A_sim)\n    Tl, youtl, xoutl = c.forced_response(W_lpos, T_sim, F_sim)\n    X_sim = np.nan_to_num(youtx + youtl)\n    \n    # Display\n            \n    R_max = np.max(np.abs(R_sim))\n    F_max = max(np.max(np.abs(F_sim)), Fa)\n    X_max = np.max(np.abs(X_sim))\n    \n    anim_ax1.set_xlim((0, T))\n    anim_ax1.set_ylim((-1.2 * R_max, 1.2 * R_max))\n    anim_ax2.set_ylim((-1.2 * F_max, 1.2 * F_max))\n    anim_ax3.set_ylim((-1.2 * X_max, 1.2 * X_max))\n    \n    global T_plot, R_plot, F_plot, X_plot, cart_pos\n    \n    T_plot = np.linspace(0, T, frame_count, dtype=np.float32)\n    R_plot = np.interp(T_plot, T_sim, R_sim)\n    F_plot = np.interp(T_plot, T_sim, F_sim)\n    X_plot = np.interp(T_plot, T_sim, X_sim)   \n    \n    cart_pos = X_plot / X_max * 2.4\n\ndef anim_init():\n    line1.set_data([], [])\n    line2.set_data([], [])\n    line3.set_data([], [])\n    \n    wheel_1.set_center((-0.2, -0.675))\n    wheel_2.set_center((0.2, -0.675))\n    wheel_1_p.set_center((-0.2, -0.675))\n    wheel_2_p.set_center((0.2, -0.675))\n    joint_p.set_center((0, -0.1))\n    \n    cart.set_xy((-0.35, -0.6))\n    \n    joint.set_xy(np.stack(([-0.075, 0.075, 0, -0.075], [-0.2, -0.2, -0.075, -0.2])).T)\n    \n    rod.set_data([0, 0], [-0.1, 0.9])\n    rod_outline.set_data([0, 0], [-0.1, 0.9])\n    \n    tilt_transform.clear()\n    \n    return (line1, line2, line3, wheel_1, wheel_2, wheel_1_p, wheel_2_p, cart, joint, joint_p, rod, rod_outline,)\n\ndef animate(i):\n    line1.set_data(T_plot[0:i], R_plot[0:i])\n    line2.set_data(T_plot[0:i], F_plot[0:i])\n    line3.set_data(T_plot[0:i], X_plot[0:i])\n    \n    wheel_1.set_center((cart_pos[i]-0.2, -0.675))\n    wheel_2.set_center((cart_pos[i]+0.2, -0.675))\n    wheel_1_p.set_center((cart_pos[i]-0.2, -0.675))\n    wheel_2_p.set_center((cart_pos[i]+0.2, -0.675))\n    joint_p.set_center((cart_pos[i], -0.1))\n    \n    cart.set_x(cart_pos[i]-0.35)\n    \n    joint.set_xy(np.stack(([-0.075, 0.075, 0, -0.075] + cart_pos[i], [-0.2, -0.2, -0.075, -0.2])).T)\n    \n    rod.set_data([cart_pos[i], cart_pos[i]], [-0.1, 0.9])\n    rod_outline.set_data([cart_pos[i], cart_pos[i]], [-0.1, 0.9])\n    \n    tilt_transform.clear().rotate_around(cart_pos[i], -0.1, R_plot[i])\n    \n    return (line1, line2, line3, wheel_1, wheel_2, wheel_1_p, wheel_2_p, cart, joint, joint_p, rod, rod_outline,)\n\nanim = animation.FuncAnimation(anim_fig, animate, init_func=anim_init,\n                               frames=frame_count, interval=10, blit=True, repeat=True)\n\n# Controllers\n\nT_slider = w.FloatLogSlider(value=1, base=10, min=-0.7, max=1, step=0.01,\n                            description='Duration [s]:', continuous_update=False,\n                            orientation='vertical', layout=w.Layout(width='auto', height='auto', flex='1 1 auto'))\n\ndt_slider = w.FloatLogSlider(value=0.001, base=10, min=-3, max=-1, step=0.01,\n                             description='Timestep [s]:', continuous_update=False,\n                             orientation='vertical', layout=w.Layout(width='auto', height='auto', flex='1 1 auto'))\n    \nF_type = w.Dropdown(options=[('Constant', 0), ('Sine', 1), ('Square', 2), ('Noise', 3)], value=2,\n                    description='Disturbance: ', continuous_update=False, layout=w.Layout(width='auto', flex='3 3 auto'))    \nFf_slider = w.FloatLogSlider(value=2, base=10, min=-2, max=2, step=0.01,\n                             description='Frequency [Hz]:', continuous_update=False,\n                             orientation='vertical', layout=w.Layout(width='auto', height='auto', flex='1 1 auto'))\nFa_slider = w.FloatLogSlider(value=20, base=10, min=-2, max=3, step=0.01,\n                             description='Amplitude [N]:', continuous_update=False,\n                             orientation='vertical', layout=w.Layout(width='auto', height='auto', flex='1 1 auto'))\nFo_slider = w.FloatSlider(value=0, min=-10, max=10, description='Offset/Ampl:', continuous_update=False,\n                              orientation='vertical', layout=w.Layout(width='auto', height='auto', flex='1 1 auto'))\n\ninput_data = w.interactive_output(simulation, {'Kp': Kp_slider, 'Ti': Ti_slider, 'Td': Td_slider,\n                                               'Fd': Fd_slider, 'Ti0' : Ti_button, 'Td0': Td_button,\n                                               'Fd0': Fd_button,\n                                               'M':M_slider, 'm':m_slider, 'L':L_slider, 'b':b_slider,\n                                               'T': T_slider, 'dt': dt_slider,\n                                               'F': F_type, 'Ff': Ff_slider, 'Fa': Fa_slider, 'Fo': Fo_slider})\n\ndisplay(w.HBox([w.HBox([T_slider, dt_slider], layout=w.Layout(width='25%')),\n                w.Box([], layout=w.Layout(width='5%')),\n                w.VBox([F_type, w.HBox([Ff_slider, Fa_slider, Fo_slider])], layout=w.Layout(width='30%'))],\n                layout=w.Layout(width='100%', justify_content='center')), input_data)\n\n\n\n\n\n\n\n\n\n\n\n\n\nThe duration parameter controls the simulated timeframe and does not affect the runtime of the animation. In contrast, the timestep controls the model sampling and can refine the results in exchange for higher computational resources."
  },
  {
    "objectID": "ICCT_en/examples/03/FD-22_DC_Cascade.html",
    "href": "ICCT_en/examples/03/FD-22_DC_Cascade.html",
    "title": "Control design for a DC motor using cascade design",
    "section": "",
    "text": "%matplotlib notebook\nimport control as c\nimport ipywidgets as w\nimport numpy as np\n\nfrom IPython.display import display, HTML\nimport matplotlib.pyplot as plt\nimport matplotlib.patches as patches\nimport matplotlib.animation as animation\n\ndisplay(HTML('&lt;script&gt; $(document).ready(function() { $(\\\"div.input\\\").hide(); }); &lt;/script&gt;'))\n\nTraceback (most recent call last):\n  File \"C:\\Users\\Uporabnik\\Anaconda3\\envs\\icct2\\lib\\site-packages\\matplotlib\\cbook\\__init__.py\", line 216, in process\n    func(*args, **kwargs)\n  File \"C:\\Users\\Uporabnik\\Anaconda3\\envs\\icct2\\lib\\site-packages\\matplotlib\\animation.py\", line 1465, in _stop\n    self.event_source.remove_callback(self._loop_delay)\nAttributeError: 'NoneType' object has no attribute 'remove_callback'\n\n\n\n\n\nThe following example is a control design task for a DC motor, implemented through two separate controllers. The DC motor model can be divided into an electrical and a mechanical component, while the back-EMF is not ignored.    The transfer functions of the motor components are:  \\[G_{elec}(s)=\\frac{1}{sL+R}\\qquad\\qquad G_{mech}=\\frac{1}{sJ+B}\\]  Your task is to choose two types of controllers, and tune them to acceptable levels of performance!\nFirst, choose a system model! Toggle between different realistic models with randomly preselected values (buttons Model 1 - Model 6). By clicking the Preset button default, valid predetermined controller parameters are set and cannot be tuned further.\n\n# Parameters\nR = [0.5, 0.25, 0.5, 1.0, 1.5, 0.25, 1.0]                       # Armature resistance - Ohm\nL = [1.5e-3, 5.0e-4, 2.0e-3, 1.5e-3, 5.0e-4, 2.0e-3, 2.0e-3]    # Armature inductance - H\nJ = [2.5e-4, 1.0e-3, 5.0e-4, 1.5e-4, 1.5e-4, 5.0e-4, 3.0e-4]    # Moment of inertia - kgm^2\nB = [1.0e-3, 1.5e-3, 1.0e-3, 5.0e-4, 1.0e-3, 5.0e-4, 7.5e-4]    # Damping factor - Nms\nkPhi = 0.05                                                     # Torque constant / Electromotive force - Nm/A or Vs/rad\n\nfig1, ((f1_ax1), (f1_ax2)) = plt.subplots(2, 1)\nfig1.set_size_inches((9.8, 5))\nfig1.set_tight_layout(True)\n\nf1_line1, = f1_ax1.plot([], [])\nf1_line2, = f1_ax2.plot([], [])  \n\nf1_ax1.grid(which='both', axis='both', color='lightgray')\nf1_ax2.grid(which='both', axis='both', color='lightgray')\n\nf1_ax1.autoscale(enable=True, axis='both', tight=True)\nf1_ax2.autoscale(enable=True, axis='both', tight=True)\n\nf1_ax1.set_title('Bode magnitude plot', fontsize=11)\nf1_ax1.set_xscale('log')\nf1_ax1.set_xlabel(r'$f\\/[Hz]$', labelpad=0, fontsize=10)\nf1_ax1.set_ylabel(r'$A\\/[dB]$', labelpad=0, fontsize=10)\nf1_ax1.tick_params(axis='both', which='both', pad=0, labelsize=8)\n\nf1_ax2.set_title('Bode phase plot', fontsize=11)\nf1_ax2.set_xscale('log')\nf1_ax2.set_xlabel(r'$f\\/[Hz]$', labelpad=0, fontsize=10)\nf1_ax2.set_ylabel(r'$\\phi\\/[°]$', labelpad=0, fontsize=10)\nf1_ax2.tick_params(axis='both', which='both', pad=0, labelsize=8)\n\ndef build_base_model(sel):\n    \n    # System model\n    W_e = c.tf([1], [L[sel], R[sel]])   # Electrical part\n    W_m = c.tf([1], [J[sel], B[sel]])   # Mechanical part\n    W_t = c.tf([kPhi], [1])   # EMF / torque constant\n\n    W_motor = c.feedback(c.series(W_e, W_t, W_m), W_t, -1)   # DC motor transfer function\n    print('DC Motor transfer function:')\n    print(W_motor)\n\n    # System analysis\n    print('System poles:\\n')\n    poles = c.pole(W_motor)   # Poles\n    print(poles)\n\n    time_constants = -1 / poles   # For stable, real poles\n    print('\\nTime constants for real, stable poles:\\n')\n    print(time_constants)\n    \n    global f1_line1, f1_line2\n    \n    f1_ax1.lines.remove(f1_line1)\n    f1_ax2.lines.remove(f1_line2)\n    \n    mag, phase, omega = c.bode_plot(W_motor, Plot=False)   # Bode-plot\n    \n    f1_line1, = f1_ax1.plot(omega/2/np.pi, 20*np.log10(mag), lw=1, color='blue')\n    f1_line2, = f1_ax2.plot(omega/2/np.pi, phase*180/np.pi, lw=1, color='blue')   \n    \n    f1_ax1.relim()\n    f1_ax2.relim()\n    f1_ax1.autoscale_view()\n    f1_ax2.autoscale_view()\n    \n# GUI widgets\ntypeSelect = w.ToggleButtons(\n    options=[('Model 1', 0), ('Model 2', 1), ('Model 3', 2), ('Model 4', 3), ('Model 5', 4), ('Model 6', 5), ('Preset', -1)],\n    value=-1, description='System: ', layout=w.Layout(width='60%'))\n\ninput_data = w.interactive_output(build_base_model, {'sel':typeSelect})\n\ndisplay(typeSelect, input_data)\n\n\n\n\n\n\n\n\n\n\n\n\n\nThe cascade controller consists of a fast controlled loop embedded within a larger one. In this example, the internal loop controls the current, and the external controls the motor’s speed. This way, optimal and safe operation can be achieved.   \nSelect an appropriate controller for the internal loop! Which one is the best for your system? Why? Set up your controller for the fastest settling time with at most 25% overshoot!\nYou can turn on/off each of the I and D components, and if D is active, you can apply the first-order filter as well, based on the derivating time constant.\n\n# PID current control\n\nfig2, ((f2_ax1, f2_ax2, f2_ax3), (f2_ax4, f2_ax5, f2_ax6)) = plt.subplots(2, 3)\nfig2.set_size_inches((9.8, 5))\nfig2.set_tight_layout(True)\n\nf2_line1, = f2_ax1.plot([], [])\nf2_line2, = f2_ax2.plot([], []) \nf2_line3, = f2_ax3.plot([], [])\nf2_line4, = f2_ax4.plot([], [])  \nf2_line5, = f2_ax5.plot([], [])\nf2_line6, = f2_ax6.plot([], [])\n\nf2_ax1.grid(which='both', axis='both', color='lightgray')\nf2_ax2.grid(which='both', axis='both', color='lightgray')\nf2_ax3.grid(which='both', axis='both', color='lightgray')\nf2_ax4.grid(which='both', axis='both', color='lightgray')\nf2_ax5.grid(which='both', axis='both', color='lightgray')\nf2_ax6.grid(which='both', axis='both', color='lightgray')\n\nf2_ax1.autoscale(enable=True, axis='both', tight=True)\nf2_ax2.autoscale(enable=True, axis='both', tight=True)\nf2_ax3.autoscale(enable=True, axis='both', tight=True)\nf2_ax4.autoscale(enable=True, axis='both', tight=True)\nf2_ax5.autoscale(enable=True, axis='both', tight=True)\nf2_ax6.autoscale(enable=True, axis='both', tight=True)\n\nf2_ax1.set_title('Closed loop step response', fontsize=9)\nf2_ax1.set_xlabel(r'$t\\/$[s]', labelpad=0, fontsize=8)\nf2_ax1.set_ylabel(r'$i\\/$[A]', labelpad=0, fontsize=8)\nf2_ax1.tick_params(axis='both', which='both', pad=0, labelsize=6)\n\nf2_ax2.set_title('Nyquist diagram', fontsize=9)\nf2_ax2.set_xlabel(r'Re', labelpad=0, fontsize=8)\nf2_ax2.set_ylabel(r'Im', labelpad=0, fontsize=8)\nf2_ax2.tick_params(axis='both', which='both', pad=0, labelsize=6)\n\nf2_ax3.set_title('Bode magniture plot', fontsize=9)\nf2_ax3.set_xscale('log')\nf2_ax3.set_xlabel(r'$f\\/$[Hz]', labelpad=0, fontsize=8)\nf2_ax3.set_ylabel(r'$A\\/$[dB]', labelpad=0, fontsize=8)\nf2_ax3.tick_params(axis='both', which='both', pad=0, labelsize=6)\n\nf2_ax4.set_title('Closed loop impulse response', fontsize=9)\nf2_ax4.set_xlabel(r'$t\\/$[s]', labelpad=0, fontsize=8)\nf2_ax4.set_ylabel(r'$i\\/$[A]', labelpad=0, fontsize=8)\nf2_ax4.tick_params(axis='both', which='both', pad=0, labelsize=6)\n\nf2_ax5.set_title('Load transfer step response', fontsize=9)\nf2_ax5.set_xlabel(r'$t\\/$[s]', labelpad=0, fontsize=8)\nf2_ax5.set_ylabel(r'$i\\/$[A]', labelpad=0, fontsize=8)\nf2_ax5.tick_params(axis='both', which='both', pad=0, labelsize=6)\n\nf2_ax6.set_title('Bode phase plot', fontsize=9)\nf2_ax6.set_xscale('log')\nf2_ax6.set_xlabel(r'$f\\/$[Hz]', labelpad=0, fontsize=8)\nf2_ax6.set_ylabel(r'$\\phi\\/$[°]', labelpad=0, fontsize=8)\nf2_ax6.tick_params(axis='both', which='both', pad=0, labelsize=6)\n\ndef current_control(iKp, iTi, iTd, iFd, iTi0, iTd0, iFd0, sel):\n    \n    W_e = c.tf([1], [L[sel], R[sel]])   # Electrical part\n    W_m = c.tf([1], [J[sel], B[sel]])   # Mechanical part\n    W_t = c.tf([kPhi], [1])   # EMF / torque constant\n    W_current = c.feedback(W_e, c.series(W_t, W_m, W_t))   # System model for current output\n    \n    # PID Controller\n    \n    iP = iKp             # Proportional term\n    iI = iKp / iTi       # Integral term\n    iD = iKp * iTd       # Derivative term\n    iTd_f = iTd / iFd    # Derivative term filter\n    \n    W_iPID = c.parallel(c.tf([iP], [1]),\n                        c.tf([iI * iTi0], [1 * iTi0, 1 * (not iTi0)]),\n                        c.tf([iD * iTd0, 0], [iTd_f * iTd0 * iFd0, 1]))  # PID controller in time constant format\n    \n    W_icont_open = c.series(W_iPID, W_current)          # Open loop of the current controlled system\n    W_icont_closed = c.feedback(W_icont_open, 1, -1)    # Closed loop\n    \n    W_iload = c.feedback(c.series(W_e, W_t, c.tf([-1], [1]),\n                                  c.feedback(W_m, W_iPID, -1)), W_t, 1)    # Load transfer function    \n    # Display\n    \n    global f2_line1, f2_line2, f2_line3, f2_line4, f2_line5, f2_line6\n    \n    f2_ax1.lines.remove(f2_line1)\n    f2_ax2.lines.remove(f2_line2)\n    f2_ax3.lines.remove(f2_line3)\n    f2_ax4.lines.remove(f2_line4)\n    f2_ax5.lines.remove(f2_line5)\n    f2_ax6.lines.remove(f2_line6)\n    \n    tout, yout = c.step_response(W_icont_closed)\n    f2_line1, = f2_ax1.plot(tout, yout, lw=1, color='blue')\n    \n    _, _, ob = c.nyquist_plot(W_icont_open, Plot=False)   # Small resolution plot to determine bounds        \n    real, imag, freq = c.nyquist_plot(W_icont_open, omega=np.logspace(np.log10(ob[0]), np.log10(ob[-1]), 1000), Plot=False)\n    f2_line2, = f2_ax2.plot(real, imag, lw=1, color='blue')\n    \n    mag, phase, omega = c.bode_plot(W_icont_open, Plot=False)\n    f2_line3, = f2_ax3.plot(omega/2/np.pi, 20*np.log10(mag), lw=1, color='blue')\n    f2_line6, = f2_ax6.plot(omega/2/np.pi, phase*180/np.pi, lw=1, color='blue')\n    \n    tout, yout = c.impulse_response(W_icont_closed)\n    f2_line4, = f2_ax4.plot(tout, yout, lw=1, color='blue')  \n    \n    tout, yout = c.step_response(W_iload)\n    f2_line5, = f2_ax5.plot(tout, yout, lw=1, color='blue')\n    \n    f2_ax1.relim()\n    f2_ax2.relim()\n    f2_ax3.relim()\n    f2_ax4.relim()\n    f2_ax5.relim()\n    f2_ax6.relim()\n    f2_ax1.autoscale_view()\n    f2_ax2.autoscale_view()\n    f2_ax3.autoscale_view()\n    f2_ax4.autoscale_view()\n    f2_ax5.autoscale_view()\n    f2_ax6.autoscale_view()\n    \ndef update_current_controller(index):\n    global iKp_slider, iTi_slider, iTd_slider, iFd_slider, iTi_button, iTd_button, iFd_button\n    \n    if index == -1:\n        iKp_slider.value = 100.0\n        iTi_slider.value = 0.01\n        iTi_button.value = True\n        iTd_button.value = False\n        iFd_button.value = False\n        \n        iKp_slider.disabled = True\n        iTi_slider.disabled = True\n        iTd_slider.disabled = True\n        iFd_slider.disabled = True\n        iTi_button.disabled = True\n        iTd_button.disabled = True\n        iFd_button.disabled = True\n    else:\n        iKp_slider.disabled = False\n        iTi_slider.disabled = False\n        iTd_slider.disabled = False\n        iFd_slider.disabled = False\n        iTi_button.disabled = False\n        iTd_button.disabled = False\n        iFd_button.disabled = False\n\n# Controllers\n\niKp_slider = w.FloatLogSlider(value=0.5, base=10, min=-3, max=3, description='Kp:', continuous_update=False,\n                               layout=w.Layout(width='auto', flex='5 5 auto'))\niTi_slider = w.FloatLogSlider(value=0.0035, base=10, min=-4, max=1, description='', continuous_update=False,\n                               layout=w.Layout(width='auto', flex='5 5 auto'))\niTd_slider = w.FloatLogSlider(value=1, base=10, min=-4, max=1, description='', continuous_update=False,\n                               layout=w.Layout(width='auto', flex='5 5 auto'))\niFd_slider = w.FloatLogSlider(value=1, base=10, min=0, max=3, description='', continuous_update=False,\n                               layout=w.Layout(width='auto', flex='5 5 auto'))\n\niTi_button = w.ToggleButton(value=True, description='Ti',\n                           layout=w.Layout(width='auto', flex='1 1 0%'))\niTd_button = w.ToggleButton(value=False, description='Td',\n                           layout=w.Layout(width='auto', flex='1 1 0%'))\niFd_button = w.ToggleButton(value=False, description='Fd',\n                           layout=w.Layout(width='auto', flex='1 1 0%'))\n\ninput_data = w.interactive_output(current_control, {'iKp': iKp_slider, 'iTi': iTi_slider, 'iTd': iTd_slider,\n                                                 'iFd': iFd_slider, 'iTi0' : iTi_button, 'iTd0': iTd_button,\n                                                 'iFd0': iFd_button, 'sel':typeSelect})\n\nw.interactive_output(update_current_controller, {'index':typeSelect})\n\ndisplay(w.HBox([iKp_slider, iTi_button, iTi_slider, iTd_button, iTd_slider, iFd_button, iFd_slider]), input_data)\n\n\n\n\n\n\n\n\n\n\n\n\n\nThe current controller should be set up so that it is still possible to control the system for speed as well. Select an appropriate controller configuration! Readjust the current controller if necessary. Set up your controller for the fastest settling time!\nYou can turn on/off each of the I and D components, and if D is active, you can apply a first-order filter as well, based on the derivating time constant.\n\n# PID speed control\n\nfig3, ((f3_ax1, f3_ax2, f3_ax3), (f3_ax4, f3_ax5, f3_ax6)) = plt.subplots(2, 3)\nfig3.set_size_inches((9.8, 5))\nfig3.set_tight_layout(True)\n\nf3_line1, = f3_ax1.plot([], [])\nf3_line2, = f3_ax2.plot([], []) \nf3_line3, = f3_ax3.plot([], [])\nf3_line4, = f3_ax4.plot([], [])  \nf3_line5, = f3_ax5.plot([], [])\nf3_line6, = f3_ax6.plot([], [])\n\nf3_ax1.grid(which='both', axis='both', color='lightgray')\nf3_ax2.grid(which='both', axis='both', color='lightgray')\nf3_ax3.grid(which='both', axis='both', color='lightgray')\nf3_ax4.grid(which='both', axis='both', color='lightgray')\nf3_ax5.grid(which='both', axis='both', color='lightgray')\nf3_ax6.grid(which='both', axis='both', color='lightgray')\n\nf3_ax1.autoscale(enable=True, axis='both', tight=True)\nf3_ax2.autoscale(enable=True, axis='both', tight=True)\nf3_ax3.autoscale(enable=True, axis='both', tight=True)\nf3_ax4.autoscale(enable=True, axis='both', tight=True)\nf3_ax5.autoscale(enable=True, axis='both', tight=True)\nf3_ax6.autoscale(enable=True, axis='both', tight=True)\n\nf3_ax1.set_title('Closed loop step response', fontsize=9)\nf3_ax1.set_xlabel(r'$t\\/$[s]', labelpad=0, fontsize=8)\nf3_ax1.set_ylabel(r'$\\omega\\/$[rad/s]', labelpad=0, fontsize=8)\nf3_ax1.tick_params(axis='both', which='both', pad=0, labelsize=6)\n\nf3_ax2.set_title('Nyquist diagram', fontsize=9)\nf3_ax2.set_xlabel(r'Re', labelpad=0, fontsize=8)\nf3_ax2.set_ylabel(r'Im', labelpad=0, fontsize=8)\nf3_ax2.tick_params(axis='both', which='both', pad=0, labelsize=6)\n\nf3_ax3.set_title('Bode magniture plot', fontsize=9)\nf3_ax3.set_xscale('log')\nf3_ax3.set_xlabel(r'$f\\/$[Hz]', labelpad=0, fontsize=8)\nf3_ax3.set_ylabel(r'$A\\/$[dB]', labelpad=0, fontsize=8)\nf3_ax3.tick_params(axis='both', which='both', pad=0, labelsize=6)\n\nf3_ax4.set_title('Closed loop impulse response', fontsize=9)\nf3_ax4.set_xlabel(r'$t\\/$[s]', labelpad=0, fontsize=8)\nf3_ax4.set_ylabel(r'$\\omega\\/$[rad/s]', labelpad=0, fontsize=8)\nf3_ax4.tick_params(axis='both', which='both', pad=0, labelsize=6)\n\nf3_ax5.set_title('Load transfer step response', fontsize=9)\nf3_ax5.set_xlabel(r'$t\\/$[s]', labelpad=0, fontsize=8)\nf3_ax5.set_ylabel(r'$\\omega\\/$[rad/s]', labelpad=0, fontsize=8)\nf3_ax5.tick_params(axis='both', which='both', pad=0, labelsize=6)\n\nf3_ax6.set_title('Bode phase plot', fontsize=9)\nf3_ax6.set_xscale('log')\nf3_ax6.set_xlabel(r'$f\\/$[Hz]', labelpad=0, fontsize=8)\nf3_ax6.set_ylabel(r'$\\phi\\/$[°]', labelpad=0, fontsize=8)\nf3_ax6.tick_params(axis='both', which='both', pad=0, labelsize=6)\n\ndef speed_control(iKp, iTi, iTd, iFd, iTi0, iTd0, iFd0, wKp, wTi, wTd, wFd, wTi0, wTd0, wFd0, sel):\n    \n    W_e = c.tf([1], [L[sel], R[sel]])   # Electrical part\n    W_m = c.tf([1], [J[sel], B[sel]])   # Mechanical part\n    W_t = c.tf([kPhi], [1])   # EMF / torque constant\n    W_current = c.feedback(W_e, c.series(W_t, W_m, W_t))   # System model for current output\n    W_motor = c.feedback(c.series(W_e, W_t, W_m), W_t, -1)   # DC motor transfer function\n    \n    # Current controller\n    iP = iKp             # Proportional term\n    iI = iKp / iTi       # Integral term\n    iD = iKp * iTd       # Derivative term\n    iTd_f = iTd / iFd    # Derivative term filter\n    \n    W_iPID = c.parallel(c.tf([iP], [1]),\n                        c.tf([iI * iTi0], [1 * iTi0, 1 * (not iTi0)]),\n                        c.tf([iD * iTd0, 0], [iTd_f * iTd0 * iFd0, 1]))  # PID controller in time constant format\n    \n    # Speed controller   \n    wP = wKp             # Proportional term\n    wI = wKp / wTi       # Integral term\n    wD = wKp * wTd       # Derivative term\n    wTd_f = wTd / wFd    # Derivative term filter\n    \n    W_wPID = c.parallel(c.tf([wP], [1]),\n                        c.tf([wI * wTi0], [1 * wTi0, 1 * (not wTi0)]),\n                        c.tf([wD * wTd0, 0], [wTd_f * wTd0 * wFd0, 1]))  # PID controller in time constant format\n    \n    W_wcont_open = c.series(W_wPID, c.feedback(c.series(W_iPID, W_current), 1, -1), W_motor)  # Speed control open loop\n    W_wcont_closed = c.feedback(W_wcont_open, 1, -1)   # Closed loop\n    \n    W_wload = c.feedback(W_m, c.series(c.parallel(W_t, c.series(W_iPID, W_wPID)),\n                                       c.feedback(W_e, W_iPID, -1), W_t), -1)       # Load transfer function\n    # Display\n    \n    global f3_line1, f3_line2, f3_line3, f3_line4, f3_line5, f3_line6\n    \n    f3_ax1.lines.remove(f3_line1)\n    f3_ax2.lines.remove(f3_line2)\n    f3_ax3.lines.remove(f3_line3)\n    f3_ax4.lines.remove(f3_line4)\n    f3_ax5.lines.remove(f3_line5)\n    f3_ax6.lines.remove(f3_line6)\n    \n    tout, yout = c.step_response(W_wcont_closed)\n    f3_line1, = f3_ax1.plot(tout, yout, lw=1, color='blue') \n    \n    _, _, ob = c.nyquist_plot(W_wcont_open, Plot=False)   # Small resolution plot to determine bounds        \n    real, imag, freq = c.nyquist_plot(W_wcont_open, omega=np.logspace(np.log10(ob[0]), np.log10(ob[-1]), 1000), Plot=False)\n    f3_line2, = f3_ax2.plot(real, imag, lw=1, color='blue')\n    \n    mag, phase, omega = c.bode_plot(W_wcont_open, Plot=False)\n    f3_line3, = f3_ax3.plot(omega/2/np.pi, 20*np.log10(mag), lw=1, color='blue')\n    f3_line6, = f3_ax6.plot(omega/2/np.pi, phase*180/np.pi, lw=1, color='blue')\n    \n    tout, yout = c.impulse_response(W_wcont_closed)\n    f3_line4, = f3_ax4.plot(tout, yout, lw=1, color='blue')   \n    \n    tout, yout = c.step_response(W_wload)\n    f3_line5, = f3_ax5.plot(tout, yout, lw=1, color='blue') \n    \n    f3_ax1.relim()\n    f3_ax2.relim()\n    f3_ax3.relim()\n    f3_ax4.relim()\n    f3_ax5.relim()\n    f3_ax6.relim()\n    f3_ax1.autoscale_view()\n    f3_ax2.autoscale_view()\n    f3_ax3.autoscale_view()\n    f3_ax4.autoscale_view()\n    f3_ax5.autoscale_view()\n    f3_ax6.autoscale_view()\n    \ndef update_speed_controller(index):\n    global wKp_slider, wTi_slider, wTd_slider, wFd_slider, wTi_button, wTd_button, wFd_button\n    \n    if index == -10:\n        wKp_slider.value = 10.0\n        wTd_slider.value = 0.05\n        wFd_slider.value = 10.0\n        wTi_button.value = False\n        wTd_button.value = True\n        wFd_button.value = True\n        \n        wKp_slider.disabled = True\n        wTi_slider.disabled = True\n        wTd_slider.disabled = True\n        wFd_slider.disabled = True\n        wTi_button.disabled = True\n        wTd_button.disabled = True\n        wFd_button.disabled = True\n    else:\n        wKp_slider.disabled = False\n        wTi_slider.disabled = False\n        wTd_slider.disabled = False\n        wFd_slider.disabled = False\n        wTi_button.disabled = False\n        wTd_button.disabled = False\n        wFd_button.disabled = False\n    \n# Controllers\n\nwKp_slider = w.FloatLogSlider(value=1.2, base=10, min=-3, max=3, description='Kp:', continuous_update=False,\n                               layout=w.Layout(width='auto', flex='5 5 auto'))\nwTi_slider = w.FloatLogSlider(value=1, base=10, min=-4, max=1, description='', continuous_update=False,\n                               layout=w.Layout(width='auto', flex='5 5 auto'))\nwTd_slider = w.FloatLogSlider(value=0.035, base=10, min=-4, max=1, description='', continuous_update=False,\n                               layout=w.Layout(width='auto', flex='5 5 auto'))\nwFd_slider = w.FloatLogSlider(value=10, base=10, min=0, max=3, description='', continuous_update=False,\n                               layout=w.Layout(width='auto', flex='5 5 auto'))\n\nwTi_button = w.ToggleButton(value=False, description='Ti',\n                           layout=w.Layout(width='auto', flex='1 1 0%'))\nwTd_button = w.ToggleButton(value=True, description='Td',\n                           layout=w.Layout(width='auto', flex='1 1 0%'))\nwFd_button = w.ToggleButton(value=True, description='Fd',\n                           layout=w.Layout(width='auto', flex='1 1 0%'))\n\ninput_data = w.interactive_output(speed_control, {'iKp': iKp_slider, 'iTi': iTi_slider, 'iTd': iTd_slider,\n                                                  'iFd': iFd_slider, 'iTi0' : iTi_button, 'iTd0': iTd_button,\n                                                  'iFd0': iFd_button,\n                                                  'wKp': wKp_slider, 'wTi': wTi_slider, 'wTd': wTd_slider,\n                                                  'wFd': wFd_slider, 'wTi0' : wTi_button, 'wTd0': wTd_button,\n                                                  'wFd0': wFd_button, 'sel':typeSelect})\n\nw.interactive_output(update_speed_controller, {'index':typeSelect})\n\ndisplay(w.HBox([wKp_slider, wTi_button, wTi_slider, wTd_button, wTd_slider, wFd_button, wFd_slider]), input_data)\n    \n\n\n\n\n\n\n\n\n\n\n\n\n\nIn the following simulation, you can observe the movement of your system based on your controller setup. You can create reference signals and even apply some disturbance and see how the system reacts.\nIs your configuration good for signal following? Readjust your controller so that it can follow a sine wave acceptably!  (The animations are scaled to fit the frame through the whole simulation. Because of this, unstable solutions might not seem to move until the very last second.)\n\n# Simulation data\n\nanim_fig = plt.figure()\nanim_fig.set_size_inches((9.8, 6))\nanim_fig.set_tight_layout(True)\n\nanim_ax1 = anim_fig.add_subplot(211)\nanim_ax2 = anim_ax1.twinx()\nanim_ax3 = anim_ax1.twinx()\n\nframe_count=1000\n\nl1 = anim_ax1.plot([], [], lw=1, color='green')\nl2 = anim_ax1.plot([], [], lw=2, color='red')\nl3 = anim_ax2.plot([], [], lw=1, color='blue')\nl4 = anim_ax3.plot([], [], lw=1, color='grey')\n\nline1 = l1[0]\nline2 = l2[0]\nline3 = l3[0]\nline4 = l4[0]\n\nanim_ax1.legend(l1+l2+l3+l4, ['Reference [rad/s]', 'Output [rad/s]', 'Current [A]', 'Load [Nm]'], loc=1)\n\nanim_ax1.set_title('Time response simulation', fontsize=12)\nanim_ax1.set_xlabel(r'$t\\/$[s]', labelpad=0, fontsize=10)\nanim_ax1.set_ylabel(r'$\\omega\\/$[rad/s]', labelpad=0, fontsize=10)\nanim_ax1.tick_params(axis='both', which='both', pad=0, labelsize=8)\nanim_ax2.set_ylabel(r'$i\\/$[A]', labelpad=0, fontsize=10)\nanim_ax2.tick_params(axis='both', which='both', pad=0, labelsize=8)\nanim_ax3.set_ylabel(r'$M\\/$[Nm]', labelpad=0, fontsize=10)\nanim_ax3.tick_params(axis='both', which='both', pad=0, labelsize=8)\n\nanim_ax1.grid(which='both', axis='both', color='lightgray')\n\nanim_ax3.spines[\"right\"].set_position((\"axes\", 1.075))\n\nT_plot = []\nU_plot = []\nM_plot = []\nR_plot = []\nI_plot = []\n\n# Scene data\n\nscene_ax = anim_fig.add_subplot(212)\nscene_ax.set_xlim((-3, 4))\nscene_ax.set_ylim((-1, 1.25))\nscene_ax.axis('off')\n\nscene_ax.add_patch(patches.Circle((-2.25, 0), fill=True, radius=0.15, ec='black', fc='white', lw=1, zorder=5))\nscene_ax.add_patch(patches.Circle((-1.75, 0), fill=True, radius=0.15, ec='black', fc='white', lw=1, zorder=5))\nscene_ax.add_patch(patches.Circle((-1.25, 0.75), fill=True, radius=0.15, ec='black', fc='white', lw=1, zorder=5))\nscene_ax.add_patch(patches.FancyArrow(-1.93, -0.18, 0.38, 0.38,length_includes_head=True,\n                                      head_width=0.05, head_length=0.075, fill=True, color='red', lw=1.5, zorder=0))\nscene_ax.add_patch(patches.FancyArrow(-1.43, 0.57, 0.38, 0.38,length_includes_head=True,\n                                      head_width=0.05, head_length=0.075, fill=True, color='blue', lw=1.5, zorder=0))\n\nscene_ax.text(-1.75, 0, 'V', fontsize=15, color='red', va='center_baseline', ha='center', zorder=10)\nscene_ax.text(-1.25, 0.75, 'A', fontsize=15, color='blue', va='center_baseline', ha='center', zorder=10)\nscene_ax.text(-2.25, 0, '+', fontsize=12, weight='bold', color='red', va='bottom', ha='center', zorder=10)\nscene_ax.text(-2.25, 0, '–', fontsize=12, weight='bold', color='blue', va='top', ha='center', zorder=10)\nscene_ax.text(-2.55, 0.3, 'U(t)', fontsize=15, color='black', va='center_baseline', ha='center', zorder=10)\n\nscene_ax.plot([-1.75, -1.75, -2.25, -2.25, 1.5, 1.5], [-0.75, 0.75, 0.75, -0.75, -0.75, -0.5], color='black', lw=1, zorder=0)\nscene_ax.plot([-1.75, -0.5, -0.4625, -0.3875, -0.3125, -0.2375, -0.1825, -0.0875, -0.0125, 0.0625, 0.1, 0.45],\n              [0.75, 0.75, 0.9, 0.6, 0.9, 0.6, 0.9, 0.6, 0.9, 0.6, 0.75, 0.75], color='black', lw=1, zorder=0)\n\nscene_ax.add_patch(patches.Arc((0.4875, 0.75), 0.075, 0.3, theta1=-100, theta2=180, color='black', lw=1, zorder=0))\nscene_ax.add_patch(patches.Arc((0.5625, 0.75), 0.075, 0.3, theta1=-100, theta2=100, color='black', lw=1, zorder=0))\nscene_ax.add_patch(patches.Arc((0.6375, 0.75), 0.075, 0.3, theta1=-100, theta2=100, color='black', lw=1, zorder=0))\nscene_ax.add_patch(patches.Arc((0.7125, 0.75), 0.075, 0.3, theta1=-100, theta2=100, color='black', lw=1, zorder=0))\nscene_ax.add_patch(patches.Arc((0.7875, 0.75), 0.075, 0.3, theta1=-100, theta2=100, color='black', lw=1, zorder=0))\nscene_ax.add_patch(patches.Arc((0.8625, 0.75), 0.075, 0.3, theta1=-100, theta2=100, color='black', lw=1, zorder=0))\nscene_ax.add_patch(patches.Arc((0.9375, 0.75), 0.075, 0.3, theta1=-100, theta2=100, color='black', lw=1, zorder=0))\n\nscene_ax.text(-0.21, 1.1, 'R', fontsize=15, color='black', va='center_baseline', ha='center', zorder=10)\nscene_ax.text(0.7125, 1.1, 'L', fontsize=15, color='black', va='center_baseline', ha='center', zorder=10)\n\nscene_ax.plot([1, 1.5, 1.5], [0.75, 0.75, 0.5], color='black', lw=1, zorder=0)\n\nscene_ax.add_patch(patches.Rectangle((1.4, 0.3), 0.2, 0.2, fill=True, ec='black', fc='red', lw=1, zorder=5))\nscene_ax.add_patch(patches.Rectangle((1.4, -0.5), 0.2, 0.2, fill=True, ec='black', fc='blue', lw=1, zorder=5))\nscene_ax.add_patch(patches.Circle((1.5, 0), fill=True, radius=0.4, ec='black', fc='lightgray', lw=1, zorder=10))\n\nscene_ax.plot([1.5, 2.5], [0, -0.25], color='black', solid_capstyle='round', lw=8, zorder=15)\nscene_ax.plot([1.5, 2.5], [0, -0.25], color='gray', solid_capstyle='round', lw=6, zorder=20)\n\nscene_ax.add_patch(patches.Circle((2.5, -0.25), fill=True, radius=0.75, ec='black', fc='white', lw=1, zorder=25))\nscene_ax.add_patch(patches.Circle((2.5, -0.25), fill=True, radius=0.05, ec='black', fc='gray', lw=1, zorder=35))\n\nscene_ax.add_patch(patches.Wedge((-1.75, 0), 0.45, width=0.1, theta1=-45, theta2=45,\n                                 fill=True, ec='black', fc='white', lw=1, zorder=10))\nscene_ax.add_patch(patches.Wedge((-1.25, 0.75), 0.45, width=0.1, theta1=-45, theta2=45,\n                                 fill=True, ec='black', fc='white', lw=1, zorder=10))\nscene_ax.add_patch(patches.Wedge((2.5, -0.25), 1, width=0.1, theta1=-30, theta2=30,\n                                 fill=True, ec='black', fc='white', lw=1, zorder=10))\nscene_ax.add_patch(patches.Wedge((2.5, -0.25), 1.1, width=0.1, theta1=-30, theta2=30,\n                                 fill=True, ec='black', fc='white', lw=1, zorder=10))\n\nspinner_1 = patches.Wedge((2.5, -0.25), 0.75, theta1=0, theta2=90, fill=True, ec='black', fc='black', lw=0, zorder=30)\nspinner_2 = patches.Wedge((2.5, -0.25), 0.75, theta1=180, theta2=270, fill=True, ec='black', fc='black', lw=0, zorder=30)\nscene_ax.add_patch(spinner_1)\nscene_ax.add_patch(spinner_2)\n\nv_bar = patches.Wedge((-1.75, 0), 0.45, width=0.1, theta1=0, theta2=0, fill=True, ec='red', fc='red', lw=0.5, zorder=15)\na_bar = patches.Wedge((-1.25, 0.75), 0.45, width=0.1, theta1=0, theta2=0, fill=True, ec='blue', fc='blue', lw=0.5, zorder=15)\nr_bar = patches.Wedge((2.5, -0.25), 1, width=0.1, theta1=0, theta2=0, fill=True, ec='green', fc='green', lw=0.5, zorder=15)\nw_bar = patches.Wedge((2.5, -0.25), 1.1, width=0.1, theta1=0, theta2=0, fill=True, ec='red', fc='red', lw=0.5, zorder=20)\nscene_ax.add_patch(v_bar)\nscene_ax.add_patch(a_bar)\nscene_ax.add_patch(r_bar)\nscene_ax.add_patch(w_bar)\n\nv_var = []\na_var = []\nr_var = []\nw_var = []\nrot_var = []\n\n#Simulation function\n\ndef simulation(iKp, iTi, iTd, iFd, iTi0, iTd0, iFd0, wKp, wTi, wTd, wFd, wTi0, wTd0, wFd0,\n               sel, T, dt, U, Uf, Ua, Uo, M, Mf, Ma, Mo):\n    \n    W_e = c.tf([1], [L[sel], R[sel]])   # Electrical part\n    W_m = c.tf([1], [J[sel], B[sel]])   # Mechanical part\n    W_t = c.tf([kPhi], [1])   # EMF / torque constant\n    W_current = c.feedback(W_e, c.series(W_t, W_m, W_t))   # System model for current output\n    W_motor = c.feedback(c.series(W_e, W_t, W_m), W_t, -1)   # DC motor transfer function\n    \n    # Current controller\n    iP = iKp             # Proportional term\n    iI = iKp / iTi       # Integral term\n    iD = iKp * iTd       # Derivative term\n    iTd_f = iTd / iFd    # Derivative term filter\n    \n    W_iPID = c.parallel(c.tf([iP], [1]),\n                        c.tf([iI * iTi0], [1 * iTi0, 1 * (not iTi0)]),\n                        c.tf([iD * iTd0, 0], [iTd_f * iTd0 * iFd0, 1]))  # PID szabályozó\n    \n    # Speed controller  \n    wP = wKp             # Proportional term\n    wI = wKp / wTi       # Integral term\n    wD = wKp * wTd       # Derivative term\n    wTd_f = wTd / wFd    # Derivative term filter\n    \n    W_wPID = c.parallel(c.tf([wP], [1]),\n                        c.tf([wI * wTi0], [1 * wTi0, 1 * (not wTi0)]),\n                        c.tf([wD * wTd0, 0], [wTd_f * wTd0 * wFd0, 1]))  # PID szabályozó\n    \n    # Speed controlled system\n    W_wsys = c.feedback(c.series(W_wPID, c.feedback(c.series(W_iPID, W_current), 1, -1), W_motor), 1, -1)  # Closed loop\n    W_wload = c.feedback(W_m, c.series(c.parallel(W_t, c.series(W_iPID, W_wPID)),\n                                       c.feedback(W_e, W_iPID, -1), W_t), -1)       # Load transfer function\n    \n    # Current transfer based on the reference and load\n    W_isys = c.feedback(c.series(W_wPID, c.feedback(c.series(W_iPID, c.feedback(W_e, c.series(W_t, W_m, W_t), -1)), 1, -1)),\n                        c.series(W_t, W_m), -1)\n    W_iload = c.feedback(c.series(W_m, c.parallel(c.negate(W_t), c.negate(c.series(W_wPID, W_iPID))),\n                                  c.feedback(W_e, W_iPID, -1)), W_t, 1)\n    \n    # Signals\n\n    T_sim = np.arange(0, T, dt, dtype=np.float64)\n    \n    if U == 0:     # Constant reference\n        U_sim = np.full_like(T_sim, Ua * Uo)\n    elif U == 1:   # Sine wave reference\n        U_sim = (np.sin(2 * np.pi * Uf * T_sim) + Uo) * Ua\n    elif U == 2:   # Square wave reference\n        U_sim = (np.sign(np.sin(2 * np.pi * Uf * T_sim)) + Uo) * Ua\n        \n    if M == 0:     # Constant load\n        M_sim = np.full_like(T_sim, Ma * Mo)\n    elif M == 1:   # Sine wave load\n        M_sim = (np.sin(2 * np.pi * Mf * T_sim) + Mo) * Ma\n    elif M == 2:   # Square wave load\n        M_sim = (np.sign(np.sin(2 * np.pi * Mf * T_sim)) + Mo) * Ma\n    elif M == 3:   # Noise form load\n        M_sim = np.interp(T_sim,\n                           np.linspace(0, T, int(T * Mf) + 2),\n                           np.random.normal(loc=(Mo * Ma), scale=Ma,\n                                            size=int(T * Mf) + 2)\n                          )\n    \n    # System response\n        \n    Tu, youtu, xoutu = c.forced_response(W_wsys, T_sim, U_sim)\n    Tm, youtm, xoutm = c.forced_response(W_wload, T_sim, M_sim)\n    R_sim = np.nan_to_num(youtu + youtm)\n    \n    Tu2, youtu2, xoutu2 = c.forced_response(W_isys, T_sim, U_sim)\n    Tm2, youtm2, xoutm2 = c.forced_response(W_iload, T_sim, M_sim)\n    I_sim = np.nan_to_num(youtu2 + youtm2)\n    \n    # Display\n            \n    UR_max = max(np.amax(np.absolute(np.concatenate((U_sim, R_sim)))), Ua)\n    M_max = max(np.amax(np.absolute(M_sim)), Ma)\n    I_max = max(np.amax(np.absolute(I_sim)), 1e-8)\n    \n    anim_ax1.set_xlim((0, T))\n    anim_ax1.set_ylim((-1.2 * UR_max, 1.2 * UR_max))\n    anim_ax2.set_ylim((-1.5 * I_max, 1.5 * I_max))\n    anim_ax3.set_ylim((-1.5 * M_max, 1.5 * M_max))\n    \n    global T_plot, U_plot, M_plot, R_plot, I_plot, v_var, a_var, r_var, w_var, rot_var\n    \n    T_plot = np.linspace(0, T, frame_count, dtype=np.float32)\n    U_plot = np.interp(T_plot, T_sim, U_sim)\n    M_plot = np.interp(T_plot, T_sim, M_sim)\n    R_plot = np.interp(T_plot, T_sim, R_sim)\n    I_plot = np.interp(T_plot, T_sim, I_sim)\n    \n    v_var = R_plot / UR_max * 45\n    a_var = I_plot / I_max * 45\n    r_var = U_plot / UR_max * 30\n    w_var = R_plot / UR_max * 30\n    \n    rot_var = np.cumsum(R_plot) / UR_max * 10   # The constant sets the apparent speed of the animation\n        \ndef anim_init():\n    line1.set_data([], [])\n    line2.set_data([], [])\n    line3.set_data([], [])\n    line4.set_data([], [])\n    \n    v_bar.set_theta1(0)\n    v_bar.set_theta2(0)\n    a_bar.set_theta1(0)\n    a_bar.set_theta2(0)\n    r_bar.set_theta1(0)\n    r_bar.set_theta2(0)\n    w_bar.set_theta1(0)\n    w_bar.set_theta2(0)\n    \n    spinner_1.set_theta1(0)\n    spinner_1.set_theta2(90)\n    spinner_2.set_theta1(180)\n    spinner_2.set_theta2(270)\n    \n    return (line1, line2, line3, line4, v_bar, a_bar, r_bar, w_bar, spinner_1, spinner_2,)\n\ndef animate(i):\n    line1.set_data(T_plot[0:i], U_plot[0:i])\n    line2.set_data(T_plot[0:i], R_plot[0:i])\n    line3.set_data(T_plot[0:i], I_plot[0:i])\n    line4.set_data(T_plot[0:i], M_plot[0:i])\n    \n    if v_var[i] &lt; 0:\n        v_bar.set_theta1(v_var[i])\n        v_bar.set_theta2(0)\n    else:\n        v_bar.set_theta1(0)\n        v_bar.set_theta2(v_var[i])\n        \n    if a_var[i] &lt; 0:\n        a_bar.set_theta1(a_var[i])\n        a_bar.set_theta2(0)\n    else:\n        a_bar.set_theta1(0)\n        a_bar.set_theta2(a_var[i])\n        \n    if r_var[i] &lt; 0:\n        r_bar.set_theta1(r_var[i])\n        r_bar.set_theta2(0)\n    else:\n        r_bar.set_theta1(0)\n        r_bar.set_theta2(r_var[i])\n        \n    if w_var[i] &lt; 0:\n        w_bar.set_theta1(w_var[i])\n        w_bar.set_theta2(0)\n    else:\n        w_bar.set_theta1(0)\n        w_bar.set_theta2(w_var[i])\n        \n    spinner_1.set_theta1(rot_var[i])\n    spinner_1.set_theta2(rot_var[i] + 90)\n    spinner_2.set_theta1(rot_var[i] + 180)\n    spinner_2.set_theta2(rot_var[i] + 270)\n\n    return (line1, line2, line3, line4, a_bar, r_bar, w_bar, spinner_1, spinner_2,)\n\nanim = animation.FuncAnimation(anim_fig, animate, init_func=anim_init,\n                               frames=frame_count, interval=10, blit=True,\n                               repeat=True)\n    \n# Controllers\n\nT_slider = w.FloatLogSlider(value=0.2, base=10, min=-0.7, max=1, step=0.01,\n                            description='Duration [s]:', continuous_update=False,\n                            orientation='vertical', layout=w.Layout(width='auto', height='auto', flex='1 1 auto'))\n\ndt_slider = w.FloatLogSlider(value=0.001, base=10, min=-3, max=-1, step=0.01,\n                             description='Timestep [s]:', continuous_update=False,\n                             orientation='vertical', layout=w.Layout(width='auto', height='auto', flex='1 1 auto'))\n\nU_type = w.Dropdown(options=[('Constant', 0), ('Sine', 1), ('Square', 2)], value=1,\n                     description='Reference: ', continuous_update=False, layout=w.Layout(width='auto', flex='3 3 auto'))    \nUf_slider = w.FloatLogSlider(value=10, base=10, min=-2, max=2, step=0.01,\n                             description='Frequency [Hz]:', continuous_update=False,\n                             orientation='vertical', layout=w.Layout(width='auto', height='auto', flex='1 1 auto'))\nUa_slider = w.FloatLogSlider(value=10, base=10, min=-2, max=2, step=0.01,\n                             description='Amplitude [rad/s]:', continuous_update=False,\n                             orientation='vertical', layout=w.Layout(width='auto', height='auto', flex='1 1 auto'))\nUo_slider = w.FloatSlider(value=0, min=-10, max=10, description='Offset/Ampl:', continuous_update=False,\n                              orientation='vertical', layout=w.Layout(width='auto', height='auto', flex='1 1 auto'))    \n    \nM_type = w.Dropdown(options=[('Constant', 0), ('Sine', 1), ('Square', 2), ('Noise', 3)], value=2,\n                     description='Load: ', continuous_update=False, layout=w.Layout(width='auto', flex='3 3 auto'))    \nMf_slider = w.FloatLogSlider(value=25, base=10, min=-2, max=2, step=0.01,\n                             description='Frequency [Hz]:', continuous_update=False,\n                             orientation='vertical', layout=w.Layout(width='auto', height='auto', flex='1 1 auto'))\nMa_slider = w.FloatLogSlider(value=0.1, base=10, min=-2, max=2, step=0.01,\n                             description='Amplitude [Nm]:', continuous_update=False,\n                             orientation='vertical', layout=w.Layout(width='auto', height='auto', flex='1 1 auto'))\nMo_slider = w.FloatSlider(value=0, min=-10, max=10, description='Offset/Ampl:', continuous_update=False,\n                              orientation='vertical', layout=w.Layout(width='auto', height='auto', flex='1 1 auto'))\n\ninput_data = w.interactive_output(simulation, {'iKp': iKp_slider, 'iTi': iTi_slider, 'iTd': iTd_slider,\n                                               'iFd': iFd_slider, 'iTi0' : iTi_button, 'iTd0': iTd_button,\n                                               'iFd0': iFd_button,\n                                               'wKp': wKp_slider, 'wTi': wTi_slider, 'wTd': wTd_slider,\n                                               'wFd': wFd_slider, 'wTi0' : wTi_button, 'wTd0': wTd_button,\n                                               'wFd0': wFd_button,\n                                               'sel':typeSelect,\n                                               'T': T_slider, 'dt': dt_slider,\n                                               'U': U_type, 'Uf': Uf_slider, 'Ua': Ua_slider, 'Uo': Uo_slider,\n                                               'M': M_type, 'Mf': Mf_slider, 'Ma': Ma_slider, 'Mo': Mo_slider})\n\ndisplay(w.HBox([w.HBox([T_slider, dt_slider], layout=w.Layout(width='25%')),\n                w.Box([], layout=w.Layout(width='5%')),\n                w.VBox([U_type, w.HBox([Uf_slider, Ua_slider, Uo_slider])], layout=w.Layout(width='30%')),\n                w.Box([], layout=w.Layout(width='5%')),\n                w.VBox([M_type, w.HBox([Mf_slider, Ma_slider, Mo_slider])], layout=w.Layout(width='30%'))],\n                layout=w.Layout(width='100%', justify_content='center')), input_data)\n\n\n\n\n\n\n\n\n\n\n\n\n\nThe duration parameter controls the simulated timeframe and does not affect the runtime of the animation. In contrast, the timestep controls the model sampling and can refine the results in exchange for higher computational resources."
  },
  {
    "objectID": "ICCT_en/examples/03/FD-20_1DoF_Mass-spring-damper.html",
    "href": "ICCT_en/examples/03/FD-20_1DoF_Mass-spring-damper.html",
    "title": "Control design for a 1DoF mass-spring-damper system",
    "section": "",
    "text": "%matplotlib notebook\nimport control as c\nimport ipywidgets as w\nimport numpy as np\n\nfrom IPython.display import display, HTML\nimport matplotlib.pyplot as plt\nimport matplotlib.patches as patches\nimport matplotlib.animation as animation\n\ndisplay(HTML('&lt;script&gt; $(document).ready(function() { $(\"div.input\").hide(); }); &lt;/script&gt;'))\n\n\n\n\nThe following example is a control design task for a mass-spring-damper system, a typical second-order model. The structure consists of a sliding mass (friction is ignored), connected to a reference point with an infinitely expandable string-damper pair.  \nIts equation of motion can be stated as:  \\[m\\cdot\\ddot{x}+b\\cdot\\dot{x}+k\\cdot{x}=F\\]  After the Laplace transformation of the differential equation, the transfer function can be expressed as:  \\[G(s)=\\frac{1}{m\\cdot s^2 +b\\cdot s + k}\\]  Your task is to choose a controller type, and tune it to acceptable levels of performance!\nFirst, choose a system model! Toggle between different realistic models with randomly preselected values (buttons Model 1 - Model 6). By clicking the Preset button default, valid predetermined controller parameters are set and cannot be tuned further.\n\n# Figure definition\n\nfig1, ((f1_ax1), (f1_ax2)) = plt.subplots(2, 1)\nfig1.set_size_inches((9.8, 5))\nfig1.set_tight_layout(True)\n\nf1_line1, = f1_ax1.plot([], [])\nf1_line2, = f1_ax2.plot([], [])  \n\nf1_ax1.grid(which='both', axis='both', color='lightgray')\nf1_ax2.grid(which='both', axis='both', color='lightgray')\n\nf1_ax1.autoscale(enable=True, axis='both', tight=True)\nf1_ax2.autoscale(enable=True, axis='both', tight=True)\n\nf1_ax1.set_title('Bode magnitude plot', fontsize=11)\nf1_ax1.set_xscale('log')\nf1_ax1.set_xlabel(r'$f\\/$[Hz]', labelpad=0, fontsize=10)\nf1_ax1.set_ylabel(r'$A\\/$[dB]', labelpad=0, fontsize=10)\nf1_ax1.tick_params(axis='both', which='both', pad=0, labelsize=8)\n\nf1_ax2.set_title('Bode phase plot', fontsize=11)\nf1_ax2.set_xscale('log')\nf1_ax2.set_xlabel(r'$f\\/$[Hz]', labelpad=0, fontsize=10)\nf1_ax2.set_ylabel(r'$\\phi\\/$[°]', labelpad=0, fontsize=10)\nf1_ax2.tick_params(axis='both', which='both', pad=0, labelsize=8)\n\n# System parameters\n\ndef build_base_model(m, k, b):\n    \n    W_sys = c.tf([1], [m, b, k])\n    \n    print('System transfer function:')\n    print(W_sys)\n    \n    # System analysis\n    \n    poles = c.pole(W_sys)     # Poles\n    \n    print('System poles:\\n')\n    print(poles)\n    \n    global f1_line1, f1_line2\n    \n    f1_ax1.lines.remove(f1_line1)\n    f1_ax2.lines.remove(f1_line2)\n    \n    mag, phase, omega = c.bode_plot(W_sys, Plot=False)   # Bode-plot\n    \n    f1_line1, = f1_ax1.plot(omega/2/np.pi, 20*np.log10(mag), lw=1, color='blue')\n    f1_line2, = f1_ax2.plot(omega/2/np.pi, phase*180/np.pi, lw=1, color='blue')   \n    \n    f1_ax1.relim()\n    f1_ax2.relim()\n    f1_ax1.autoscale_view()\n    f1_ax2.autoscale_view()\n    \n# GUI widgets\n\ntypeSelect = w.ToggleButtons(\n    options=[('Model 1', 0), ('Model 2', 1), ('Model 3', 2), ('Model 4', 3), ('Model 5', 4), ('Model 6', 5), ('Preset', -1)],\n    value =-1, description='System: ', layout=w.Layout(width='60%'))\n\nm_slider = w.FloatLogSlider(value=0.5, base=10, min=-3, max=3, description='m [kg] :', continuous_update=False,\n                             layout=w.Layout(width='auto', flex='5 5 auto'))\nk_slider = w.FloatLogSlider(value=100, base=10, min=-2, max=4, description='k [N/m] :', continuous_update=False,\n                             layout=w.Layout(width='auto', flex='5 5 auto'))\nb_slider = w.FloatLogSlider(value=50, base=10, min=-2, max=4, description='b [Ns/m] :', continuous_update=False,\n                             layout=w.Layout(width='auto', flex='5 5 auto'))\n\ninput_data = w.interactive_output(build_base_model, {'m':m_slider, 'k':k_slider, 'b':b_slider})\n\ndef update_sliders(index):\n    global m_slider, k_slider, b_slider\n    \n    mval = [0.05, 0.1, 0.25, 0.5, 1, 5, 0.25]\n    kval = [1.25, 10, 100, 10, 50, 1000, 50]\n    bval = [1, 0.5, 2, 10, 10, 20, 1]\n    \n    m_slider.value = mval[index]\n    k_slider.value = kval[index]\n    b_slider.value = bval[index]\n    \n    if index == -1:\n        m_slider.disabled = True\n        k_slider.disabled = True\n        b_slider.disabled = True\n    else:\n        m_slider.disabled = False\n        k_slider.disabled = False\n        b_slider.disabled = False\n    \ninput_data2 = w.interactive_output(update_sliders, {'index':typeSelect})\n\ndisplay(typeSelect, input_data2)\ndisplay(w.HBox([m_slider, k_slider, b_slider]), input_data)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nDepending on your selection, the system is either under- or overdamped.  Select an appropriate controller configuration! Which one is the best for your system? Why? Set up your controller for the fastest settling time with at most 25% overshoot!\nYou can turn on/off each of the I and D components, and if D is active, you can apply the first-order filter as well, based on the derivating time constant.\n\n# PID position control\n\nfig2, ((f2_ax1, f2_ax2, f2_ax3), (f2_ax4, f2_ax5, f2_ax6)) = plt.subplots(2, 3)\nfig2.set_size_inches((9.8, 5))\nfig2.set_tight_layout(True)\n\nf2_line1, = f2_ax1.plot([], [])\nf2_line2, = f2_ax2.plot([], []) \nf2_line3, = f2_ax3.plot([], [])\nf2_line4, = f2_ax4.plot([], [])  \nf2_line5, = f2_ax5.plot([], [])\nf2_line6, = f2_ax6.plot([], [])\n\nf2_ax1.grid(which='both', axis='both', color='lightgray')\nf2_ax2.grid(which='both', axis='both', color='lightgray')\nf2_ax3.grid(which='both', axis='both', color='lightgray')\nf2_ax4.grid(which='both', axis='both', color='lightgray')\nf2_ax5.grid(which='both', axis='both', color='lightgray')\nf2_ax6.grid(which='both', axis='both', color='lightgray')\n\nf2_ax1.autoscale(enable=True, axis='both', tight=True)\nf2_ax2.autoscale(enable=True, axis='both', tight=True)\nf2_ax3.autoscale(enable=True, axis='both', tight=True)\nf2_ax4.autoscale(enable=True, axis='both', tight=True)\nf2_ax5.autoscale(enable=True, axis='both', tight=True)\nf2_ax6.autoscale(enable=True, axis='both', tight=True)\n\n\nf2_ax1.set_title('Closed loop step response', fontsize=9)\nf2_ax1.set_xlabel(r'$t\\/$[s]', labelpad=0, fontsize=8)\nf2_ax1.set_ylabel(r'$x\\/$[m]', labelpad=0, fontsize=8)\nf2_ax1.tick_params(axis='both', which='both', pad=0, labelsize=6)\n\nf2_ax2.set_title('Nyquist diagram', fontsize=9)\nf2_ax2.set_xlabel(r'Re', labelpad=0, fontsize=8)\nf2_ax2.set_ylabel(r'Im', labelpad=0, fontsize=8)\nf2_ax2.tick_params(axis='both', which='both', pad=0, labelsize=6)\n\nf2_ax3.set_title('Bode magniture plot', fontsize=9)\nf2_ax3.set_xscale('log')\nf2_ax3.set_xlabel(r'$f\\/$[Hz]', labelpad=0, fontsize=8)\nf2_ax3.set_ylabel(r'$A\\/$[dB]', labelpad=0, fontsize=8)\nf2_ax3.tick_params(axis='both', which='both', pad=0, labelsize=6)\n\nf2_ax4.set_title('Closed loop impulse response', fontsize=9)\nf2_ax4.set_xlabel(r'$t\\/$[s]', labelpad=0, fontsize=8)\nf2_ax4.set_ylabel(r'$x\\/$[m]', labelpad=0, fontsize=8)\nf2_ax4.tick_params(axis='both', which='both', pad=0, labelsize=6)\n\nf2_ax5.set_title('Load transfer step response', fontsize=9)\nf2_ax5.set_xlabel(r'$t\\/$[s]', labelpad=0, fontsize=8)\nf2_ax5.set_ylabel(r'$x\\/$[m]', labelpad=0, fontsize=8)\nf2_ax5.tick_params(axis='both', which='both', pad=0, labelsize=6)\n\nf2_ax6.set_title('Bode phase plot', fontsize=9)\nf2_ax6.set_xscale('log')\nf2_ax6.set_xlabel(r'$f\\/$[Hz]', labelpad=0, fontsize=8)\nf2_ax6.set_ylabel(r'$\\phi\\/$[°]', labelpad=0, fontsize=8)\nf2_ax6.tick_params(axis='both', which='both', pad=0, labelsize=6)\n\ndef position_control(Kp, Ti, Td, Fd, Ti0, Td0, Fd0, m, k, b):\n    \n    W_sys = c.tf([1], [m, b, k])\n    \n    # PID Controller\n    \n    P = Kp             # Proportional term\n    I = Kp / Ti        # Integral term\n    D = Kp * Td        # Derivative term\n    Td_f = Td / Fd     # Derivative term filter\n    \n    W_PID = c.parallel(c.tf([P], [1]),\n                       c.tf([I * Ti0], [1 * Ti0, 1 * (not Ti0)]),\n                       c.tf([D * Td0, 0], [Td_f * Td0 * Fd0, 1]))  # PID controller in time constant format\n    \n    W_open = c.series(W_PID, W_sys)         # Open loop with two integrators added for position output\n    W_closed = c.feedback(W_open, 1, -1)    # Closed loop with negative feedback\n    \n    W_load = c.feedback(W_sys, W_PID, -1)   # Transfer function of the load based errors  \n                        \n    # Display\n                        \n    global f2_line1, f2_line2, f2_line3, f2_line4, f2_line5, f2_line6\n    \n    f2_ax1.lines.remove(f2_line1)\n    f2_ax2.lines.remove(f2_line2)\n    f2_ax3.lines.remove(f2_line3)\n    f2_ax4.lines.remove(f2_line4)\n    f2_ax5.lines.remove(f2_line5)\n    f2_ax6.lines.remove(f2_line6)\n    \n    tout, yout = c.step_response(W_closed)\n    f2_line1, = f2_ax1.plot(tout, yout, lw=1, color='blue') \n    \n    _, _, ob = c.nyquist_plot(W_open, Plot=False)   # Small resolution plot to determine bounds        \n    real, imag, freq = c.nyquist_plot(W_open, omega=np.logspace(np.log10(ob[0]), np.log10(ob[-1]), 1000), Plot=False)\n    f2_line2, = f2_ax2.plot(real, imag, lw=1, color='blue')\n    \n    mag, phase, omega = c.bode_plot(W_open, Plot=False)\n    f2_line3, = f2_ax3.plot(omega/2/np.pi, 20*np.log10(mag), lw=1, color='blue')\n    f2_line6, = f2_ax6.plot(omega/2/np.pi, phase*180/np.pi, lw=1, color='blue')\n\n    tout, yout = c.impulse_response(W_closed)\n    f2_line4, = f2_ax4.plot(tout, yout, lw=1, color='blue')   \n\n    tout, yout = c.step_response(W_load)\n    f2_line5, = f2_ax5.plot(tout, yout, lw=1, color='blue')\n    \n    f2_ax1.relim()\n    f2_ax2.relim()\n    f2_ax3.relim()\n    f2_ax4.relim()\n    f2_ax5.relim()\n    f2_ax6.relim()\n    f2_ax1.autoscale_view()\n    f2_ax2.autoscale_view()\n    f2_ax3.autoscale_view()\n    f2_ax4.autoscale_view()\n    f2_ax5.autoscale_view()\n    f2_ax6.autoscale_view()\n    \ndef update_controller(index):\n    global Kp_slider, Ti_slider, Td_slider, Fd_slider, Ti_button, Td_button, Fd_button\n    \n    if index == -1:\n        Kp_slider.value = 100\n        Td_slider.value = 0.05\n        Fd_slider.value = 10\n        Ti_button.value = False\n        Td_button.value = True\n        Fd_button.value = True\n        \n        Kp_slider.disabled = True\n        Ti_slider.disabled = True\n        Td_slider.disabled = True\n        Fd_slider.disabled = True\n        Ti_button.disabled = True\n        Td_button.disabled = True\n        Fd_button.disabled = True\n    else:\n        Kp_slider.disabled = False\n        Ti_slider.disabled = False\n        Td_slider.disabled = False\n        Fd_slider.disabled = False\n        Ti_button.disabled = False\n        Td_button.disabled = False\n        Fd_button.disabled = False\n    \n# GUI widgets\n\nKp_slider = w.FloatLogSlider(value=0.5, base=10, min=-1, max=4, description='Kp:', continuous_update=False,\n                             layout=w.Layout(width='auto', flex='5 5 auto'))\nTi_slider = w.FloatLogSlider(value=0.0035, base=10, min=-4, max=1, description='', continuous_update=False,\n                             layout=w.Layout(width='auto', flex='5 5 auto'))\nTd_slider = w.FloatLogSlider(value=1, base=10, min=-4, max=1, description='', continuous_update=False,\n                             layout=w.Layout(width='auto', flex='5 5 auto'))\nFd_slider = w.FloatLogSlider(value=1, base=10, min=0, max=3, description='', continuous_update=False,\n                             layout=w.Layout(width='auto', flex='5 5 auto'))\n\nTi_button = w.ToggleButton(value=True, description='Ti',\n                           layout=w.Layout(width='auto', flex='1 1 0%'))\nTd_button = w.ToggleButton(value=False, description='Td',\n                           layout=w.Layout(width='auto', flex='1 1 0%'))\nFd_button = w.ToggleButton(value=False, description='Fd',\n                           layout=w.Layout(width='auto', flex='1 1 0%'))\n\ninput_data = w.interactive_output(position_control, {'Kp': Kp_slider, 'Ti': Ti_slider, 'Td': Td_slider,\n                                                 'Fd': Fd_slider, 'Ti0' : Ti_button, 'Td0': Td_button,\n                                                 'Fd0': Fd_button, 'm':m_slider, 'k':k_slider, 'b':b_slider})\n\nw.interactive_output(update_controller, {'index': typeSelect})\n\ndisplay(w.HBox([Kp_slider, Ti_button, Ti_slider, Td_button, Td_slider, Fd_button, Fd_slider]), input_data)\n\n\n\n\n\n\n\n\n\n\n\n\n\nIn the following simulation, you can observe the movement of your system based on your controller setup. You can create reference signals and even apply some disturbance and see how the system reacts.\nIs your configuration suitable for signal-following? Readjust your controller so that it can follow a sine wave acceptably!  (The animations are scaled to fit the frame through the whole simulation. Because of this, unstable solutions might not seem to move until the very last second.)\n\n# Simulation data\n\nanim_fig = plt.figure()\nanim_fig.set_size_inches((9.8, 6))\nanim_fig.set_tight_layout(True)\n\nanim_ax1 = anim_fig.add_subplot(211)\nanim_ax2 = anim_ax1.twinx()\n\nframe_count=1000\n\nl1 = anim_ax1.plot([], [], lw=1, color='blue')\nl2 = anim_ax1.plot([], [], lw=2, color='red')\nl3 = anim_ax2.plot([], [], lw=1, color='grey')\n\nline1 = l1[0]\nline2 = l2[0]\nline3 = l3[0]\n\nanim_ax1.legend(l1+l2+l3, ['Reference [m]', 'Output [m]', 'Load [N]'], loc=1)\n\nanim_ax1.set_title('Time response simulation', fontsize=12)\nanim_ax1.set_xlabel(r'$t\\/$[s]', labelpad=0, fontsize=10)\nanim_ax1.set_ylabel(r'$x\\/$[m]', labelpad=0, fontsize=10)\nanim_ax1.tick_params(axis='both', which='both', pad=0, labelsize=8)\nanim_ax2.set_ylabel(r'$F\\/$[N]', labelpad=0, fontsize=10)\nanim_ax2.tick_params(axis='both', which='both', pad=0, labelsize=8)\n\nanim_ax1.grid(which='both', axis='both', color='lightgray')\n\nT_plot = []\nX_plot = []\nL_plot = []\nR_plot = []\n\n# Scene data\n\nscene_ax = anim_fig.add_subplot(212)\nscene_ax.set_xlim((-3, 4))\nscene_ax.set_ylim((-0.5, 1.5))\nscene_ax.axis('off')\n\nscene_ax.plot([-2.5, -2.3, -2.3, -0.3, -2.3, -2.3, -0.3], [0.75, 0.75, 0.9, 0.9, 0.9, 0.6, 0.6], lw=2, color='blue', zorder=0)\nscene_ax.plot([-2.5, -2.3], [0.25, 0.25], lw=2, color='red', zorder=0)\nscene_ax.plot([-2.5, -2.5], [1.25, -0.25], lw=4, color='gray', zorder=2)\n\nscene_ax.text(-1.3, 1, 'b', fontsize=14, color='blue', va='bottom', zorder=5)\nscene_ax.text(-1.3, 0, 'k', fontsize=14, color='red', va='top', zorder=5)\n\nb_line, = scene_ax.plot([], [], lw=2, color='blue')\nk_line, = scene_ax.plot([], [], lw=2, color='red')\n\nm_text = scene_ax.text(1.75, 0.5, 'm', fontsize=14, color='green', va='center', ha='center', zorder=5)\nm_box = patches.Rectangle((1, 0), 1.5, 1, lw=2, color='green', fill=False, zorder=10)\nscene_ax.add_patch(m_box)\n\nx_arrow = scene_ax.arrow(1.75, -0.5, 0, 0.25, color='blue', head_width=0.1,\n                         length_includes_head=True, lw=1, fill=False, zorder=5)\nr_arrow = scene_ax.arrow(1.75, -0.5, 0, 0.25, color='red', head_width=0.1,\n                         length_includes_head=True, lw=1, fill=False, zorder=5)\nbase_arrow = x_arrow.xy\n\npos_var = []\nref_var = []\n\n#Simulation function\n\ndef simulation(Kp, Ti, Td, Fd, Ti0, Td0, Fd0, m, k, b, T, dt, X, Xf, Xa, Xo, L, Lf, La, Lo):\n    \n    # Controller\n    P = Kp            # Proportional term\n    I = Kp / Ti       # Integral term\n    D = Kp * Td       # Derivative term\n    Td_f = Td / Fd    # Derivative term filter\n    \n    W_PID = c.parallel(c.tf([P], [1]),\n                       c.tf([I * Ti0], [1 * Ti0, 1 * (not Ti0)]),\n                       c.tf([D * Td0, 0], [Td_f * Td0 * Fd0, 1]))    # PID controller\n    \n    # System\n    W_sys = c.tf([1], [m, b, k])\n    \n    # Model\n    W_open = c.series(W_PID, W_sys)         # Open loop with two integrators added for position output\n    W_closed = c.feedback(W_open, 1, -1)    # Closed loop with negative feedback\n    \n    W_load = c.feedback(W_sys, W_PID, -1)   # Transfer function of the load based errors  \n    \n    # Reference and disturbance signals\n\n    T_sim = np.arange(0, T, dt, dtype=np.float64)\n    \n    if X == 0:     # Constant reference\n        X_sim = np.full_like(T_sim, Xa * Xo)\n    elif X == 1:   # Sine wave reference\n        X_sim = (np.sin(2 * np.pi * Xf * T_sim) + Xo) * Xa\n    elif X == 2:   # Square wave reference\n        X_sim = (np.sign(np.sin(2 * np.pi * Xf * T_sim)) + Xo) * Xa\n        \n    if L == 0:     # Constant load\n        L_sim = np.full_like(T_sim, La * Lo)\n    elif L == 1:   # Sine wave load\n        L_sim = (np.sin(2 * np.pi * Lf * T_sim) + Lo) * La\n    elif L == 2:   # Square wave load\n        L_sim = (np.sign(np.sin(2 * np.pi * Lf * T_sim)) + Lo) * La\n    elif L_type.value == 3:   # Noise form load\n        L_sim = np.interp(T_sim, np.linspace(0, T, int(T * Lf) + 2),\n                          np.random.normal(loc=(Lo * La), scale=La, size=int(T * Lf) + 2))\n    \n    # System response\n        \n    Tx, youtx, xoutx = c.forced_response(W_closed, T_sim, X_sim)\n    Tl, youtl, xoutl = c.forced_response(W_load, T_sim, L_sim)\n    R_sim = np.nan_to_num(youtx + youtl)\n    \n    # Display\n    \n    XR_max = max(np.amax(np.absolute(np.concatenate((X_sim, R_sim)))), Xa)\n    L_max = max(np.amax(np.absolute(L_sim)), La)\n    \n    anim_ax1.set_xlim((0, T))\n    anim_ax1.set_ylim((-1.2 * XR_max, 1.2 * XR_max))\n    anim_ax2.set_ylim((-1.5 * L_max, 1.5 * L_max))\n    \n    global T_plot, X_plot, L_plot, R_plot, pos_var, ref_var\n    \n    T_plot = np.linspace(0, T, frame_count, dtype=np.float32)\n    X_plot = np.interp(T_plot, T_sim, X_sim)\n    L_plot = np.interp(T_plot, T_sim, L_sim)\n    R_plot = np.interp(T_plot, T_sim, R_sim)\n    \n    pos_var = R_plot/XR_max\n    ref_var = X_plot/XR_max\n        \ndef anim_init():\n    line1.set_data([], [])\n    line2.set_data([], [])\n    line3.set_data([], [])\n    \n    b_line.set_data([], [])\n    k_line.set_data([], [])\n    \n    x_arrow.set_xy(base_arrow)\n    r_arrow.set_xy(base_arrow)\n    \n    m_text.set_position((1.75, 0.5))\n    m_box.set_xy((1, 0))\n    \n    return (line1, line2, line3, m_text, m_box, b_line, k_line,)\n\ndef animate(i):\n    line1.set_data(T_plot[0:i], X_plot[0:i])\n    line2.set_data(T_plot[0:i], R_plot[0:i])\n    line3.set_data(T_plot[0:i], L_plot[0:i])\n    \n    b_line.set_data([-1.3, -1.3, -1.3, 1]+pos_var[i], [0.66, 0.84, 0.75, 0.75])\n    k_line.set_data(np.append(np.array([0, 1, 3, 5, 7, 9, 11, 13, 15, 17, 19, 21, 22])*(pos_var[i]+2)/20-2.3, pos_var[i]+1),\n                    [0.25, 0.34, 0.16, 0.34, 0.16, 0.34, 0.16, 0.34, 0.16, 0.34, 0.16, 0.34, 0.25, 0.25])\n    \n    x_arrow.set_xy(base_arrow+[ref_var[i], 0])\n    r_arrow.set_xy(base_arrow+[pos_var[i], 0])\n    \n    m_text.set_position((pos_var[i]+1.75, 0.5))\n    m_box.set_x(pos_var[i]+1)\n    \n    return (line1, line2, line3, m_text, m_box, b_line, k_line,)\n\nanim = animation.FuncAnimation(anim_fig, animate, init_func=anim_init,\n                               frames=frame_count, interval=10, blit=True,\n                               repeat=True)\n\n# Controllers\n\nT_slider = w.FloatLogSlider(value=10, base=10, min=-0.7, max=1, step=0.01,\n                            description='Duration [s]:', continuous_update=False,\n                            orientation='vertical', layout=w.Layout(width='auto', height='auto', flex='1 1 auto'))\n\ndt_slider = w.FloatLogSlider(value=0.1, base=10, min=-3, max=-1, step=0.01,\n                             description='Timestep [s]:', continuous_update=False,\n                             orientation='vertical', layout=w.Layout(width='auto', height='auto', flex='1 1 auto'))\n       \nX_type = w.Dropdown(options=[('Constant', 0), ('Sine', 1), ('Square', 2)], value=1,\n                     description='Reference: ', continuous_update=False, layout=w.Layout(width='auto', flex='3 3 auto'))    \nXf_slider = w.FloatLogSlider(value=0.5, base=10, min=-2, max=2, step=0.01,\n                             description='Frequency [Hz]:', continuous_update=False,\n                             orientation='vertical', layout=w.Layout(width='auto', height='auto', flex='1 1 auto'))\nXa_slider = w.FloatLogSlider(value=1, base=10, min=-2, max=2, step=0.01,\n                             description='Amplitude [m]:', continuous_update=False,\n                             orientation='vertical', layout=w.Layout(width='auto', height='auto', flex='1 1 auto'))\nXo_slider = w.FloatSlider(value=0, min=-10, max=10, description='Offset/Ampl:', continuous_update=False,\n                              orientation='vertical', layout=w.Layout(width='auto', height='auto', flex='1 1 auto'))    \n    \nL_type = w.Dropdown(options=[('Constant', 0), ('Sine', 1), ('Square', 2), ('Noise', 3)], value=2,\n                     description='Load: ', continuous_update=False, layout=w.Layout(width='auto', flex='3 3 auto'))    \nLf_slider = w.FloatLogSlider(value=1, base=10, min=-2, max=2, step=0.01,\n                             description='Frequency [Hz]:', continuous_update=False,\n                             orientation='vertical', layout=w.Layout(width='auto', height='auto', flex='1 1 auto'))\nLa_slider = w.FloatLogSlider(value=0.1, base=10, min=-2, max=2, step=0.01,\n                             description='Amplitude [N]:', continuous_update=False,\n                             orientation='vertical', layout=w.Layout(width='auto', height='auto', flex='1 1 auto'))\nLo_slider = w.FloatSlider(value=0, min=-10, max=10, description='Offset/Ampl:', continuous_update=False,\n                              orientation='vertical', layout=w.Layout(width='auto', height='auto', flex='1 1 auto'))\n\ninput_data = w.interactive_output(simulation, {'Kp': Kp_slider, 'Ti': Ti_slider, 'Td': Td_slider,\n                                               'Fd': Fd_slider, 'Ti0' : Ti_button, 'Td0': Td_button,\n                                               'Fd0': Fd_button,\n                                               'm':m_slider, 'k':k_slider, 'b':b_slider,\n                                               'T': T_slider, 'dt': dt_slider,\n                                               'X': X_type, 'Xf': Xf_slider, 'Xa': Xa_slider, 'Xo': Xo_slider,\n                                               'L': L_type, 'Lf': Lf_slider, 'La': La_slider, 'Lo': Lo_slider})\n\ndisplay(w.HBox([w.HBox([T_slider, dt_slider], layout=w.Layout(width='25%')),\n                w.Box([], layout=w.Layout(width='5%')),\n                w.VBox([X_type, w.HBox([Xf_slider, Xa_slider, Xo_slider])], layout=w.Layout(width='30%')),\n                w.Box([], layout=w.Layout(width='5%')),\n                w.VBox([L_type, w.HBox([Lf_slider, La_slider, Lo_slider])], layout=w.Layout(width='30%'))],\n                layout=w.Layout(width='100%', justify_content='center')), input_data)\n\n\n\n\n\n\n\n\n\n\n\n\n\nThe duration parameter controls the simulated timeframe and does not affect the runtime of the animation. In contrast, the timestep controls the model sampling and can refine the results in exchange for higher computational resources."
  },
  {
    "objectID": "ICCT_en/examples/03/FD-18_OpAmp_PD_Controller.html",
    "href": "ICCT_en/examples/03/FD-18_OpAmp_PD_Controller.html",
    "title": "Creating a PD-controller using Operational Amplifiers",
    "section": "",
    "text": "%matplotlib notebook\nimport control as c\nimport ipywidgets as w\nimport numpy as np\n\nfrom IPython.display import display, HTML\nimport matplotlib.pyplot as plt\nimport matplotlib.animation as animation\n\ndisplay(HTML('&lt;script&gt; $(document).ready(function() { $(\"div.input\").hide(); }); &lt;/script&gt;'))\n\n\n\n\nIn analog electronics, operational amplifiers are generally used for the realization of Proportional-Integral-Derivating (PID) controllers. While the mathematical model of Linear Time-invariant (LTI) systems assumes ideal conditions, the realistic circuits may not entirely match them.\nIn most cases, the ideal model returns acceptable results, but the frequency characteristics can be approximated better by expanding the model with the amplifier’s open-loop gain:  \\[G_{ideal}(s)=\\frac{V_{out}}{V_{in}}=-\\frac{Z_F}{Z_G}\\qquad\\qquad G_{approx}(s)=\\frac{V_{out}}{V_{in}}=-\\frac{\\frac{-A\\cdot Z_F}{Z_G+Z_F}}{1+\\frac{A\\cdot Z_G}{Z_G+Z_F}}\\] \nIn this example, we will explore some of the operational amplifier based PD controller configurations. First, select an open-loop gain value for the calculations!\n\n# Model selector\nopampGain = w.ToggleButtons(\n    options=[('10 000', 10000), ('50 000', 50000), ('200 000', 200000),],\n    description='Operational amplifier gain: ', style={'description_width':'30%'})\n\ndisplay(opampGain)\n\n\n\n\nThe simplest implementation of the PD controller contains a capacitor in the feedforward and a resistor in the feedback path. The ideal model matches exactly the mathematical form of the controller. But after the inclusion of the open-loop gain, a first-order component appears, serving as a low-pass filter. This form of the PD controller is often used in place of the ideal version when designing applications.    Adjust the passive components so that the non-ideal model is the closest to the ideal! Where does the significant cutoff appear? What can be said about the phase plot?\n\n# Figure definition\n\nfig1, ((f1_ax1), (f1_ax2)) = plt.subplots(2, 1)\nfig1.set_size_inches((9.8, 5))\nfig1.set_tight_layout(True)\n\nl1 = f1_ax1.plot([], [], color='red')\nl2 = f1_ax2.plot([], [], color='red') \nl3 = f1_ax1.plot([], [], color='blue')\nl4 = f1_ax2.plot([], [], color='blue')  \n\nf1_line1 = l1[0]\nf1_line2 = l2[0]\nf1_line3 = l3[0]\nf1_line4 = l4[0]\n    \nf1_ax1.legend(l1+l3, ['Non-ideal', 'Ideal'], loc=1)\nf1_ax2.legend(l2+l4, ['Non-ideal', 'Ideal'], loc=1)\n\nf1_ax1.grid(which='both', axis='both', color='lightgray')\nf1_ax2.grid(which='both', axis='both', color='lightgray')\n\nf1_ax1.autoscale(enable=True, axis='x', tight=True)\nf1_ax2.autoscale(enable=True, axis='x', tight=True)\nf1_ax1.autoscale(enable=True, axis='y', tight=False)\nf1_ax2.autoscale(enable=True, axis='y', tight=False)\n\nf1_ax1.set_title('Bode magnitude plot', fontsize=11)\nf1_ax1.set_xscale('log')\nf1_ax1.set_xlabel(r'$f\\/$[Hz]', labelpad=0, fontsize=10)\nf1_ax1.set_ylabel(r'$A\\/$[dB]', labelpad=0, fontsize=10)\nf1_ax1.tick_params(axis='both', which='both', pad=0, labelsize=8)\n\nf1_ax2.set_title('Bode phase plot', fontsize=11)\nf1_ax2.set_xscale('log')\nf1_ax2.set_xlabel(r'$f\\/$[Hz]', labelpad=0, fontsize=10)\nf1_ax2.set_ylabel(r'$\\phi\\/$[°]', labelpad=0, fontsize=10)\nf1_ax2.tick_params(axis='both', which='both', pad=0, labelsize=8)  \n\n# System model\n\ndef system_model(cg, rf, a):\n\n    Rf = rf / 1000      # Convert to Ohm\n    Cg = cg * 1000000   # Convert to Farad\n\n    W_ideal = c.tf([-Rf*Cg, 0], [1])\n    W_ac = c.tf([-Rf*Cg*a, 0], [Rf*Cg, a+1])\n    \n    global f1_line1, f1_line2, f1_line3, f1_line4\n    \n    f1_ax1.lines.remove(f1_line1)\n    f1_ax2.lines.remove(f1_line2)\n    f1_ax1.lines.remove(f1_line3)\n    f1_ax2.lines.remove(f1_line4)\n\n    mag, phase, omega = c.bode_plot(W_ac, Plot=False)   # Non-ideal Bode-plot\n    f1_line1, = f1_ax1.plot(omega/2/np.pi, 20*np.log10(mag), lw=1, color='red')\n    f1_line2, = f1_ax2.plot(omega/2/np.pi, phase*180/np.pi, lw=1, color='red') \n    \n    mag, phase, omega = c.bode_plot(W_ideal, omega=omega, Plot=False)   # Ideal Bode-plot at the non-ideal points\n    f1_line3, = f1_ax1.plot(omega/2/np.pi, 20*np.log10(mag), lw=1, color='blue')\n    f1_line4, = f1_ax2.plot(omega/2/np.pi, phase*180/np.pi, lw=1, color='blue')   \n\n    f1_ax1.relim()\n    f1_ax2.relim()\n\n    f1_ax1.autoscale_view()\n    f1_ax2.autoscale_view()\n    \n    print('Ideal PD transfer function:')\n    print(W_ideal)\n    print('\\nNon-ideal PD transfer function:')\n    print(W_ac)\n    \n# GUI widgets\n    \nrf_slider = w.FloatLogSlider(value=1, base=10, min=-3, max=3, description=r'$R_f$$\\ [k\\Omega]\\ :$', continuous_update=False,\n                             layout=w.Layout(width='75%'), style={'description_width':'30%'})\ncg_slider = w.FloatLogSlider(value=1, base=10, min=-3, max=3, description=r'$C_g$$\\ [\\mu H]\\ :$', continuous_update=False,\n                             layout=w.Layout(width='75%'), style={'description_width':'30%'})\n\ninput_data = w.interactive_output(system_model, {'rf':rf_slider, 'cg':cg_slider, 'a':opampGain})\n\ndisplay(w.HBox([cg_slider, rf_slider]), input_data)\n\n\n\n\n\n\n\n\n\n\n\n\n\nThis implementation of the PD controller though really simple, has a few shortcomings, including its high noise sensitivity. To reduce the this problem, a resistor can be included in the feedforward path, while the transfer function of the system keeps its form.    Adjust the passive components so that the non-ideal model is the closest to the ideal! What are the differences compared to the previous model?\n\n# Filtered PD - serial (with \"stop\")\n\nfig2, ((f2_ax1), (f2_ax2)) = plt.subplots(2, 1)\nfig2.set_size_inches((9.8, 5))\nfig2.set_tight_layout(True)\n\nl1 = f2_ax1.plot([], [], color='red')\nl2 = f2_ax2.plot([], [], color='red') \nl3 = f2_ax1.plot([], [], color='blue')\nl4 = f2_ax2.plot([], [], color='blue')  \n\nf2_line1 = l1[0]\nf2_line2 = l2[0]\nf2_line3 = l3[0]\nf2_line4 = l4[0]\n\nf2_ax1.legend(l1+l3, ['Non-ideal', 'Ideal'], loc=1)\nf2_ax2.legend(l2+l4, ['Non-ideal', 'Ideal'], loc=1)\n\nf2_ax1.grid(which='both', axis='both', color='lightgray')\nf2_ax2.grid(which='both', axis='both', color='lightgray')\n\nf2_ax1.autoscale(enable=True, axis='x', tight=True)\nf2_ax2.autoscale(enable=True, axis='x', tight=True)\nf2_ax1.autoscale(enable=True, axis='y', tight=False)\nf2_ax2.autoscale(enable=True, axis='y', tight=False)\n\nf2_ax1.set_title('Bode magnitude plot', fontsize=11)\nf2_ax1.set_xscale('log')\nf2_ax1.set_xlabel(r'$f\\/$[Hz]', labelpad=0, fontsize=10)\nf2_ax1.set_ylabel(r'$A\\/$[dB]', labelpad=0, fontsize=10)\nf2_ax1.tick_params(axis='both', which='both', pad=0, labelsize=8)\n\nf2_ax2.set_title('Bode phase plot', fontsize=11)\nf2_ax2.set_xscale('log')\nf2_ax2.set_xlabel(r'$f\\/$[Hz]', labelpad=0, fontsize=10)\nf2_ax2.set_ylabel(r'$\\phi\\/$[°]', labelpad=0, fontsize=10)\nf2_ax2.tick_params(axis='both', which='both', pad=0, labelsize=8)\n\n# System model\n\ndef system2_model(cg, rg, rf, a):\n\n    Rf = rf / 1000      # Convert to Ohm\n    Rg = rg / 1000 \n    Cg = cg * 1000000   # Convert to Farad\n\n    W_ideal = c.tf([-Rf*Cg, 0], [1])\n    W_ac = c.tf([-Rf*Cg*a, 0], [(Rf+Rg*(a+1))*Cg, a+1])\n    \n    global f2_line1, f2_line2, f2_line3, f2_line4\n    \n    f2_ax1.lines.remove(f2_line1)\n    f2_ax2.lines.remove(f2_line2)\n    f2_ax1.lines.remove(f2_line3)\n    f2_ax2.lines.remove(f2_line4)\n\n    mag, phase, omega = c.bode_plot(W_ac, Plot=False)   # Non-ideal Bode-plot\n    f2_line1, = f2_ax1.plot(omega/2/np.pi, 20*np.log10(mag), lw=1, color='red')\n    f2_line2, = f2_ax2.plot(omega/2/np.pi, phase*180/np.pi, lw=1, color='red') \n    \n    mag, phase, omega = c.bode_plot(W_ideal, omega=omega, Plot=False)   # Ideal Bode-plot at the non-ideal points\n    f2_line3, = f2_ax1.plot(omega/2/np.pi, 20*np.log10(mag), lw=1, color='blue')\n    f2_line4, = f2_ax2.plot(omega/2/np.pi, phase*180/np.pi, lw=1, color='blue')   \n\n    f2_ax1.relim()\n    f2_ax2.relim()\n    \n    f2_ax1.autoscale_view()\n    f2_ax2.autoscale_view()\n    \n    print('Ideal PD (differentiator with stop) transfer function:')\n    print(W_ideal)\n    print('\\nNon-ideal PD (differentiator with stop) transfer function:')\n    print(W_ac)\n    \n# GUI widgets\n    \nrg2_slider = w.FloatLogSlider(value=1, base=10, min=-3, max=3, description=r'$R_g$$\\ [k\\Omega]\\ :$', continuous_update=False,\n                             layout=w.Layout(width='75%'), style={'description_width':'30%'})\nrf2_slider = w.FloatLogSlider(value=1, base=10, min=-3, max=3, description=r'$R_f$$\\ [k\\Omega]\\ :$', continuous_update=False,\n                             layout=w.Layout(width='75%'), style={'description_width':'30%'})\ncg2_slider = w.FloatLogSlider(value=1, base=10, min=-3, max=3, description=r'$C_g$$\\ [\\mu H]\\ :$', continuous_update=False,\n                             layout=w.Layout(width='75%'), style={'description_width':'30%'})\n\ninput_data = w.interactive_output(system2_model, {'rg':rg2_slider, 'rf':rf2_slider, 'cg':cg2_slider, 'a':opampGain})\n\ndisplay(w.HBox([rg2_slider, cg2_slider, rf2_slider]), input_data)"
  },
  {
    "objectID": "ICCT_en/examples/03/FD-16_OpAmp_P_Controller.html",
    "href": "ICCT_en/examples/03/FD-16_OpAmp_P_Controller.html",
    "title": "Creating a P-controller using Operational Amplifiers",
    "section": "",
    "text": "%matplotlib notebook\nimport control as c\nimport ipywidgets as w\nimport numpy as np\n\nfrom IPython.display import display, HTML\nimport matplotlib.pyplot as plt\nimport matplotlib.patches as patches\nimport matplotlib.animation as animation\n\ndisplay(HTML('&lt;script&gt; $(document).ready(function() { $(\"div.input\").hide(); }); &lt;/script&gt;'))\n\n\n\n\nIn analog electronics, operational amplifiers are generally used for the realization of Proportional-Integral-Derivating (PID) controllers. While the mathematical models for Linear Time-Invariant (LTI) systems assume ideal conditions, the realistic circuits may not entirely match them. In the following example, we will take a look at two models used to describe operational amplifiers and compare their output to the idealized system in order to understand how close they approximate the ideal model in a steady state.\nOne of the most important parameters of an operational amplifier is its open-loop gain, a frequency-dependent parameter that is the ratio of the output voltage, and the input voltage difference.\nSelect an open-loop gain value for the calculations!\n\n# Model selector\nopampGain = w.ToggleButtons(\n    options=[('10 000', 10000), ('200 000', 200000),],\n    description='Operational amplifier gain: ', style={'description_width':'30%'})\n\ndisplay(opampGain)\n\n\n\n\nAn ideal operational amplifier assumes the input voltage difference to be zero, and the open-loop gain to be infinite. This model allows for the calculation of a transfer function based on the complex impedance of the feedforward and feedback paths. In this example, only resistors are present in the circuit; therefore, the result will be a simple closed-loop gain:  \\[\\frac{V_{out}}{V_{in}}=-\\frac{Z_F}{Z_G}\\]  Some frequency characteristics can be included in the linear model by the following expansion:  \\[\\frac{V_{out}}{V_{in}}=-\\frac{\\frac{-A\\cdot Z_F}{Z_G+Z_F}}{1+\\frac{A\\cdot Z_G}{Z_G+Z_F}}\\]  Set up a system so that the results are approximating the ideal as much as possible! At what conditions does this happen?\n  \n\n# System model\n\ndef system_model(rg, rf, a):\n\n    Rg = rg / 1000   # Convert to Ohm\n    Rf = rf / 1000\n\n    G_ideal = -Rf / Rg   # Ideal closed-loop gain\n    G_ac = (-a*Rf/(Rf+Rg)) / (1+a*Rg/(Rf+Rg))   # Non-ideal closed-loop gain\n    \n    print('Ideal closed-loop gain:')\n    print('{0:.4g}'.format(G_ideal))\n    print('\\nNon-ideal closed-loop gain:')\n    print('{0:.4g}'.format(G_ac))\n    print('\\nDifference from ideal:')\n    print('{0:.4%}'.format((G_ac-G_ideal)/G_ideal))   \n\n\n# GUI widgets\n    \nrg_slider = w.FloatLogSlider(value=1, base=10, min=-3, max=3, description=r'$R_g\\ [k\\Omega]\\ :$', continuous_update=False,\n                             layout=w.Layout(width='75%'))\nrf_slider = w.FloatLogSlider(value=1, base=10, min=-3, max=3, description=r'$R_f\\ [k\\Omega]\\ :$', continuous_update=False,\n                             layout=w.Layout(width='75%'))\n\ninput_data = w.interactive_output(system_model, {'rg':rg_slider, 'rf':rf_slider, 'a':opampGain})\n\ndisplay(w.HBox([rg_slider, rf_slider]), input_data)\n\n\n\n\n\n\n\nThis model can be further refined by including the internal and load impedances of the operational amplifier. This realistic model, however, is still based on frequency-dependent components. When designing an analog control circuit, these parameters have to be chosen so that the amplifier most closely approximates the ideal at the controller’s frequency range.\nAdjust the system parameters, so that the system approximates the ideal value! What are your observations?\n\n# Scene data\n\nanim_fig = plt.figure()\nanim_fig.set_size_inches((9.8, 4))\nanim_fig.set_tight_layout(True)\n\nscene_ax = anim_fig.add_subplot(111)\nscene_ax.set_xlim((-3, 4))\nscene_ax.set_ylim((-1, 1.8))\nscene_ax.axis('off')\n\nscene_ax.add_patch(patches.Polygon(np.array([[-0.7, -0.7, 1.55], [-1, 1.7, 0.35]]).T, closed=True, fill=False,\n                                  lw=2, ec='dimgray', joinstyle='round', zorder=20))\nscene_ax.add_patch(patches.Rectangle((-0.6, 0), 0.25, 0.7, fill=False, lw=1.5, ec='blue', zorder=10))\nscene_ax.add_patch(patches.Rectangle((0.5, 0.225), 0.7, 0.25, fill=False, lw=1.5, ec='blue', zorder=10))\nscene_ax.add_patch(patches.Circle((0.2, 0.35), 0.2, fill=False, lw=1.5, ec='blue', zorder=10))\n\nscene_ax.plot([-1.1, -0.475, -0.475], [1.2, 1.2, 0.7], color='red', lw=1.5, zorder=0)\nscene_ax.plot([-1.1, -0.475, -0.475], [-0.5, -0.5, 0], color='red', lw=1.5, zorder=0)\n\nscene_ax.add_patch(patches.Circle((-1.15, 1.2), 0.05, fill=False, lw=1.5, ec='blue', zorder=10))\nscene_ax.add_patch(patches.Circle((-1.15, -0.5), 0.05, fill=False, lw=1.5, ec='blue', zorder=10))\n\nscene_ax.plot([-0.15, -0.15, 0], [-0.1, 0.35, 0.35], color='red', lw=1.5, zorder=0)\n\nscene_ax.plot([-0.275, -0.025], [-0.1, -0.1], color='blue', lw=1.5, zorder=10)\nscene_ax.plot([-0.225, -0.075], [-0.175, -0.175], color='blue', lw=1.5, zorder=10)\nscene_ax.plot([-0.175, -0.125], [-0.25, -0.25], color='blue', lw=1.5, zorder=10)\n\nscene_ax.plot([0.4, 0.5], [0.35, 0.35], color='red', lw=1.5, zorder=0)\nscene_ax.plot([1.2, 1.75], [0.35, 0.35], color='red', lw=1.5, zorder=0)\n\nscene_ax.add_patch(patches.Circle((1.8, 0.35), 0.05, fill=False, lw=1.5, ec='blue', zorder=10))\nscene_ax.add_patch(patches.Rectangle((2, -0.55), 0.25, 0.7, fill=False, lw=1.5, ec='blue', zorder=10))\n\nscene_ax.plot([1.85, 2.125, 2.125], [0.35, 0.35, 0.15], color='red', lw=1.5, zorder=0)\nscene_ax.plot([2.125, 2.125], [-0.55, -0.75], color='red', lw=1.5, zorder=0)\n\nscene_ax.plot([2, 2.25], [-0.75, -0.75], color='blue', lw=1.5, zorder=10)\nscene_ax.plot([2.05, 2.2], [-0.825, -0.825], color='blue', lw=1.5, zorder=10)\nscene_ax.plot([2.1, 2.15], [-0.9, -0.9], color='blue', lw=1.5, zorder=10)\n\nscene_ax.text(0.85, 0.6, '$R_{out}$', fontsize=15, color='black', va='center_baseline', ha='center', zorder=30)\nscene_ax.text(1.9, -0.05, '$R_{load}$', fontsize=15, color='black', va='center_baseline', ha='center',\n              rotation=90, zorder=30)\nscene_ax.text(-0.3, 0.85, '$R_{in}$', fontsize=15, color='black', va='center_baseline', ha='center', zorder=30)\nscene_ax.text(0.2, 0.375, '$A\\\\dot{}V_{in}$', fontsize=15, color='black', va='center_baseline', ha='center', zorder=30)\n\nRin_text = scene_ax.text(-0.4, 0.35, '$R_{in}$', fontsize=11, color='black', va='center_baseline', ha='center',\n              rotation=90, rotation_mode='anchor', zorder=30)\nRout_text = scene_ax.text(0.85, 0.35, '$R_{out}$', fontsize=11, color='black', va='center_baseline', ha='center', zorder=30)\nRload_text = scene_ax.text(2.2, -0.2, '$R_{load}$', fontsize=11, color='black', va='center_baseline', ha='center',\n              rotation=90, rotation_mode='anchor', zorder=30)\n\n# System parameters\n\ndef real_model(rg, rf, a, rin, rout, rload):\n    \n    global Rin_text, Rout_text, Rload_text\n    \n    Rin_text.set_text('${0:.3g}\\/k\\Omega$'.format(rin))\n    Rout_text.set_text('${0:.3g}\\/k\\Omega$'.format(rout))\n    Rload_text.set_text('${0:.3g}\\/k\\Omega$'.format(rload))\n    \n    Rg = rg / 1000   # Convert to Ohm\n    Rf = rf / 1000\n    Rin = rin / 1000\n    Rout = rout / 1000\n    Rload = rload / 1000\n    \n    G_ideal = -Rf / Rg   # Ideal closed-loop gain\n    mu = (1 + Rout/Rf + Rout/Rload) * (1 + Rf/Rg + Rf/Rin) / (a - Rout/Rf)\n    G_real = (-Rf / Rg) / (1 + mu)   # Realistic closed-loop gain\n    \n    print('Real closed-loop gain:')\n    print('{0:.4g}'.format(G_real))\n    print('\\nDifference from ideal:')\n    print('{0:.4%}'.format((G_real-G_ideal)/G_ideal))\n    \nrin_slider = w.FloatLogSlider(value=1, base=10, min=-3, max=3, description=r'$R_{in}\\ [k\\Omega]\\ :$', continuous_update=False,\n                             layout=w.Layout(width='75%'), style={'description_width':'30%'})\nrout_slider = w.FloatLogSlider(value=1, base=10, min=-3, max=3, description=r'$R_{out}\\ [k\\Omega]\\ :$', continuous_update=False,\n                             layout=w.Layout(width='75%'), style={'description_width':'30%'})\nrload_slider = w.FloatLogSlider(value=1, base=10, min=-3, max=3, description=r'$R_{load}\\ [k\\Omega]\\ :$', continuous_update=False,\n                             layout=w.Layout(width='75%'), style={'description_width':'30%'})\n\ninput_data = w.interactive_output(real_model, {'rg':rg_slider, 'rf':rf_slider, 'a':opampGain,\n                                                 'rin':rin_slider, 'rout':rout_slider, 'rload':rload_slider})\n\ndisplay(w.HBox([rin_slider, rout_slider, rload_slider]), input_data)"
  },
  {
    "objectID": "ICCT_en/examples/03/FD-14_Discrete_PID_Control_of_Continuous_First-Order_Systems.html",
    "href": "ICCT_en/examples/03/FD-14_Discrete_PID_Control_of_Continuous_First-Order_Systems.html",
    "title": "Discrete PID control of a First-Order system",
    "section": "",
    "text": "%matplotlib notebook\nimport control as c\nimport ipywidgets as w\nimport numpy as np\n\nfrom IPython.display import display, HTML\nimport matplotlib.pyplot as plt\nimport matplotlib.animation as animation\n\ndisplay(HTML('&lt;script&gt; $(document).ready(function() { $(\"div.input\").hide(); }); &lt;/script&gt;'))\n\nTraceback (most recent call last):\n  File \"C:\\Users\\Uporabnik\\Anaconda3\\envs\\icct2\\lib\\site-packages\\matplotlib\\cbook\\__init__.py\", line 216, in process\n    func(*args, **kwargs)\n  File \"C:\\Users\\Uporabnik\\Anaconda3\\envs\\icct2\\lib\\site-packages\\matplotlib\\animation.py\", line 1465, in _stop\n    self.event_source.remove_callback(self._loop_delay)\nAttributeError: 'NoneType' object has no attribute 'remove_callback'\n\n\n\n\n\nIn the following example, we will explore the effect of discrete-time sampling on a first-order system with a PID controller. The controller is designed and tuned with continuous-time parameters, but it is then converted to discrete-time by a zero-order hold (ZOH) or pole matching. The controller signal is returned to continuous time using yet another zero-order-hold and is then supplied to the system.\n \\[G(s)=\\frac{1}{\\tau s + 1}\\]    Choose a time constant for the system and a sampling period for discretization!\n\n# Figure definition\n\nfig1, ((f1_ax1), (f1_ax2)) = plt.subplots(2, 1)\nfig1.set_size_inches((9.8, 5))\nfig1.set_tight_layout(True)\n\nf1_line1, = f1_ax1.plot([], [])\nf1_line2, = f1_ax2.plot([], [])  \n\nf1_ax1.grid(which='both', axis='both', color='lightgray')\nf1_ax2.grid(which='both', axis='both', color='lightgray')\n\nf1_ax1.autoscale(enable=True, axis='both', tight=True)\nf1_ax2.autoscale(enable=True, axis='both', tight=True)\n\nf1_ax1.set_title('Bode magnitude plot', fontsize=11)\nf1_ax1.set_xscale('log')\nf1_ax1.set_xlabel(r'$f\\/$[Hz]', labelpad=0, fontsize=10)\nf1_ax1.set_ylabel(r'$A\\/$[dB]', labelpad=0, fontsize=10)\nf1_ax1.tick_params(axis='both', which='both', pad=0, labelsize=8)\n\nf1_ax2.set_title('Bode phase plot', fontsize=11)\nf1_ax2.set_xscale('log')\nf1_ax2.set_xlabel(r'$f\\/$[Hz]', labelpad=0, fontsize=10)\nf1_ax2.set_ylabel(r'$\\phi\\/$[°]', labelpad=0, fontsize=10)\nf1_ax2.tick_params(axis='both', which='both', pad=0, labelsize=8)   \n\n\n# System model\n\ndef system_model(T1, dts):\n\n    W_syscont = c.tf([1], [T1, 1])\n    W_sys = c.sample_system(W_syscont, dts, method='zoh') \n    # Zero Order Hold conversion to include continuous system in discrete model\n\n    print('System transfer function:')\n    print(W_syscont)\n    print('\\nDiscretized transfer function:')\n    print(W_sys)\n\n    # System analysis\n\n    poles_cont = c.pole(W_syscont)     # Poles\n    poles = c.pole(W_sys)\n\n    print('\\nSystem poles:')\n    print(poles_cont)\n    print('\\nDiscrete time system poles:')\n    print(poles)\n    \n    global f1_line1, f1_line2\n    \n    f1_ax1.lines.remove(f1_line1)\n    f1_ax2.lines.remove(f1_line2)\n\n    mag, phase, omega = c.bode_plot(W_sys, Plot=False)   # Bode-plot\n\n    f1_line1, = f1_ax1.plot(omega/2/np.pi, 20*np.log10(mag), lw=1, color='blue')\n    f1_line2, = f1_ax2.plot(omega/2/np.pi, phase*180/np.pi, lw=1, color='blue')   \n\n    f1_ax1.relim()\n    f1_ax2.relim()\n    f1_ax1.autoscale_view()\n    f1_ax2.autoscale_view()\n    \n# GUI widgets\n    \nT1_slider = w.FloatLogSlider(value=0.1, base=10, min=-4, max=1, description='T1 [s] :', continuous_update=False,\n                             layout=w.Layout(width='75%'))\ndts_slider = w.FloatLogSlider(value=0.1, base=10, min=-4, max=0, description='dts [s] :', continuous_update=False,\n                                 layout=w.Layout(width='75%'))\n\ninput_data = w.interactive_output(system_model, {'T1':T1_slider, 'dts':dts_slider})\n\ndisplay(w.HBox([T1_slider, dts_slider]), input_data)\n\n\n\n\n\n\n\n\n\n\n\n\n\nAfter observing the system characteristics, select a controller type!\n\n#Controller type select\n\ntypeSelect = w.ToggleButtons(\n    options=[('P (matched)', 0), ('PI (ZOH)', 1), ('PD (matched)', 2), ('PD Realistic (ZOH)', 3), ('PID Realistic (ZOH)', 4)],\n    description='Controller type: ', style={'description_width':'15%'})\n\ndisplay(typeSelect)\n\n\n\n\nTune the selected controller so that rising/settling time, overshoot, or remaining error is minimized! It is not possible to get the best out of each parameter in a single setup. Create multiple solutions, one for each type!\n\n# PID control\n\n# Figure definition\nfig2, ((f2_ax1, f2_ax2, f2_ax3), (f2_ax4, f2_ax5, f2_ax6)) = plt.subplots(2, 3)\nfig2.set_size_inches((9.8, 5))\nfig2.set_tight_layout(True)\n\nf2_line1, = f2_ax1.plot([], [])\nf2_line2, = f2_ax2.plot([], []) \nf2_line3, = f2_ax3.plot([], [])\nf2_line4, = f2_ax4.plot([], [])  \nf2_line5, = f2_ax5.plot([], [])\nf2_line6, = f2_ax6.plot([], [])\n\nf2_ax1.grid(which='both', axis='both', color='lightgray')\nf2_ax2.grid(which='both', axis='both', color='lightgray')\nf2_ax3.grid(which='both', axis='both', color='lightgray')\nf2_ax4.grid(which='both', axis='both', color='lightgray')\nf2_ax5.grid(which='both', axis='both', color='lightgray')\nf2_ax6.grid(which='both', axis='both', color='lightgray')\n\nf2_ax1.autoscale(enable=True, axis='both', tight=True)\nf2_ax2.autoscale(enable=True, axis='both', tight=True)\nf2_ax3.autoscale(enable=True, axis='both', tight=True)\nf2_ax4.autoscale(enable=True, axis='both', tight=True)\nf2_ax5.autoscale(enable=True, axis='both', tight=True)\nf2_ax6.autoscale(enable=True, axis='both', tight=True)\n\nf2_ax1.set_title('Closed loop step response', fontsize=9)\nf2_ax1.set_xlabel(r'$t\\/$[s]', labelpad=0, fontsize=8)\nf2_ax1.set_ylabel(r'$x\\/$[m]', labelpad=0, fontsize=8)\nf2_ax1.tick_params(axis='both', which='both', pad=0, labelsize=6)\n\nf2_ax2.set_title('Nyquist diagram', fontsize=9)\nf2_ax2.set_xlabel(r'Re', labelpad=0, fontsize=8)\nf2_ax2.set_ylabel(r'Im', labelpad=0, fontsize=8)\nf2_ax2.tick_params(axis='both', which='both', pad=0, labelsize=6)\n\nf2_ax3.set_title('Bode magnitude plot', fontsize=9)\nf2_ax3.set_xscale('log')\nf2_ax3.set_xlabel(r'$f\\/$[Hz]', labelpad=0, fontsize=8)\nf2_ax3.set_ylabel(r'$A\\/$[dB]', labelpad=0, fontsize=8)\nf2_ax3.tick_params(axis='both', which='both', pad=0, labelsize=6)\n\nf2_ax4.set_title('Closed loop impulse response', fontsize=9)\nf2_ax4.set_xlabel(r'$t\\/$[s]', labelpad=0, fontsize=8)\nf2_ax4.set_ylabel(r'$x\\/$[m]', labelpad=0, fontsize=8)\nf2_ax4.tick_params(axis='both', which='both', pad=0, labelsize=6)\n\nf2_ax5.set_title('Open loop step response', fontsize=9)\nf2_ax5.set_xlabel(r'$t\\/$[s]', labelpad=0, fontsize=8)\nf2_ax5.set_ylabel(r'$x\\/$[m]', labelpad=0, fontsize=8)\nf2_ax5.tick_params(axis='both', which='both', pad=0, labelsize=6)\n\nf2_ax6.set_title('Bode phase plot', fontsize=9)\nf2_ax6.set_xscale('log')\nf2_ax6.set_xlabel(r'$f\\/$[Hz]', labelpad=0, fontsize=8)\nf2_ax6.set_ylabel(r'$\\phi\\/$[°]', labelpad=0, fontsize=8)\nf2_ax6.tick_params(axis='both', which='both', pad=0, labelsize=6)\n\ndef pid_control(Kp, Ti, Td, Fd, type_select, T1, dts):\n    \n    W_syscont = c.tf([1], [T1, 1])\n    W_sys = c.sample_system(W_syscont, dts, method='zoh')\n    # Zero Order Hold conversion to include continuous system in discrete model\n    \n    if type_select in (1, 4):\n        Ti0 = 1\n    else:\n        Ti0 = 0\n        \n    if type_select in (2, 3, 4):\n        Td0 = 1\n    else :\n        Td0 = 0\n        \n    if type_select in (3, 4):\n        Fd0 = 1\n    else:\n        Fd0 = 0\n    \n    if type_select in (0, 2):\n        convmet = \"matched\"\n    else:\n        convmet = \"zoh\"\n    \n    # PID Controller\n    \n    P = Kp             # Proportional term\n    I = Kp / Ti        # Integral term\n    D = Kp * Td        # Derivative term\n    Td_f = Td / Fd     # Derivative term filter\n    \n    W_PID_cont = c.parallel(c.tf([P], [1]),\n                            c.tf([I * Ti0], [1 * Ti0, 1 * (not Ti0)]),\n                            c.tf([D * Td0, 0], [Td_f * Td0 * Fd0, 1]))  # PID controller in time constant format    \n    \n    W_PID = c.sample_system(W_PID_cont, dts, method=convmet) # PID discretization\n    \n    W_open = c.series(W_PID, W_sys)      # Open loop\n    W_closed = c.feedback(W_open, 1, -1)    # Closed loop with negative feedback\n                        \n    # Display\n                        \n    global f2_line1, f2_line2, f2_line3, f2_line4, f2_line5, f2_line6\n\n    try:\n        f2_ax1.lines.remove(f2_line1)\n        f2_ax2.lines.remove(f2_line2)\n        f2_ax3.lines.remove(f2_line3)\n        f2_ax4.lines.remove(f2_line4)\n        f2_ax5.lines.remove(f2_line5)\n        f2_ax6.lines.remove(f2_line6)\n    except:\n            pass\n    \n    tin = np.arange(0, 10*T1, dts)\n\n    if tin.size &gt; 1:\n        \n        tout, yout = c.step_response(W_closed, tin)\n        maxint = min(tout.size, yout.size)\n        f2_line1, = f2_ax1.plot(tout[0:maxint], yout[0:maxint], lw=1, color='blue')\n\n        _, _, ob = c.nyquist_plot(W_open, Plot=False)   # Small resolution plot to determine bounds        \n        real, imag, freq = c.nyquist_plot(W_open, omega=np.logspace(np.log10(ob[0]), np.log10(ob[-1]), 1000), Plot=False)\n        f2_line2, = f2_ax2.plot(real, imag, lw=1, color='blue')\n\n        mag, phase, omega = c.bode_plot(W_open, Plot=False)\n        f2_line3, = f2_ax3.plot(omega/2/np.pi, 20*np.log10(mag), lw=1, color='blue')\n        f2_line6, = f2_ax6.plot(omega/2/np.pi, phase*180/np.pi, lw=1, color='blue')\n\n        tout, yout = c.impulse_response(W_closed, tin)\n        maxint = min(tout.size, yout.size)\n        f2_line4, = f2_ax4.plot(tout[0:maxint], yout[0:maxint], lw=1, color='blue')\n\n        tout, yout = c.step_response(W_open, tin)\n        maxint = min(tout.size, yout.size)\n        f2_line5, = f2_ax5.plot(tout[0:maxint], yout[0:maxint], lw=1, color='blue')\n\n    f2_ax1.relim()\n    f2_ax2.relim()\n    f2_ax3.relim()\n    f2_ax4.relim()\n    f2_ax5.relim()\n    f2_ax6.relim()\n\n    f2_ax1.autoscale_view()\n    f2_ax2.autoscale_view()\n    f2_ax3.autoscale_view()\n    f2_ax4.autoscale_view()\n    f2_ax5.autoscale_view()\n    f2_ax6.autoscale_view()\n    \n# GUI widgets\n\ndef draw_controllers(type_select):\n    \n    global Kp_slider\n    global Ti_slider\n    global Td_slider\n    global Fd_slider\n    \n    Kp_slider = w.FloatLogSlider(value=0.5, base=10, min=-1, max=4, description='Kp:', continuous_update=False,\n                                 layout=w.Layout(width='auto', flex='5 5 auto'))\n    \n    if type_select in (1, 4):\n        Ti_slider = w.FloatLogSlider(value=0.0035, base=10, min=-4, max=1, description='Ti:', continuous_update=False,\n                                     layout=w.Layout(width='auto', flex='5 5 auto'))\n    else:\n        Ti_slider = w.FloatLogSlider(value=0.0035, base=10, min=-4, max=1, description='Ti:', continuous_update=False,\n                                     layout=w.Layout(width='auto', flex='5 5 auto'), disabled=True)\n        \n    if type_select in (2, 3, 4):\n        Td_slider = w.FloatLogSlider(value=1, base=10, min=-4, max=1, description='Td:', continuous_update=False,\n                                     layout=w.Layout(width='auto', flex='5 5 auto'))\n    else:\n        Td_slider = w.FloatLogSlider(value=1, base=10, min=-4, max=1, description='Td:', continuous_update=False,\n                                     layout=w.Layout(width='auto', flex='5 5 auto'), disabled=True)\n        \n    if type_select in (3, 4):\n        Fd_slider = w.FloatLogSlider(value=1, base=10, min=0, max=3, description='Fd:', continuous_update=False,\n                                     layout=w.Layout(width='auto', flex='5 5 auto'))\n    else:\n        Fd_slider = w.FloatLogSlider(value=1, base=10, min=0, max=3, description='Fd:', continuous_update=False,\n                                     layout=w.Layout(width='auto', flex='5 5 auto'), disabled=True)    \n\n    input_data = w.interactive_output(pid_control, {'Kp': Kp_slider, 'Ti': Ti_slider, 'Td': Td_slider,\n                                      'Fd': Fd_slider, 'type_select':typeSelect, 'T1':T1_slider, 'dts':dts_slider})\n\n    display(w.HBox([Kp_slider, Ti_slider, Td_slider, Fd_slider]), input_data)\n    \nw.interactive_output(draw_controllers, {'type_select':typeSelect})\n\n\n\n\n\n\n\n\n\n\nYou can test the controlled system’s signal following capabilities using the simulated scope. Readjust your controller so that it can follow a sine wave acceptably!\n\n# Simulation data\n\nanim_fig = plt.figure()\nanim_fig.set_size_inches((9.8, 4))\nanim_fig.set_tight_layout(True)\n\nanim_ax1 = anim_fig.add_subplot(111)\n\nframe_count=1000\nscope_rounds=4\n\nl1 = anim_ax1.plot([], [], lw=1, color='blue')\nl2 = anim_ax1.plot([], [], lw=2, color='red')\n\nline1 = l1[0]\nline2 = l2[0]\n\nanim_ax1.legend(l1+l2, ['Reference', 'Output'], loc=1)\n\nanim_ax1.set_title('Scope', fontsize=12)\nanim_ax1.set_xlabel(r'$t\\/$[s]', labelpad=0, fontsize=10)\nanim_ax1.set_ylabel(r'$y\\/$[/]', labelpad=0, fontsize=10)\nanim_ax1.tick_params(axis='both', which='both', pad=0, labelsize=8)\n\nanim_ax1.grid(which='both', axis='both', color='lightgray')\n\nT_plot = []\nX_plot = []\nR_plot = []\n\n#Simulation function\n\ndef simulation(Kp, Ti, Td, Fd, type_select, T1, dts, T, X, Xf, Xa):\n    \n    W_syscont = c.tf([1], [T1, 1])\n    W_sys = c.sample_system(W_syscont, dts, method='zoh')\n    # Zero Order Hold conversion to include continuous system in discrete model\n    \n    if type_select in (1, 4):\n        Ti0 = 1\n    else:\n        Ti0 = 0\n        \n    if type_select in (2, 3, 4):\n        Td0 = 1\n    else :\n        Td0 = 0\n        \n    if type_select in (3, 4):\n        Fd0 = 1\n    else:\n        Fd0 = 0\n    \n    if type_select in (0, 2):\n        convmet = \"matched\"\n    else:\n        convmet = \"zoh\"\n    \n    # Controller\n    \n    P = Kp             # Proportional term\n    I = Kp / Ti        # Integral term\n    D = Kp * Td        # Derivative term\n    Td_f = Td * Fd     # Derivative term filter\n    \n    W_PID_cont = c.parallel(c.tf([P], [1]),\n                            c.tf([I * Ti0], [1 * Ti0, 1 * (not Ti0)]),\n                            c.tf([D * Td0, 0], [Td_f * Td0 * Fd0, 1]))  # PID controller in time constant format    \n    \n    # Model\n    \n    W_PID = c.sample_system(W_PID_cont, dts, method=convmet) # PID discretization\n    W_open = c.series(W_PID, W_sys)      # Open loop\n    W_closed = c.feedback(W_open, 1, -1)    # Closed loop with negative feedback\n    \n    # Reference and disturbance signals\n\n    T_sim = np.arange(0, T, dts, dtype=np.float64)\n    \n    if X == 0:   # Sine wave reference\n        X_sim = np.sin(2 * np.pi * Xf * T_sim) * Xa\n    elif X == 1:   # Square wave reference\n        X_sim = np.sign(np.sin(2 * np.pi * Xf * T_sim)) * Xa\n    \n    # System response\n        \n    Tx, youtx, xoutx = c.forced_response(W_closed, T_sim, X_sim)\n    \n    # Display\n    \n    XR_max = max(np.amax(np.absolute(np.concatenate((X_sim, youtx)))), Xa)\n    if not np.isnan(XR_max):\n        anim_ax1.set_ylim((-1.2 * XR_max, 1.2 * XR_max))\n    \n    global T_plot, X_plot, R_plot\n    \n    T_plot = np.linspace(0, T, frame_count*(scope_rounds+1), dtype=np.float32)\n    X_plot = np.interp(T_plot, T_sim, X_sim)\n    R_plot = np.interp(T_plot, T_sim, youtx)\n        \ndef anim_init():\n    line1.set_data([], [])\n    line2.set_data([], [])\n    anim_ax1.set_xlim((0, T_plot[frame_count-1]))\n    \n    return (line1, line2, anim_ax1,)\n\ndef animate(i):\n    line1.set_data(T_plot[scope_rounds*i:scope_rounds*i+frame_count-1], X_plot[scope_rounds*i:scope_rounds*i+frame_count-1])\n    line2.set_data(T_plot[scope_rounds*i:scope_rounds*i+frame_count-1], R_plot[scope_rounds*i:scope_rounds*i+frame_count-1])\n    anim_ax1.set_xlim((T_plot[i*scope_rounds], T_plot[i*scope_rounds+frame_count-1]))\n    \n    return (line1, line2, anim_ax1,)\n\nanim = animation.FuncAnimation(anim_fig, animate, init_func=anim_init,\n                               frames=frame_count, interval=10, blit=True,\n                               repeat=True)\n\n# Controllers\n\nT_slider = w.FloatLogSlider(value=10, base=10, min=-0.7, max=1, step=0.01,\n                            description='Duration [s]:', continuous_update=False,\n                            orientation='vertical', layout=w.Layout(width='auto', height='auto', flex='1 1 auto'))\n       \nX_type = w.Dropdown(options=[('Sine', 0), ('Square', 1)], value=1,\n                    description='Reference: ', continuous_update=False, layout=w.Layout(width='auto', flex='3 3 auto'))    \nXf_slider = w.FloatLogSlider(value=0.5, base=10, min=-2, max=2, step=0.01,\n                             description='Frequency [Hz]:', continuous_update=False,\n                             orientation='vertical', layout=w.Layout(width='auto', height='auto', flex='1 1 auto'))\nXa_slider = w.FloatLogSlider(value=1, base=10, min=-2, max=2, step=0.01,\n                             description='Amplitude [/]:', continuous_update=False,\n                             orientation='vertical', layout=w.Layout(width='auto', height='auto', flex='1 1 auto'))    \n\ninput_data = w.interactive_output(simulation, {'Kp': Kp_slider, 'Ti': Ti_slider, 'Td': Td_slider,'Fd': Fd_slider,\n                                               'type_select': typeSelect, 'T1': T1_slider, 'dts':dts_slider,\n                                               'T': T_slider,\n                                               'X': X_type, 'Xf': Xf_slider, 'Xa': Xa_slider})\n\ndisplay(w.HBox([w.HBox([T_slider], layout=w.Layout(width='25%')),\n                w.Box([], layout=w.Layout(width='5%')),\n                w.VBox([X_type, w.HBox([Xf_slider, Xa_slider])], layout=w.Layout(width='30%')),\n                w.Box([], layout=w.Layout(width='5%'))],\n                layout=w.Layout(width='100%', justify_content='center')), input_data)\n\n\n\n\n\n\n\n\n\n\n\n\n\nThe duration parameter controls the simulated timeframe and does not affect the runtime of the animation."
  },
  {
    "objectID": "ICCT_en/examples/03/FD-12_PID_Control_of_Second-Order_Overdamped_Systems.html",
    "href": "ICCT_en/examples/03/FD-12_PID_Control_of_Second-Order_Overdamped_Systems.html",
    "title": "PID control of an Overdamped Second-Order system",
    "section": "",
    "text": "%matplotlib notebook\nimport control as c\nimport ipywidgets as w\nimport numpy as np\n\nfrom IPython.display import display, HTML\nimport matplotlib.pyplot as plt\nimport matplotlib.animation as animation\n\ndisplay(HTML('&lt;script&gt; $(document).ready(function() { $(\"div.input\").hide(); }); &lt;/script&gt;'))\n\n\n\n\nIn the following example, we will be using a PID controller (or one of its subtypes) to control an overdamped second-order LTI (linear time-invariant) system.\nThe two poles of the system are distinct and real. Therefore, there are two breaking points in the magnitude transfer of the system. The two poles can be defined simply by their real values.  \\[G(s)=\\frac{1}{s^2+(P_1+P_2)s+P_1P_2}\\]  Various examples using analog circuit designs: \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nStacked filter design\n\n\n\n\nRLC design \\(\\left(\\frac{R}{2}\\sqrt{\\frac{C}{L}}&gt;1\\right)\\)\n\n\n\n\n\n The transfer function of the RLC implementation:   \\[G(s) = \\frac{V_{out}(s)}{V_{in}(s)} = K\\frac{1}{s^2+2\\zeta\\omega_0 s+\\omega_0^2}=\\frac{1}{LC}\\frac{1}{s^2+\\frac{R}{L}+\\frac{1}{LC}} \\qquad \\omega_0=\\frac{1}{LC} \\qquad \\zeta=\\frac{R}{2}\\sqrt{\\frac{C}{L}}&gt;1\\] \nChoose poles for the system!\n\n# Figure definition\n\nfig1, ((f1_ax1), (f1_ax2)) = plt.subplots(2, 1)\nfig1.set_size_inches((9.8, 5))\nfig1.set_tight_layout(True)\n\nf1_line1, = f1_ax1.plot([], [])\nf1_line2, = f1_ax2.plot([], [])  \n\nf1_ax1.grid(which='both', axis='both', color='lightgray')\nf1_ax2.grid(which='both', axis='both', color='lightgray')\n\nf1_ax1.autoscale(enable=True, axis='both', tight=True)\nf1_ax2.autoscale(enable=True, axis='both', tight=True)\n\nf1_ax1.set_title('Bode magnitude plot', fontsize=11)\nf1_ax1.set_xscale('log')\nf1_ax1.set_xlabel(r'$f\\/$[Hz]', labelpad=0, fontsize=10)\nf1_ax1.set_ylabel(r'$A\\/$[dB]', labelpad=0, fontsize=10)\nf1_ax1.tick_params(axis='both', which='both', pad=0, labelsize=8)\n\nf1_ax2.set_title('Bode phase plot', fontsize=11)\nf1_ax2.set_xscale('log')\nf1_ax2.set_xlabel(r'$f\\/$[Hz]', labelpad=0, fontsize=10)\nf1_ax2.set_ylabel(r'$\\phi\\/$[°]', labelpad=0, fontsize=10)\nf1_ax2.tick_params(axis='both', which='both', pad=0, labelsize=8)   \n\n\n# System model\n\ndef system_model(pole1, pole2):\n\n    W_sys = c.tf([1], [1, pole1+pole2, pole1*pole2])\n\n    print('System transfer function:')\n    print(W_sys)\n\n    # System analysis\n\n    poles = c.pole(W_sys)     # Poles\n\n    print('System poles:\\n')\n    print(poles)\n    \n    global f1_line1, f1_line2\n    \n    f1_ax1.lines.remove(f1_line1)\n    f1_ax2.lines.remove(f1_line2)\n\n    mag, phase, omega = c.bode_plot(W_sys, Plot=False)   # Bode-plot\n\n    f1_line1, = f1_ax1.plot(omega/2/np.pi, 20*np.log10(mag), lw=1, color='blue')\n    f1_line2, = f1_ax2.plot(omega/2/np.pi, phase*180/np.pi, lw=1, color='blue')   \n\n    f1_ax1.relim()\n    f1_ax2.relim()\n    f1_ax1.autoscale_view()\n    f1_ax2.autoscale_view()\n    \n# GUI widgets\n    \np1_slider = w.FloatLogSlider(value=0.1, base=10, min=-4, max=1, description='P1.Re (negative) :', continuous_update=False,\n                             layout=w.Layout(width='75%'), style={'description_width':'50%'})\np2_slider = w.FloatLogSlider(value=0.1, base=10, min=-4, max=1, description='P2.Re (negative) :', continuous_update=False,\n                             layout=w.Layout(width='75%'), style={'description_width':'50%'})\n\ninput_data = w.interactive_output(system_model, {'pole1':p1_slider, 'pole2':p2_slider})\n\ndisplay(w.HBox([p1_slider, p2_slider]), input_data)\n\n\n\n\n\n\n\n\n\n\n\n\n\nAfter observing the system characteristics, select a controller type!\n\n#Controller type select\n\ntypeSelect = w.ToggleButtons(\n    options=[('P', 0), ('PI', 1), ('PD', 2), ('PID', 3), ('PID Realistic', 4)],\n    description='Controller type: ', style={'description_width':'15%'})\n\ndisplay(typeSelect)\n\n\n\n\nTune the selected controller so that rising/settling time, overshoot, or remaining error is minimized! It is not possible to get the best results for each parameter in a single setup. Create multiple solutions, one for each type!\n\n# PID control\n\n# Figure definition\nfig2, ((f2_ax1, f2_ax2, f2_ax3), (f2_ax4, f2_ax5, f2_ax6)) = plt.subplots(2, 3)\nfig2.set_size_inches((9.8, 5))\nfig2.set_tight_layout(True)\n\nf2_line1, = f2_ax1.plot([], [])\nf2_line2, = f2_ax2.plot([], []) \nf2_line3, = f2_ax3.plot([], [])\nf2_line4, = f2_ax4.plot([], [])  \nf2_line5, = f2_ax5.plot([], [])\nf2_line6, = f2_ax6.plot([], [])\n\nf2_ax1.grid(which='both', axis='both', color='lightgray')\nf2_ax2.grid(which='both', axis='both', color='lightgray')\nf2_ax3.grid(which='both', axis='both', color='lightgray')\nf2_ax4.grid(which='both', axis='both', color='lightgray')\nf2_ax5.grid(which='both', axis='both', color='lightgray')\nf2_ax6.grid(which='both', axis='both', color='lightgray')\n\nf2_ax1.autoscale(enable=True, axis='both', tight=True)\nf2_ax2.autoscale(enable=True, axis='both', tight=True)\nf2_ax3.autoscale(enable=True, axis='both', tight=True)\nf2_ax4.autoscale(enable=True, axis='both', tight=True)\nf2_ax5.autoscale(enable=True, axis='both', tight=True)\nf2_ax6.autoscale(enable=True, axis='both', tight=True)\n\nf2_ax1.set_title('Closed loop step response', fontsize=9)\nf2_ax1.set_xlabel(r'$t\\/$[s]', labelpad=0, fontsize=8)\nf2_ax1.set_ylabel(r'$x\\/$[m]', labelpad=0, fontsize=8)\nf2_ax1.tick_params(axis='both', which='both', pad=0, labelsize=6)\n\nf2_ax2.set_title('Nyquist diagram', fontsize=9)\nf2_ax2.set_xlabel(r'Re', labelpad=0, fontsize=8)\nf2_ax2.set_ylabel(r'Im', labelpad=0, fontsize=8)\nf2_ax2.tick_params(axis='both', which='both', pad=0, labelsize=6)\n\nf2_ax3.set_title('Bode magnitude plot', fontsize=9)\nf2_ax3.set_xscale('log')\nf2_ax3.set_xlabel(r'$f\\/$[Hz]', labelpad=0, fontsize=8)\nf2_ax3.set_ylabel(r'$A\\/$[dB]', labelpad=0, fontsize=8)\nf2_ax3.tick_params(axis='both', which='both', pad=0, labelsize=6)\n\nf2_ax4.set_title('Closed loop impulse response', fontsize=9)\nf2_ax4.set_xlabel(r'$t\\/$[s]', labelpad=0, fontsize=8)\nf2_ax4.set_ylabel(r'$x\\/$[m]', labelpad=0, fontsize=8)\nf2_ax4.tick_params(axis='both', which='both', pad=0, labelsize=6)\n\nf2_ax5.set_title('Open loop step response', fontsize=9)\nf2_ax5.set_xlabel(r'$t\\/$[s]', labelpad=0, fontsize=8)\nf2_ax5.set_ylabel(r'$x\\/$[m]', labelpad=0, fontsize=8)\nf2_ax5.tick_params(axis='both', which='both', pad=0, labelsize=6)\n\nf2_ax6.set_title('Bode phase plot', fontsize=9)\nf2_ax6.set_xscale('log')\nf2_ax6.set_xlabel(r'$f\\/$[Hz]', labelpad=0, fontsize=8)\nf2_ax6.set_ylabel(r'$\\phi\\/$[°]', labelpad=0, fontsize=8)\nf2_ax6.tick_params(axis='both', which='both', pad=0, labelsize=6)\n\ndef pid_control(Kp, Ti, Td, Fd, type_select, pole1, pole2):\n    \n    W_sys = c.tf([1], [1, pole1+pole2, pole1*pole2])\n    \n    if type_select in (1, 3, 4):\n        Ti0 = 1\n    else:\n        Ti0 = 0\n        \n    if type_select in (2, 3, 4):\n        Td0 = 1\n    else :\n        Td0 = 0\n        \n    if type_select == 4:\n        Fd0 = 1\n    else:\n        Fd0 = 0\n    \n    # PID Controller\n    \n    P = Kp             # Proportional term\n    I = Kp / Ti        # Integral term\n    D = Kp * Td        # Derivative term\n    Td_f = Td / Fd     # Derivative term filter\n    \n    W_PID = c.parallel(c.tf([P], [1]),\n                       c.tf([I * Ti0], [1 * Ti0, 1 * (not Ti0)]),\n                       c.tf([D * Td0, 0], [Td_f * Td0 * Fd0, 1]))  # PID controller in time constant format\n    \n    W_open = c.series(W_PID, W_sys)         # Open loop\n    W_closed = c.feedback(W_open, 1, -1)    # Closed loop with negative feedback\n                        \n    # Display\n                        \n    global f2_line1, f2_line2, f2_line3, f2_line4, f2_line5, f2_line6\n    \n    f2_ax1.lines.remove(f2_line1)\n    f2_ax2.lines.remove(f2_line2)\n    f2_ax3.lines.remove(f2_line3)\n    f2_ax4.lines.remove(f2_line4)\n    f2_ax5.lines.remove(f2_line5)\n    f2_ax6.lines.remove(f2_line6)\n    \n    tout, yout = c.step_response(W_closed)\n    f2_line1, = f2_ax1.plot(tout, yout, lw=1, color='blue') \n\n    _, _, ob = c.nyquist_plot(W_open, Plot=False)   # Small resolution plot to determine bounds        \n    real, imag, freq = c.nyquist_plot(W_open, omega=np.logspace(np.log10(ob[0]), np.log10(ob[-1]), 1000), Plot=False)\n    f2_line2, = f2_ax2.plot(real, imag, lw=1, color='blue')\n    \n    mag, phase, omega = c.bode_plot(W_open, Plot=False)\n    f2_line3, = f2_ax3.plot(omega/2/np.pi, 20*np.log10(mag), lw=1, color='blue')\n    f2_line6, = f2_ax6.plot(omega/2/np.pi, phase*180/np.pi, lw=1, color='blue')\n\n    tout, yout = c.impulse_response(W_closed)\n    f2_line4, = f2_ax4.plot(tout, yout, lw=1, color='blue')   \n    \n    tout, yout = c.step_response(W_open)\n    f2_line5, = f2_ax5.plot(tout, yout, lw=1, color='blue') \n    \n    f2_ax1.relim()\n    f2_ax2.relim()\n    f2_ax3.relim()\n    f2_ax4.relim()\n    f2_ax5.relim()\n    f2_ax6.relim()\n    f2_ax1.autoscale_view()\n    f2_ax2.autoscale_view()\n    f2_ax3.autoscale_view()\n    f2_ax4.autoscale_view()\n    f2_ax5.autoscale_view()\n    f2_ax6.autoscale_view()\n    \n# GUI widgets\n\ndef draw_controllers(type_select):\n    \n    global Kp_slider\n    global Ti_slider\n    global Td_slider\n    global Fd_slider\n    \n    Kp_slider = w.FloatLogSlider(value=0.5, base=10, min=-1, max=4, description='Kp:', continuous_update=False,\n                                 layout=w.Layout(width='auto', flex='5 5 auto'))\n    \n    if type_select in (1, 3, 4):\n        Ti_slider = w.FloatLogSlider(value=0.0035, base=10, min=-4, max=1, description='Ti:', continuous_update=False,\n                                     layout=w.Layout(width='auto', flex='5 5 auto'))\n    else:\n        Ti_slider = w.FloatLogSlider(value=0.0035, base=10, min=-4, max=1, description='Ti:', continuous_update=False,\n                                     layout=w.Layout(width='auto', flex='5 5 auto'), disabled=True)\n        \n    if type_select in (2, 3, 4):\n        Td_slider = w.FloatLogSlider(value=1, base=10, min=-4, max=1, description='Td:', continuous_update=False,\n                                     layout=w.Layout(width='auto', flex='5 5 auto'))\n    else:\n        Td_slider = w.FloatLogSlider(value=1, base=10, min=-4, max=1, description='Td:', continuous_update=False,\n                                     layout=w.Layout(width='auto', flex='5 5 auto'), disabled=True)\n    \n    if type_select == 4:\n        Fd_slider = w.FloatLogSlider(value=1, base=10, min=0, max=3, description='Fd:', continuous_update=False,\n                                     layout=w.Layout(width='auto', flex='5 5 auto'))\n    else:\n        Fd_slider = w.FloatLogSlider(value=1, base=10, min=0, max=3, description='Fd:', continuous_update=False,\n                                     layout=w.Layout(width='auto', flex='5 5 auto'), disabled=True)\n\n\n    input_data = w.interactive_output(pid_control, {'Kp': Kp_slider, 'Ti': Ti_slider, 'Td': Td_slider,\n                                      'Fd': Fd_slider, 'type_select':typeSelect, 'pole1':p1_slider, 'pole2':p2_slider})\n\n    display(w.HBox([Kp_slider, Ti_slider, Td_slider, Fd_slider]), input_data)\n    \nw.interactive_output(draw_controllers, {'type_select':typeSelect})\n\n\n\n\n\n\n\n\n\n\nYou can test the controlled system’s signal following capabilities using the simulated scope. Readjust your controller so that it can follow a sine wave acceptably!  (The animations are scaled to fit the frame through the whole simulation. Because of this, unstable solutions might not seem to move until the very last second.)\n\n# Simulation data\n\nanim_fig = plt.figure()\nanim_fig.set_size_inches((9.8, 4))\nanim_fig.set_tight_layout(True)\n\nanim_ax1 = anim_fig.add_subplot(111)\n\nframe_count=1000\nscope_rounds=4\n\nl1 = anim_ax1.plot([], [], lw=1, color='blue')\nl2 = anim_ax1.plot([], [], lw=2, color='red')\n\nline1 = l1[0]\nline2 = l2[0]\n\nanim_ax1.legend(l1+l2, ['Reference', 'Output'], loc=1)\n\nanim_ax1.set_title('Scope', fontsize=12)\nanim_ax1.set_xlabel(r'$t\\/$[s]', labelpad=0, fontsize=10)\nanim_ax1.set_ylabel(r'$y\\/$[/]', labelpad=0, fontsize=10)\nanim_ax1.tick_params(axis='both', which='both', pad=0, labelsize=8)\n\nanim_ax1.grid(which='both', axis='both', color='lightgray')\n\nT_plot = []\nX_plot = []\nR_plot = []\n\n#Simulation function\n\ndef simulation(Kp, Ti, Td, Fd, type_select, pole1, pole2, T, dt, X, Xf, Xa):\n    \n    W_sys = c.tf([1], [1, pole1+pole2, pole1*pole2])\n    \n    if type_select in (1, 3, 4):\n        Ti0 = 1\n    else:\n        Ti0 = 0\n        \n    if type_select in (2, 3, 4):\n        Td0 = 1\n    else :\n        Td0 = 0\n        \n    if type_select == 4:\n        Fd0 = 1\n    else:\n        Fd0 = 0\n    \n    # Controller\n    P = Kp            # Proportional term\n    I = Kp / Ti       # Integral term\n    D = Kp * Td       # Derivative term\n    Td_f = Td * Fd    # Derivative term filter\n    \n    W_PID = c.parallel(c.tf([P], [1]),\n                       c.tf([I * Ti0], [1 * Ti0, 1 * (not Ti0)]),\n                       c.tf([D * Td0, 0], [Td_f * Td0 * Fd0, 1]))    # PID controller\n    \n    # Model\n    W_open = c.series(W_PID, W_sys)         # Open loop\n    W_closed = c.feedback(W_open, 1, -1)    # Closed loop with negative feedback\n    \n    # Reference and disturbance signals\n\n    T_sim = np.arange(0, T, dt, dtype=np.float64)\n    \n    if X == 0:   # Sine wave reference\n        X_sim = np.sin(2 * np.pi * Xf * T_sim) * Xa\n    elif X == 1:   # Square wave reference\n        X_sim = np.sign(np.sin(2 * np.pi * Xf * T_sim)) * Xa\n    \n    # System response\n        \n    Tx, youtx, xoutx = c.forced_response(W_closed, T_sim, X_sim)\n    R_sim = youtx\n    \n    # Display\n    \n    XR_max = max(np.amax(np.absolute(np.concatenate((X_sim, R_sim)))), Xa)\n    \n    anim_ax1.set_ylim((-1.2 * XR_max, 1.2 * XR_max))\n    \n    global T_plot, X_plot, R_plot\n    \n    T_plot = np.linspace(0, T, frame_count*(scope_rounds+1), dtype=np.float32)\n    X_plot = np.interp(T_plot, T_sim, X_sim)\n    R_plot = np.interp(T_plot, T_sim, R_sim)\n        \ndef anim_init():\n    line1.set_data([], [])\n    line2.set_data([], [])\n    anim_ax1.set_xlim((0, T_plot[frame_count-1]))\n    \n    return (line1, line2, anim_ax1,)\n\ndef animate(i):\n    line1.set_data(T_plot[scope_rounds*i:scope_rounds*i+frame_count-1], X_plot[scope_rounds*i:scope_rounds*i+frame_count-1])\n    line2.set_data(T_plot[scope_rounds*i:scope_rounds*i+frame_count-1], R_plot[scope_rounds*i:scope_rounds*i+frame_count-1])\n    anim_ax1.set_xlim((T_plot[i*scope_rounds], T_plot[i*scope_rounds+frame_count-1]))\n    \n    return (line1, line2, anim_ax1,)\n\nanim = animation.FuncAnimation(anim_fig, animate, init_func=anim_init,\n                               frames=frame_count, interval=10, blit=True,\n                               repeat=True)\n\n# Controllers\n\nT_slider = w.FloatLogSlider(value=10, base=10, min=-0.7, max=1, step=0.01,\n                            description='Duration [s]:', continuous_update=False,\n                            orientation='vertical', layout=w.Layout(width='auto', height='auto', flex='1 1 auto'))\n\ndt_slider = w.FloatLogSlider(value=0.1, base=10, min=-3, max=-1, step=0.01,\n                             description='Timestep [s]:', continuous_update=False,\n                             orientation='vertical', layout=w.Layout(width='auto', height='auto', flex='1 1 auto'))\n       \nX_type = w.Dropdown(options=[('Sine', 0), ('Square', 1)], value=1,\n                    description='Reference: ', continuous_update=False, layout=w.Layout(width='auto', flex='3 3 auto'))    \nXf_slider = w.FloatLogSlider(value=0.5, base=10, min=-2, max=2, step=0.01,\n                             description='Frequency [Hz]:', continuous_update=False,\n                             orientation='vertical', layout=w.Layout(width='auto', height='auto', flex='1 1 auto'))\nXa_slider = w.FloatLogSlider(value=1, base=10, min=-2, max=2, step=0.01,\n                             description='Amplitude [/]:', continuous_update=False,\n                             orientation='vertical', layout=w.Layout(width='auto', height='auto', flex='1 1 auto'))    \n\ninput_data = w.interactive_output(simulation, {'Kp': Kp_slider, 'Ti': Ti_slider, 'Td': Td_slider,'Fd': Fd_slider,\n                                               'type_select': typeSelect, 'pole1': p1_slider, 'pole2':p2_slider,\n                                               'T': T_slider, 'dt': dt_slider,\n                                               'X': X_type, 'Xf': Xf_slider, 'Xa': Xa_slider})\n\ndisplay(w.HBox([w.HBox([T_slider, dt_slider], layout=w.Layout(width='25%')),\n                w.Box([], layout=w.Layout(width='5%')),\n                w.VBox([X_type, w.HBox([Xf_slider, Xa_slider])], layout=w.Layout(width='30%')),\n                w.Box([], layout=w.Layout(width='5%'))],\n                layout=w.Layout(width='100%', justify_content='center')), input_data)\n\n\n\n\n\n\n\n\n\n\n\n\n\nThe duration parameter controls the simulated timeframe and does not affect the runtime of the animation. In contrast, the timestep controls the model sampling and can refine the results in exchange for higher computational resources."
  },
  {
    "objectID": "ICCT_en/examples/03/FD-10_PID_Control_of_Second-Order_Undamped_and_Critically_Damped_Systems.html",
    "href": "ICCT_en/examples/03/FD-10_PID_Control_of_Second-Order_Undamped_and_Critically_Damped_Systems.html",
    "title": "PID control of an Undamped or Critically Damped Second-Order system",
    "section": "",
    "text": "%matplotlib notebook\nimport control as c\nimport ipywidgets as w\nimport numpy as np\n\nfrom IPython.display import display, HTML\nimport matplotlib.pyplot as plt\nimport matplotlib.animation as animation\n\ndisplay(HTML('&lt;script&gt; $(document).ready(function() { $(\"div.input\").hide(); }); &lt;/script&gt;'))\n\n\n\n\nIn the following example, we will be using a PID controller (or one of its subtypes) to control a second-order LTI (linear time-invariant system) that is either undamped or critically damped.\nBoth conditions share the property that either the real or the imaginary component of their complex pole pair is zero. We define their models using the non-zero component.  \\[G_{un}(s)=\\frac{1}{s^2+A^2}\\qquad\\qquad G_{crit}(s)=\\frac{1}{s^2+2As+A^2}\\]  Typical examples using serial RLC circuits: \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nUndamped system\n\n\n\n\nCritically damped system \\(\\left(R=2\\sqrt{\\frac{L}{C}}\\right)\\)\n\n\n\n\n\n Where the transfer functions can be expressed as:  \\[G_{u}(s)=\\frac{1}{LCs^2+1} \\qquad\\qquad G_{c}(s)=K\\frac{1}{s^2+2\\omega_0 s+\\omega_0^2}=\\frac{1}{LC}\\frac{1}{s^2+\\frac{R}{L}+\\frac{1}{LC}} \\qquad \\omega_0=\\frac{R}{2L}=\\frac{1}{\\sqrt{LC}}\\]  Choose a damping type and a pole for the system!\n\n# Damping selection\n\ndampSelect = w.ToggleButtons(\n    options=[('Undamped', 0), ('Critically Damped', 1),],\n    description='Damping type: ', style={'description_width':'15%'})\n\ndisplay(dampSelect)\n\n\n\n\n\n# Figure definition\n\nfig1, ((f1_ax1), (f1_ax2)) = plt.subplots(2, 1)\nfig1.set_size_inches((9.8, 5))\nfig1.set_tight_layout(True)\n\nf1_line1, = f1_ax1.plot([], [])\nf1_line2, = f1_ax2.plot([], [])  \n\nf1_ax1.grid(which='both', axis='both', color='lightgray')\nf1_ax2.grid(which='both', axis='both', color='lightgray')\n\nf1_ax1.autoscale(enable=True, axis='both', tight=True)\nf1_ax2.autoscale(enable=True, axis='both', tight=True)\n\nf1_ax1.set_title('Bode magnitude plot', fontsize=11)\nf1_ax1.set_xscale('log')\nf1_ax1.set_xlabel(r'$f\\/$[Hz]', labelpad=0, fontsize=10)\nf1_ax1.set_ylabel(r'$A\\/$[dB]', labelpad=0, fontsize=10)\nf1_ax1.tick_params(axis='both', which='both', pad=0, labelsize=8)\n\nf1_ax2.set_title('Bode phase plot', fontsize=11)\nf1_ax2.set_xscale('log')\nf1_ax2.set_xlabel(r'$f\\/$[Hz]', labelpad=0, fontsize=10)\nf1_ax2.set_ylabel(r'$\\phi\\/$[°]', labelpad=0, fontsize=10)\nf1_ax2.tick_params(axis='both', which='both', pad=0, labelsize=8)   \n\n\n# System model\n\ndef system_model(pole, damp_select):\n\n    if damp_select == 1: # Critically damped\n        W_sys = c.tf([1], [1, 2*pole, pole*pole])\n    else: # Undamped\n        W_sys = c.tf([1], [1, 0, pole*pole])\n\n    print('System transfer function:')\n    print(W_sys)\n\n    # System analysis\n\n    poles = c.pole(W_sys)     # Poles\n\n    print('System poles:\\n')\n    print(poles)\n    \n    global f1_line1, f1_line2\n    \n    f1_ax1.lines.remove(f1_line1)\n    f1_ax2.lines.remove(f1_line2)\n\n    mag, phase, omega = c.bode_plot(W_sys, Plot=False)   # Bode-plot\n\n    f1_line1, = f1_ax1.plot(omega/2/np.pi, 20*np.log10(mag), lw=1, color='blue')\n    f1_line2, = f1_ax2.plot(omega/2/np.pi, phase*180/np.pi, lw=1, color='blue')   \n\n    f1_ax1.relim()\n    f1_ax2.relim()\n    f1_ax1.autoscale_view()\n    f1_ax2.autoscale_view()\n    \n# GUI widgets\n\ndef draw_slider(damp_select):\n    \n    global pole_slider\n    \n    if damp_select == 1: # Critically damped\n        pole_slider = w.FloatLogSlider(value=0.1, base=10, min=-4, max=1, description='Pole.Re (negative):',\n                                       continuous_update=False, layout=w.Layout(width='75%'),\n                                       style={'description_width':'50%'})\n    else: # Undamped\n        pole_slider = w.FloatLogSlider(value=0.01, base=10, min=-4, max=1, description='Pole.Im:', continuous_update=False,\n                                       layout=w.Layout(width='75%'), style={'description_width':'50%'})\n\n    input_data = w.interactive_output(system_model, {'pole':pole_slider, 'damp_select':dampSelect})\n\n    display(w.HBox([pole_slider]), input_data)\n    \nw.interactive_output(draw_slider, {'damp_select':dampSelect})\n\n\n\n\n\n\n\n\n\n\nAfter observing the system’s characteristics, select a controller type!\n\n#Controller type select\n\ntypeSelect = w.ToggleButtons(\n    options=[('P', 0), ('PI', 1), ('PD', 2), ('PID', 3), ('PID Realistic', 4)],\n    description='Controller type: ', style={'description_width':'15%'})\n\ndisplay(typeSelect)\n\n\n\n\nTune the selected controller so that rising/settling time, overshoot, or remaining error is minimized! It is not possible to get the best results for each parameter in a single setup. Create multiple solutions, one for each type!\n\n# PID control\n\n# Figure definition\nfig2, ((f2_ax1, f2_ax2, f2_ax3), (f2_ax4, f2_ax5, f2_ax6)) = plt.subplots(2, 3)\nfig2.set_size_inches((9.8, 5))\nfig2.set_tight_layout(True)\n\nf2_line1, = f2_ax1.plot([], [])\nf2_line2, = f2_ax2.plot([], []) \nf2_line3, = f2_ax3.plot([], [])\nf2_line4, = f2_ax4.plot([], [])  \nf2_line5, = f2_ax5.plot([], [])\nf2_line6, = f2_ax6.plot([], [])\n\nf2_ax1.grid(which='both', axis='both', color='lightgray')\nf2_ax2.grid(which='both', axis='both', color='lightgray')\nf2_ax3.grid(which='both', axis='both', color='lightgray')\nf2_ax4.grid(which='both', axis='both', color='lightgray')\nf2_ax5.grid(which='both', axis='both', color='lightgray')\nf2_ax6.grid(which='both', axis='both', color='lightgray')\n\nf2_ax1.autoscale(enable=True, axis='both', tight=True)\nf2_ax2.autoscale(enable=True, axis='both', tight=True)\nf2_ax3.autoscale(enable=True, axis='both', tight=True)\nf2_ax4.autoscale(enable=True, axis='both', tight=True)\nf2_ax5.autoscale(enable=True, axis='both', tight=True)\nf2_ax6.autoscale(enable=True, axis='both', tight=True)\n\nf2_ax1.set_title('Closed loop step response', fontsize=9)\nf2_ax1.set_xlabel(r'$t\\/$[s]', labelpad=0, fontsize=8)\nf2_ax1.set_ylabel(r'$x\\/$[m]', labelpad=0, fontsize=8)\nf2_ax1.tick_params(axis='both', which='both', pad=0, labelsize=6)\n\nf2_ax2.set_title('Nyquist diagram', fontsize=9)\nf2_ax2.set_xlabel(r'Re', labelpad=0, fontsize=8)\nf2_ax2.set_ylabel(r'Im', labelpad=0, fontsize=8)\nf2_ax2.tick_params(axis='both', which='both', pad=0, labelsize=6)\n\nf2_ax3.set_title('Bode magnitude plot', fontsize=9)\nf2_ax3.set_xscale('log')\nf2_ax3.set_xlabel(r'$f\\/$[Hz]', labelpad=0, fontsize=8)\nf2_ax3.set_ylabel(r'$A\\/$[dB]', labelpad=0, fontsize=8)\nf2_ax3.tick_params(axis='both', which='both', pad=0, labelsize=6)\n\nf2_ax4.set_title('Closed loop impulse response', fontsize=9)\nf2_ax4.set_xlabel(r'$t\\/$[s]', labelpad=0, fontsize=8)\nf2_ax4.set_ylabel(r'$x\\/$[m]', labelpad=0, fontsize=8)\nf2_ax4.tick_params(axis='both', which='both', pad=0, labelsize=6)\n\nf2_ax5.set_title('Open loop step response', fontsize=9)\nf2_ax5.set_xlabel(r'$t\\/$[s]', labelpad=0, fontsize=8)\nf2_ax5.set_ylabel(r'$x\\/$[m]', labelpad=0, fontsize=8)\nf2_ax5.tick_params(axis='both', which='both', pad=0, labelsize=6)\n\nf2_ax6.set_title('Bode phase plot', fontsize=9)\nf2_ax6.set_xscale('log')\nf2_ax6.set_xlabel(r'$f\\/$[Hz]', labelpad=0, fontsize=8)\nf2_ax6.set_ylabel(r'$\\phi\\/$[°]', labelpad=0, fontsize=8)\nf2_ax6.tick_params(axis='both', which='both', pad=0, labelsize=6)\n\ndef pid_control(Kp, Ti, Td, Fd, type_select, pole, damp_select):\n    \n    if damp_select == 1: # Critically damped\n        W_sys = c.tf([1], [1, 2*pole, pole*pole])\n    else: # Undamped\n        W_sys = c.tf([1], [1, 0, pole*pole])\n    \n    if type_select in (1, 3, 4):\n        Ti0 = 1\n    else:\n        Ti0 = 0\n        \n    if type_select in (2, 3, 4):\n        Td0 = 1\n    else :\n        Td0 = 0\n        \n    if type_select == 4:\n        Fd0 = 1\n    else:\n        Fd0 = 0\n    \n    # PID Controller\n    \n    P = Kp             # Proportional term\n    I = Kp / Ti        # Integral term\n    D = Kp * Td        # Derivative term\n    Td_f = Td / Fd     # Derivative term filter\n    \n    W_PID = c.parallel(c.tf([P], [1]),\n                       c.tf([I * Ti0], [1 * Ti0, 1 * (not Ti0)]),\n                       c.tf([D * Td0, 0], [Td_f * Td0 * Fd0, 1]))  # PID controller in time constant format\n    \n    W_open = c.series(W_PID, W_sys)         # Open loop\n    W_closed = c.feedback(W_open, 1, -1)    # Closed loop with negative feedback\n                        \n    # Display\n                        \n    global f2_line1, f2_line2, f2_line3, f2_line4, f2_line5, f2_line6\n    \n    f2_ax1.lines.remove(f2_line1)\n    f2_ax2.lines.remove(f2_line2)\n    f2_ax3.lines.remove(f2_line3)\n    f2_ax4.lines.remove(f2_line4)\n    f2_ax5.lines.remove(f2_line5)\n    f2_ax6.lines.remove(f2_line6)\n    \n    tout, yout = c.step_response(W_closed)\n    f2_line1, = f2_ax1.plot(tout, yout, lw=1, color='blue') \n\n    _, _, ob = c.nyquist_plot(W_open, Plot=False)   # Small resolution plot to determine bounds        \n    real, imag, freq = c.nyquist_plot(W_open, omega=np.logspace(np.log10(ob[0]), np.log10(ob[-1]), 1000), Plot=False)\n    f2_line2, = f2_ax2.plot(real, imag, lw=1, color='blue')\n    \n    mag, phase, omega = c.bode_plot(W_open, Plot=False)\n    f2_line3, = f2_ax3.plot(omega/2/np.pi, 20*np.log10(mag), lw=1, color='blue')\n    f2_line6, = f2_ax6.plot(omega/2/np.pi, phase*180/np.pi, lw=1, color='blue')\n\n    tout, yout = c.impulse_response(W_closed)\n    f2_line4, = f2_ax4.plot(tout, yout, lw=1, color='blue')   \n    \n    tout, yout = c.step_response(W_open)\n    f2_line5, = f2_ax5.plot(tout, yout, lw=1, color='blue') \n    \n    f2_ax1.relim()\n    f2_ax2.relim()\n    f2_ax3.relim()\n    f2_ax4.relim()\n    f2_ax5.relim()\n    f2_ax6.relim()\n    f2_ax1.autoscale_view()\n    f2_ax2.autoscale_view()\n    f2_ax3.autoscale_view()\n    f2_ax4.autoscale_view()\n    f2_ax5.autoscale_view()\n    f2_ax6.autoscale_view()\n    \n# GUI widgets\n\ndef draw_controllers(type_select):\n    \n    global Kp_slider\n    global Ti_slider\n    global Td_slider\n    global Fd_slider\n    \n    Kp_slider = w.FloatLogSlider(value=20, base=10, min=-1, max=4, description='Kp:', continuous_update=False,\n                                 layout=w.Layout(width='auto', flex='5 5 auto'))\n    \n    if type_select in (1, 3, 4):\n        Ti_slider = w.FloatLogSlider(value=0.0035, base=10, min=-4, max=1, description='Ti:', continuous_update=False,\n                                     layout=w.Layout(width='auto', flex='5 5 auto'))\n    else:\n        Ti_slider = w.FloatLogSlider(value=0.0035, base=10, min=-4, max=1, description='Ti:', continuous_update=False,\n                                     layout=w.Layout(width='auto', flex='5 5 auto'), disabled=True)\n        \n    if type_select in (2, 3, 4):\n        Td_slider = w.FloatLogSlider(value=1, base=10, min=-4, max=1, description='Td:', continuous_update=False,\n                                     layout=w.Layout(width='auto', flex='5 5 auto'))\n    else:\n        Td_slider = w.FloatLogSlider(value=1, base=10, min=-4, max=1, description='Td:', continuous_update=False,\n                                     layout=w.Layout(width='auto', flex='5 5 auto'), disabled=True)\n    \n    if type_select == 4:\n        Fd_slider = w.FloatLogSlider(value=1, base=10, min=0, max=3, description='Fd:', continuous_update=False,\n                                     layout=w.Layout(width='auto', flex='5 5 auto'))\n    else:\n        Fd_slider = w.FloatLogSlider(value=1, base=10, min=0, max=3, description='Fd:', continuous_update=False,\n                                     layout=w.Layout(width='auto', flex='5 5 auto'), disabled=True)\n\n\n    input_data = w.interactive_output(pid_control, {'Kp': Kp_slider, 'Ti': Ti_slider, 'Td': Td_slider,\n                                      'Fd': Fd_slider, 'type_select':typeSelect, 'pole':pole_slider, 'damp_select':dampSelect})\n\n    display(w.HBox([Kp_slider, Ti_slider, Td_slider, Fd_slider]), input_data)\n    \nw.interactive_output(draw_controllers, {'type_select':typeSelect})\n\n\n\n\n\n\n\n\n\n\nYou can test the controlled system’s signal following capabilities using the simulated scope. Readjust your controller so that it can follow a sine wave acceptably!  (The animations are scaled to fit the frame through the whole simulation. Because of this, unstable solutions might not seem to move until the very last second.)\n\n# Simulation data\n\nanim_fig = plt.figure()\nanim_fig.set_size_inches((9.8, 4))\nanim_fig.set_tight_layout(True)\n\nanim_ax1 = anim_fig.add_subplot(111)\n\nframe_count=1000\nscope_rounds=4\n\nl1 = anim_ax1.plot([], [], lw=1, color='blue')\nl2 = anim_ax1.plot([], [], lw=2, color='red')\n\nline1 = l1[0]\nline2 = l2[0]\n\nanim_ax1.legend(l1+l2, ['Reference', 'Output'], loc=1)\n\nanim_ax1.set_title('Scope', fontsize=12)\nanim_ax1.set_xlabel(r'$t\\/$[s]', labelpad=0, fontsize=10)\nanim_ax1.set_ylabel(r'$y\\/$[/]', labelpad=0, fontsize=10)\nanim_ax1.tick_params(axis='both', which='both', pad=0, labelsize=8)\n\nanim_ax1.grid(which='both', axis='both', color='lightgray')\n\nT_plot = []\nX_plot = []\nR_plot = []\n\n#Simulation function\n\ndef simulation(Kp, Ti, Td, Fd, type_select, pole, damp_select, T, dt, X, Xf, Xa):\n    \n    if damp_select == 1: # Critically damped\n        W_sys = c.tf([1], [1, 2*pole, pole*pole])\n    else: # Undamped\n        W_sys = c.tf([1], [1, 0, pole*pole])\n    \n    if type_select in (1, 3, 4):\n        Ti0 = 1\n    else:\n        Ti0 = 0\n        \n    if type_select in (2, 3, 4):\n        Td0 = 1\n    else :\n        Td0 = 0\n        \n    if type_select == 4:\n        Fd0 = 1\n    else:\n        Fd0 = 0\n    \n    # Controller\n    P = Kp            # Proportional term\n    I = Kp / Ti       # Integral term\n    D = Kp * Td       # Derivative term\n    Td_f = Td * Fd    # Derivative term filter\n    \n    W_PID = c.parallel(c.tf([P], [1]),\n                       c.tf([I * Ti0], [1 * Ti0, 1 * (not Ti0)]),\n                       c.tf([D * Td0, 0], [Td_f * Td0 * Fd0, 1]))    # PID controller\n    \n    # Model\n    W_open = c.series(W_PID, W_sys)         # Open loop\n    W_closed = c.feedback(W_open, 1, -1)    # Closed loop with negative feedback\n    \n    # Reference and disturbance signals\n\n    T_sim = np.arange(0, T, dt, dtype=np.float64)\n    \n    if X == 0:   # Sine wave reference\n        X_sim = np.sin(2 * np.pi * Xf * T_sim) * Xa\n    elif X == 1:   # Square wave reference\n        X_sim = np.sign(np.sin(2 * np.pi * Xf * T_sim)) * Xa\n    \n    # System response\n        \n    Tx, youtx, xoutx = c.forced_response(W_closed, T_sim, X_sim)\n    R_sim = youtx\n    \n    # Display\n    \n    XR_max = max(np.amax(np.absolute(np.concatenate((X_sim, R_sim)))), Xa)\n    \n    anim_ax1.set_ylim((-1.2 * XR_max, 1.2 * XR_max))\n    \n    global T_plot, X_plot, R_plot\n    \n    T_plot = np.linspace(0, T, frame_count*(scope_rounds+1), dtype=np.float32)\n    X_plot = np.interp(T_plot, T_sim, X_sim)\n    R_plot = np.interp(T_plot, T_sim, R_sim)\n        \ndef anim_init():\n    line1.set_data([], [])\n    line2.set_data([], [])\n    anim_ax1.set_xlim((0, T_plot[frame_count-1]))\n    \n    return (line1, line2, anim_ax1,)\n\ndef animate(i):\n    line1.set_data(T_plot[scope_rounds*i:scope_rounds*i+frame_count-1], X_plot[scope_rounds*i:scope_rounds*i+frame_count-1])\n    line2.set_data(T_plot[scope_rounds*i:scope_rounds*i+frame_count-1], R_plot[scope_rounds*i:scope_rounds*i+frame_count-1])\n    anim_ax1.set_xlim((T_plot[i*scope_rounds], T_plot[i*scope_rounds+frame_count-1]))\n    \n    return (line1, line2, anim_ax1,)\n\nanim = animation.FuncAnimation(anim_fig, animate, init_func=anim_init,\n                               frames=frame_count, interval=10, blit=True,\n                               repeat=True)\n\n# Controllers\n\nT_slider = w.FloatLogSlider(value=10, base=10, min=-0.7, max=1, step=0.01,\n                            description='Duration [s]:', continuous_update=False,\n                            orientation='vertical', layout=w.Layout(width='auto', height='auto', flex='1 1 auto'))\n\ndt_slider = w.FloatLogSlider(value=0.1, base=10, min=-3, max=-1, step=0.01,\n                             description='Timestep [s]:', continuous_update=False,\n                             orientation='vertical', layout=w.Layout(width='auto', height='auto', flex='1 1 auto'))\n       \nX_type = w.Dropdown(options=[('Sine', 0), ('Square', 1)], value=1,\n                    description='Reference: ', continuous_update=False, layout=w.Layout(width='auto', flex='3 3 auto'))    \nXf_slider = w.FloatLogSlider(value=0.5, base=10, min=-2, max=2, step=0.01,\n                             description='Frequency [Hz]:', continuous_update=False,\n                             orientation='vertical', layout=w.Layout(width='auto', height='auto', flex='1 1 auto'))\nXa_slider = w.FloatLogSlider(value=1, base=10, min=-2, max=2, step=0.01,\n                             description='Amplitude [/]:', continuous_update=False,\n                             orientation='vertical', layout=w.Layout(width='auto', height='auto', flex='1 1 auto'))    \n\ninput_data = w.interactive_output(simulation, {'Kp': Kp_slider, 'Ti': Ti_slider, 'Td': Td_slider,'Fd': Fd_slider,\n                                               'type_select': typeSelect, 'pole':pole_slider, 'damp_select':dampSelect,\n                                               'T': T_slider, 'dt': dt_slider,\n                                               'X': X_type, 'Xf': Xf_slider, 'Xa': Xa_slider})\n\ndisplay(w.HBox([w.HBox([T_slider, dt_slider], layout=w.Layout(width='25%')),\n                w.Box([], layout=w.Layout(width='5%')),\n                w.VBox([X_type, w.HBox([Xf_slider, Xa_slider])], layout=w.Layout(width='30%')),\n                w.Box([], layout=w.Layout(width='5%'))],\n                layout=w.Layout(width='100%', justify_content='center')), input_data)\n\n\n\n\n\n\n\n\n\n\n\n\n\nThe duration parameter controls the simulated timeframe and does not affect the runtime of the animation. In contrast, the timestep controls the model sampling and can refine the results in exchange for higher computational resources."
  },
  {
    "objectID": "ICCT_en/examples/03/FD-08_PID_Control_of_First-Order_Systems_with_Integrator.html",
    "href": "ICCT_en/examples/03/FD-08_PID_Control_of_First-Order_Systems_with_Integrator.html",
    "title": "PID control of a First-Order system with Integrator",
    "section": "",
    "text": "%matplotlib notebook\nimport control as c\nimport ipywidgets as w\nimport numpy as np\n\nfrom IPython.display import display, HTML\nimport matplotlib.pyplot as plt\nimport matplotlib.animation as animation\n\ndisplay(HTML('&lt;script&gt; $(document).ready(function() { $(\"div.input\").hide(); }); &lt;/script&gt;'))\n\nTraceback (most recent call last):\n  File \"C:\\Users\\Uporabnik\\Anaconda3\\envs\\icct2\\lib\\site-packages\\matplotlib\\cbook\\__init__.py\", line 216, in process\n    func(*args, **kwargs)\n  File \"C:\\Users\\Uporabnik\\Anaconda3\\envs\\icct2\\lib\\site-packages\\matplotlib\\animation.py\", line 1465, in _stop\n    self.event_source.remove_callback(self._loop_delay)\nAttributeError: 'NoneType' object has no attribute 'remove_callback'\n\n\n\n\n\nIn the following example, we will be using a PID controller (or one of its subtypes) to control a first-order LTI (linear time-invariant system) with an attached integrator.\nThe system consists of a single stable pole multiplied with the transfer function of the integrator, both of which can be expressed using time constants:  \\[G(s)=\\frac{1}{T_{1}T_{int}s^2 + T_{int}s}\\]  A typical example of a first-order system with an integrator is a mass-damper system with force input and position output:    Where the transfer function can be expressed as:  \\[G(s) = \\frac{X(s)}{F(s)} = \\frac{1}{ms^2+bs} \\qquad T_{1}=\\frac{m}{b} \\qquad T_{int}=b\\]  Choose time constants for the system!\n\n# Figure definition\n\nfig1, ((f1_ax1), (f1_ax2)) = plt.subplots(2, 1)\nfig1.set_size_inches((9.8, 5))\nfig1.set_tight_layout(True)\n\nf1_line1, = f1_ax1.plot([], [])\nf1_line2, = f1_ax2.plot([], [])  \n\nf1_ax1.grid(which='both', axis='both', color='lightgray')\nf1_ax2.grid(which='both', axis='both', color='lightgray')\n\nf1_ax1.autoscale(enable=True, axis='both', tight=True)\nf1_ax2.autoscale(enable=True, axis='both', tight=True)\n\nf1_ax1.set_title('Bode magnitude plot', fontsize=11)\nf1_ax1.set_xscale('log')\nf1_ax1.set_xlabel(r'$f\\/$[Hz]', labelpad=0, fontsize=10)\nf1_ax1.set_ylabel(r'$A\\/$[dB]', labelpad=0, fontsize=10)\nf1_ax1.tick_params(axis='both', which='both', pad=0, labelsize=8)\n\nf1_ax2.set_title('Bode phase plot', fontsize=11)\nf1_ax2.set_xscale('log')\nf1_ax2.set_xlabel(r'$f\\/$[Hz]', labelpad=0, fontsize=10)\nf1_ax2.set_ylabel(r'$\\phi\\/$[°]', labelpad=0, fontsize=10)\nf1_ax2.tick_params(axis='both', which='both', pad=0, labelsize=8)   \n\n\n# System model\n\ndef system_model(T1, Tint):\n\n    W_sys = c.tf([1], [T1*Tint, Tint, 0])\n\n    print('System transfer function:')\n    print(W_sys)\n\n    # System analysis\n\n    poles = c.pole(W_sys)     # Poles\n\n    print('System poles:\\n')\n    print(poles)\n    \n    global f1_line1, f1_line2\n    \n    f1_ax1.lines.remove(f1_line1)\n    f1_ax2.lines.remove(f1_line2)\n\n    mag, phase, omega = c.bode_plot(W_sys, Plot=False)   # Bode-plot\n\n    f1_line1, = f1_ax1.plot(omega/2/np.pi, 20*np.log10(mag), lw=1, color='blue')\n    f1_line2, = f1_ax2.plot(omega/2/np.pi, phase*180/np.pi, lw=1, color='blue')   \n\n    f1_ax1.relim()\n    f1_ax2.relim()\n    f1_ax1.autoscale_view()\n    f1_ax2.autoscale_view()\n    \n# GUI widgets\n    \nT1_slider = w.FloatLogSlider(value=0.1, base=10, min=-4, max=1, description='T1 [s] :', continuous_update=False,\n                             layout=w.Layout(width='75%'))\nTint_slider = w.FloatLogSlider(value=0.1, base=10, min=-4, max=1, description='Tint [s] :', continuous_update=False,\n                             layout=w.Layout(width='75%'))\n\ninput_data = w.interactive_output(system_model, {'T1':T1_slider, 'Tint':Tint_slider})\n\ndisplay(w.HBox([T1_slider, Tint_slider]), input_data)\n\n\n\n\n\n\n\n\n\n\n\n\n\nAfter observing the system’s characteristics, select a controller type!\n\n#Controller type select\n\ntypeSelect = w.ToggleButtons(\n    options=[('P', 0), ('PI', 1), ('PD', 2), ('PID', 3), ('PID Realistic', 4)],\n    description='Controller type: ', style={'description_width':'15%'})\n\ndisplay(typeSelect)\n\n\n\n\nTune the selected controller so that rising/settling time, overshoot, or remaining error is minimized! It is not possible to get the best results for each parameter in a single setup. Create multiple solutions, one for each type!\n\n# PID control\n\n# Figure definition\nfig2, ((f2_ax1, f2_ax2, f2_ax3), (f2_ax4, f2_ax5, f2_ax6)) = plt.subplots(2, 3)\nfig2.set_size_inches((9.8, 5))\nfig2.set_tight_layout(True)\n\nf2_line1, = f2_ax1.plot([], [])\nf2_line2, = f2_ax2.plot([], []) \nf2_line3, = f2_ax3.plot([], [])\nf2_line4, = f2_ax4.plot([], [])  \nf2_line5, = f2_ax5.plot([], [])\nf2_line6, = f2_ax6.plot([], [])\n\nf2_ax1.grid(which='both', axis='both', color='lightgray')\nf2_ax2.grid(which='both', axis='both', color='lightgray')\nf2_ax3.grid(which='both', axis='both', color='lightgray')\nf2_ax4.grid(which='both', axis='both', color='lightgray')\nf2_ax5.grid(which='both', axis='both', color='lightgray')\nf2_ax6.grid(which='both', axis='both', color='lightgray')\n\nf2_ax1.autoscale(enable=True, axis='both', tight=True)\nf2_ax2.autoscale(enable=True, axis='both', tight=True)\nf2_ax3.autoscale(enable=True, axis='both', tight=True)\nf2_ax4.autoscale(enable=True, axis='both', tight=True)\nf2_ax5.autoscale(enable=True, axis='both', tight=True)\nf2_ax6.autoscale(enable=True, axis='both', tight=True)\n\nf2_ax1.set_title('Closed loop step response', fontsize=9)\nf2_ax1.set_xlabel(r'$t\\/$[s]', labelpad=0, fontsize=8)\nf2_ax1.set_ylabel(r'$x\\/$[m]', labelpad=0, fontsize=8)\nf2_ax1.tick_params(axis='both', which='both', pad=0, labelsize=6)\n\nf2_ax2.set_title('Nyquist diagram', fontsize=9)\nf2_ax2.set_xlabel(r'Re', labelpad=0, fontsize=8)\nf2_ax2.set_ylabel(r'Im', labelpad=0, fontsize=8)\nf2_ax2.tick_params(axis='both', which='both', pad=0, labelsize=6)\n\nf2_ax3.set_title('Bode magnitude plot', fontsize=9)\nf2_ax3.set_xscale('log')\nf2_ax3.set_xlabel(r'$f\\/$[Hz]', labelpad=0, fontsize=8)\nf2_ax3.set_ylabel(r'$A\\/$[dB]', labelpad=0, fontsize=8)\nf2_ax3.tick_params(axis='both', which='both', pad=0, labelsize=6)\n\nf2_ax4.set_title('Closed loop impulse response', fontsize=9)\nf2_ax4.set_xlabel(r'$t\\/$[s]', labelpad=0, fontsize=8)\nf2_ax4.set_ylabel(r'$x\\/$[m]', labelpad=0, fontsize=8)\nf2_ax4.tick_params(axis='both', which='both', pad=0, labelsize=6)\n\nf2_ax5.set_title('Open loop step response', fontsize=9)\nf2_ax5.set_xlabel(r'$t\\/$[s]', labelpad=0, fontsize=8)\nf2_ax5.set_ylabel(r'$x\\/$[m]', labelpad=0, fontsize=8)\nf2_ax5.tick_params(axis='both', which='both', pad=0, labelsize=6)\n\nf2_ax6.set_title('Bode phase plot', fontsize=9)\nf2_ax6.set_xscale('log')\nf2_ax6.set_xlabel(r'$f\\/$[Hz]', labelpad=0, fontsize=8)\nf2_ax6.set_ylabel(r'$\\phi\\/$[°]', labelpad=0, fontsize=8)\nf2_ax6.tick_params(axis='both', which='both', pad=0, labelsize=6)\n\ndef pid_control(Kp, Ti, Td, Fd, type_select, T1, Tint):\n    \n    W_sys = c.tf([1], [T1*Tint, Tint, 0])\n    \n    if type_select in (1, 3, 4):\n        Ti0 = 1\n    else:\n        Ti0 = 0\n        \n    if type_select in (2, 3, 4):\n        Td0 = 1\n    else :\n        Td0 = 0\n        \n    if type_select == 4:\n        Fd0 = 1\n    else:\n        Fd0 = 0\n    \n    # PID Controller\n    \n    P = Kp             # Proportional term\n    I = Kp / Ti        # Integral term\n    D = Kp * Td        # Derivative term\n    Td_f = Td / Fd     # Derivative term filter\n    \n    W_PID = c.parallel(c.tf([P], [1]),\n                       c.tf([I * Ti0], [1 * Ti0, 1 * (not Ti0)]),\n                       c.tf([D * Td0, 0], [Td_f * Td0 * Fd0, 1]))  # PID controller in time constant format\n    \n    W_open = c.series(W_PID, W_sys)         # Open loop\n    W_closed = c.feedback(W_open, 1, -1)    # Closed loop with negative feedback\n                        \n    # Display\n                        \n    global f2_line1, f2_line2, f2_line3, f2_line4, f2_line5, f2_line6\n    \n    f2_ax1.lines.remove(f2_line1)\n    f2_ax2.lines.remove(f2_line2)\n    f2_ax3.lines.remove(f2_line3)\n    f2_ax4.lines.remove(f2_line4)\n    f2_ax5.lines.remove(f2_line5)\n    f2_ax6.lines.remove(f2_line6)\n    \n    tout, yout = c.step_response(W_closed)\n    f2_line1, = f2_ax1.plot(tout, yout, lw=1, color='blue') \n\n    _, _, ob = c.nyquist_plot(W_open, Plot=False)   # Small resolution plot to determine bounds        \n    real, imag, freq = c.nyquist_plot(W_open, omega=np.logspace(np.log10(ob[0]), np.log10(ob[-1]), 1000), Plot=False)\n    f2_line2, = f2_ax2.plot(real, imag, lw=1, color='blue')\n    \n    mag, phase, omega = c.bode_plot(W_open, Plot=False)\n    f2_line3, = f2_ax3.plot(omega/2/np.pi, 20*np.log10(mag), lw=1, color='blue')\n    f2_line6, = f2_ax6.plot(omega/2/np.pi, phase*180/np.pi, lw=1, color='blue')\n\n    tout, yout = c.impulse_response(W_closed)\n    f2_line4, = f2_ax4.plot(tout, yout, lw=1, color='blue')   \n    \n    tout, yout = c.step_response(W_open)\n    f2_line5, = f2_ax5.plot(tout, yout, lw=1, color='blue') \n    \n    f2_ax1.relim()\n    f2_ax2.relim()\n    f2_ax3.relim()\n    f2_ax4.relim()\n    f2_ax5.relim()\n    f2_ax6.relim()\n    f2_ax1.autoscale_view()\n    f2_ax2.autoscale_view()\n    f2_ax3.autoscale_view()\n    f2_ax4.autoscale_view()\n    f2_ax5.autoscale_view()\n    f2_ax6.autoscale_view()\n    \n# GUI widgets\n\ndef draw_controllers(type_select):\n    \n    global Kp_slider\n    global Ti_slider\n    global Td_slider\n    global Fd_slider\n    \n    Kp_slider = w.FloatLogSlider(value=0.5, base=10, min=-1, max=4, description='Kp:', continuous_update=False,\n                                 layout=w.Layout(width='auto', flex='5 5 auto'))\n    \n    if type_select in (1, 3, 4):\n        Ti_slider = w.FloatLogSlider(value=0.0035, base=10, min=-4, max=1, description='Ti:', continuous_update=False,\n                                     layout=w.Layout(width='auto', flex='5 5 auto'))\n    else:\n        Ti_slider = w.FloatLogSlider(value=0.0035, base=10, min=-4, max=1, description='Ti:', continuous_update=False,\n                                     layout=w.Layout(width='auto', flex='5 5 auto'), disabled=True)\n        \n    if type_select in (2, 3, 4):\n        Td_slider = w.FloatLogSlider(value=1, base=10, min=-4, max=1, description='Td:', continuous_update=False,\n                                     layout=w.Layout(width='auto', flex='5 5 auto'))\n    else:\n        Td_slider = w.FloatLogSlider(value=1, base=10, min=-4, max=1, description='Td:', continuous_update=False,\n                                     layout=w.Layout(width='auto', flex='5 5 auto'), disabled=True)\n    \n    if type_select == 4:\n        Fd_slider = w.FloatLogSlider(value=1, base=10, min=0, max=3, description='Fd:', continuous_update=False,\n                                     layout=w.Layout(width='auto', flex='5 5 auto'))\n    else:\n        Fd_slider = w.FloatLogSlider(value=1, base=10, min=0, max=3, description='Fd:', continuous_update=False,\n                                     layout=w.Layout(width='auto', flex='5 5 auto'), disabled=True)\n\n\n    input_data = w.interactive_output(pid_control, {'Kp': Kp_slider, 'Ti': Ti_slider, 'Td': Td_slider,\n                                      'Fd': Fd_slider, 'type_select':typeSelect, 'T1':T1_slider, 'Tint':Tint_slider})\n\n    display(w.HBox([Kp_slider, Ti_slider, Td_slider, Fd_slider]), input_data)\n    \nw.interactive_output(draw_controllers, {'type_select':typeSelect})\n\n\n\n\n\n\n\n\n\n\nYou can test the controlled system’s signal following capabilities using the simulated scope. Readjust your controller so that it can follow a sine wave acceptably!  (The animations are scaled to fit the frame through the whole simulation. Because of this, unstable solutions might not seem to move until the very last second.)\n\n# Simulation data\n\nanim_fig = plt.figure()\nanim_fig.set_size_inches((9.8, 4))\nanim_fig.set_tight_layout(True)\n\nanim_ax1 = anim_fig.add_subplot(111)\n\nframe_count=1000\nscope_rounds=4\n\nl1 = anim_ax1.plot([], [], lw=1, color='blue')\nl2 = anim_ax1.plot([], [], lw=2, color='red')\n\nline1 = l1[0]\nline2 = l2[0]\n\nanim_ax1.legend(l1+l2, ['Reference', 'Output'], loc=1)\n\nanim_ax1.set_title('Scope', fontsize=12)\nanim_ax1.set_xlabel(r'$t\\/$[s]', labelpad=0, fontsize=10)\nanim_ax1.set_ylabel(r'$y\\/$[/]', labelpad=0, fontsize=10)\nanim_ax1.tick_params(axis='both', which='both', pad=0, labelsize=8)\n\nanim_ax1.grid(which='both', axis='both', color='lightgray')\n\nT_plot = []\nX_plot = []\nR_plot = []\n\n#Simulation function\n\ndef simulation(Kp, Ti, Td, Fd, type_select, T1, Tint, T, dt, X, Xf, Xa):\n    \n    W_sys = c.tf([1], [T1*Tint, Tint, 0])\n    \n    if type_select in (1, 3, 4):\n        Ti0 = 1\n    else:\n        Ti0 = 0\n        \n    if type_select in (2, 3, 4):\n        Td0 = 1\n    else :\n        Td0 = 0\n        \n    if type_select == 4:\n        Fd0 = 1\n    else:\n        Fd0 = 0\n    \n    # Controller\n    P = Kp            # Proportional term\n    I = Kp / Ti       # Integral term\n    D = Kp * Td       # Derivative term\n    Td_f = Td * Fd    # Derivative term filter\n    \n    W_PID = c.parallel(c.tf([P], [1]),\n                       c.tf([I * Ti0], [1 * Ti0, 1 * (not Ti0)]),\n                       c.tf([D * Td0, 0], [Td_f * Td0 * Fd0, 1]))    # PID controller\n    \n    # Model\n    W_open = c.series(W_PID, W_sys)         # Open loop\n    W_closed = c.feedback(W_open, 1, -1)    # Closed loop with negative feedback\n    \n    # Reference and disturbance signals\n\n    T_sim = np.arange(0, T, dt, dtype=np.float64)\n    \n    if X == 0:   # Sine wave reference\n        X_sim = np.sin(2 * np.pi * Xf * T_sim) * Xa\n    elif X == 1:   # Square wave reference\n        X_sim = np.sign(np.sin(2 * np.pi * Xf * T_sim)) * Xa\n    \n    # System response\n        \n    Tx, youtx, xoutx = c.forced_response(W_closed, T_sim, X_sim)\n    R_sim = youtx\n    \n    # Display\n    \n    XR_max = max(np.amax(np.absolute(np.concatenate((X_sim, R_sim)))), Xa)\n    \n    anim_ax1.set_ylim((-1.2 * XR_max, 1.2 * XR_max))\n    \n    global T_plot, X_plot, R_plot\n    \n    T_plot = np.linspace(0, T, frame_count*(scope_rounds+1), dtype=np.float32)\n    X_plot = np.interp(T_plot, T_sim, X_sim)\n    R_plot = np.interp(T_plot, T_sim, R_sim)\n        \ndef anim_init():\n    line1.set_data([], [])\n    line2.set_data([], [])\n    anim_ax1.set_xlim((0, T_plot[frame_count-1]))\n    \n    return (line1, line2, anim_ax1,)\n\ndef animate(i):\n    line1.set_data(T_plot[scope_rounds*i:scope_rounds*i+frame_count-1], X_plot[scope_rounds*i:scope_rounds*i+frame_count-1])\n    line2.set_data(T_plot[scope_rounds*i:scope_rounds*i+frame_count-1], R_plot[scope_rounds*i:scope_rounds*i+frame_count-1])\n    anim_ax1.set_xlim((T_plot[i*scope_rounds], T_plot[i*scope_rounds+frame_count-1]))\n    \n    return (line1, line2, anim_ax1,)\n\nanim = animation.FuncAnimation(anim_fig, animate, init_func=anim_init,\n                               frames=frame_count, interval=10, blit=True,\n                               repeat=True)\n\n# Controllers\n\nT_slider = w.FloatLogSlider(value=10, base=10, min=-0.7, max=1, step=0.01,\n                            description='Duration [s]:', continuous_update=False,\n                            orientation='vertical', layout=w.Layout(width='auto', height='auto', flex='1 1 auto'))\n\ndt_slider = w.FloatLogSlider(value=0.1, base=10, min=-3, max=-1, step=0.01,\n                             description='Timestep [s]:', continuous_update=False,\n                             orientation='vertical', layout=w.Layout(width='auto', height='auto', flex='1 1 auto'))\n       \nX_type = w.Dropdown(options=[('Sine', 0), ('Square', 1)], value=1,\n                    description='Reference: ', continuous_update=False, layout=w.Layout(width='auto', flex='3 3 auto'))    \nXf_slider = w.FloatLogSlider(value=0.5, base=10, min=-2, max=2, step=0.01,\n                             description='Frequency [Hz]:', continuous_update=False,\n                             orientation='vertical', layout=w.Layout(width='auto', height='auto', flex='1 1 auto'))\nXa_slider = w.FloatLogSlider(value=1, base=10, min=-2, max=2, step=0.01,\n                             description='Amplitude [/]:', continuous_update=False,\n                             orientation='vertical', layout=w.Layout(width='auto', height='auto', flex='1 1 auto'))    \n\ninput_data = w.interactive_output(simulation, {'Kp': Kp_slider, 'Ti': Ti_slider, 'Td': Td_slider,'Fd': Fd_slider,\n                                               'type_select': typeSelect, 'T1': T1_slider, 'Tint':Tint_slider,\n                                               'T': T_slider, 'dt': dt_slider,\n                                               'X': X_type, 'Xf': Xf_slider, 'Xa': Xa_slider})\n\ndisplay(w.HBox([w.HBox([T_slider, dt_slider], layout=w.Layout(width='25%')),\n                w.Box([], layout=w.Layout(width='5%')),\n                w.VBox([X_type, w.HBox([Xf_slider, Xa_slider])], layout=w.Layout(width='30%')),\n                w.Box([], layout=w.Layout(width='5%'))],\n                layout=w.Layout(width='100%', justify_content='center')), input_data)\n\n\n\n\n\n\n\n\n\n\n\n\n\nThe duration parameter controls the simulated timeframe and does not affect the runtime of the animation. In contrast, the timestep controls the model sampling and can refine the results in exchange for higher computational resources."
  },
  {
    "objectID": "ICCT_en/examples/03/FD-06_PID_Controller_Formulation.html",
    "href": "ICCT_en/examples/03/FD-06_PID_Controller_Formulation.html",
    "title": "PID controller formulation",
    "section": "",
    "text": "%matplotlib notebook\nimport control as c\nimport ipywidgets as w\nimport numpy as np\n\nfrom IPython.display import display, HTML\nimport matplotlib.pyplot as plt\nimport matplotlib.animation as animation\nimport matplotlib.gridspec as gridspec\n\ndisplay(HTML('&lt;script&gt; $(document).ready(function() { $(\"div.input\").hide(); }); &lt;/script&gt;'))\n\n\n\n\nIn the following example, we will examine the components and various definition methods of the Proportional-Integral-Derivating (PID) controller. As the name suggests, the system is composed of three distinct components (an integrator, a differentiator, and a gain), and the output is the weighted sum of these signals.\n\\[y_{PID}(t) = P\\cdot u(t) + I\\cdot\\int u(t)dt + D\\cdot\\frac{d}{dt}u(t)\\]\nAfter Laplace transforming the model, the following transfer function can be assigned to the controller:\n\\[G_{PID}(s)=P+\\frac{I}{s}+D\\cdot s\\]\n\nThis ideal form, where the components are separate and independent, is referred to as the ideal controller form. An alternate form of this controller can be formed by calculating the common gain of the three components (Kp). In this case, the remaining coefficients represent the frequency characteristics of the appropriate components. This form is usually referred to as the parallel form:\n\\[G_{PID} = K_p(1 + \\frac{1}{T_is} + T_ds)\\]\nAn alternate version of the controller is occasionally used, where the components are connected in series instead of parallel. In this case, the resulting equation is highly similar, but the gain for the P component is dependent on the time constants.\n\\[G_{PID} = K_p(1 + \\frac{1}{T_is})(1 + T_ds) = K_p(1 + \\frac{T_d}{T_i} + \\frac{1}{T_is} + T_ds)\\]\n\nThere is an issue with these PID models when it comes to analog electronic implementations. It is impossible to implement the ideal derivating component, as realistic components have a cutoff at high frequencies (infinite gain can not be implemented). This property can be modelled by including a first-order component in the transfer function. With this modification, the parallel model can be expressed as:\n\\[G_{PID} = K_p(1 + \\frac{1}{T_is} + \\frac{T_ds}{{T_d}'s + 1}) \\qquad {T_d}'=\\frac{T_d}{F_d} \\qquad F_d \\substack{\\in\\\\ \\sim} [8,\\;20]\\]\nSelect a model type!\n\n# System type selector\ntypeSelect = w.ToggleButtons(\n    options=[('Independent', 0), ('Parallel', 1), ('Serial', 2), ('Realistic', 3)],\n    description='PID type: ', layout=w.Layout(width='100%'))\n\ndisplay(typeSelect)\n\n\n\n\nChose PID components! Observe the changes in the frequency characteristics!\n\nfig1, ((f1_ax1), (f1_ax2)) = plt.subplots(2, 1)\nfig1.set_size_inches((9.8, 5))\nfig1.set_tight_layout(True)\n\nf1_line1, = f1_ax1.plot([], [], lw=1, color='blue')\nf1_line2, = f1_ax2.plot([], [], lw=1, color='blue')\n\nf1_ax1.grid(which='both', axis='both', color='lightgray')\nf1_ax2.grid(which='both', axis='both', color='lightgray')\n\nf1_ax1.autoscale(enable=True, axis='x', tight=True)\nf1_ax2.autoscale(enable=True, axis='x', tight=True)\nf1_ax1.autoscale(enable=True, axis='y', tight=False)\nf1_ax2.autoscale(enable=True, axis='y', tight=False)\n\nf1_ax1.set_title('Bode magnitude plot', fontsize=11)\nf1_ax1.set_xscale('log')\nf1_ax1.set_xlabel(r'$\\omega\\/[\\frac{rad}{s}]$', labelpad=0, fontsize=10)\nf1_ax1.set_ylabel(r'$A\\/$[dB]', labelpad=0, fontsize=10)\nf1_ax1.tick_params(axis='both', which='both', pad=0, labelsize=8)\n\nf1_ax2.set_title('Bode phase plot', fontsize=11)\nf1_ax2.set_xscale('log')\nf1_ax2.set_xlabel(r'$\\omega\\/[\\frac{rad}{s}]$', labelpad=0, fontsize=10)\nf1_ax2.set_ylabel(r'$\\phi\\/$[°]', labelpad=0, fontsize=10)\nf1_ax2.tick_params(axis='both', which='both', pad=0, labelsize=8)\n\n\ndef calculate_tf(P, I, D, I0, D0, model, F=1):   \n    \n    global I_slider, D_slider\n    \n    if I0:\n        I_slider.disabled=False\n    else:\n        I_slider.disabled=True\n        \n    if D0:\n        D_slider.disabled=False\n    else:\n        D_slider.disabled=True\n    \n    \n    if model == 0: # Ideal\n        \n        W = c.parallel(c.tf([P], [1]),\n                       c.tf([I * I0], [1 * I0, 1 * (not I0)]),\n                       c.tf([D * D0, 0], [1]))\n        \n    elif model == 1: # Parallel\n        \n        W = c.parallel(c.tf([P], [1]),\n                       c.tf([P / I * I0], [1 * I0, 1 * (not I0)]),\n                       c.tf([P * D * D0, 0], [1]))\n        \n    elif model == 2: # Series\n        \n        W = c.parallel(c.tf([P + (D * D0 + 1 * (not D0)) / (I * I0 + 1 * (not I0))], [1]),\n                       c.tf([P / I * I0], [1 * I0, 1 * (not I0)]),\n                       c.tf([P * D * D0, 0], [1]))\n        \n    else: # Realistic\n        \n        W = c.parallel(c.tf([P], [1]),\n                       c.tf([P / I * I0], [1 * I0, 1 * (not I0)]),\n                       c.tf([P * D * D0, 0], [D / F * D0, 1]))\n        \n    print('PID transfer function:')\n    print(W)\n    \n    global f1_line1, f1_line2\n    \n    f1_ax1.lines.remove(f1_line1)\n    f1_ax2.lines.remove(f1_line2)\n    \n    mag, phase, omega = c.bode_plot(W, Plot=False)   # Bode-plot \n    \n    f1_line1, = f1_ax1.plot(omega, 20*np.log10(mag), lw=1, color='blue')\n    f1_line2, = f1_ax2.plot(omega, phase*180/np.pi, lw=1, color='blue')\n    \n    f1_ax1.relim()\n    f1_ax2.relim()\n    f1_ax1.autoscale_view()\n    f1_ax2.autoscale_view()        \n\ndef draw_controllers(model):\n    \n    global P_slider, I_slider, D_slider, I_button, D_button, F_slider\n    \n    if model == 0: # Ideal\n        \n        P_slider = w.FloatLogSlider(value=0.5, base=10, min=-4, max=4, description='$P$', continuous_update=False,\n                                    layout=w.Layout(width='auto', flex='10 10 auto'))\n        I_slider = w.FloatLogSlider(value=0.1, base=10, min=-4, max=4, description='$I$', continuous_update=False,\n                                    layout=w.Layout(width='auto', flex='10 10 auto'))\n        D_slider = w.FloatLogSlider(value=1, base=10, min=-4, max=4, description='$D$', continuous_update=False,\n                                    layout=w.Layout(width='auto', flex='10 10 auto'))\n\n        I_button = w.ToggleButton(value=True, description='',\n                                  layout=w.Layout(width='auto', flex='1 1 0%'))\n        D_button = w.ToggleButton(value=False, description='',\n                                  layout=w.Layout(width='auto', flex='1 1 0%'))\n\n        input_data = w.interactive_output(calculate_tf, {'P': P_slider, 'I': I_slider, 'D': D_slider,\n                                                         'I0' : I_button, 'D0': D_button,\n                                                         'model': typeSelect})\n\n        display(w.HBox([P_slider, I_button, I_slider, D_button, D_slider]), input_data)\n        \n    elif model in [1, 2]: # Series and Parallel\n        \n        P_slider = w.FloatLogSlider(value=0.5, base=10, min=-1, max=4, description='$K_p$', continuous_update=False,\n                                    layout=w.Layout(width='auto', flex='10 10 auto'))\n        I_slider = w.FloatLogSlider(value=0.0035, base=10, min=-4, max=1, description='$T_i$', continuous_update=False,\n                                    layout=w.Layout(width='auto', flex='10 10 auto'))\n        D_slider = w.FloatLogSlider(value=1, base=10, min=-4, max=1, description='$T_d$', continuous_update=False,\n                                    layout=w.Layout(width='auto', flex='10 10 auto'))\n\n        I_button = w.ToggleButton(value=True, description='',\n                                  layout=w.Layout(width='auto', flex='1 1 0%'))\n        D_button = w.ToggleButton(value=False, description='',\n                                  layout=w.Layout(width='auto', flex='1 1 0%'))\n\n        input_data = w.interactive_output(calculate_tf, {'P': P_slider, 'I': I_slider, 'D': D_slider,\n                                                         'I0' : I_button, 'D0': D_button,\n                                                         'model': typeSelect})\n\n        display(w.HBox([P_slider, I_button, I_slider, D_button, D_slider]), input_data)\n        \n    else: # Realistic\n        \n        P_slider = w.FloatLogSlider(value=0.5, base=10, min=-1, max=4, description='$K_p$', continuous_update=False,\n                                    layout=w.Layout(width='auto', flex='10 10 auto'))\n        I_slider = w.FloatLogSlider(value=0.0035, base=10, min=-4, max=1, description='$T_i$', continuous_update=False,\n                                    layout=w.Layout(width='auto', flex='10 10 auto'))\n        D_slider = w.FloatLogSlider(value=1, base=10, min=-4, max=1, description='$T_d$', continuous_update=False,\n                                    layout=w.Layout(width='auto', flex='10 10 auto'))\n        F_slider = w.FloatLogSlider(value=1, base=10, min=0, max=3, description=\"${T_d}'=T_d/ $\", continuous_update=False,\n                                    layout=w.Layout(width='auto', flex='10 10 auto'))\n\n        I_button = w.ToggleButton(value=True, description='',\n                                  layout=w.Layout(width='auto', flex='1 1 0%'))\n        D_button = w.ToggleButton(value=False, description='',\n                                  layout=w.Layout(width='auto', flex='1 1 0%'))\n\n        input_data = w.interactive_output(calculate_tf, {'P': P_slider, 'I': I_slider, 'D': D_slider,\n                                                         'F': F_slider, 'I0' : I_button, 'D0': D_button,\n                                                         'model': typeSelect})\n\n        display(w.HBox([P_slider, I_button, I_slider, D_button, D_slider, F_slider]), input_data)\n    \n    \nw.interactive_output(draw_controllers, {'model': typeSelect})"
  },
  {
    "objectID": "ICCT_en/examples/03/FD-04_Negative_Feedback_Systems.html",
    "href": "ICCT_en/examples/03/FD-04_Negative_Feedback_Systems.html",
    "title": "Negative feedback systems",
    "section": "",
    "text": "%matplotlib notebook\nimport control as c\nimport ipywidgets as w\nimport numpy as np\n\nfrom IPython.display import display, HTML\nimport matplotlib.pyplot as plt\nimport matplotlib.animation as animation\nimport matplotlib.gridspec as gridspec\n\ndisplay(HTML('&lt;script&gt; $(document).ready(function() { $(\"div.input\").hide(); }); &lt;/script&gt;'))\n\n\n\n\nIn the following example, we will examine the effects of negative feedback on an LTI (Linear Time-Invariant) system. The output of the original system (\\(G(s)\\)) is deducted from the input signal, creating what’s called a negative feedback. Optionally the feedback line can contain an LTI system of its own (\\(H(s)\\)) that modify the output signal before returning to the input side.\n\nThe transfer function of the closed-loop system can be calculated as:\n\\[G_{cl}(s)=\\frac{G(s)}{1+H(s)G(s)},\\]\nwhere the \\(+\\) sign corresponds to the negative feedback in the figure above. Positive feedback systems are calculated by a negative sign. While the open-loop system is defined as the system from the input to the feedback point:\n\\[G_{ol}(s)=H(s)G(s)\\]\nWhen analyzing the properties of a negative feedback system, some of the tests have to be carried out on the open-loop system.\nSelect the method of analysis!\n\n# Example mode selector\ntypeSelect = w.ToggleButtons(\n    options=[('Pole-Zero map', 0), ('Bode plot', 1), ('Nyquist plot', 2)],\n    description='System: ', layout=w.Layout(width='100%'))\n\ndisplay(typeSelect)\n\n\n\n\nAssemble the transfer functions for the feedforward and feedback systems!\n\nb = {}\na = {}\ne = {}\nf = {}\n\nb[0] = w.FloatText(value=1.0, description='', disabled=False, step=0.1, layout=w.Layout(width='19%'))\nb[1] = w.FloatText(value=1.0, description='', disabled=False, step=0.1, layout=w.Layout(width='19%'))\nb[2] = w.FloatText(value=0.0, description='', disabled=False, step=0.1, layout=w.Layout(width='19%'))\n\na[0] = w.FloatText(value=10.0, description='', disabled=False, step=0.1, layout=w.Layout(width='19%'))\na[1] = w.FloatText(value=1.0, description='', disabled=False, step=0.1, layout=w.Layout(width='19%'))\na[2] = w.FloatText(value=0.0, description='', disabled=False, step=0.1, layout=w.Layout(width='19%'))\na[3] = w.FloatText(value=0.0, description='', disabled=False, step=0.1, layout=w.Layout(width='19%'))\n\nf[0] = w.FloatText(value=1.0, description='', disabled=False, step=0.1, layout=w.Layout(width='24%'))\nf[1] = w.FloatText(value=1.0, description='', disabled=False, step=0.1, layout=w.Layout(width='24%'))\n\ne[0] = w.FloatText(value=1.0, description='', disabled=False, step=0.1, layout=w.Layout(width='24%'))\ne[1] = w.FloatText(value=1.0, description='', disabled=False, step=0.1, layout=w.Layout(width='24%'))\ne[2] = w.FloatText(value=0.0, description='', disabled=False, step=0.1, layout=w.Layout(width='24%'))\n\ndef transfer_function(a0, a1, a2, a3, b0, b1, b2, e0, e1, e2, f0, f1):\n\n    b1c = b1\n    b2c = b2\n    f1c = f1\n    \n    global b, f\n       \n    if a3 == 0:\n        b[2].disabled=True\n        b2c = 0\n    else:\n        b[2].disabled=False    \n        \n    if a3 == 0 and a2 == 0:\n        b[1].disabled=True\n        b1c = 0\n    else:\n        b[1].disabled=False   \n    \n    \n    if e2 == 0:\n        f[1].disabled=True\n        f1c = 0\n    else:\n        f[1].disabled=False\n    \n    \n    G = c.tf([b2c, b1c, b0], [a3, a2, a1, a0]) # Feedforward transfer function\n    H = c.tf([f1c, f0], [e2, e1, e0]) # Feedback transfer function\n\n    print('Feedforward transfer function:')\n    print(G)\n    print('Feedback transfer function:')\n    print(H)\n\ninput_data = w.interactive_output(transfer_function, {'a0':a[0], 'a1':a[1], 'a2':a[2], 'a3':a[3],\n                                                      'b0':b[0], 'b1':b[1], 'b2':b[2],\n                                                      'e0':e[0], 'e1':e[1], 'e2':e[2],\n                                                      'f0':f[0], 'f1':f[1]})\n\ndisplay(w.VBox([\n        w.HBox([w.VBox([w.Label('$G(s)=$')], layout=w.Layout(justify_content=\"center\", align_items='flex-start')),\n        w.VBox([w.HBox([b[2], w.Label('$s^2+$'), b[1], w.Label('$s+$'), b[0]],\n                       layout=w.Layout(justify_content='center')),\n                w.HBox([w.HTML(value='&lt;hr style=\"border-top: 1px solid black\"&gt;', layout=w.Layout(width='100%'))],\n                       layout=w.Layout(justify_content='center')),\n                w.HBox([a[3], w.Label('$s^3+$'), a[2], w.Label('$s^2+$'), a[1], w.Label('$s+$'), a[0]],\n                       layout=w.Layout(justify_content='center')) ],\n                layout=w.Layout(width='50%'))], layout=w.Layout(justify_content='center') ),\n        w.HTML(value='&lt;br&gt;&lt;br&gt;'),\n        w.HBox([w.VBox([w.Label('$H(s)=$')], layout=w.Layout(justify_content=\"center\", align_items='flex-start')),\n        w.VBox([w.HBox([f[1], w.Label('$s+$'), f[0]],\n                       layout=w.Layout(justify_content='center')),\n                w.HBox([w.HTML(value='&lt;hr style=\"border-top: 1px solid black\"&gt;', layout=w.Layout(width='100%'))],\n                       layout=w.Layout(justify_content='center')),\n                w.HBox([e[2], w.Label('$s^2+$'), e[1], w.Label('$s+$'), e[0]],\n                       layout=w.Layout(justify_content='center')) ],\n                layout=w.Layout(width='35%'))], layout=w.Layout(justify_content='center') )\n       ]), input_data)\n\n\n\n\n\n\n\nBased on these system components, the open- and closed-loop models can be calculated.\n\ndef feedback_function(a0, a1, a2, a3, b0, b1, b2, e0, e1, e2, f0, f1):\n\n    b1c = b1\n    b2c = b2\n    \n    f1c = f1\n    \n    global b, f\n       \n    if a3 == 0:\n        b2c = 0 \n        \n    if a3 == 0 and a2 == 0:\n        b1c = 0    \n    \n    if e2 == 0:\n        f1c = 0\n    \n    G = c.tf([b2c, b1c, b0], [a3, a2, a1, a0]) # Feedforward transfer function\n    H = c.tf([f1c, f0], [e2, e1, e0]) # Feedback transfer function\n    \n    Wol = c.series(G, H)\n    Wcl = c.feedback(G, H, -1)\n    \n    print('Open-loop transfer function:')\n    print(Wol)\n    print('Closed-loop transfer function:')\n    print(Wcl)\n    \nw.interactive_output(feedback_function, {'a0':a[0], 'a1':a[1], 'a2':a[2], 'a3':a[3],\n                                         'b0':b[0], 'b1':b[1], 'b2':b[2],\n                                         'e0':e[0], 'e1':e[1], 'e2':e[2],\n                                         'f0':f[0], 'f1':f[1]})\n\n\n\n\nObserve the differences in the time response between the two systems!\n\n# Figure definition\n\nfig1, (f1_ax1, f1_ax2) = plt.subplots(2, 1)\nfig1.set_size_inches((9.8, 5))\nfig1.set_tight_layout(True)\n\nf1_line1, = f1_ax1.plot([], [], lw=1, color='blue')\nf1_line2, = f1_ax1.plot([], [], lw=1, color='red')\nf1_line3, = f1_ax2.plot([], [], lw=1, color='blue')\nf1_line4, = f1_ax2.plot([], [], lw=1, color='red')\n\nf1_ax1.grid(which='both', axis='both', color='lightgray')\nf1_ax2.grid(which='both', axis='both', color='lightgray')\n\nf1_ax1.autoscale(enable=True, axis='x', tight=True)\nf1_ax2.autoscale(enable=True, axis='x', tight=True)\nf1_ax1.autoscale(enable=True, axis='y', tight=False)\nf1_ax2.autoscale(enable=True, axis='y', tight=False)\n\nf1_ax1.set_title('Step response', fontsize=11)\nf1_ax1.set_xlabel(r'$t\\/\\/$[s]', labelpad=0, fontsize=10)\nf1_ax1.set_ylabel(r'$v\\/\\/$[/]', labelpad=0, fontsize=10)\nf1_ax1.tick_params(axis='both', which='both', pad=0, labelsize=8)\n\nf1_ax2.set_title('Impulse response', fontsize=11)\nf1_ax2.set_xlabel(r'$t\\/\\/$[s]', labelpad=0, fontsize=10)\nf1_ax2.set_ylabel(r'$w\\/\\/$[/]', labelpad=0, fontsize=10)\nf1_ax2.tick_params(axis='both', which='both', pad=0, labelsize=8)\n\nf1_ax1.legend([f1_line1, f1_line2], ['Open-loop', 'Closed-loop'], loc='lower right')\nf1_ax2.legend([f1_line3, f1_line4], ['Open-loop', 'Closed-loop'], loc='upper right')\n\n\ndef time_analysis(a0, a1, a2, a3, b0, b1, b2, e0, e1, e2, f0, f1):\n\n    b1c = b1\n    b2c = b2\n    \n    f1c = f1\n    \n    global b, f\n       \n    if a3 == 0:\n        b2c = 0 \n        \n    if a3 == 0 and a2 == 0:\n        b1c = 0    \n    \n    if e2 == 0:\n        f1c = 0\n    \n    G = c.tf([b2c, b1c, b0], [a3, a2, a1, a0]) # Feedforward transfer function\n    H = c.tf([f1c, f0], [e2, e1, e0]) # Feedback transfer function\n    \n    Wol = c.series(G, H)\n    Wcl = c.feedback(G, H, -1)\n    \n    Ts_ol, step_ol = c.step_response(Wol)\n    Ts_cl, step_cl = c.step_response(Wcl)\n    Ti_ol, imp_ol = c.impulse_response(Wol)\n    Ti_cl, imp_cl = c.impulse_response(Wcl)\n    \n    global f1_line1, f1_line2, f1_line3, f1_line4\n    \n    f1_ax1.lines.remove(f1_line1)\n    f1_ax1.lines.remove(f1_line2)\n    f1_ax2.lines.remove(f1_line3)\n    f1_ax2.lines.remove(f1_line4)\n\n    f1_line1, = f1_ax1.plot(Ts_ol, step_ol, lw=1, color='blue')\n    f1_line2, = f1_ax1.plot(Ts_cl, step_cl, lw=1, color='red')\n    f1_line3, = f1_ax2.plot(Ti_ol, imp_ol, lw=1, color='blue')   \n    f1_line4, = f1_ax2.plot(Ti_cl, imp_cl, lw=1, color='red')\n    \n    f1_ax1.relim()\n    f1_ax2.relim()\n    f1_ax1.autoscale_view()\n    f1_ax2.autoscale_view()   \n    \nw.interactive_output(time_analysis, {'a0':a[0], 'a1':a[1], 'a2':a[2], 'a3':a[3],\n                                     'b0':b[0], 'b1':b[1], 'b2':b[2],\n                                     'e0':e[0], 'e1':e[1], 'e2':e[2],\n                                     'f0':f[0], 'f1':f[1]})\n\n\n\n\n\n\n\n\n\n\nCompare the frequency domain properties of the two systems!\n\nfig2, (f2_ax1, f2_ax2) = plt.subplots(2, 1)\nfig2.set_tight_layout(True)\ngrid2 = f2_ax1.get_gridspec()\n\nf2_line1, = f2_ax1.plot([], [])\nf2_line2, = f2_ax1.plot([], [])\nf2_line3, = f2_ax1.plot([], [])\nf2_line4, = f2_ax1.plot([], [])\nf2_line5, = f2_ax2.plot([], [])\nf2_line6, = f2_ax2.plot([], [])\n\nf2_line7 = f2_ax1.axhline(y=0, color='k', lw=0.5)\nf2_line8 = f2_ax1.axvline(x=0, color='k', lw=0.5)\n\nf2_ax1.grid(which='both', axis='both', color='lightgray')\nf2_ax2.grid(which='both', axis='both', color='lightgray')\n\ndef type_analysis(a0, a1, a2, a3, b0, b1, b2, e0, e1, e2, f0, f1, typeSelect):\n\n    b1c = b1\n    b2c = b2\n    f1c = f1\n    \n    global b, f\n       \n    if a3 == 0:\n        b2c = 0 \n        \n    if a3 == 0 and a2 == 0:\n        b1c = 0    \n    \n    if e2 == 0:\n        f1c = 0\n    \n    G = c.tf([b2c, b1c, b0], [a3, a2, a1, a0]) # Feedforward transfer function\n    H = c.tf([f1c, f0], [e2, e1, e0]) # Feedback transfer function\n    \n    Wol = c.series(G, H)\n    Wcl = c.feedback(G, H, -1)\n    \n    global fig2, grid2, f2_ax1, f2_ax2, f2_line1, f2_line2, f2_line3, f2_line4, f2_line5, f2_line6, f2_line7, f2_line8\n    \n    try:\n        f2_ax1.lines.remove(f2_line1)\n        f2_ax1.lines.remove(f2_line2)\n        f2_ax1.lines.remove(f2_line3)\n        f2_ax1.lines.remove(f2_line4)\n        f2_ax2.lines.remove(f2_line5)\n        f2_ax2.lines.remove(f2_line6)\n    except:\n        pass\n    \n    if typeSelect == 0: # Pole-Zero map\n        \n        fig2.set_size_inches((5, 5))\n        f2_ax2.set_visible(False)\n        grid2.set_height_ratios([100, 1])\n        \n        p_ol, z_ol = c.pzmap(Wol, Plot=False)\n        p_cl, z_cl = c.pzmap(Wcl, Plot=False)\n        \n        f2_ax1.autoscale(enable=True, axis='both', tight=False) \n        \n        px_ol = [x.real for x in p_ol] \n        py_ol = [x.imag for x in p_ol]\n        zx_ol = [x.real for x in z_ol]\n        zy_ol = [x.imag for x in z_ol]\n        \n        px_cl = [x.real for x in p_cl] \n        py_cl = [x.imag for x in p_cl]\n        zx_cl = [x.real for x in z_cl]\n        zy_cl = [x.imag for x in z_cl]\n        \n        f2_line1, = f2_ax1.plot(zx_ol, zy_ol, 'rs', fillstyle='none') \n        f2_line2, = f2_ax1.plot(px_ol, py_ol, 'bo', fillstyle='none')\n        f2_line3, = f2_ax1.plot(zx_cl, zy_cl, 'm^', fillstyle='none') \n        f2_line4, = f2_ax1.plot(px_cl, py_cl, 'cD', fillstyle='none')\n        f2_line5, = f2_ax2.plot([], [])\n        f2_line6, = f2_ax2.plot([], [])\n        \n        f2_line7.set_visible(True)\n        f2_line8.set_visible(True)\n        \n        f2_ax1.set_title('Pole-Zero map', fontsize=11)\n        f2_ax1.set_xscale('linear')\n        f2_ax1.set_xlabel(r'Re', labelpad=0, fontsize=10)\n        f2_ax1.set_ylabel(r'Im', labelpad=0, fontsize=10)\n        f2_ax1.tick_params(axis='both', which='both', pad=0, labelsize=8)\n        \n        f2_ax1.legend((f2_line1, f2_line2, f2_line3, f2_line4),\n                      ('Zero (Open-loop)', 'Pole (Open-loop)', 'Zero (Closed-loop)', 'Pole (Closed-loop)'))\n    \n    elif typeSelect == 1: # Bode plot\n        \n        fig2.set_size_inches((9.6, 5))\n        f2_ax2.set_visible(True)\n        grid2.set_height_ratios([1, 1])\n        \n        m_ol, p_ol, o_ol = c.bode(Wol, Plot=False)\n        m_cl, p_cl, o_cl = c.bode(Wcl, Plot=False)\n        \n        f2_ax1.autoscale(enable=True, axis='x', tight=True)\n        f2_ax2.autoscale(enable=True, axis='x', tight=True)\n        f2_ax1.autoscale(enable=True, axis='y', tight=False)\n        f2_ax2.autoscale(enable=True, axis='y', tight=False)\n        \n        f2_line1, = f2_ax1.plot(o_ol, m_ol, lw=1, color='blue') \n        f2_line2, = f2_ax1.plot(o_cl, m_cl, lw=1, color='red')\n        f2_line3, = f2_ax1.plot([], [])\n        f2_line4, = f2_ax1.plot([], [])\n        f2_line5, = f2_ax2.plot(o_ol, p_ol, lw=1, color='blue')\n        f2_line6, = f2_ax2.plot(o_cl, p_cl, lw=1, color='red')\n        \n        f2_line7.set_visible(False)\n        f2_line8.set_visible(False)\n        \n        f2_ax1.set_title('Bode magnitude plot', fontsize=11)\n        f2_ax1.set_xscale('log')\n        f2_ax1.set_xlabel(r'$\\omega\\/[\\frac{rad}{s}]$', labelpad=0, fontsize=10)\n        f2_ax1.set_ylabel(r'$A\\/[dB]$', labelpad=0, fontsize=10)\n        f2_ax1.tick_params(axis='both', which='both', pad=0, labelsize=8)\n\n        f2_ax2.set_title('Bode phase plot', fontsize=11)\n        f2_ax2.set_xscale('log')\n        f2_ax2.set_xlabel(r'$\\omega\\/[\\frac{rad}{s}]$', labelpad=0, fontsize=10)\n        f2_ax2.set_ylabel(r'$\\phi\\/[°]$', labelpad=0, fontsize=10)\n        f2_ax2.tick_params(axis='both', which='both', pad=0, labelsize=8)\n        \n        f2_ax1.legend((f2_line1, f2_line2), ('Open-loop', 'Closed-loop'))\n        f2_ax2.legend((f2_line5, f2_line6), ('Open-loop', 'Closed-loop'))\n        \n    else: # Nyquist plot\n        \n        fig2.set_size_inches((5, 5))\n        f2_ax2.set_visible(False)\n        grid2.set_height_ratios([100, 1])\n        \n        _, _, ob_ol = c.nyquist_plot(Wol, Plot=False)   # Small resolution plot to determine bounds  \n        _, _, ob_cl = c.nyquist_plot(Wcl, Plot=False)\n          \n        r_ol, i_ol, _ = c.nyquist(Wol, omega=np.logspace(np.log10(ob_ol[0]), np.log10(ob_ol[-1]), 1000), Plot=False)\n        r_cl, i_cl, _ = c.nyquist(Wcl, omega=np.logspace(np.log10(ob_cl[0]), np.log10(ob_cl[-1]), 1000), Plot=False)\n        \n        f2_ax1.autoscale(enable=True, axis='both', tight=False)\n        \n        f2_line1, = f2_ax1.plot(r_ol, i_ol, lw=1, color='blue') \n        f2_line2, = f2_ax1.plot(r_cl, i_cl, lw=1, color='red')\n        f2_line3, = f2_ax1.plot([], [])\n        f2_line4, = f2_ax1.plot([], [])\n        f2_line5, = f2_ax2.plot([], [])\n        f2_line6, = f2_ax2.plot([], [])\n        \n        f2_line7.set_visible(True)\n        f2_line8.set_visible(True)\n        \n        f2_ax1.set_title('Nyquist plot', fontsize=11)\n        f2_ax1.set_xscale('linear')\n        f2_ax1.set_xlabel(r'Re', labelpad=0, fontsize=10)\n        f2_ax1.set_ylabel(r'Im', labelpad=0, fontsize=10)\n        f2_ax1.tick_params(axis='both', which='both', pad=0, labelsize=8)\n        \n        f2_ax1.legend((f2_line1, f2_line2), ('Open-loop', 'Closed-loop'))\n        \n    f2_ax1.relim(visible_only=True)\n    f2_ax2.relim(visible_only=True)\n    f2_ax1.autoscale_view()\n    f2_ax2.autoscale_view() \n        \n    \nw.interactive_output(type_analysis, {'a0':a[0], 'a1':a[1], 'a2':a[2], 'a3':a[3],\n                                     'b0':b[0], 'b1':b[1], 'b2':b[2],\n                                     'e0':e[0], 'e1':e[1], 'e2':e[2],\n                                     'f0':f[0], 'f1':f[1], 'typeSelect':typeSelect})"
  },
  {
    "objectID": "ICCT_en/examples/03/FD-02_Bode_Diagram_Formulation.html",
    "href": "ICCT_en/examples/03/FD-02_Bode_Diagram_Formulation.html",
    "title": "Bode diagram formulation",
    "section": "",
    "text": "%matplotlib notebook\nimport control as c\nimport ipywidgets as w\nimport numpy as np\n\nfrom IPython.display import display, HTML, Math\nimport matplotlib.pyplot as plt\nimport matplotlib.animation as animation\n\ndisplay(HTML('&lt;script&gt; $(document).ready(function() { $(\"div.input\").hide(); }); &lt;/script&gt;'))\n\n\n\n\nThroughout the following example, we will analyze the phase and magnitude transfer characteristics of Linear Time-Invariant (LTI) systems in the frequency domain. These properties are usually displayed in a pair of graphs, called the Bode diagram. The magnitude is expressed in decibels, the phase in angles, and they are plotted against the angular frequency or angular frequency (usually with a logarithmic scale) of the sinusoid input signal.\nBy analyzing these graphs, it is possible to determine some of the dynamic properties of the systems they represent.\nSelect a system type!\n\ndef print_model(model):\n    \n    print ('\\nThe selected system model:')\n\n    if model == 0:\n        display(Math(r'$$G(s)=\\frac{s-Z}{s-P}$$'))\n    elif model == 1:\n        display(Math(r'$$G(s)=\\frac{K_i(s-Z)}{s(s-P)}$$'))\n    elif model == 2:\n        display(Math(r'$$G(s)=\\frac{K_d\\cdot s}{(s-P)}$$'))\n    elif model == 3:\n        display(Math(r'$$G(s)=\\frac{s-Z}{(s-P_1)(s-P_2)}$$'))\n    else:\n        display(Math(r'$$G(s)=\\frac{s-Z}{s^2+2\\zeta\\omega_0s+{\\omega_0}^2}$$'))\n            \n\nsystemSelect = w.ToggleButtons(\n    options=[('First-Order', 0), ('First-Order Integrating', 1), ('First-Order Differentiating', 2),\n             ('Second-Order Overdamped', 3), ('Second-Order Underdamped', 4)],\n    description='System: ', layout=w.Layout(width='100%'))\n\nsystemSelect.style.button_width='48%'\n\ninput_data = w.interactive_output(print_model, {'model': systemSelect})\n\ndisplay(systemSelect, input_data)\n\n\n\n\n\n\n\nThe Bode diagram can be approximated by asymptotic lines, that are easy to calculate by hand using the following rules:\nMagnitude plot:\n\n\nAt every pole, the slope increases, and at every zero, it decreases by 20dB. The effects of overlapping poles and zeros combine.\n\nThe initial slope is determined by the number of zeros and poles not shown on the plot (for example, integrating and differentiating components), calculated according to the previous rules. With no poles or zeros outside of the plotting area, the slope is horizontal.\n\n\nThe initial value is determined by substituting the initial point into the equation: \\(M_{start}=|G(j\\omega_{start})|\\) where \\(j\\omega=s\\)\n\n\nRight half-plane (unstable) poles and zeros work opposite to their stable counterparts. However, they are not represented in this example.\n\n\n Phase plot:\n\n\nIf the static gain (K) of the function form \\(G(s)= \\prod{K\\frac{(b_i-Z_i)}{(a_i-P_i)}}\\) is positive, the starting phase is 0°, otherwise -180°.\n\n\nPoles and zeros before the starting point (for example, integrating and differentiating components) increase (zeros) or decrease (poles) the starting phase by 90°.\n\n\nPoles decrease, and zeros increase the phase by 90°, which can be represented by a 45° slope around their frequency (starting a decade earlier and ending a decade later). Overlapping components combine their effects.\n\n\nSimilarly to the magnitude plot, right half-plane (unstable) poles and zeros work opposite to their stable counterparts. However, they are not represented in this example.\n\n\nReal-valued poles and zeros are represented directly on the Bode plot with their absolute values, but for complex pairs, \\(\\omega_0\\) has to be calculated, where they are represented as second-order poles. If plotting the Bode diagram’s frequency axis in Hz units, all values have to be divided by \\(2\\pi\\)!\nThe asymptotic plot can be further refined by adding peaks and curvatures, but in this example, we stick to the straight-lines only version.\nSelect parameters for the system; observe the changes in the Bode plot! At which positions does the asymptotic approximation fit well the original characteristics? Why?\n\ndef calculate_tf(P1, P2, Z, Zb, model):\n    \n    if model == 0:\n        if Zb:\n            W = c.tf([1, Z], [1, P1])\n        else:\n            W = c.tf([1], [1, P1])\n    elif model == 1:\n        if Zb:\n            W = c.tf([P2, P2*Z], [1, -P1, 0])\n        else:\n            W = c.tf([P2], [1, P1, 0])\n    elif model == 2:\n         W = c.tf([P2, 0], [1, P1])\n    elif model == 3:\n        if Zb:\n            W = c.tf([1, Z], [1, P1+P2, P1*P2])\n        else:\n            W = c.tf([1], [1, P1+P2, P1*P2])\n    else:\n        if Zb:\n            W = c.tf([1, Z], [1, 2*P1*P2, P1*P1])\n        else:\n            W = c.tf([1], [1, 2*P1*P2, P1*P1])\n\n    print('\\n The resulting transfer function:')\n    print(W)\n    \n    poles, zeros = c.pzmap(W, Plot=False)\n    \n    print('Zeros of the model:')\n    print(zeros)\n    print('Poles of the model:')\n    print(poles)\n\ndef draw_controllers(model):\n    \n    global P1_slider, P2_slider, Z_slider, Z_button\n\n    if model == 0:\n        P1_slider = w.FloatLogSlider(value=0.5, base=10, min=-3, max=3, description='Pole', continuous_update=False,\n                                 layout=w.Layout(width='auto', flex='5 5 auto'), disabled=False)\n        P2_slider = w.FloatLogSlider(value=1, base=10, min=-3, max=3, description='', continuous_update=False,\n                                 layout=w.Layout(width='auto', flex='5 5 auto'), disabled=True)\n        Z_slider = w.FloatLogSlider(value=1, base=10, min=-3, max=3, description='Zero', continuous_update=False,\n                                 layout=w.Layout(width='auto', flex='5 5 auto'), disabled=False)\n        Z_button = w.ToggleButton(value=True, description='Add/remove zero',\n                               layout=w.Layout(width='auto'), disabled=False)\n\n    elif model == 1:\n        P1_slider = w.FloatLogSlider(value=0.5, base=10, min=-3, max=3, description='Pole', continuous_update=False,\n                                 layout=w.Layout(width='auto', flex='5 5 auto'), disabled=False)\n        P2_slider = w.FloatLogSlider(value=1, base=10, min=-3, max=3, description='Ki', continuous_update=False,\n                                 layout=w.Layout(width='auto', flex='5 5 auto'), disabled=False)\n        Z_slider = w.FloatLogSlider(value=1, base=10, min=-3, max=3, description='Zero', continuous_update=False,\n                                 layout=w.Layout(width='auto', flex='5 5 auto'), disabled=False)\n        Z_button = w.ToggleButton(value=True, description='Add/remove zero',\n                               layout=w.Layout(width='auto'), disabled=False)\n\n        \n    elif model == 2:\n        P1_slider = w.FloatLogSlider(value=0.5, base=10, min=-3, max=3, description='Pole', continuous_update=False,\n                                 layout=w.Layout(width='auto', flex='5 5 auto'), disabled=False)\n        P2_slider = w.FloatLogSlider(value=1, base=10, min=-3, max=3, description='Kd', continuous_update=False,\n                                 layout=w.Layout(width='auto', flex='5 5 auto'), disabled=False)\n        Z_slider = w.FloatLogSlider(value=1, base=10, min=-3, max=3, description='Zero', continuous_update=False,\n                                 layout=w.Layout(width='auto', flex='5 5 auto'), disabled=True)\n        Z_button = w.ToggleButton(value=True, description='Add/remove zero',\n                               layout=w.Layout(width='auto'), disabled=True)\n        \n    elif model == 3:\n        P1_slider = w.FloatLogSlider(value=0.5, base=10, min=-3, max=3, description='Pole 1', continuous_update=False,\n                                 layout=w.Layout(width='auto', flex='5 5 auto'), disabled=False)\n        P2_slider = w.FloatLogSlider(value=1, base=10, min=-3, max=3, description='Pole 2', continuous_update=False,\n                                 layout=w.Layout(width='auto', flex='5 5 auto'), disabled=False)\n        Z_slider = w.FloatLogSlider(value=1, base=10, min=-3, max=3, description='Zero', continuous_update=False,\n                                 layout=w.Layout(width='auto', flex='5 5 auto'), disabled=False)\n        Z_button = w.ToggleButton(value=True, description='Add/remove zero',\n                               layout=w.Layout(width='auto'), disabled=False)\n        \n    else:\n        P1_slider = w.FloatLogSlider(value=0.5, base=10, min=-3, max=3, description=r'$\\omega_0$', continuous_update=False,\n                                 layout=w.Layout(width='auto', flex='5 5 auto'), disabled=False)\n        P2_slider = w.FloatLogSlider(value=1, base=10, min=-4, max=1, description=r'$\\zeta$', continuous_update=False,\n                                 layout=w.Layout(width='auto', flex='5 5 auto'), disabled=False)\n        Z_slider = w.FloatLogSlider(value=1, base=10, min=-3, max=3, description='Zero', continuous_update=False,\n                                 layout=w.Layout(width='auto', flex='5 5 auto'), disabled=False)\n        Z_button = w.ToggleButton(value=True, description='Add/remove zero',\n                               layout=w.Layout(width='auto'), disabled=False)\n        \n    \n    input_data2 = w.interactive_output(calculate_tf, {'P1': P1_slider, 'P2': P2_slider, 'Z': Z_slider,\n                                                      'Zb': Z_button, 'model': systemSelect})\n    \n    display(w.HBox([P1_slider, P2_slider, Z_button, Z_slider]), input_data2)\n    \n    \nw.interactive_output(draw_controllers, {'model': systemSelect})\n\n\n\n\n\n# Figure definition\n\nfig1, ((f1_ax1), (f1_ax2)) = plt.subplots(2, 1)\nfig1.set_size_inches((9.8, 5))\nfig1.set_tight_layout(True)\n\nf1_line1, = f1_ax1.plot([], [], lw=1, color='dimgrey')\nf1_line3, = f1_ax1.plot([], [], lw=1, color='dimgrey')\nf1_line2, = f1_ax2.plot([], [], lw=1.5, color='limegreen')\nf1_line4, = f1_ax2.plot([], [], lw=1.5, color='limegreen')\n\nf1_line5, = f1_ax1.plot([], [], color='blue', ls='--')\nf1_line6, = f1_ax1.plot([], [], color='blue', ls='--')\nf1_line7, = f1_ax1.plot([], [], color='red', ls='--')\n\nf1_line8, = f1_ax2.plot([], [], color='blue', ls='--')\nf1_line9, = f1_ax2.plot([], [], color='blue', ls='--')\nf1_line10, = f1_ax2.plot([], [], color='red', ls='--')\n\nf1_line11, = f1_ax2.plot([], [])\nf1_line12, = f1_ax2.plot([], [])\nf1_line13, = f1_ax2.plot([], [])\nf1_line14, = f1_ax2.plot([], [])\nf1_line15, = f1_ax2.plot([], [])\nf1_line16, = f1_ax2.plot([], [])\n\n\nf1_ax1.grid(which='both', axis='both', color='lightgray')\nf1_ax2.grid(which='both', axis='both', color='lightgray')\n\nf1_ax1.autoscale(enable=True, axis='x', tight=True)\nf1_ax2.autoscale(enable=True, axis='x', tight=True)\nf1_ax1.autoscale(enable=True, axis='y', tight=False)\nf1_ax2.autoscale(enable=True, axis='y', tight=False)\n\nf1_ax1.set_title('Bode magnitude plot', fontsize=11)\nf1_ax1.set_xscale('log')\nf1_ax1.set_xlabel(r'$\\omega\\/[\\frac{rad}{s}]$', labelpad=0, fontsize=10)\nf1_ax1.set_ylabel(r'$A\\/$[dB]', labelpad=0, fontsize=10)\nf1_ax1.tick_params(axis='both', which='both', pad=0, labelsize=8)\n\nf1_ax2.set_title('Bode phase plot', fontsize=11)\nf1_ax2.set_xscale('log')\nf1_ax2.set_xlabel(r'$\\omega\\/[\\frac{rad}{s}]$', labelpad=0, fontsize=10)\nf1_ax2.set_ylabel(r'$\\phi\\/$[°]', labelpad=0, fontsize=10)\nf1_ax2.tick_params(axis='both', which='both', pad=0, labelsize=8)\n\nf1_ax1.legend([f1_line1, f1_line2, f1_line5, f1_line7], ['Exact', 'Asymptotic', 'Poles', 'Zeros'], loc='upper right')\nf1_ax2.legend([f1_line3, f1_line4, f1_line8, f1_line10], ['Exact', 'Asymptotic', 'Poles', 'Zeros'], loc='upper right')\n\n# System model\n\ndef draw_bode(P1, P2, Z, Zb, model):\n\n    if model == 0:\n        if Zb:\n            W = c.tf([1, Z], [1, P1])\n        else:\n            W = c.tf([1], [1, P1])\n    elif model == 1:\n        if Zb:\n            W = c.tf([P2, P2*Z], [1, P1, 0])\n        else:\n            W = c.tf([P2], [1, P1, 0])\n    elif model == 2:\n         W = c.tf([P2, 0], [1, P1])\n    elif model == 3:\n        if Zb:\n            W = c.tf([1, Z], [1, P1+P2, P1*P2])\n        else:\n            W = c.tf([1], [1, P1+P2, P1*P2])\n    else:\n        if Zb:\n            W = c.tf([1, Z], [1, 2*P1*P2, P1*P1])\n        else:\n            W = c.tf([1], [1, 2*P1*P2, P1*P1])            \n    \n    _, _, ob = c.bode_plot(W, Plot=False)   # Small resolution plot to determine bounds\n    \n    mag, phase, omega = c.bode_plot(W, omega=np.logspace(np.log10(ob[0]), np.log10(ob[-1]), 100), Plot=False)   # Bode-plot         \n    poles, zeros = c.pzmap(W, Plot=False) # Poles and zeros\n    \n    log_omega = np.log10(omega)    \n    \n    mag_approx = np.full_like(mag, 20 * np.log10(mag[0]))\n    phase_approx = np.full_like(phase, 0)\n    \n    pole_x = []\n    zero_x = []\n    break_x = []\n    \n    for p in poles:\n        if p.imag == 0:\n            om = abs(p.real)\n        else:\n            om = np.sqrt(p.real*p.real + p.imag*p.imag)\n            \n        if om == 0:\n            mag_approx = mag_approx - 20 * (log_omega - np.log10(omega[0]))\n            phase_approx = phase_approx - 90\n        else:\n            mag_approx = mag_approx - 20 * np.maximum(log_omega - np.log10(om), 0)\n            phase_approx = phase_approx + 45 * np.maximum(log_omega - np.log10(om) - 1, 0)\n            phase_approx = phase_approx - 45 * np.maximum(log_omega - np.log10(om) + 1, 0)\n            \n            pole_x.append(om)\n            break_x.append(om/10)\n            break_x.append(om*10)\n            \n    for z in zeros:\n        if z.imag == 0:\n            om = abs(z.real)\n        else:\n            om = np.sqrt(z.real*z.real + z.imag*z.imag)\n            \n        if om == 0:\n            mag_approx = mag_approx + 20 * (log_omega - np.log10(omega[0]))\n            phase_approx = phase_approx + 90\n        else:\n            mag_approx = mag_approx + 20 * np.maximum(log_omega - np.log10(om), 0)\n            phase_approx = phase_approx - 45 * np.maximum(log_omega - np.log10(om) - 1, 0)\n            phase_approx = phase_approx + 45 * np.maximum(log_omega - np.log10(om) + 1, 0)\n            \n            zero_x.append(om)\n            break_x.append(om/10)\n            break_x.append(om*10)\n            \n    global f1_line1, f1_line2, f1_line3, f1_line4\n    global f1_line5, f1_line6, f1_line7, f1_line8, f1_line9, f1_line10\n    global f1_line11, f1_line12, f1_line13, f1_line14, f1_line15, f1_line16\n    \n    f1_ax1.lines.remove(f1_line1)\n    f1_ax1.lines.remove(f1_line3)\n    f1_ax2.lines.remove(f1_line2)\n    f1_ax2.lines.remove(f1_line4)\n\n    f1_line1, = f1_ax1.plot(omega, 20*np.log10(mag), lw=1, color='dimgrey')\n    f1_line3, = f1_ax1.plot(omega, mag_approx, lw=1.5, color='limegreen')\n    f1_line2, = f1_ax2.plot(omega, phase*180/np.pi, lw=1, color='dimgrey')   \n    f1_line4, = f1_ax2.plot(omega, phase_approx, lw=1.5, color='limegreen')\n    \n    f1_ax1.lines.remove(f1_line5)\n    f1_ax1.lines.remove(f1_line6)\n    f1_ax1.lines.remove(f1_line7)\n    f1_ax2.lines.remove(f1_line8)\n    f1_ax2.lines.remove(f1_line9)\n    f1_ax2.lines.remove(f1_line10)\n    \n    if len(pole_x) &gt;= 1:\n        f1_line5 = f1_ax1.axvline(pole_x[0], color='blue', ls='--', ymin=0.03, ymax=0.97, marker='v')\n        f1_line8 = f1_ax2.axvline(pole_x[0], color='blue', ls='--', ymin=0.03, ymax=0.97, marker='v')\n    else:\n        f1_line5, = f1_ax1.plot([], [])\n        f1_line8, = f1_ax2.plot([], [])\n    if len(pole_x) == 2:\n        f1_line6 = f1_ax1.axvline(pole_x[1], color='blue', ls='--', ymin=0.03, ymax=0.97, marker='v')\n        f1_line9 = f1_ax2.axvline(pole_x[1], color='blue', ls='--', ymin=0.03, ymax=0.97, marker='v')\n    else:\n        f1_line6, = f1_ax1.plot([], [])\n        f1_line9, = f1_ax2.plot([], [])\n    if len(zero_x) == 1:\n        f1_line7 = f1_ax1.axvline(zero_x[0], color='red', ls='--', ymin=0.03, ymax=0.97, marker='^')\n        f1_line10 = f1_ax2.axvline(zero_x[0], color='red', ls='--', ymin=0.03, ymax=0.97, marker='^')\n    else:\n        f1_line7, = f1_ax1.plot([], [])\n        f1_line10, = f1_ax2.plot([], [])\n        \n    f1_ax2.lines.remove(f1_line11)\n    f1_ax2.lines.remove(f1_line12)\n    f1_ax2.lines.remove(f1_line13)\n    f1_ax2.lines.remove(f1_line14)\n    f1_ax2.lines.remove(f1_line15)\n    f1_ax2.lines.remove(f1_line16)\n        \n    if len(break_x) &gt;= 1:\n        f1_line11 = f1_ax2.axvline(break_x[0], color='limegreen', lw=0.5, ls=(0, (8, 5)))\n        f1_line12 = f1_ax2.axvline(break_x[1], color='limegreen', lw=0.5, ls=(0, (8, 5)))\n    else:\n        f1_line11, = f1_ax2.plot([], [])\n        f1_line12, = f1_ax2.plot([], [])\n        \n    if len(break_x) &gt;= 3:\n        f1_line13 = f1_ax2.axvline(break_x[2], color='limegreen', lw=0.5, ls=(0, (8, 5)))\n        f1_line14 = f1_ax2.axvline(break_x[3], color='limegreen', lw=0.5, ls=(0, (8, 5)))\n    else:\n        f1_line13, = f1_ax2.plot([], [])\n        f1_line14, = f1_ax2.plot([], [])\n           \n    if len(break_x) &gt;= 5:\n        f1_line15 = f1_ax2.axvline(break_x[4], color='limegreen', lw=0.5, ls=(0, (8, 5)))\n        f1_line16 = f1_ax2.axvline(break_x[5], color='limegreen', lw=0.5, ls=(0, (8, 5)))\n    else:\n        f1_line15, = f1_ax2.plot([], [])\n        f1_line16, = f1_ax2.plot([], [])\n\n    f1_ax1.relim()\n    f1_ax2.relim()\n    f1_ax1.autoscale_view()\n    f1_ax2.autoscale_view()\n    \n\ndef link_controls(model):\n    w.interactive_output(draw_bode, {'P1': P1_slider, 'P2': P2_slider, 'Z': Z_slider,\n                                     'Zb': Z_button, 'model': systemSelect})\n    \nw.interactive_output(link_controls, {'model': systemSelect})"
  },
  {
    "objectID": "ICCT_en/examples/02/TD-18-Root-locus.html",
    "href": "ICCT_en/examples/02/TD-18-Root-locus.html",
    "title": "Root locus",
    "section": "",
    "text": "# Erasmus+ ICCT project (2018-1-SI01-KA203-047081)\n\n# Toggle cell visibility\n\nfrom IPython.display import HTML\ndisplay(HTML('&lt;script&gt; $(document).ready(function() { $(\"div.input\").hide(); }); &lt;/script&gt;'))\n\n\nToggle cell visibility here.\n\n\n\n%matplotlib notebook\nimport matplotlib.pyplot as plt\nimport numpy as np\nimport sympy as sym\nimport scipy.signal as signal\nfrom ipywidgets import widgets, interact\nimport control as cn\n\nRoot locus is a plot of the location of closed-loop system poles in relation with a certain parameter (typically amplification). It can be shown that the curves start in the open-loop poles and end up in the open-loop zeros (or infinity). The location of closed-loop system poles not only gives an indication of system stability, but other closed-loop system response properties such as overshoot, rise time and settling time can also be inferred from pole location.\n\n\nHow to use this notebook?\n\nClick on P0, P1, I0 or I1 to toggle between the following objects: proportional of the zeroth, first or second order, or an integral one of zeroth or first order. The transfer function of P0 object is \\(k_p\\) (in this example \\(k_p=2\\)), of PI object \\(\\frac{k_p}{\\tau s+1}\\) (in this example \\(k_p=1\\) and \\(\\tau=2\\)), of IO object \\(\\frac{k_i}{s}\\) (in this example \\(k_i=\\frac{1}{10}\\)) and of I1 object \\(\\frac{k_i}{s(\\tau s +1)}\\) (in this example \\(k_i=1\\) and \\(\\tau=10\\)).\nClick on the P, PI, PD or PID button to toogle between proportional, proportional-integral, proportional-derivative or proportional–integral–derivative control algorithm types.\nMove the sliders to change the values of proportional (\\(K_p\\)), integral (\\(T_i\\)) and derivative (\\(T_d\\)) PID tunning coefficients.\nMove the slider \\(t_{max}\\) to change the maximum value of the time on x axis.\n\n\nA = 10\na=0.1\ns, P, I, D = sym.symbols('s, P, I, D')\n\nobj = 1/(A*s)\nPID = P + P/(I*s) + P*D*s#/(a*D*s+1)\nsystem = obj*PID/(1+obj*PID)\nnum = [sym.fraction(system.factor())[0].expand().coeff(s, i) for i in reversed(range(1+sym.degree(sym.fraction(system.factor())[0], gen=s)))]\nden = [sym.fraction(system.factor())[1].expand().coeff(s, i) for i in reversed(range(1+sym.degree(sym.fraction(system.factor())[1], gen=s)))]\nsystem_func_open = obj*PID\nnum_open = [sym.fraction(system_func_open.factor())[0].expand().coeff(s, i) for i in reversed(range(1+sym.degree(sym.fraction(system_func_open.factor())[0], gen=s)))]\nden_open = [sym.fraction(system_func_open.factor())[1].expand().coeff(s, i) for i in reversed(range(1+sym.degree(sym.fraction(system_func_open.factor())[1], gen=s)))]\n    \n# make figure\nfig = plt.figure(figsize=(9.8, 4),num='Root locus')\nplt.subplots_adjust(wspace=0.3)\n\n# add axes\nax = fig.add_subplot(121)\nax.grid(which='both', axis='both', color='lightgray')\nax.set_title('Time response')\nax.set_xlabel('t [s]')\nax.set_ylabel('input, output')\n\nrlocus = fig.add_subplot(122)\n\n\n# plot step function and responses (initalisation)\ninput_plot, = ax.plot([],[],'C0', lw=1, label='input')\nresponse_plot, = ax.plot([],[], 'C1', lw=2, label='output')\nax.legend()\n\nrlocus_plot, = rlocus.plot([], [], 'r')\n\nplt.show()\n\nsystem_open = None\nsystem_close = None\ndef update_plot(KP, TI, TD, Time_span):\n    global num, den, num_open, den_open\n    global system_open, system_close\n    num_temp = [float(i.subs(P,KP).subs(I,TI).subs(D,TD)) for i in num]\n    den_temp = [float(i.subs(P,KP).subs(I,TI).subs(D,TD)) for i in den]\n    system = signal.TransferFunction(num_temp, den_temp)\n    system_close = system\n    num_temp_open = [float(i.subs(P,KP).subs(I,TI).subs(D,TD)) for i in num_open]\n    den_temp_open = [float(i.subs(P,KP).subs(I,TI).subs(D,TD)) for i in den_open]\n    system_open = signal.TransferFunction(num_temp_open, den_temp_open)\n    \n    rlocus.clear()\n    r, k, xlim, ylim = cn.root_locus_modified(system_open, Plot=False)\n#     r, k = cn.root_locus(system_open, Plot=False)\n    #rlocus.scatter(r)\n    #plot closed loop poles and zeros\n    poles = np.roots(system.den)\n    rlocus.plot(np.real(poles), np.imag(poles), 'kx')\n    zeros = np.roots(system.num)\n    if zeros.size &gt; 0:\n        rlocus.plot(np.real(zeros), np.imag(zeros), 'ko', alpha=0.5)\n    # plot open loop poles and zeros\n    poles = np.roots(system_open.den)\n    rlocus.plot(np.real(poles), np.imag(poles), 'x', alpha=0.5)\n    zeros = np.roots(system_open.num)\n    if zeros.size &gt; 0:\n        rlocus.plot(np.real(zeros), np.imag(zeros), 'o')\n    #plot root locus\n    for index, col in enumerate(r.T):\n        rlocus.plot(np.real(col), np.imag(col), 'b', alpha=0.5)\n    \n    rlocus.set_title('Root locus')\n    rlocus.set_xlabel('Re')\n    rlocus.set_ylabel('Im')\n    rlocus.grid(which='both', axis='both', color='lightgray')\n    \n    rlocus.axhline(linewidth=.3, color='g')\n    rlocus.axvline(linewidth=.3, color='g')\n    rlocus.set_ylim(ylim)\n    rlocus.set_xlim(xlim)\n    \n    time = np.linspace(0, Time_span, 300)\n    u = np.ones_like(time)\n    u[0] = 0\n    time, response = signal.step(system, T=time)\n        \n    response_plot.set_data(time, response)\n    input_plot.set_data(time, u)\n    \n    ax.set_ylim([min([np.min(u), min(response),-.1]),min(100,max([max(response)*1.05, 1, 1.05*np.max(u)]))])\n    ax.set_xlim([-0.1,max(time)])\n\n    plt.show()\n\ncontroller_ = PID\nobject_ = obj\n\ndef calc_tf():\n    global num, den, controller_, object_, num_open, den_open\n    system_func = object_*controller_/(1+object_*controller_)\n    \n    num = [sym.fraction(system_func.factor())[0].expand().coeff(s, i) for i in reversed(range(1+sym.degree(sym.fraction(system_func.factor())[0], gen=s)))]\n    den = [sym.fraction(system_func.factor())[1].expand().coeff(s, i) for i in reversed(range(1+sym.degree(sym.fraction(system_func.factor())[1], gen=s)))]\n    \n    system_func_open = object_*controller_\n    num_open = [sym.fraction(system_func_open.factor())[0].expand().coeff(s, i) for i in reversed(range(1+sym.degree(sym.fraction(system_func_open.factor())[0], gen=s)))]\n    den_open = [sym.fraction(system_func_open.factor())[1].expand().coeff(s, i) for i in reversed(range(1+sym.degree(sym.fraction(system_func_open.factor())[1], gen=s)))]\n    \n    update_plot(Kp_widget.value, Ti_widget.value, Td_widget.value, time_span_widget.value)\n\ndef transfer_func(controller_type):\n    global controller_\n    proportional = P\n    integral = P/(I*s)\n    differential = P*D*s/(a*D*s+1)\n    if controller_type =='P':\n        controller_func = proportional\n        Kp_widget.disabled=False\n        Ti_widget.disabled=True\n        Td_widget.disabled=True\n    elif controller_type =='PI':\n        controller_func = proportional+integral\n        Kp_widget.disabled=False\n        Ti_widget.disabled=False\n        Td_widget.disabled=True\n    elif controller_type == 'PD':\n        controller_func = proportional+differential\n        Kp_widget.disabled=False\n        Ti_widget.disabled=True\n        Td_widget.disabled=False\n    else:\n        controller_func = proportional+integral+differential\n        Kp_widget.disabled=False\n        Ti_widget.disabled=False\n        Td_widget.disabled=False\n    \n    controller_ = controller_func\n    calc_tf()\n    \ndef transfer_func_obj(object_type):\n    global object_\n    if object_type == 'P0':\n        object_ = 2\n    elif object_type == 'P1':\n        object_ = 1/(2*s+1) \n    elif object_type == 'I0':\n        object_ = 1/(10*s)\n    elif object_type == 'I1':\n        object_ = 1/(s*(10*s+1))\n    calc_tf()\n\nstyle = {'description_width': 'initial'}\n\ndef buttons_controller_clicked(event):\n    controller = buttons_controller.options[buttons_controller.index]\n    transfer_func(controller)\nbuttons_controller = widgets.ToggleButtons(\n    options=['P', 'PI', 'PD', 'PID'],\n    description='Select control algorithm type:',\n    disabled=False,\n    style=style)\nbuttons_controller.observe(buttons_controller_clicked)\n\ndef buttons_object_clicked(event):\n    object_ = buttons_object.options[buttons_object.index]\n    transfer_func_obj(object_)\nbuttons_object = widgets.ToggleButtons(\n    options=['P0', 'P1', 'I0', 'I1'],\n    description='Select object:',\n    disabled=False,\n    style=style)\nbuttons_object.observe(buttons_object_clicked)\n\n    \nKp_widget = widgets.FloatLogSlider(value=.5,min=-3,max=2.1,step=.001,description=r'\\(K_p\\)',\n    disabled=False,continuous_update=True,orientation='horizontal',readout=True,readout_format='.3f')\nTi_widget = widgets.FloatLogSlider(value=1.,min=-3,max=1.8,step=.001,description=r'\\(T_{i} \\)',\n    disabled=False,continuous_update=True,orientation='horizontal',readout=True,readout_format='.3f')\nTd_widget = widgets.FloatLogSlider(value=1.,min=-3,max=1.8,step=.001,description=r'\\(T_{d} \\)',\n    disabled=False,continuous_update=True,orientation='horizontal',readout=True,readout_format='.3f')\n\ntime_span_widget = widgets.FloatSlider(value=10.,min=.5,max=50.,step=0.1,description=r'\\(t_{max} \\)',\n    disabled=False,continuous_update=True,orientation='horizontal',readout=True,readout_format='.1f')\n\ntransfer_func(buttons_controller.options[buttons_controller.index])\ntransfer_func_obj(buttons_object.options[buttons_object.index])\n\ndisplay(buttons_object)\ndisplay(buttons_controller)\n\ninteract(update_plot, KP=Kp_widget, TI=Ti_widget, TD=Td_widget, Time_span=time_span_widget);"
  },
  {
    "objectID": "ICCT_en/examples/02/TD-16-PID-controller-Closed-loop-model.html",
    "href": "ICCT_en/examples/02/TD-16-PID-controller-Closed-loop-model.html",
    "title": "PID controller - closed-loop model",
    "section": "",
    "text": "# Erasmus+ ICCT project (2018-1-SI01-KA203-047081)\n\n# Toggle cell visibility\n\nfrom IPython.display import HTML\ntag = HTML('''&lt;script&gt;\ncode_show=true; \nfunction code_toggle() {\n    if (code_show){\n        $('div.input').hide()\n    } else {\n        $('div.input').show()\n    }\n    code_show = !code_show\n} \n$( document ).ready(code_toggle);\n&lt;/script&gt;\nToggle cell visibility &lt;a href=\"javascript:code_toggle()\"&gt;here&lt;/a&gt;.''')\ndisplay(tag)\n\n# Hide the code completely\n\n# from IPython.display import HTML\n# tag = HTML('''&lt;style&gt;\n# div.input {\n#     display:none;\n# }\n# &lt;/style&gt;''')\n# display(tag)\n\n\nToggle cell visibility here.\n\n\n\n%matplotlib notebook\nimport matplotlib.pyplot as plt\nimport numpy as np\nimport sympy as sym\nimport scipy.signal as signal\nfrom ipywidgets import widgets, interact\n\nA proportional–integral–derivative (PID) control algorithm is by far the most common control algorithm. Its transfer function is equal to:\n\\[\\begin{equation}\n    P(s)=K_p \\cdot \\left( 1 + \\frac{1}{T_i s} + T_d s \\right).\n\\end{equation}\\]\nIt is made as a sum of proportional, integral and derivative channels. Not all of them have to be present, so PI or PD control algorithms are also used. In this example the response of a P, PI, PD or PID controller is shown for unit step, unit impulse, unit ramp or sine input. The controller is in this case part of a feedback control system. The object can either be a proportional of the zeroth, first or second order, or an integral of zeroth or first order.\nThe plots below show: 1. The response of the closed-loop system for the selected input, object type and the selected controller (left figure). 2. The position of the zeros and poles of the transfer function of the resulting closed-loop system.\n\n\nHow to use this notebook?\n\nToggle between unit step function, unit impulse function, unit ramp function, and sine to select the input signal.\nClick on P0, P1, I0 or I1 to toggle between the following objects: proportional of the zeroth, first or second order, or an integral one of zeroth or first order. The transfer function of P0 object is \\(k_p\\) (in this example \\(k_p=2\\)), of PI object \\(\\frac{k_p}{\\tau s+1}\\) (in this example \\(k_p=1\\) and \\(\\tau=2\\)), of IO object \\(\\frac{k_i}{s}\\) (in this example \\(k_i=\\frac{1}{10}\\)) and of I1 object \\(\\frac{k_i}{s(\\tau s +1) }\\) (in this example \\(k_i=1\\) and \\(\\tau=10\\)).\nClick on the P, PI, PD and PID buttons to toogle between proportional, proportional-integral, proportional-derivative and proportional–integral–derivative control algorithm type.\nMove the sliders to change the values of proportional (\\(K_p\\)), integral (\\(T_i\\)) and derivative (\\(T_d\\)) PID tunning coefficients.\nMove the slider \\(t_{max}\\) to change the maximum value of the time on x axis of the Time response plot.\n\n\nA = 10\na=0.1\ns, P, I, D = sym.symbols('s, P, I, D')\n\nobj = 1/(A*s)\nPID = P + P/(I*s) + P*D*s#/(a*D*s+1)\nsystem = obj*PID/(1+obj*PID)\nnum = [sym.fraction(system.factor())[0].expand().coeff(s, i) for i in reversed(range(1+sym.degree(sym.fraction(system.factor())[0], gen=s)))]\nden = [sym.fraction(system.factor())[1].expand().coeff(s, i) for i in reversed(range(1+sym.degree(sym.fraction(system.factor())[1], gen=s)))]\n\n# make figure\nfig = plt.figure(figsize=(9.8, 4),num='PID controller - closed-loop system')\nplt.subplots_adjust(wspace=0.3)\n\n# add axes\nax = fig.add_subplot(121)\nax.grid(which='both', axis='both', color='lightgray')\nax.set_title('Time response')\nax.set_xlabel('$t$ [s]')\nax.set_ylabel('input, output')\nax.axhline(linewidth=.5, color='k')\nax.axvline(linewidth=.5, color='k')\n\nrlocus = fig.add_subplot(122)\n\n\ninput_type = 'unit step function'\n\n# plot step function and responses (initalisation)\ninput_plot, = ax.plot([],[],'C0', lw=1, label='input')\nresponse_plot, = ax.plot([],[], 'C1', lw=2, label='output')\nax.legend()\n\n\n\n\nrlocus_plot, = rlocus.plot([], [], 'r')\n\nplt.show()\n\ndef update_plot(KP, TI, TD, Time_span):\n    global num, den, input_type\n    \n    num_temp = [float(i.subs(P,KP).subs(I,TI).subs(D,TD)) for i in num]\n    den_temp = [float(i.subs(P,KP).subs(I,TI).subs(D,TD)) for i in den]\n    system = signal.TransferFunction(num_temp, den_temp)\n    zeros = np.roots(num_temp)\n    poles = np.roots(den_temp)\n    \n    rlocus.clear()\n    rlocus.scatter([np.real(i) for i in poles], [np.imag(i) for i in poles], marker='x', color='g', label='pole')\n    rlocus.scatter([np.real(i) for i in zeros], [np.imag(i) for i in zeros], marker='o', color='g', label='zero')\n    rlocus.set_title('Pole-zero plot')\n    rlocus.set_xlabel('Re')\n    rlocus.set_ylabel('Im')\n    rlocus.grid(which='both', axis='both', color='lightgray')\n    \n    time = np.linspace(0, Time_span, 300)\n    \n    if input_type == 'unit step function':\n        u = np.ones_like(time)\n        u[0] = 0\n        time, response = signal.step(system, T=time)\n    elif input_type == 'unit impulse function':\n        u = np.zeros_like(time)\n        u[0] = 10\n        time, response = signal.impulse(system, T=time)\n    elif input_type == 'sine function':\n        u = np.sin(time*2*np.pi)\n        time, response, _ = signal.lsim(system, U=u, T=time)\n    elif input_type == 'unit ramp function':\n        u = time\n        time, response, _ = signal.lsim(system, U=u, T=time)\n    else:\n        raise Exception(\"Error in the program. Please restart simulation.\")\n        \n    response_plot.set_data(time, response)\n    input_plot.set_data(time, u)\n    \n    rlocus.axhline(linewidth=.3, color='k')\n    rlocus.axvline(linewidth=.3, color='k')\n    rlocus.legend()\n    \n    ax.set_ylim([min([np.min(u), min(response),-.1]),min(100,max([max(response)*1.05, 1, 1.05*np.max(u)]))])\n    ax.set_xlim([-0.1,max(time)])\n\n    plt.show()\n\ncontroller_ = PID\nobject_ = obj\n\ndef calc_tf():\n    global num, den, controller_, object_\n    system_func = object_*controller_/(1+object_*controller_)\n    \n    num = [sym.fraction(system_func.factor())[0].expand().coeff(s, i) for i in reversed(range(1+sym.degree(sym.fraction(system_func.factor())[0], gen=s)))]\n    den = [sym.fraction(system_func.factor())[1].expand().coeff(s, i) for i in reversed(range(1+sym.degree(sym.fraction(system_func.factor())[1], gen=s)))]\n    update_plot(Kp_widget.value, Ti_widget.value, Td_widget.value, time_span_widget.value)\n\ndef transfer_func(controller_type):\n    global controller_\n    proportional = P\n    integral = P/(I*s)\n    differential = P*D*s/(a*D*s+1)\n    if controller_type =='P':\n        controller_func = proportional\n        Kp_widget.disabled=False\n        Ti_widget.disabled=True\n        Td_widget.disabled=True\n    elif controller_type =='PI':\n        controller_func = proportional+integral\n        Kp_widget.disabled=False\n        Ti_widget.disabled=False\n        Td_widget.disabled=True\n    elif controller_type == 'PD':\n        controller_func = proportional+differential\n        Kp_widget.disabled=False\n        Ti_widget.disabled=True\n        Td_widget.disabled=False\n    else:\n        controller_func = proportional+integral+differential\n        Kp_widget.disabled=False\n        Ti_widget.disabled=False\n        Td_widget.disabled=False\n    \n    controller_ = controller_func\n    calc_tf()\n    \ndef transfer_func_obj(object_type):\n    global object_\n    if object_type == 'P0':\n        object_ = 2\n    elif object_type == 'P1':\n        object_ = 1/(2*s+1) \n    elif object_type == 'I0':\n        object_ = 1/(10*s)\n    elif object_type == 'I1':\n        object_ = 1/(s*(10*s+1))\n    calc_tf()\n\nstyle = {'description_width': 'initial'}\n\ndef buttons_controller_clicked(event):\n    controller = buttons_controller.options[buttons_controller.index]\n    transfer_func(controller)\nbuttons_controller = widgets.ToggleButtons(\n    options=['P', 'PI', 'PD', 'PID'],\n    description='Select control algorithm type:',\n    disabled=False,\n    style=style)\nbuttons_controller.observe(buttons_controller_clicked)\n\ndef buttons_object_clicked(event):\n    object_ = buttons_object.options[buttons_object.index]\n    transfer_func_obj(object_)\nbuttons_object = widgets.ToggleButtons(\n    options=['P0', 'P1', 'I0', 'I1'],\n    description='Select object:',\n    disabled=False,\n    style=style)\nbuttons_object.observe(buttons_object_clicked)\n\ndef buttons_input_clicked(event):\n    \n    global input_type\n    input_type = buttons_input.options[buttons_input.index]\n    update_plot(Kp_widget.value, Ti_widget.value, Td_widget.value, time_span_widget.value)\nbuttons_input = widgets.ToggleButtons(\n    options=['unit step function','unit impulse function', 'unit ramp function', 'sine function'],\n    description='Select input signal:',\n    disabled=False,\n    style=style)\nbuttons_input.observe(buttons_input_clicked)\n    \nKp_widget = widgets.IntSlider(value=10,min=1,max=50,step=1,description=r'\\(K_p\\)',\n    disabled=False,continuous_update=True,orientation='horizontal',readout=True,readout_format='.1d')\nTi_widget = widgets.FloatLogSlider(value=1.,min=-3,max=1.1,step=.001,description=r'\\(T_{i} \\)',\n    disabled=False,continuous_update=True,orientation='horizontal',readout=True,readout_format='.3f')\nTd_widget = widgets.FloatLogSlider(value=1.,min=-3,max=1.1,step=.001,description=r'\\(T_{d} \\)',\n    disabled=False,continuous_update=True,orientation='horizontal',readout=True,readout_format='.3f')\n\ntime_span_widget = widgets.FloatSlider(value=10.,min=.5,max=50.,step=0.1,description=r'\\(t_{max} \\)',\n    disabled=False,continuous_update=True,orientation='horizontal',readout=True,readout_format='.1f')\n\ntransfer_func(buttons_controller.options[buttons_controller.index])\ntransfer_func_obj(buttons_object.options[buttons_object.index])\n\ndisplay(buttons_input)\ndisplay(buttons_object)\ndisplay(buttons_controller)\n\ninteract(update_plot, KP=Kp_widget, TI=Ti_widget, TD=Td_widget, Time_span=time_span_widget);"
  },
  {
    "objectID": "ICCT_en/examples/02/TD-14-Routh-Hurwitz-stability-criterion.html",
    "href": "ICCT_en/examples/02/TD-14-Routh-Hurwitz-stability-criterion.html",
    "title": "Routh and Hurwitz stability criterion",
    "section": "",
    "text": "# Erasmus+ ICCT project (2018-1-SI01-KA203-047081)\n\n# Toggle cell visibility\n\nfrom IPython.display import HTML\ntag = HTML('''&lt;script&gt;\ncode_show=true; \nfunction code_toggle() {\n    if (code_show){\n        $('div.input').hide()\n    } else {\n        $('div.input').show()\n    }\n    code_show = !code_show\n} \n$( document ).ready(code_toggle);\n&lt;/script&gt;\nToggle cell visibility &lt;a href=\"javascript:code_toggle()\"&gt;here&lt;/a&gt;.''')\ndisplay(tag)\n\n# Hide the code completely\n\n# from IPython.display import HTML\n# tag = HTML('''&lt;style&gt;\n# div.input {\n#     display:none;\n# }\n# &lt;/style&gt;''')\n# display(tag)\n\n\nToggle cell visibility here.\n\n\n\nimport sympy as sp # Symbolic Python\nimport numpy as np # Arrays, matrices and corresponding mathematical operations\nfrom IPython.display import Latex, display, Markdown, clear_output # For displaying Markdown and LaTeX code\nfrom ipywidgets import widgets # Interactivity module\nfrom IPython.display import Javascript\n\n# Function for the conversion of array/matrix to LaTeX/Markdown format.\ndef vmatrix(a):\n    if len(a.shape) &gt; 2:\n         raise ValueError('bmatrix can at most display two dimensions')\n    lines = str(a).replace('[', '').replace(']', '').splitlines()\n    rv = [r'\\begin{vmatrix}']\n    rv += ['  ' + ' & '.join(l.split()) + r'\\\\' for l in lines]\n    rv +=  [r'\\end{vmatrix}']\n    return '\\n'.join(rv)\n\nIn control system theory, the Routh–Hurwitz stability criterion is a mathematical test used to detect the number of poles of the closed-loop transfer function that have positive real parts. The number of the sign changes in the first column of the Routh array gives the number of poles in the right half of the complex plane. The necessary and sufficient condition for the stability of a linear time-invariant control system is that all closed-loop system poles have negative real parts. That means that there should be no changes of sign in the first column. A similar stability criterion based on the determinants of a system is called Hurwitz criterion.\nThe starting point for determining system stability is the characteristic polynmial defined as:\n\\[\\begin{equation}\n    a_ns^n+a_{n-1}s^{n-1}+...+a_1s+a_0\n\\end{equation}\\]\nIn the case of the Routh’s criterion we then form the so called Routh’s array:\n\\[\\begin{array}{l|ccccc}\n     & 1 & 2 & 3 & 4 & 5 \\\\\n     \\hline\n    s^n & a_n & a_{n-2} & a_{n-4} & a_{n-6} & \\dots \\\\\n    s^{n-1} & a_{n-1} & a_{n-3} & a_{n-5} & a_{n-7} &\\dots \\\\\n    s^{n-2} & b_1 & b_2 & b_3 & b_4 & \\dots \\\\\n    s^{n-3} & c_1 & c_2 & c_3 & c_4 & \\dots \\\\\n    s^{n-4} & d_1 & d_2 & d_3 & d_4 & \\dots \\\\\n    \\vdots & \\vdots & \\vdots & \\vdots & \\vdots & \\ddots\\\\\n\\end{array}\\]\nThe coefficients in the first two rows (\\(a_i\\)) are obtained from the characteristic polynomial. All the others are determined using the following formulae:\n\\[\\begin{array}{cccc}\n    \\,  \\! \\! \\! \\! b_1 \\! = \\! \\frac{a_{n-1}a_{n-2}-a_n a_{n-3}}{a_{n-1}} & \\! \\!  \\! \\! \\,  \\! \\! b_2 \\!  = \\!  \\frac{a_{n-1}a_{n-4}-a_n a_{n-5}}{a_{n-1}} & \\,  \\! \\! b_3 \\! = \\! \\frac{a_{n-1}a_{n-6}-a_n a_{n-7}}{a_{n-1}} & \\, \\! \\! \\! \\! \\dots \\\\\n     c_1=\\frac{b_1a_{n-3}-a_{n-1} b_2}{b_1} & c_2=\\frac{b_1a_{n-5}-a_{n-1}b_3}{b_1} & c_3=\\frac{b_1a_{n-7}-a_{n-1}b_4}{b_1} & \\, \\! \\! \\! \\! \\dots \\\\\n     d_1=\\frac{c_1 b_2-b_1 c_2}{c_1} & d_2=\\frac{c_1 b_3-b_1 c_3}{c_1} & d_3=\\frac{c_1 b_4-b_1 c_4}{c_1} & \\, \\! \\! \\! \\! \\dots \\\\\n    \\vdots & \\vdots & \\vdots & \\, \\! \\! \\! \\! \\ddots \\\\\n\\end{array}\\]\nIf all coefficients in the first column (\\(n+1\\) coefficients) have the same sign (either all are positive or all are negative), the system is stable. The number of sign changes in the first column gives us the number of the roots of the characteristic polynomial that lie in the left half of the complex plane.\nIn the case of the Hurwitz criterion a determinant \\(\\Delta_n\\) with the dimensions \\(n\\times n\\) is formed based on the characteristic polynomial.\n\\[\\begin{equation}\n    \\Delta_n=\n    \\begin{array}{|cccccccc|}\n        a_{n-1} & a_{n-3} & a_{n-5} & \\dots & \\left[ \\begin{array}{cc} a_0 & \\mbox{if\n        }n \\mbox{ is odd} \\\\ a_1 & \\mbox{if }n \\mbox{ is even} \\end{array}\n        \\right] & 0 & \\dots & 0  \\\\[3mm]\n        a_{n} & a_{n-2} & a_{n-4} & \\dots & \\left[ \\begin{array}{cc} a_1 & \\mbox{if }n \\mbox{ is odd} \\\\ a_0 & \\mbox{if }n \\mbox{ is even} \\end{array} \\right] & 0 & \\dots & 0 \\\\\n        0 & a_{n-1} & a_{n-3} & a_{n-5} & \\dots &  \\dots & \\dots & 0 \\\\\n        0 & a_{n} & a_{n-2} & a_{n-4} & \\dots &  \\dots & \\dots & 0 \\\\\n        0 & 0 & a_{n-1} & a_{n-3} & \\dots &  \\dots & \\dots & 0 \\\\\n        0 & 0 & a_{n} & a_{n-2} & \\dots &  \\dots & \\dots & 0 \\\\\n        \\vdots & \\vdots & \\vdots & \\vdots & \\vdots & \\vdots & \\vdots & \\vdots \\\\\n        0 & \\dots & \\dots & \\dots & \\dots & \\dots & \\dots & a_0 \\\\\n    \\end{array}\n\\end{equation}\\]\nBased on the determinant \\(\\Delta_n\\) we form the subdeterminants on the main diagonal. The subdeterminant \\(\\Delta_1\\) is equal to\n\\[\\begin{equation}\n    \\Delta_1=a_{n-1},\n\\end{equation}\\]\nsubdterminant \\(\\Delta_2\\) to\n\\[\\begin{equation}\n    \\Delta_2=\n    \\begin{array}{|cc|}\n    a_{n-1} & a_{n-3} \\\\\n    a_{n} & a_{n-2} \\\\\n    \\end{array},\n\\end{equation}\\]\nand subdeterminant \\(\\Delta_3\\) to\n\\[\\begin{equation}\n    \\Delta_3=\n    \\begin{array}{|ccc|}\n    a_{n-1} & a_{n-3} & a_{n-5} \\\\\n    a_{n} & a_{n-2} & a_{n-4} \\\\\n    0 & a_{n-1} & a_{n-3} \\\\\n    \\end{array}.\n\\end{equation}\\]\nWe continue in this manner until we get to the subdeterminant \\(\\Delta_{n-1}\\). The system is stable if all subdeterminants on the main diagonal (from \\(\\Delta_1\\) to \\(\\Delta_{n-1}\\)) as well as the determinant \\(\\Delta_n\\) are strictly larger than zero.\n\n\nHow to use this notebook?\nPlease define the characteristic polynomial of interest by inserting its order and the corresponding coefficients, and then choosing the desired stabiliy criterion (Routh or Hurwitz).\n\npolynomialOrder = input (\"Insert the order of the characteristic polynomial (press Enter to confirm):\")\ntry:\n    val = int(polynomialOrder)\nexcept ValueError:\n    display(Markdown('Order of the polynomial has to be an integer. Please re-enter the value.+'))\ndisplay(Markdown('Please insert the coefficients of the characteristic polynomial (use $K$ for undefined coefficient) and click \"Confirm\".'))\ntext=[None]*(int(polynomialOrder)+1)\nfor i in range(int(polynomialOrder)+1):\n    text[i]=widgets.Text(description=('$s^%i$'%(-(i-int(polynomialOrder)))))\n    display(text[i])\nbtn1=widgets.Button(description=\"Confirm\")\nbtnReset=widgets.Button(description=\"Reset\")\ndisplay(widgets.HBox((btn1, btnReset)))\n\nbtn2=widgets.Button(description=\"Confirm\")\nw=widgets.Select(\n    options=['Routh', 'Hurwitz'],\n    rows=3,\n    description='Select:',\n    disabled=False\n)\n\ncoef=[None]*(int(polynomialOrder)+1)\n\ndef on_button_clickedReset(ev):\n    display(Javascript(\"Jupyter.notebook.execute_cells_below()\"))\n\n\ndef on_button_clicked1(btn1):\n    clear_output()\n    for i in range(int(polynomialOrder)+1):\n        if text[i].value=='' or text[i].value=='Please insert a coefficient':\n            text[i].value='Please insert a coefficient'\n        else:\n            try:\n                coef[i]=float(text[i].value)\n            except ValueError:\n                if text[i].value!='' or text[i].value!='Please insert a coefficient':\n                    coef[i]=sp.var(text[i].value)\n    coef.reverse()\n    enacba=\"$\"\n    for i in range (int(polynomialOrder),-1,-1):\n        if i==int(polynomialOrder):\n            enacba=enacba+str(coef[i])+\"s^\"+str(i)\n        elif i==1:\n            enacba=enacba+\"+\"+str(coef[i])+\"s\"\n        elif i==0:\n            enacba=enacba+\"+\"+str(coef[i])+\"$\"\n        else:\n            enacba=enacba+\"+\"+str(coef[i])+\"s^\"+str(i)\n    coef.reverse()\n    display(Markdown('The characteristic polynomial of interest is:'), Markdown(enacba))\n    display(Markdown('Would you like to use Routh or Hurwitz criterion to check the stability?'))\n    display(w)\n    display(widgets.HBox((btn2, btnReset)))\n    display(out)\n\ndef on_button_clicked2(btn2):\n    \n    if w.value=='Routh':\n\n        s=np.zeros((len(coef), len(coef)//2+(len(coef)%2)),dtype=object)\n        xx=np.zeros((len(coef), len(coef)//2+(len(coef)%2)),dtype=object)\n        check_index=0\n        \n        if len(s[0]) == len(coef[::2]):\n            s[0] = coef[::2]\n        elif len(s[0])-1 == len(coef[::2]):\n            s[0,:-1] = coef[::2]\n        #soda mesta\n        if len(s[1]) == len(coef[1::2]):\n            s[1] = coef[1::2]\n        elif len(s[1])-1 == len(coef[1::2]):\n            s[1,:-1] = coef[1::2]\n            \n        for i in range(len(s[2:,:])):\n            i+=2\n            for j in range(len(s[0,0:-1])):\n                s[i,j] = (s[i-1,0]*s[i-2,j+1]-s[i-2,0]*s[i-1,j+1]) / s[i-1,0]\n                if s[i,0] == 0:\n                    epsilon=sp.Symbol('\\u03B5')\n                    s[i,0] = epsilon\n                    check_index=1\n        \n        if check_index==1:\n            for i in range(len(s)):\n                for j in range(len(s[0])):\n                    xx[i,j] = sp.limit(s[i,j],epsilon,0)\n            \n            positive_check=xx[:,0]&gt;0\n            negative_check=xx[:,0]&lt;0\n            if all(positive_check)==True:\n                with out:\n                    clear_output()\n                    display(Markdown('One of the elements in the first column of the Routh table is equal to 0. We replace it with $\\epsilon$ and observe the values of the elements when $\\epsilon$ goes to zero.')) \n                    display(Markdown('Routh table $%s$\\n' % vmatrix(s)))\n                    display(Markdown('System is stable, because all the elements in the first column of the Routh table are positive.'))\n                    display(Markdown('Routh table $%s$\\n' % vmatrix(xx)))\n\n            elif all(negative_check)==True:\n                with out:\n                    clear_output()\n                    display(Markdown('One of the elements in the first column of the Routh table is equal to 0. We replace it with $\\epsilon$ and observe the values of the elements when $\\epsilon$ goes to zero.')) \n                    display(Markdown('Routh table $%s$\\n' % vmatrix(s)))\n                    display(Markdown('System is stable, because all the elements in the first column of the Routh table are negative.'))\n                    display(Markdown('Routh table $%s$\\n' % vmatrix(xx)))           \n            else:\n                with out:\n                    clear_output()\n                    display(Markdown('One of the elements in the first column of the Routh table is equal to 0. We replace it with $\\epsilon$ and observe the values of the elements when value of $\\epsilon$ goes to zero.')) \n                    display(Markdown('Routh table $%s$\\n' % vmatrix(s)))\n                    display(Markdown('System is unstable, because the elements in the first column of the Routh table do not have the same sign.'))\n                    display(Markdown('Routh table $%s$\\n' % vmatrix(xx)))\n            \n            \n        elif check_index==0:      \n\n            if all(isinstance(x, (int,float)) for x in coef):\n                positive_check=s[:,0]&gt;0\n                negative_check=s[:,0]&lt;0\n                if all(positive_check)==True:\n                    with out:\n                        clear_output()\n                        display(Markdown('System is stable, because all the elements in the first column of the Routh table are positive.'))\n                        display(Markdown('Routh table $%s$' % vmatrix(s)))\n                elif all(negative_check)==True:\n                    with out:\n                        clear_output()\n                        display(Markdown('System is stable, because all the elements in the first column of the Routh table are negative.'))\n                        display(Markdown('Routh table $%s$' % vmatrix(s)))\n                else:\n                    with out:\n                        clear_output()\n                        display(Markdown('System is unstable, because the elements in the first column of the Routh table do not have the same sign.'))\n                        display(Markdown('Routh table $%s$' % vmatrix(s)))\n\n            else:\n                testSign=[]\n                for i in range(len(s)):\n                    if isinstance(s[i,0],(int,float)):\n                        testSign.append(s[i,0]&gt;0)\n                solution=[]\n                if all(elem == True for elem in testSign):\n                    for x in s[:,0]:\n                        if not isinstance(x,(sp.numbers.Integer,sp.numbers.Float,int,float)):\n                            solution.append(sp.solve(x&gt;0,K)) # Define the solution for each value of the determinant\n                    with out:\n                        clear_output()\n                        display(Markdown('Routh table $%s$' % vmatrix(s)))\n                        display(Markdown('All the known coefficients in the first column of Routh table are positive, therefore the system is stable for:'))\n                        print(solution)            \n                elif all(elem == False for elem in test):\n                    for x in s[:,0]:\n                        if not isinstance(x,(sp.numbers.Integer,sp.numbers.Float,int,float)):\n                            solution.append(sp.solve(x&lt;0,K)) # Define the solution for each value of the determinant\n                    with out:\n                        clear_output()\n                        display(Markdown('Routh table $%s$' % vmatrix(s)))\n                        display(Markdown('All the known coefficients in the first column of Routh table are negative, therefore the system is stable for:'))\n                        print(solution)\n                else:\n                    with out:\n                        display(Markdown('Routh table $%s$' % vmatrix(s)))\n                        display(Markdown('System is unstable, beacuse the signs of the coefficients in the first column differ between each other.'))\n\n\n\n    elif w.value=='Hurwitz':\n        \n\n\n        # Check if all the coefficients are numbers or not and preallocate basic determinant.\n\n        if all(isinstance(x, (int,float)) for x in coef):\n            determinant=np.zeros([len(coef)-1,len(coef)-1])\n        else:\n            determinant=np.zeros([len(coef)-1,len(coef)-1],dtype=object)\n\n        # Define the first two rows of the basic determinant.    \n        for i in range(len(coef)-1):\n            try:\n                determinant[0,i]=coef[2*i+1]\n            except:\n                determinant[0,i]=0\n\n        for i in range(len(coef)-1):\n            try:\n                determinant[1,i]=coef[2*i]\n            except:\n                determinant[1,i]=0\n        # Define the remaining rows of the basic determinant by shifting the first two rows.        \n        for i in range(2,len(coef)-1):\n            determinant[i,:]=np.roll(determinant[i-2,:],1)\n            determinant[2:,0]=0\n\n        # Define all the subdeterminants.\n        subdet=[];\n        \n        for i in range(len(determinant)-1):\n            subdet.append(determinant[0:i+1,0:i+1])\n\n        # Append the basic determinant to the subdeterminants' array.\n        subdet.append(determinant)\n\n        # Check if all coefficients are numbers.\n        if all(isinstance(x, (int,float)) for x in coef):\n            det_value=[] # Preallocate array containing values of all determinants.\n            for i in range(len(subdet)):\n                det_value.append(np.linalg.det(subdet[i])); # Calculate determinant and append the values to det_value.\n\n            if all(i &gt; 0 for i in det_value)==True: # Check if all values in det_value are positive or not.\n                with out:\n                    clear_output()\n                    display(Markdown('System is stable, because all determinants are positive.'))\n                    for i in range(len(subdet)):\n                        display(Markdown('$\\Delta_{%i}=$'%(i+1) + '$%s$' %vmatrix(subdet[i]) + '$=%s$' %det_value[i]))\n            else:\n                with out:\n                    clear_output()\n                    display(Markdown('System is unstable, because not all determinants are positive.'))\n                    for i in range(len(subdet)):\n                        display(Markdown('$\\Delta_{%i}=$'%(i+1) + '$%s$' %vmatrix(subdet[i]) + '$=%s$' %det_value[i]))\n        else:\n            subdetSym=[] # Preallocate subdetSym.\n            det_value=[] # Preallocate det_value.\n            solution=[] # Preallocate solution.\n            \n            for i in subdet:\n                subdetSym.append(sp.Matrix(i)) # Transform matrix subdet to symbolic.\n            for i in range(len(subdetSym)):\n                det_value.append(subdetSym[i].det()) # Calculate the value of the determinant.\n            \n            testSign=[]\n            \n            for i in range(len(det_value)):\n                if isinstance(det_value[i],(int,float,sp.numbers.Integer,sp.numbers.Float)):\n                    testSign.append(det_value[i]&gt;0)\n            \n            if all(elem == True for elem in testSign):\n                solution=[]\n                for x in det_value:\n                    if not isinstance(x,(sp.numbers.Integer,sp.numbers.Float,int,float)):\n                        solution.append(sp.solve(x&gt;0,K)) # Define the solution for each value of the determinant\n                \n                with out:\n                    clear_output()                    \n                for i in range(len(subdet)):\n                    display(Markdown('$\\Delta_{%i}=$'%(i+1) + '$%s$' %vmatrix(subdet[i]) + '$=%s$' %det_value[i]))\n                display(Markdown('System is stable, for:'))\n                print(solution)    \n\n            else:\n                with out:\n                    clear_output()\n                    display(Markdown('System is unstable, because not all known determinants are positive.'))\n                for i in range(len(subdet)):\n                    display(Markdown('$\\Delta_{%i}=$'%(i+1) + '$%s$' %vmatrix(subdet[i]) + '$=%s$' %det_value[i]))\n\nglobal out\nout=widgets.Output()\n\nbtn3=widgets.Button(description=\"Reset all\")\nw=widgets.Select(\n    options=['Routh', 'Hurwitz'],\n    rows=3,\n    description='Select:',\n    disabled=False\n)\n\nbtn1.on_click(on_button_clicked1)\nbtn2.on_click(on_button_clicked2)       \nbtnReset.on_click(on_button_clickedReset) \n\nThe characteristic polynomial of interest is:\n\n\n\\(1.0s^3+1.0s^2+2.0s+8.0\\)\n\n\nWould you like to use Routh or Hurwitz criterion to check the stability?"
  },
  {
    "objectID": "ICCT_en/examples/02/TD-12-Dominant-pole-approximation.html",
    "href": "ICCT_en/examples/02/TD-12-Dominant-pole-approximation.html",
    "title": "Dominant pole approximation",
    "section": "",
    "text": "from IPython.display import HTML\ntag = HTML('''&lt;script&gt;\ncode_show=true; \nfunction code_toggle() {\n    if (code_show){\n        $('div.input').hide()\n    } else {\n        $('div.input').show()\n    }\n    code_show = !code_show\n} \n$( document ).ready(code_toggle);\n&lt;/script&gt;\nToggle cell visibility &lt;a href=\"javascript:code_toggle()\"&gt;here&lt;/a&gt;.''')\ndisplay(tag)\n\n\nToggle cell visibility here.\n\n\n\n# Erasmus+ ICCT project (2018-1-SI01-KA203-047081)\n\n%matplotlib notebook\nimport numpy as np\nimport math\nimport matplotlib.pyplot as plt\nfrom scipy import signal\nimport ipywidgets as widgets\nimport control as c\nimport sympy as sym\nfrom IPython.display import Latex, display, Markdown # For displaying Markdown and LaTeX code\nfrom fractions import Fraction\nimport matplotlib.patches as patches\n\nWhen studying the behaviour of systems, we often approximate systems by a dominant pole or a pair of dominant complex poles. This example demonstrates this property.\nA second-order system is defined by the following transfer function:\n\\[\\begin{equation}\n    G(s)=\\frac{\\alpha\\beta}{(s+\\alpha)(s+\\beta)}=\\frac{1}{(\\frac{1}{\\alpha}s+1)(\\frac{1}{\\beta}s+1)},\n\\end{equation}\\]\nwhere \\(\\beta=1\\), and \\(\\alpha\\) is iterable.\nA third-order system is defined by the following transfer function:\n\\[\\begin{equation}\n    G(s)=\\frac{\\alpha{\\omega_0}^2}{\\big(s+\\alpha\\big)\\big(s^2+2\\zeta\\omega_0s+\\omega_0^2\\big)}=\\frac{1}{(\\frac{1}{\\alpha}s+1)(\\frac{1}{\\omega_0^2}s^2+\\frac{2\\zeta\\alpha}{\\omega_0}s+1)},\n\\end{equation}\\]\nwhere \\(\\beta=1\\), \\(\\omega_0=4.1\\) and \\(\\zeta=0.24\\), and \\(\\alpha\\) is iterable.\n\n\nHow to use this notebook?\nToggle between the second- and third-order system and move the slider to change the location of the moveable pole \\(\\alpha\\).\nThis notebook is based on the following tutorial by Prof. Erik Cheever.\n\n# System selector buttons\nstyle = {'description_width': 'initial'}\ntypeSelect = widgets.ToggleButtons(\n    options=[('second-order system', 0), ('third-order system', 1),],\n    description='Select: ',style=style)\n\n\ndisplay(typeSelect)\ncontinuous_update=False\n\n# set up plot \n\nfig, ax = plt.subplots(2,1,figsize=[9.8,7],num='Dominant pole approximation')\nplt.subplots_adjust(hspace=0.35)\nax[0].grid(True)\nax[1].grid(True)\n# ax[2].grid(which='both', axis='both', color='lightgray')\nax[0].axhline(y=0,color='k',lw=.8)\nax[1].axhline(y=0,color='k',lw=.8)\nax[0].axvline(x=0,color='k',lw=.8)\nax[1].axvline(x=0,color='k',lw=.8)\nax[0].set_xlabel('Re')\nax[0].set_ylabel('Im')\nax[0].set_xlim([-10,0.5])\nax[1].set_xlim([-0.5,20])\nax[1].set_xlabel('$t$ [s]')\nax[1].set_ylabel('input, output')\nax[0].set_title('Pole-zero plot')\nax[1].set_title('Time response')\n\nplotzero, = ax[0].plot([], [])\nresponse, = ax[1].plot([], [])\nresponseAdom, = ax[1].plot([], [])\nresponseBdom, = ax[1].plot([], [])\n\nax[1].step([0,50],[0,1],color='C0',label='input')\n\n# generate x values\n  \ndef response_func(a,index):\n    \n    global plotzero, response, responseAdom, responseBdom \n#     global bodePlot, bodePlotAdom, bodePlotBdom\n\n    t = np.linspace(0, 50, 1000)\n    \n    if index==0:\n        b=1\n        num=a*b\n        den=([1,a+b,a*b])\n        tf_sys=c.TransferFunction(num,den)\n        poles_sys,zeros_sys=c.pzmap(tf_sys, Plot=False)\n        tout, yout = c.step_response(tf_sys,t)\n        den1=([1,a])\n        tf_sys1=c.TransferFunction(a,den1)\n        toutA, youtA = c.step_response(tf_sys1,t)\n        den2=([1,b])\n        tf_sys2=c.TransferFunction(b,den2)\n        toutB, youtB = c.step_response(tf_sys2,t)\n        mag, phase, omega = c.bode_plot(tf_sys, Plot=False)   # Bode-plot\n        magA, phase, omegaA = c.bode_plot(tf_sys1, Plot=False)   # Bode-plot\n        magB, phase, omegaB = c.bode_plot(tf_sys2, Plot=False)   # Bode-plot\n        s=sym.Symbol('s')\n        eq=(a*b/((s+a)*(s+b)))\n        eq1=1/(((1/a)*s+1)*((1/b)*s+1))\n        display(Markdown('Moveable pole (purple curve) $\\\\alpha$ is equal to %.1f, fixed pole (red curve) $b$ is equal to %i; The transfer function is equal to:'%(a,1)))\n        display(eq),display(Markdown('or')),display(eq1)\n\n    elif index==1:\n        omega0=4.1\n        zeta=0.24\n        num=a*omega0**2\n        den=([1,2*zeta*omega0+a,omega0**2+2*zeta*omega0*a,a*omega0**2])\n        tf_sys=c.TransferFunction(num,den)\n        poles_sys,zeros_sys=c.pzmap(tf_sys, Plot=False)\n        tout, yout = c.step_response(tf_sys,t)\n        den1=([1,a])\n        tf_sys1=c.TransferFunction(a,den1)\n        toutA, youtA = c.step_response(tf_sys1,t)\n        den2=([1,2*zeta*omega0,omega0**2])\n        tf_sys2=c.TransferFunction(omega0**2,den2)\n        toutB, youtB = c.step_response(tf_sys2,t)\n        mag, phase, omega = c.bode_plot(tf_sys, Plot=False)   # Bode-plot\n        magA, phase, omegaA = c.bode_plot(tf_sys1, Plot=False)   # Bode-plot\n        magB, phase, omegaB = c.bode_plot(tf_sys2, Plot=False)   # Bode-plot\n        s=sym.Symbol('s')\n        eq=(a*omega0**2/((s+a)*(s**2+2*zeta*omega0*s+omega0*omega0)))\n        eq1=1/(((1/a)*s+1)*((1/(omega0*omega0))*s*s+(2*zeta*a/omega0)*s+1))\n        \n        display(Markdown('Moveable pole (purple curve) $\\\\alpha$ is equal to %.1f, fixed poles (red curve) $\\\\beta$ are equal to $1\\pm4j$ ($\\omega_0$ is set to 4.1, $\\zeta$ is set to 0.24). The transfer function is equal to:'%(a)))\n        display(eq),display(Markdown('or')),display(eq1)\n    \n    ax[0].lines.remove(plotzero)\n    ax[1].lines.remove(response)\n    ax[1].lines.remove(responseAdom)\n    ax[1].lines.remove(responseBdom)\n    \n    plotzero, = ax[0].plot(np.real(poles_sys), np.imag(poles_sys), 'xg', markersize=10, label = 'pole')\n    response, = ax[1].plot(tout,yout,color='C1',label='system response',lw=3)\n    responseAdom, = ax[1].plot(toutA,youtA,color='C4',label='response due to the moveable pole (pair) only')\n    responseBdom, = ax[1].plot(toutB,youtB,color='C3',label='response due to the fixed pole only')\n\n    ax[0].legend()\n    ax[1].legend()\n    \na_slider=widgets.FloatSlider(value=0.1, min=0.1, max=10, step=.1,\n                                        description='$\\\\alpha$:',disabled=False,continuous_update=False,\n                                        orientation='horizontal',readout=True,readout_format='.2f',)\n\ninput_data=widgets.interactive_output(response_func,{'a':a_slider,'index':typeSelect})\n\ndef update_slider(index):\n    global a_slider\n    \n    aval=[0.1,0.1]\n    a_slider.value=aval[index]    \n\ninput_data2=widgets.interactive_output(update_slider,{'index':typeSelect})\n\ndisplay(a_slider,input_data)"
  },
  {
    "objectID": "ICCT_en/examples/02/TD-10-First-and-second-order-systems-Basics.html",
    "href": "ICCT_en/examples/02/TD-10-First-and-second-order-systems-Basics.html",
    "title": "First-order systems with no zeros",
    "section": "",
    "text": "from IPython.display import HTML\ntag = HTML('''&lt;script&gt;\ncode_show=true; \nfunction code_toggle() {\n    if (code_show){\n        $('div.input').hide()\n    } else {\n        $('div.input').show()\n    }\n    code_show = !code_show\n} \n$( document ).ready(code_toggle);\n&lt;/script&gt;\nToggle cell visibility &lt;a href=\"javascript:code_toggle()\"&gt;here&lt;/a&gt;.''')\ndisplay(tag)\n\n\nToggle cell visibility here.\n# Erasmus+ ICCT project (2018-1-SI01-KA203-047081)\n\n%matplotlib notebook\nimport numpy as np\nimport math\nimport matplotlib.pyplot as plt\nfrom scipy import signal\nimport ipywidgets as widgets\nimport control as c\nimport sympy as sym\nfrom IPython.display import Latex, display, Markdown # For displaying Markdown and LaTeX code\nfrom fractions import Fraction\nimport matplotlib.patches as patches"
  },
  {
    "objectID": "ICCT_en/examples/02/TD-10-First-and-second-order-systems-Basics.html#second-order-systems",
    "href": "ICCT_en/examples/02/TD-10-First-and-second-order-systems-Basics.html#second-order-systems",
    "title": "First-order systems with no zeros",
    "section": "Second-order systems",
    "text": "Second-order systems\n\nIntroduction\nIn contrast to the first-order systems presented above, in which the parameter \\(k\\) only affected the speed of the response, changes of the analogue parameters in the second order systems may affect the actual form of the response. The following four responses are possible in these systems: - overdamped response, - underdamped response, - undapmed response, and - critically damped response.\n\n\nHow to use this notebook?\nMove the slider to define the values of \\(a\\) and \\(b\\) in the transfer function of the second-order system of the form \\(G(s)=\\frac{b}{s^2+as+b}\\) and observe the pole-zero plot and the unit step time response of the defined system.\n\n# set up plot\nfig1, ax1 = plt.subplots(1,2,figsize=[9.8,4],num='Second-order system')\nax1[0].set_ylim([-3.5, 3])\nax1[1].set_ylim([0, 2.5])\n# ax1.set_xlim([0, 5])\nax1[0].grid(True)\nax1[1].grid(True)\nax1[0].axhline(y=0,color='k',lw=.8)\nax1[1].axhline(y=0,color='k',lw=.8)\nax1[0].axvline(x=0,color='k',lw=.8)\nax1[1].axvline(x=0,color='k',lw=.8)\nax1[0].set_xlabel('Re')\nax1[0].set_ylabel('Im')\nax1[1].set_xlabel('$t$ [s]')\nax1[1].set_ylabel('Input, output')\nax1[0].set_title('Pole-zero plot')\nax1[1].set_title('Time response')\n\nt = np.linspace(0, 20, 10000)\n\ntextGs = ax1[0].text(0,0,'')\n\nax1[1].step([0,20],[0,1],color='C0',label='input')\n\nplotzero, = ax1[0].plot([], [])\nresponse2, = ax1[1].plot([], [])\n\ndef response_func2(t, a, b):\n    num_sys=np.array([b])\n    den_sys=np.array([1,a,b])\n    tf_sys=c.TransferFunction(num_sys,den_sys)\n    poles_sys,zeros_sys=c.pzmap(tf_sys, Plot=False)\n    T, yout = c.step_response(tf_sys,t)\n    return T, yout, poles_sys, tf_sys\n \n@widgets.interact(a=(0, 10, 1),b=(1,10,1))\n\ndef update(a=7,b=9):\n    \"\"\" Update plots \"\"\"\n    global response2, plotzero, textGs\n    ax1[0].lines.remove(plotzero)\n    ax1[1].lines.remove(response2)\n#     textGs.remove()\n    T, yout, poles_sys, tf_sys = response_func2(t, a, b)\n    plotzero, = ax1[0].plot(np.real(poles_sys), np.imag(poles_sys), 'xg', markersize=10, label = 'Poles')\n#     textGs = ax1[0].text(-7,1,tf_sys)\n    response2, = ax1[1].plot(T,yout,color='C1',label='output')\n    s=sym.Symbol('s')\n    eq=b/(s**2+a*s+b)\n    coeff = [1,a,b]\n    rootsdenom=np.roots(coeff)\n    eq2=b/((s-rootsdenom[0])*(s-rootsdenom[1]))\n    display(Markdown('Transfer function of the system $G(s)$ is equal to:'))\n    display(eq),display(Markdown('or')),display(eq2)\n\n    if np.imag(poles_sys)[0] == 0 and np.imag(poles_sys)[1] == 0 and np.real(poles_sys)[0] &lt; 0 and np.real(poles_sys)[1] &lt; 0 and np.real(poles_sys)[0]!=np.real(poles_sys)[1]:\n        display(Markdown('The system is **overdamped**, because both poles have only negative real parts.'))\n    elif math.isclose(0, np.imag(poles_sys)[0], abs_tol=10**-6) and math.isclose(0, np.imag(poles_sys)[1], abs_tol=10**-6) and np.real(poles_sys)[1] &lt; 0 and np.real(poles_sys)[0]==np.real(poles_sys)[1]:\n        display(Markdown('The system is **critically damped** beacuse there is a double pole with negative real part only.'))\n    elif np.real(poles_sys)[0] == 0 and np.real(poles_sys)[1] == 0:\n        display(Markdown('The system is **undamped**, because the poles have only imaginary parts.'))\n    elif np.imag(poles_sys)[0] != 0 and np.imag(poles_sys)[1] != 0 and np.real(poles_sys)[0] != 0 and np.real(poles_sys)[1] != 0:\n        display(Markdown('The system is **underdamped** beacuse both poles have negative real and non-zero complex part.'))\n    ax1[0].legend()\n    ax1[1].legend()"
  },
  {
    "objectID": "ICCT_en/examples/02/TD-08-Pole-zero-placement.html",
    "href": "ICCT_en/examples/02/TD-08-Pole-zero-placement.html",
    "title": "Pole/zero placement",
    "section": "",
    "text": "# Erasmus+ ICCT project (2018-1-SI01-KA203-047081)\n\n# Toggle cell visibility\n\nfrom IPython.display import HTML\ntag = HTML('''&lt;script&gt;\ncode_show=true; \nfunction code_toggle() {\n    if (code_show){\n        $('div.input').hide()\n    } else {\n        $('div.input').show()\n    }\n    code_show = !code_show\n} \n$( document ).ready(code_toggle);\n&lt;/script&gt;\nToggle cell visibility &lt;a href=\"javascript:code_toggle()\"&gt;here&lt;/a&gt;.''')\ndisplay(tag)\n\n# Hide the code completely\n\n# from IPython.display import HTML\n# tag = HTML('''&lt;style&gt;\n# div.input {\n#     display:none;\n# }\n# &lt;/style&gt;''')\n# display(tag)\n\n\nToggle cell visibility here.\n\n\n\n# Erasmus+ ICCT project (2018-1-SI01-KA203-047081)\n\n%matplotlib notebook\nimport numpy as np\nimport math\nimport matplotlib.pyplot as plt\nfrom scipy import signal\nimport ipywidgets as widgets\n\nA pole–zero plot is a graphical representation of zeros and poles of the transfer function. The layout of zeros and especially poles gives us a lot of information about the properties of the system. Stability is for example ensured if all the poles lie in the left half of the complex plane.\n\n\nHow to use this notebook?\nTo move a pole (marked with a green cross) or a zero (pair) (marked with a green circle) click and drag it. To add or remove a pole or a zero (pair) click the corresponding button.\n\nx_axis = [[-10, 10], [0, 0]] #lists of ploted axes [[x-data], [y-data]]\ny_axis = [[0, 0], [-10, 10]]\n\npoles = [] # list of coordinates of poles\nzeros = [] # list of coordinates of zeros\ndoublepoles = []\ndoublezeros = []\n\ndef calc_gain(poles, doublepoles, zeros, doublezeros):\n    # calculate gain of the system (to be final value equal one)\n    gain = 1\n    for pole in poles:\n        if pole[0] !=0:\n            gain *= np.abs(pole[0])\n    for zero in zeros:\n        if zero[0] !=0:\n            gain /= (-1)*zero[0]#np.abs(zero[0])\n    for doublepole in doublepoles:\n        gain *= np.abs(np.sqrt((doublepole[0])**2+(doublepole[1])**2))\n    for doublezero in doublezeros:\n        gain /= np.abs(np.sqrt((doublezero[0])**2+(doublezero[1])**2))\n    return gain\n\ndef make_label(poles, doublepoles, zeros, doublezeros):\n    den_str = ''\n    number_integrators = 0\n    for i in poles:\n        if i[0] == 0:\n            number_integrators += 1\n    if number_integrators == 1:\n        den_str = ''.join((den_str, 's'))\n    elif number_integrators &gt;1:\n        den_str = ''.join((den_str, 's^{', '{:1d}'.format(number_integrators), '}'))\n    for i in poles:\n        sign = '+' if i[0]&lt;0 else '-'\n        #den_str = ''.join((den_str, '(s', sign, '{:.1f}'.format(np.abs(i[0])), ')'))\n        if np.abs(i[0]) != 0:\n            den_str = ''.join((den_str, '(\\dfrac{s}','{', '{:.1f}'.format(np.abs(i[0])), '}', sign, '1', ')'))\n    for number in range(len(doublepoles)):\n        if number % 2 == 1:\n            continue\n        else:\n            i = doublepoles[number]\n            if i[0] != 0:\n                sign = '+' if i[0]&lt;0 else '-'\n                #den_str = ''.join((den_str, '(s^{2}', sign, '{:.1f}'.format(np.abs(2*i[0])), ' s', '+{:.1f}'.format(i[0]**2+i[1]**2), ')'))\n                den_str = ''.join((den_str, '(\\dfrac{s^{2}}{', '{:.1f}'.format(i[0]**2+i[1]**2), '}', sign, '\\dfrac{s}{', '{:.1f}'.format((i[0]**2+i[1]**2)/np.abs(2*i[0])), '}+1', ')'))\n            else:\n                den_str = ''.join((den_str, '(\\dfrac{s^{2}}{', '{:.1f}'.format(i[0]**2+i[1]**2), '}+1', ')'))\n\n    num_str = ''\n    if len(zeros+doublezeros) &gt;0:\n        number_integrators = 0\n        for i in zeros:\n            if i[0] == 0:\n                number_integrators += 1\n        if number_integrators == 1:\n            num_str = ''.join((num_str, 's'))\n        elif number_integrators &gt;1:\n            num_str = ''.join((num_str, 's^{', '{:1d}'.format(number_integrators), '}'))\n        for i in zeros:\n            sign = '+' if i[0]&lt;0 else '-'\n            #num_str = ''.join((num_str, '(s', sign, '{:.1f}'.format(np.abs(i[0])), ')'))\n            if np.abs(i[0]) != 0:\n                num_str = ''.join((num_str, '(\\dfrac{s}','{', '{:.1f}'.format(np.abs(i[0])), '}', sign, '1', ')'))\n        for number in range(len(doublezeros)):\n            if number % 2 == 1:\n                continue\n            else:\n                i = doublezeros[number]\n            if i[0] != 0:\n                sign = '+' if i[0]&lt;0 else '-'\n                #num_str = ''.join((num_str, '(s^{2}', sign, '{:.1f}'.format(np.abs(2*i[0])), ' s', '+{:.1f}'.format(i[0]**2+i[1]**2), ')'))\n                num_str = ''.join((num_str, '(\\dfrac{s^{2}}{', '{:.1f}'.format(i[0]**2+i[1]**2), '}', sign, '\\dfrac{s}{', '{:.1f}'.format((i[0]**2+i[1]**2)/np.abs(2*i[0])), '}+1', ')'))\n            else:\n                num_str = ''.join((num_str, '(\\dfrac{s^{2}}{', '{:.1f}'.format(i[0]**2+i[1]**2), '}+1', ')'))\n    else:\n        num_str = '1'\n        \n    #label = ''.join(('${:.1f}'.format(calc_gain(poles, doublepoles, zeros, doublezeros)), '\\,\\dfrac{',num_str, '}{', den_str, '}$'))\n    sign = ''if calc_gain(poles, doublepoles, zeros, doublezeros)&gt;=0 else '-'\n    label = ''.join(('$', sign, '\\,\\dfrac{',num_str, '}{', den_str, '}$'))\n   \n    return label\n\ndrag = False # variable for mouse drag, which on a list is dragged\ndragged = False # flag which is dragged (pole or zero)\n\nfig = plt.figure(figsize=(9.8, 4),num='Pole-zero placement') # figure, where to plot\n\n\n\nroot = fig.add_subplot(121) #axes for root locus plot\nroot.set_xlabel('Re')\nroot.set_ylabel('Im')\nroot.set_title('Pole-zero plot')\nroot.set_xlim([-10,10])\nroot.set_ylim([-10,10])\nroot.axhline(linewidth=.5, color='k')\nroot.axvline(linewidth=.5, color='k')\nroot.set_aspect('equal', adjustable='datalim')\nroot.grid(which='both', axis='both', color='lightgray')\n\nstep_plot = fig.add_subplot(122) # axes for step plot\nstep_plot.set_xlabel('$t$ [s]')\nstep_plot.set_ylabel('Output')\nstep_plot.set_title('Step response')\nroot.set_aspect('equal', adjustable='datalim')\nstep_plot.grid(which='both', axis='both', color='lightgray')\n\n# points, which appear at start of program\npoles.append([-1, 0])\nzeros.append([-7, 0])\n\n# computing init step response data\nsig = signal.ZerosPolesGain([zeros[0][0]], [poles[0][0]], calc_gain(poles, doublepoles, zeros, doublezeros)) # Close loop transfer function (ZerosPolesGain)\ntimep, stepr = signal.step(sig, T=np.linspace(0,10,300))\n\n# plotting init plot\npoles_plot, = root.plot(poles[0][0], poles[0][1], 'xg', label='pole')\nzeros_plot, = root.plot(zeros[0][0], zeros[0][1], 'og', label='zero')\ndoublepoles_plot, = root.plot([], [], 'xg', lw=2)\ndoublezeros_plot, = root.plot([], [], 'og', lw=2)\n#for plotting colored , which are dragged\ndragged_plot_poles, = root.plot([],[],'bx')\ndragged_plot_zeros, = root.plot([],[],'bo')\n\nstep_ax, = step_plot.plot(timep, stepr, 'C1', lw=1.5, label=make_label(poles, doublepoles, zeros, doublezeros))\nstep_plot.set_ylim([min(stepr)-max(stepr)*.05,max(stepr)*1.05])\nstep_plot.legend(loc=4, prop={'size': 10-max(len(poles+doublepoles),len(zeros+doublezeros))})\nstep_plot.axhline(linewidth=.5, color='k')\nstep_plot.axvline(linewidth=.5, color='k')\nroot.legend()\nplt.show()  \n\n# FIRST PART, for manipulating zeros and poles on matplotlib plot\ndef check_point_clicked(xdata, ydata):\n    global poles, zeros, poles_plot, zeros_plot, dragged, drag\n    global doublepoles, doublezeros, doublezeros_plot, doublepoles_plot\n    tolerance = .3\n    for i in range(len(poles)):\n        pole = poles[i]\n        if ((xdata-pole[0])**2 + (ydata-pole[1])**2)**0.5 &lt; tolerance: # check if pole near (xdata, ydata)\n            drag = i\n            dragged_plot_poles.set_data([poles[drag][0]],[poles[drag][1]])\n            dragged_plot_poles.set_marker('x')\n            dragged_plot_poles.set_visible(True)\n            dragged = 'pole'\n            return\n    for i in range(len(zeros)):\n        zero = zeros[i]\n        if ((xdata-zero[0])**2 + (ydata-zero[1])**2)**0.5 &lt; tolerance:\n            drag = i\n            dragged_plot_zeros.set_data([zeros[drag][0]],[zeros[drag][1]])\n            dragged_plot_zeros.set_visible(True)\n            dragged = 'zero'\n            return\n    #check also in doublepoles/doublezeros lists\n    for i in range(len(doublepoles)):\n        doublepole = doublepoles[i]\n        if ((xdata-doublepole[0])**2 + (ydata-doublepole[1])**2)**0.5 &lt; tolerance: # check if doublepole near (xdata, ydata)\n            dragged = 'doublepole'\n            drag = i\n            if i%2 == 0:\n                dragged_plot_poles.set_data([doublepoles[drag][0],doublepoles[drag+1][0]],[doublepoles[drag][1],doublepoles[drag+1][1]])\n            if i%2 == 1:\n                dragged_plot_poles.set_data([doublepoles[drag-1][0],doublepoles[drag][0]],[doublepoles[drag-1][1],doublepoles[drag][1]])\n            dragged_plot_poles.set_visible(True)\n            return\n    for i in range(len(doublezeros)):\n        doublezero = doublezeros[i]\n        if ((xdata-doublezero[0])**2 + (ydata-doublezero[1])**2)**0.5 &lt; tolerance:\n            dragged = 'doublezero'\n            drag = i\n            if i%2 == 0:\n                dragged_plot_zeros.set_data([doublezeros[drag][0],doublezeros[drag+1][0]],[doublezeros[drag][1],doublezeros[drag+1][1]])\n            if i%2 == 1:\n                dragged_plot_zeros.set_data([doublezeros[drag-1][0],doublezeros[drag][0]],[doublezeros[drag-1][1],doublezeros[drag][1]])\n            dragged_plot_zeros.set_visible(True)\n            return\n\n# when click on left mouse button\ndef onclick(event):\n    mouse_coordx = np.round(event.xdata, 1)\n    mouse_coordy = np.round(event.ydata, 1)#extract location of mouse cursor\n    check_point_clicked(mouse_coordx, mouse_coordy) # which point is dragged\n\ndef onrelease(event):\n    global poles_plot, zeros_plot, dragged, drag, poles, zeros\n    global doublepoles_plot, doublezeros_plot, doublepoles, doublezeros\n    mouse_coordx = np.round(event.xdata, 1)\n    mouse_coordy = np.round(event.ydata, 1)\n    if dragged == 'pole':\n        poles[drag][0] = mouse_coordx\n        poles_plot.set_data([poles[i][0] for i in range(len(poles))], [poles[j][1] for j in range(len(poles))])\n        dragged_plot_poles.set_visible(False)\n    if dragged == 'zero':\n        zeros[drag][0] = mouse_coordx\n        zeros_plot.set_data([zeros[i][0] for i in range(len(zeros))], [zeros[j][1] for j in range(len(zeros))])\n        dragged_plot_zeros.set_visible(False)\n    if dragged == 'doublepole':\n        doublepoles[drag] = [mouse_coordx, mouse_coordy]\n        if drag%2 == 0:\n            doublepoles[drag+1] = [mouse_coordx, -mouse_coordy]\n        else:\n            doublepoles[drag-1] = [mouse_coordx, -mouse_coordy]\n        doublepoles_plot.set_data([doublepoles[i][0] for i in range(len(doublepoles))],\n                                  [doublepoles[j][1] for j in range(len(doublepoles))])\n        dragged_plot_poles.set_visible(False)\n    if dragged == 'doublezero':\n        doublezeros[drag] = [mouse_coordx, mouse_coordy]\n        if drag%2 == 0:\n            doublezeros[drag+1] = [mouse_coordx, -mouse_coordy]\n        else:\n            doublezeros[drag-1] = [mouse_coordx, -mouse_coordy]\n        doublezeros_plot.set_data([doublezeros[i][0] for i in range(len(doublezeros))],\n                                  [doublezeros[j][1] for j in range(len(doublezeros))])\n        dragged_plot_zeros.set_visible(False)\n\n    \n    sig = signal.ZerosPolesGain([zero[0]+zero[1]*1j for zero in zeros + doublezeros], # zeros\n                                [pole[0]+pole[1]*1j for pole in poles + doublepoles], # poles\n                                calc_gain(poles, doublepoles, zeros, doublezeros))  # gain\n    timep, stepr = signal.step(sig, T=np.linspace(0,10,300))\n\n    #update step plots\n    step_ax.set_data(timep, stepr)\n    step_plot.set_ylim([min(stepr)-max(stepr)*.05,max(stepr)*1.05])\n    step_ax.set_label(make_label(poles, doublepoles, zeros, doublezeros))\n    step_plot.legend(loc=4, prop={'size': 10-.5*max(len(poles+doublepoles),len(zeros+doublezeros))})\n    drag = False\n    dragged = False\n\nt = 0 # variable for plotting motion faster\nfastRat = 7 # how much times faster\ndef onmotion(event):\n    global t, poles_plot, zeros_plot, dragged, poles, zeros, drag\n    global doublepoles, doublezeros, doublepoles_plot, doublezeros_plot\n    if dragged:\n        mouse_coordx = np.round(event.xdata, 1)\n        mouse_coordy = np.round(event.ydata, 1)\n        if t%fastRat == fastRat-1:# for faster plotting in jupyter notebook\n            if dragged == 'pole':\n                poles[drag][0] = mouse_coordx\n                poles_plot.set_data([poles[i][0] for i in range(len(poles))], [poles[j][1] for j in range(len(poles))])\n                dragged_plot_poles.set_data([poles[drag][0]],[poles[drag][1]])\n            if dragged == 'zero':\n                zeros[drag][0] = mouse_coordx\n                zeros_plot.set_data([zeros[i][0] for i in range(len(zeros))], [zeros[j][1] for j in range(len(zeros))])\n                dragged_plot_zeros.set_data([zeros[drag][0]],[zeros[drag][1]])\n            if dragged == 'doublepole':\n                doublepoles[drag] = [mouse_coordx, mouse_coordy]\n                if drag%2 == 0:\n                    doublepoles[drag+1] = [mouse_coordx, -mouse_coordy]\n                elif drag%2 == 1:\n                    doublepoles[drag-1] = [mouse_coordx, -mouse_coordy]\n                else:\n                    raise Exception\n                doublepoles_plot.set_data([doublepoles[i][0] for i in range(len(doublepoles))],\n                                          [doublepoles[j][1] for j in range(len(doublepoles))])\n                if drag%2 == 0:\n                    dragged_plot_poles.set_data([doublepoles[drag][0],doublepoles[drag+1][0]],[doublepoles[drag][1],doublepoles[drag+1][1]])\n                elif drag%2 == 1:\n                    dragged_plot_poles.set_data([doublepoles[drag-1][0],doublepoles[drag][0]],[doublepoles[drag-1][1],doublepoles[drag][1]])\n            if dragged == 'doublezero':\n                doublezeros[drag] = [mouse_coordx, mouse_coordy]\n                if drag%2 == 0:\n                    doublezeros[drag+1] = [mouse_coordx, -mouse_coordy]\n                elif drag%2 == 1:\n                    doublezeros[drag-1] = [mouse_coordx, -mouse_coordy]\n                doublezeros_plot.set_data([doublezeros[i][0] for i in range(len(doublezeros))],\n                                          [doublezeros[j][1] for j in range(len(doublezeros))])\n                if drag%2 == 0:\n                    dragged_plot_zeros.set_data([doublezeros[drag][0],doublezeros[drag+1][0]],[doublezeros[drag][1],doublezeros[drag+1][1]])\n                elif drag%2 == 1:\n                    dragged_plot_zeros.set_data([doublezeros[drag-1][0],doublezeros[drag][0]],[doublezeros[drag-1][1],doublezeros[drag][1]])\n\n    t = t + 1\n    # for t not to become too large\n    if t &gt;= 1000*fastRat:\n        t = 0\n\n# mouse events for interactive plot\npress_event = fig.canvas.mpl_connect('button_press_event', onclick)\nmotion_event = fig.canvas.mpl_connect('motion_notify_event', onmotion)\nrelease_event = fig.canvas.mpl_connect('button_release_event', onrelease)\n\n# SECOND PART, for adding and taking poles and zeros:\n\ndef check_improper_function():\n    if len(poles+doublepoles) &gt;= len(zeros+doublezeros)+2:\n        TsinglePole.disabled=False\n        TdoublePole.disabled=False\n        AsingleZero.disabled=False\n        AdoubleZero.disabled=False\n    if len(poles+doublepoles) == len(zeros+doublezeros)+1:\n        TsinglePole.disabled=False\n        TdoublePole.disabled=True\n        AsingleZero.disabled=False\n        AdoubleZero.disabled=True\n    if len(poles+doublepoles) == len(zeros+doublezeros):\n        TsinglePole.disabled=True\n        TdoublePole.disabled=True\n        AsingleZero.disabled=True\n        AdoubleZero.disabled=True\n    if len(poles+doublepoles) &lt; len(zeros+doublezeros):\n        raise Exception('System error, improper transfer function')\n    if len(poles)&lt;=1 and len(doublepoles)==0 or len(poles)==0 and len(doublepoles)&lt;=2:\n        TsinglePole.disabled=True\n        TdoublePole.disabled=True\n    \ndef update_plot():\n    sig = signal.ZerosPolesGain([zero[0]+zero[1]*1j for zero in zeros + doublezeros], # zeros\n                                [pole[0]+pole[1]*1j for pole in poles + doublepoles], # poles\n                                calc_gain(poles, doublepoles, zeros, doublezeros))  # gain\n    timep, stepr = signal.step(sig, T=np.linspace(0,10,300))\n    #update step plots\n    step_ax.set_data(timep, stepr)\n    step_plot.set_ylim([min(stepr)-max(stepr)*.05,max(stepr)*1.05])\n    step_ax.set_label(make_label(poles, doublepoles, zeros, doublezeros))\n    step_plot.legend(loc=4, prop={'size': 10-.5*max(len(poles+doublepoles),len(zeros+doublezeros))})\n    \n    \n# functions for event buttons \ndef AsinglePole_clicked(event):\n    if len(poles) &lt;= 10:\n        poles.append([0, 0])\n        poles_plot.set_data([poles[i][0] for i in range(len(poles))], [poles[j][1] for j in range(len(poles))])\n        check_improper_function()\n        update_plot()\ndef TsinglePole_clicked(event):\n    if len(poles) &gt;= 1:\n        poles.pop(-1)\n        poles_plot.set_data([poles[i][0] for i in range(len(poles))], [poles[j][1] for j in range(len(poles))])\n        check_improper_function()\n        update_plot()\n\ndef AdoublePole_clicked(event):\n    if len(doublepoles) &lt;= 10:\n        doublepoles.append([0, 1])\n        doublepoles.append([0, -1])\n        doublepoles_plot.set_data([doublepoles[i][0] for i in range(len(doublepoles))],\n                                  [doublepoles[j][1] for j in range(len(doublepoles))])\n        check_improper_function()\n        update_plot()\ndef TdoublePole_clicked(event):\n    if len(doublepoles) &gt;= 2:\n        doublepoles.pop(-1)\n        doublepoles.pop(-1)\n        doublepoles_plot.set_data([doublepoles[i][0] for i in range(len(doublepoles))],\n                                    [doublepoles[j][1] for j in range(len(doublepoles))])\n        check_improper_function()\n        update_plot()\n\ndef AsingleZero_clicked(event):\n    if len(zeros) &lt;= 10:\n        zeros.append([0, 0])\n        zeros_plot.set_data([zeros[i][0] for i in range(len(zeros))], [zeros[j][1] for j in range(len(zeros))])\n        check_improper_function()\n        update_plot()\ndef TsingleZero_clicked(event):\n    if len(zeros) &gt;= 1:\n        zeros.pop(-1)\n        zeros_plot.set_data([zeros[i][0] for i in range(len(zeros))], [zeros[j][1] for j in range(len(zeros))])\n        check_improper_function()\n        update_plot()\n    \ndef AdoubleZero_clicked(event):\n    if len(doublezeros) &lt;= 10:\n        doublezeros.append([0, 1])\n        doublezeros.append([0, -1])\n        doublezeros_plot.set_data([doublezeros[i][0] for i in range(len(doublezeros))],\n                                  [doublezeros[j][1] for j in range(len(doublezeros))])\n        check_improper_function()\n        update_plot()\ndef TdoubleZero_clicked(event):\n    if len(doublezeros)&gt;=2:\n        doublezeros.pop(-1)\n        doublezeros.pop(-1)\n        doublezeros_plot.set_data([doublezeros[i][0] for i in range(len(doublezeros))],\n                                  [doublezeros[j][1] for j in range(len(doublezeros))])\n        check_improper_function()\n        update_plot()\n\n# defined buttons for adding or taking poles and zeros\n\nAsinglePole = widgets.Button(description='Add pole', disabled=False, tooltip='Click me', icon='', layout=widgets.Layout(width='180px', height='40px'))\nAdoublePole = widgets.Button(description='Add complex conjugate pole pair', disabled=False, tooltip='Click me', icon='', layout=widgets.Layout(width='250px', height='40px'))\n\nAsingleZero = widgets.Button(description='Add zero', disabled=False, tooltip='Click me', icon='', layout=widgets.Layout(width='180px', height='40px'))\nAdoubleZero = widgets.Button(description='Add complex conjugate zero pair', disabled=False, tooltip='Click me', icon='', layout=widgets.Layout(width='250px', height='40px'))\n\nTsinglePole = widgets.Button(description='Remove pole', disabled=False, tooltip='Click me', icon='', layout=widgets.Layout(width='180px', height='40px'))\nTdoublePole = widgets.Button(description='Remove complex conjugate pole pair', disabled=False, tooltip='Click me', icon='', layout=widgets.Layout(width='250px', height='40px'))\n\nTsingleZero = widgets.Button(description='Remove zero', disabled=False, tooltip='Click me', icon='', layout=widgets.Layout(width='180px', height='40px'))\nTdoubleZero = widgets.Button(description='Remove complex conjugate zero pair', disabled=False, tooltip='Click me', icon='', layout=widgets.Layout(width='250px', height='40px'))\n\n# make layout\ncolumn1 = widgets.VBox([AsinglePole, TsinglePole])\ncolumn2 = widgets.VBox([AdoublePole, TdoublePole])\ncolumn3 = widgets.VBox([AsingleZero, TsingleZero])\ncolumn4 = widgets.VBox([AdoubleZero, TdoubleZero])\n\nboth_columns = widgets.HBox([column1, column2, column3, column4])\n\ndisplay(both_columns)\n\n# defined events\nAsinglePole.on_click(AsinglePole_clicked)\nAdoublePole.on_click(AdoublePole_clicked)\nAsingleZero.on_click(AsingleZero_clicked)\nAdoubleZero.on_click(AdoubleZero_clicked)\n\nTsinglePole.on_click(TsinglePole_clicked)\nTdoublePole.on_click(TdoublePole_clicked)\nTsingleZero.on_click(TsingleZero_clicked)\nTdoubleZero.on_click(TdoubleZero_clicked)\n\ncheck_improper_function()"
  },
  {
    "objectID": "ICCT_en/examples/02/TD-06-Linearization-Pendulum.html",
    "href": "ICCT_en/examples/02/TD-06-Linearization-Pendulum.html",
    "title": "Linearization - Simple pendulum",
    "section": "",
    "text": "# Erasmus+ ICCT project (2018-1-SI01-KA203-047081)\n\n# Toggle cell visibility\n\nfrom IPython.display import HTML\ntag = HTML('''&lt;script&gt;\ncode_show=true; \nfunction code_toggle() {\n    if (code_show){\n        $('div.input').hide()\n    } else {\n        $('div.input').show()\n    }\n    code_show = !code_show\n} \n$( document ).ready(code_toggle);\n&lt;/script&gt;\nToggle cell visibility &lt;a href=\"javascript:code_toggle()\"&gt;here&lt;/a&gt;.''')\ndisplay(tag)\n\n\nToggle cell visibility here.\n\n\n\n%matplotlib notebook\nimport numpy as np\nfrom scipy.integrate import odeint\nimport matplotlib.pyplot as plt\nimport ipywidgets as widgets\n\nWhen dealing with system models, linearization is a process of modelling a nonlinear system with a linear differential equation in the neighbourhood of some operating point (typically an equilibrium point). In this notebook this process will be demonstrated using a simple pendulum. The force causing the oscillation motion of the pendulum (shown in the figure below) is defined as \\(-mgsin\\theta\\). The equation of motion for the pendulum is defined as:\n\\[\\begin{equation}\n    mL^2\\frac{d^2\\theta}{dt^2}=-mgsin\\theta L.\n\\end{equation}\\]\nUpon rearrangement we get the following non-linear second-order differential equation:\n\\[\\begin{equation}\n    \\frac{d^2\\theta}{dt^2}+\\frac{g}{L}sin\\theta=0.\n\\end{equation}\\]\nIn a case of small angular displacements, the small angle approximation (i.e. \\(sin\\theta\\approx\\theta\\)) holds and the following linear second-order differential equation is obtained:\n\\[\\begin{equation}\n    \\frac{d^2\\theta}{dt^2}+\\frac{g}{L}\\theta=0.\n\\end{equation}\\]\n\n\n\n\nSimple pendulum\n\n\n\n\n\n\n\n\n\n\n\nHow to use this notebook?\nMove the sliders to change the pendulum length \\(L\\) and the values of the initial conditions \\(\\theta_0\\) and \\(\\dot{\\theta_0}\\).\n\n# create figure\nfig = plt.figure(figsize=(9.8, 3),num='Linearization - simple pendulum')\n\n# add sublot\nax = fig.add_subplot(111)\nax.set_title('Time response')\nax.set_ylabel('output')\nax.set_xlabel('$t$ [s]')\nax.axhline(y=0, xmin=-1, xmax=6, color='k', linewidth=1)\n\nax.grid(which='both', axis='both', color='lightgray')\n\nnonlinear, = ax.plot([], [])\nlinear, = ax.plot([], [])\n\nstyle = {'description_width': 'initial'}\n\ng=9.81 # m/s^2\n\ndef model_nonlinear(ic,t,L):\n    fi, fidot = ic\n    return [fidot,-g/L*np.sin(fi)]\n\ndef model_linear(ic,t,L):\n    fi, fidot = ic\n    return [fidot,-g/L*fi]\n\ndef build_model(y0,ypika0,L):\n    ic=[y0,ypika0]\n    t=np.linspace(0,5,num=500)\n    fi=odeint(model_nonlinear,ic,t,args=(L,))\n    ys=fi[:,0]\n\n    fi_linear=odeint(model_linear,ic,t,args=(L,))\n    ys_linear=fi_linear[:,0]\n    \n    global nonlinear, linear\n\n    ax.lines.remove(nonlinear)\n    ax.lines.remove(linear)\n \n    nonlinear, = ax.plot(t,ys,label='original',color='C0', linewidth=5)\n    linear, = ax.plot(t,ys_linear,label='linear',color='C3', linewidth=2)\n    \n    ax.legend()\n    \n    ax.relim()\n    ax.autoscale_view()\n\nL_slider=widgets.FloatSlider(value=0.3, min=.01, max=2., step=.01,\n                                        description='$L$ [m]:',disabled=False,continuous_update=False,\n                                        orientation='horizontal',readout=True,readout_format='.2f',)\n\nypika0_slider=widgets.FloatSlider(value=1, min=-3, max=3, step=0.1,\n                                        description='$\\dot \\\\theta_0$ [rad/s]:',disabled=False,continuous_update=False,\n                                        orientation='horizontal',readout=True,readout_format='.2f',) \n\ny0_slider=widgets.FloatSlider(value=1, min=-3, max=3, step=0.1,\n                                        description='$\\\\theta_0$ [rad]:',disabled=False,continuous_update=False,\n                                        orientation='horizontal',readout=True,readout_format='.2f',) \n\ninput_data=widgets.interactive_output(build_model, {'y0':y0_slider,'ypika0':ypika0_slider,'L':L_slider})\n\ndisplay(L_slider,y0_slider,ypika0_slider,input_data)"
  },
  {
    "objectID": "ICCT_en/examples/02/TD-04-Differential-equations.html",
    "href": "ICCT_en/examples/02/TD-04-Differential-equations.html",
    "title": "Differential equations - linear or nonlinear system",
    "section": "",
    "text": "# Erasmus+ ICCT project (2018-1-SI01-KA203-047081)\n\n# Toggle cell visibility\n\nfrom IPython.display import HTML\ntag = HTML('''&lt;script&gt;\ncode_show=true; \nfunction code_toggle() {\n    if (code_show){\n        $('div.input').hide()\n    } else {\n        $('div.input').show()\n    }\n    code_show = !code_show\n} \n$( document ).ready(code_toggle);\n&lt;/script&gt;\nToggle cell visibility &lt;a href=\"javascript:code_toggle()\"&gt;here&lt;/a&gt;.''')\ndisplay(tag)\n\n# Hide the code completely\n\n# from IPython.display import HTML\n# tag = HTML('''&lt;style&gt;\n# div.input {\n#     display:none;\n# }\n# &lt;/style&gt;''')\n# display(tag)\n\n\nToggle cell visibility here.\n\n\n\ncontinuous_update=False\n%matplotlib notebook\nimport matplotlib.pyplot as plt\nimport numpy as np\nfrom scipy.integrate import odeint\n\nfrom ipywidgets import interact, interactive, fixed, interact_manual\nimport ipywidgets as widgets\n\nThis notebook covers various systems defined by the following differential equations:\n\nnonlinear vibration: \\(\\ddot{x}+0.25\\dot{x}+5\\sin{x}=F\\),\nlinear vibration: \\(\\ddot{x}+0.25\\dot{x}+5x=F\\),\nnonlinear system: \\(\\ddot{x}+0.003\\dot{x}x=F\\),\nlinear time-dependent system: \\(\\ddot{x}-0.2{x}t^{\\frac{1}{4}}=F\\),\nnonlinear time-dependent system: \\(\\ddot{x}+0.0001x^2t=F\\),\n\nwhere \\(F\\) denotes the input (step function), \\(t\\) time, and \\(x\\) the dependent variable.\nThe left figure shows time responses for different intial conditions and different inputs. The bold blue curve represents the time response based on the values set by the sliders. The other curves represent time responses obtained from multiples of 1) a value of the first initial condition - displacement \\(x(0)\\), 2) a value of the second initial condition - speed \\(\\dot x(0)\\), or 3) a system input (depending on the What to change radio button selection). The multiples are integer values ranging from -5 to +5. \nExample:  \\(\\text{input}=0.7\\), \\(x(0)=2.0\\), and \\(\\dot x(0)=5.5\\), input radio button selected. Outputs: Bold curve is based on the values set above. Other curves are based on the same \\(x(0)\\) and \\(\\dot x(0)\\) values, but with the following step amplitudes:\n\\(0.7\\begin{pmatrix}-5& -4& -3& -2& -1& 0& 1& 2& 3& 4& 5\\end{pmatrix}=\\begin{pmatrix}-3.5& -2.8& -2.1& -1.4& -0.7& 0& 0.7& 1.4& 2.1& 2.8& 3.5\\end{pmatrix}\\).\nThe right figure shows the values of all the time responses shown in the left figure at the selected instant of time. The x-axes tick labels denote integer values ranging from -5 to +5. For a linear system the time response is always a line.\n\n\nHow to use this notebook?\nMove the sliders to change the time responses to the selected step amplitude (input) or the intial conditions of the pre-defined systems introduced above. You can toggle between different systems by pressing the corresponding toggle button.\n\nLegend:\n\ninput: value of the input (step) amplitude.\ndelay: time delay for the start of integration (for time dependent systems).\ninstant of time: time at which the responses in right figure are shown.\n\\(x(0)\\): value of the first initial condition - displacement.\n\\(\\dot x(0)\\): value of the second initial condition - speed. \n\n\n# diferential equations:\n\ndef nonlinear_vibr(y,t, x): # y začetni pogoj, t čas, x krmilni vhod\n    '''nonlinear vibration'''\n    th, om = y\n    b=0.25\n    c=5.\n    dydt = (om, x - b*om - c*np.sin(th))\n    return dydt\n\ndef linear_vibr(y,t,x):\n    '''linear vibration'''\n    th, om = y\n    b=0.25\n    c=5.\n    dydt = (om, x - b*om - c*th)\n    return dydt\n\ndef nonlinear(y,t,x):\n    '''nonlinear d.e.'''\n    c, v = y\n    dydt = (v, x - 0.003*c*v)\n    return dydt\n\ndef time_dependent(y,t,x):\n    '''time dependent d.e.'''\n    c, v = y\n    dydt = (v, x + .2*c*t**(1/4))\n    return dydt\n\ndef first_order (y, t, x):\n    '''first order nonlinear time dependent d.e.'''\n    c, v = y\n    dydt = (v, x - .0001*c*c*t)\n    return dydt\n\n\nfig = plt.figure(figsize=(9.8, 4),num=\"Differential equations (DE)\")\n\nresponse = fig.add_subplot(1, 2, 1)\n\npnts_of_resp = fig.add_subplot(1, 2, 2)\n\ny0 = np.array([0.,0.]) # init. conditions\n\nt_end = 10\n\nx=1\nt_0=1\nt_calc=1\ny0_0=1\ny0_1=1\n\n\ndef func():\n    global y0, x, t_0, t_calc, y0_0, y0_1\n    y0[0] = y0_0\n    y0[1] = y0_1\n    t = np.linspace(0,t_end,t_end*10+1) #time points, where response (solution) is calculated\n    linearity = [] # point to look, if d.e. is linear on not\n    \n    t = t+ t_0\n    \n    plus_minus = 5.\n    input_amp = np.round(np.linspace(-plus_minus,plus_minus,2*int(plus_minus)+1))\n\n    response.clear()\n    pnts_of_resp.clear()\n    \n    current_button = buttons.index\n    for amp in input_amp:\n        if radio_buttons.index == 0:\n            i=amp*x\n            input_pack = [i, y0]\n        if radio_buttons.index == 1:\n            i=amp*float(y0[0])\n            input_pack = [x, [i, y0[1]]]\n        if radio_buttons.index == 2:\n            i=amp*float(y0[1])\n            input_pack = [x, [y0[0], i]]\n\n        if current_button == 0:\n            solution = odeint(nonlinear_vibr, input_pack[1], t, args=(input_pack[0],))\n        if current_button == 1:\n            solution = odeint(linear_vibr, input_pack[1], t, args=(input_pack[0],))\n        if current_button == 2:\n            solution = odeint(nonlinear, input_pack[1], t, args=(input_pack[0],))\n        if current_button == 3:\n            solution = odeint(time_dependent, input_pack[1], t, args=(input_pack[0],))\n        if current_button == 4:\n            solution = odeint(first_order, input_pack[1], t, args=(input_pack[0],))\n            \n        solution = solution[:,0]\n        linearity.append(solution[int(t_calc*10)])\n        \n        if amp == 1:\n            response.plot(t, solution, 'b', lw=2, label='response')\n        else:\n            response.plot(t, solution, lw=.7)\n        \n    response.grid()\n    response.set_xlabel('$t$ [s]')\n    response.set_ylabel('response')\n    response.set_title('Solutions of DE')\n    response.legend()\n\n    pnts_of_resp.plot(input_amp, linearity, label='linearity')\n    pnts_of_resp.grid()\n    pnts_of_resp.legend()\n    pnts_of_resp.set_xlabel('various inputs or initial conditions')\n    pnts_of_resp.set_ylabel('response at instant of time %.1d' %t_calc)\n    pnts_of_resp.set_title('Linearity of DE')\n    \n    \n    \nstyle = {'description_width': 'initial'}\nx_widget = widgets.FloatSlider(value=0.5,min=0,max=1,step=.1,description='input',\n    disabled=False,continuous_update=True,orientation='horizontal',readout=True,readout_format='.1f')\nt_0_widget = widgets.IntSlider(value=0,min=0,max=10,step=1,description='delay [s]',\n    disabled=False,continuous_update=True,orientation='horizontal',readout=True,readout_format='.1d')\nt_calc_widget = widgets.IntSlider(value=1,min=1,max=10,step=1,description='instant of time [s]',\n    disabled=False,continuous_update=True,orientation='horizontal',readout=True,readout_format='.1d',style=style)\ny0_0_widget = widgets.FloatSlider(value=0.,min=0,max=10,step=.1,description='$x(0)$',\n    disabled=False,continuous_update=True,orientation='horizontal',readout=True,readout_format='.1f')\ny0_1_widget = widgets.FloatSlider(value=0.,min=0,max=10,step=.1,description='$\\dot x(0)$',\n    disabled=False,continuous_update=True,orientation='horizontal',readout=True,readout_format='.1f')\n\nstyle = {'description_width': 'initial','button_width':'180px'}\n\nbuttons = widgets.ToggleButtons(options=['nonlinear vibration', 'linear vibration', 'nonlinear', 'linear time dependent', 'nonlinear time dependent'],\n    description='Select a system:',value = 'nonlinear vibration',disabled=False,style=style)\n\ndisplay(buttons)\n\ni=0\ndef buttons_clicked(event):\n    global i\n    i+=1\n    if i%5==0: # for more efficient program\n        i=0\n        func()   \n\nbuttons.observe(buttons_clicked)\n\nradio_buttons = widgets.RadioButtons(options=['input', 'x(0)', u'\\u1E8B''(0)'],\n    value='input',description='What to change:',disabled=False,style=style)\n\nj=0\ndef radio_buttons_clicked(event):\n    global j\n    j+=1\n    if j%5==0:\n        if radio_buttons.index==0:\n            x_widget.min=.1\n            y0_0_widget.min=0\n            y0_1_widget.min=0\n        if radio_buttons.index==1:\n            x_widget.min=0\n            y0_0_widget.min=.1\n            y0_1_widget.min=0\n        if radio_buttons.index==2:\n            x_widget.min=0\n            y0_0_widget.min=0\n            y0_1_widget.min=.1\n        \n        j=0\n        func()   \n\nradio_buttons.observe(radio_buttons_clicked)\n\n\nvbox = widgets.VBox([x_widget, t_0_widget, t_calc_widget, y0_0_widget, y0_1_widget])\nhbox = widgets.HBox([vbox, radio_buttons])\n\n#buttons.observe(buttons_clicked)\ndisplay(hbox)\n\n\nk=0\ndef set_values(event):\n    global k, x, t_0, t_calc, y0_0, y0_1\n    k+=1\n    if k%3==0: # every three times is because .observe sends 3 events\n        k=0\n        x=x_widget.value\n        t_0=t_0_widget.value\n        t_calc=t_calc_widget.value\n        y0_0=y0_0_widget.value\n        y0_1=y0_1_widget.value\n        func()\n\nx_widget.observe(set_values)\nt_0_widget.observe(set_values)\nt_calc_widget.observe(set_values)\ny0_0_widget.observe(set_values)\ny0_1_widget.observe(set_values)\n\n#initialize:\ndef initialize():\n    set_values(0)\n    set_values(0)\n    set_values(0)\n    x_widget.min = .1\ninitialize()"
  },
  {
    "objectID": "ICCT_en/examples/02/TD-02-Antenna-azimuth-position-control-system.html",
    "href": "ICCT_en/examples/02/TD-02-Antenna-azimuth-position-control-system.html",
    "title": "Antenna azimuth position control system",
    "section": "",
    "text": "# Erasmus+ ICCT project (2018-1-SI01-KA203-047081)\n\n# Toggle cell visibility\n\nfrom IPython.display import HTML\ntag = HTML('''&lt;script&gt;\ncode_show=true; \nfunction code_toggle() {\n    if (code_show){\n        $('div.input').hide()\n    } else {\n        $('div.input').show()\n    }\n    code_show = !code_show\n} \n$( document ).ready(code_toggle);\n&lt;/script&gt;\nToggle cell visibility &lt;a href=\"javascript:code_toggle()\"&gt;here&lt;/a&gt;.''')\ndisplay(tag)\n\n# Hide the code completely\n\n# from IPython.display import HTML\n# tag = HTML('''&lt;style&gt;\n# div.input {\n#     display:none;\n# }\n# &lt;/style&gt;''')\n# display(tag)\n\n\nToggle cell visibility here.\n\n\n\n%matplotlib notebook\n\nimport matplotlib.pyplot as plt\nimport matplotlib.animation as animation\nimport numpy as np\nimport sympy as sym\n\nfrom ipywidgets import widgets, Layout\nfrom ipywidgets import interact\n\nfrom IPython.display import Latex, display, Markdown # For displaying Markdown and LaTeX code\n\nfrom matplotlib import patches\n\nAn example of a simple antenna azimuth position control system is shown schematically in the left figure below. The goal of this control system is to maintain the reference (desired) position of the antenna by setting the desired angle \\(\\theta_{ref}\\) with the reference potentiometer (RP). Block diagram of this system (shown in the right figure below) therefore starts with the signal \\(\\theta_{ref}\\), which is converted to voltage \\(U_1\\). Voltage \\(U_2\\) is then subtracted from \\(U_1\\). \\(U_2\\) is the output from the measuring potentiometer (MP), which provides the information about the actual angle. Voltage difference \\(U_1-U_2\\) represents the error that tells us how much the actual angle differs from the desired one. Based on this error the controller affects the electromotor, which (by means of gearing) rotates the antenna in the way in which the error is reduced. \\(d_w\\) is a disturbance due to the wind, which randomly rotates the antenna.\n \n\n\n\nSchematic representation of the antenna azimuth position control system\n\n\nBlock diagram of the antenna azimuth position control system\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nLegend: RP-reference potentiometer, MP-measuring potentiometer, dw-disturbance due to the wind.\n\n\n\n\n\nHow to use this notebook?\n\nMove the sliders to change the values of the desired antenna azimuth angle (\\(\\theta_{ref}\\)), disturbance due to the wind (\\(d_w\\)), and proportional (\\(K_p\\)), integral (\\(K_i\\)) and derivative (\\(K_d\\)) tuning coefficients.\nPress the buttons to toggle between proportional (P), proportional-integral (PI) and proportional-integral-derivative (PID) controller type.\n\n\n\n\nNotes\n\nSize of the red arrow on the schematic representation of the antenna is proportional to the magnitude of the disturbance due to the wind (\\(d_w\\)), whereas the direction of the arrow indicates the direction of the disturbance.\nDashed blue line on the schematic representation of an antenna denotes the actual angle of the antenna.\nDashed green line on the schematic representation of an antenna denotes the desired angle of the antenna.\nDash-dot red line on the schematic representation of an antenna indicates the previous actual angle of the antenna.\n\nYou can select between two different options for displaying the results: 1. Reset the schematic representation when the controller type is changed. 2. Reset the plot when the controller type is changed.\n\n# define system constants\n_Kpot = 0.318\n\n_K1 = 100\n_a = 100\n_Km = 2.083\n_am = 1.71\n_Kg = 0.1\n_R = 8\n_Kt = 0.5\n_Tv = 200 #in milliseconds\n\n#set current theta and theta reference:\nth = [0,0,0,0,0,0]\nthref = [0,0,0,0,0,0]\n# disturbance:\nm = [0,0,0,0,0,0]\n#joined together (first theta reference, second disturbance, then theta measured):\nvariables = [thref, m, th]\n\n# variables of controller:\n_K = 1\n_taui = 1\n_taud = 1\n\n\n# symbolic calculus:\ntaui, taud, K, s, z = sym.symbols('taui, taud, K, s, z')\n\n_alpha=0.1\n#controller:\nP = K\nI = K/(taui*s)\nD = K*taud*s/(_alpha*taud*s+1)\n\ndef make_model(controller):\n    if controller == 'P':\n        C = P\n    elif controller == 'PI':\n        C = P+I\n    elif controller == 'PID':\n        C = P+I+D\n    else:\n        print('Controller type not in library')\n    \n    tf_s = C*_K1*_Km*_Kg*_Kpot/(s*(s+_a)*(s+_am)+C*_K1*_Km*_Kg*_Kpot)\n    tf_s = tf_s.simplify()\n\n    tf_z = tf_s.subs(s,2/(_Tv/1000)*(z-1)/(z+1))\n    tf_z = tf_z.simplify()\n    \n    num = [sym.fraction(tf_z.factor())[0].expand().coeff(z, i) for i in reversed(range(1+sym.degree(sym.fraction(tf_z.factor())[0], gen=z)))]\n    den = [sym.fraction(tf_z.factor())[1].expand().coeff(z, i) for i in reversed(range(1+sym.degree(sym.fraction(tf_z.factor())[1], gen=z)))]\n    #print(num)\n    #print(den)\n\n    tf_sM = _Km*_Kg*_R*(s+_a)/(s*(s+_a)*(s+_am)*_Kt+C*_K1*_Km*_Kg*_Kpot*_Kt)\n    \n    tf_zM = tf_sM.subs(s,2/(_Tv/1000)*(z-1)/(z+1))\n    tf_zM = tf_zM.simplify()\n    num_M = [sym.fraction(tf_zM.factor())[0].expand().coeff(z, i) for i in reversed(range(1+sym.degree(sym.fraction(tf_zM.factor())[0], gen=z)))]\n    #print(num_M)\n    #print(den_M)\n    \n    #print('\\n........finished........')\n    return sym.lambdify((K, taui, taud), [np.array(num), -np.array(num_M), -np.array(den)])\n\nz_transform_p = make_model('P')\nz_transform_pi = make_model('PI')\nz_transform_pid = make_model('PID')\n\n\ndef calculate_next(z_transform):\n    variables[-1][0] = 0 # set current to zero\n    z_transform = z_transform(_K, _taui, _taud)\n    \n    temp = 0\n    for i in range(len(z_transform)): # for every polynomial\n        for j in range(len(z_transform[i])): # for every term in polynomial\n            temp += z_transform[i][j] * variables[i][j]\n\n    return temp / z_transform[-1][0]*(-1)\n\n\nfig = plt.figure(figsize=(9.8, 4),num='Antenna azimuth position control system')\n# add axes\nax = fig.add_subplot(121)\ngraph = fig.add_subplot(122)\n    \n#set current theta and theta reference:\nth = [0,0,0,0,0,0]\nthref = [1,0,0,0,0,0]\n# disturbance:\nm = [.1,0,0,0,0,0]\n#joined together (first theta reference, second disturbance, then theta measured):\nvariables = [thref, m, th]\n\n# variables of controller:\n_K = 20\n_taui = 10\n_taud = 1\n\nnew_flag_value = [True, 0] # flag for displaying old value of th, before th_ref was changed [flag, angle]\n\n#slider widgets:\nth_ref_widget = widgets.FloatSlider(value=variables[0][0],min=0.0,max=2*np.pi,step=.01,description=r'\\(\\theta_{ref} \\) [rad]',\n                    disabled=False,continuous_update=True,orientation='horizontal',readout=True,readout_format='.2f')\nm_widget = widgets.FloatSlider(value=variables[1][0],min=-.3,max=.3,step=.01,description=r'\\(d_{w} \\)',\n                    disabled=False,continuous_update=True,orientation='horizontal',readout=True,readout_format='.2f')\nK_widget = widgets.FloatSlider(value=_K,min=0.0,max=40,step=.1,description=r'\\(K_p \\)',\n                    disabled=False,continuous_update=True,orientation='horizontal',readout=True,readout_format='.1f')\ntaui_widget = widgets.FloatSlider(value=_taui,min=0.01,max=60,step=.01,description=r'\\(K_i \\)',\n                    disabled=False,continuous_update=True,orientation='horizontal',readout=True,readout_format='.2f')\ntaud_widget = widgets.FloatSlider(value=_taud,min=0.0,max=5,step=.1,description=r'\\(K_d \\)',\n                    disabled=False,continuous_update=True,orientation='horizontal',readout=True,readout_format='.2f')\n#interact(set_coefficients, setK=K_widget, setthref=th_ref_widget, setm=m_widget, settaui=taui_widget, settaud=taud_widget)\n\n#checkboxes\n#checkbox_reset_antenna = widgets.Checkbox(value=False, description='Reset schematic representation of antenna when type of controller is changed', disabled=False)\n#checkbox_reset_graph = widgets.Checkbox(value=False, description='Reset graph when type of controller is changed', disabled=False)\n\ncheckbox_reset_antenna = widgets.Checkbox(value=False, disabled=False, layout=Layout(width='100px'))\nlabel_scheme = widgets.Label('Reset schematic representation of the antenna when the controller type is changed', layout=Layout(width='500px'))\nbox1 = widgets.HBox([checkbox_reset_antenna, label_scheme])\n                             \ncheckbox_reset_graph = widgets.Checkbox(value=False, disabled=False, layout=Layout(width='100px'))\nlabel_graph = widgets.Label('Reset \"Antenna azimuth angle vs. time\" diagram when the controller type is changed', layout=Layout(width='500px'))\nbox2 = widgets.HBox([checkbox_reset_graph, label_graph])\n\nstyle = {'description_width': 'initial'}\n\n#buttons:\ndef buttons_clicked(event):\n    global controller_type, equation, list_th, list_th_ref, list_time\n    controller_type = buttons.options[buttons.index]\n    if controller_type =='P':\n        taui_widget.disabled=True\n        taud_widget.disabled=True\n        equation = '$Kp$'\n    if controller_type =='PI':\n        taui_widget.disabled=False\n        taud_widget.disabled=True\n        equation = '$Kp\\,(1+\\dfrac{1}{T_{i}\\,s})$'\n    if controller_type =='PID':\n        taui_widget.disabled=False\n        taud_widget.disabled=False\n        equation = '$Kp\\,(1+\\dfrac{1}{T_{i}\\,s}+\\dfrac{T_{d}\\,s}{a\\,T_{d}\\,s+1})$'\n    if checkbox_reset_antenna.value:\n        #reset values to zero:\n        for i in range(len(variables)):\n            for j in range(1, len(variables[i])):\n                variables[i][j] = 0\n        variables[-1][0] = 0\n    if checkbox_reset_graph.value:\n        list_th = []\n        list_th_ref = []\n        list_time = []\n        \nbuttons = widgets.ToggleButtons(\n    options=['P', 'PI', 'PID'],\n    description='Select controller type:',\n    disabled=False,\n    style=style)\nbuttons.observe(buttons_clicked)\n\n\n#updating values\ndef set_values(event):\n    global _K, _taui, _taud\n    if event['name'] != 'value':\n        return\n    if th_ref_widget.value != variables[0][0] and not new_flag_value[0]:\n        new_flag_value[0] = True\n        new_flag_value[1] = variables[-1][0]\n        \n    variables[0][0] = th_ref_widget.value\n    variables[1][0] = m_widget.value\n    _K = K_widget.value\n    _taui = taui_widget.value\n    _taud = taud_widget.value\nth_ref_widget.observe(set_values)\nm_widget.observe(set_values)\nK_widget.observe(set_values)\ntaui_widget.observe(set_values)\ntaud_widget.observe(set_values)\n\n#displaying widgets:\ndisplay(buttons)\nvbox1 = widgets.VBox([th_ref_widget, m_widget, K_widget, taui_widget, taud_widget])\nvbox2 = widgets.VBox([box1, box2])\nhbox = widgets.HBox([vbox1, vbox2])\ndisplay(hbox)\n\n#setting at start:\ncontroller_type = 'P'\ntaui_widget.disabled=True\ntaud_widget.disabled=True\nequation = '$Kp$'\nset_values({'name':'value'})\n\n#lists for graph in time:\nlist_time = []\nlist_th = []\nlist_th_ref = []\n\n#previous th before change of th_ref:\nprev_th = 0\n\ncycles_flag = True\n\ndef update_figure(i_time):\n    global cycles_flag, variables, _K, controller_type, equation\n    \n    if cycles_flag == True:\n        cycles_flag = False\n        return\n    \n    if controller_type == 'P':\n        th = calculate_next(z_transform_p)\n    elif controller_type == 'PI':\n        th = calculate_next(z_transform_pi)\n    elif controller_type == 'PID':\n        th = calculate_next(z_transform_pid)\n    variables[-1][0] = th\n    \n    # save variables for next time step:\n    for i in range(len(variables)):\n        for j in reversed(range(len(variables[i])-1)):\n            variables[i][j+1] = variables[i][j]\n\n    list_time.append((i_time+1)*_Tv/1000)\n    list_th.append(th)\n    list_th_ref.append(variables[0][0])\n    \n    #plot:\n    ax.clear()\n    ax.plot([-1.5, 1.5, 1.5, -1.5], [-1.5, -1.5, 1.5, 1.5], ',', color='b')\n    \n    #plot line:\n    ax.plot([np.cos(th)*-.5, np.cos(th)*1.5], [np.sin(th)*-.5, np.sin(th)*1.5], 'b--', linewidth=.7, alpha=.7)\n    \n    #plot antenna:\n    center1 = 1\n    center2 = 3\n    d1 = 2.2\n    d2 = 5.5\n    x1 = center1*np.cos(th)\n    y1 = center1*np.sin(th)\n    x2 = center2*np.cos(th)\n    y2 = center2*np.sin(th)\n    arc1 = patches.Arc((x1, y1), d1, d1,\n                 angle=th/np.pi*180+180, theta1=-58, theta2=58, linewidth=2, color='black', alpha=.7)\n    arc2 = patches.Arc((x2, y2), d2, d2,\n                 angle=th/np.pi*180+180, theta1=-20, theta2=20, linewidth=2, color='black', alpha=.7)\n    ax.add_patch(arc1)\n    ax.add_patch(arc2)\n    if m_widget.value &gt; 0:\n        ax.plot(0, 0, 'r', alpha=.1, marker=r'$\\circlearrowright$',ms=150*m_widget.value)\n    elif m_widget.value &lt; 0:\n        ax.plot(0, 0, 'r', alpha=.1, marker=r'$\\circlearrowleft$',ms=-150*m_widget.value)\n    ax.set_title('Schematic representation of an antenna')\n\n    \n    #plot direction of antenna before thref change\n    if abs(variables[0][0] - th) &lt; 0.03:\n        new_flag_value[0] = False\n    if new_flag_value[0]:\n        ax.plot([0,np.cos(new_flag_value[1])], [0, np.sin(new_flag_value[1])], 'r-.', alpha=.3, linewidth=0.5)\n    #plot desired direction of antenna\n    ax.plot([0,np.cos(variables[0][0])], [0, np.sin(variables[0][0])], 'g-.', alpha=.7, linewidth=0.7)\n    \n    ax.text(-1, 1.3, 'actual angle: %.2f rad' %th)\n    ax.text(-1, -1.3, 'controller type:')\n    ax.text(-1, -1.6, equation)\n    \n    ax.set_aspect('equal', adjustable='datalim')\n    ax.set_xlim(-1.5,1.5)\n    ax.set_ylim(-1.5,1.5)\n    ax.axis('off')\n    \n    graph.clear()\n    graph.plot(list_time, list_th_ref, 'g', label='desired angle')\n    graph.plot(list_time, list_th, 'b', label='actual angle')    \n    graph.set_xlabel('$t$ [s]')\n    graph.set_ylabel('$\\\\theta$ [rad]')\n    graph.legend(loc=4, fontsize=8)\n    graph.set_title('Antenna azimuth angle vs. time')\n    \n    plt.show()\n\nani = animation.FuncAnimation(fig, update_figure, interval=_Tv)"
  },
  {
    "objectID": "ICCT_en/examples/01/M-09_Laplace_transform.html",
    "href": "ICCT_en/examples/01/M-09_Laplace_transform.html",
    "title": "Laplace transform",
    "section": "",
    "text": "from IPython.display import HTML\n\n# Cell visibility - COMPLETE:\ntag = HTML('''&lt;style&gt;\ndiv.input {\n   display:none;\n}\n&lt;/style&gt;''')\ndisplay(tag)\n\n# #Cell visibility - TOGGLE:\n# tag = HTML('''&lt;script&gt;\n# code_show=true; \n# function code_toggle() {\n#     if (code_show){\n#         $('div.input').hide()\n#     } else {\n#         $('div.input').show()\n#     }\n#     code_show = !code_show\n# } \n# $( document ).ready(code_toggle);\n# &lt;/script&gt;\n# &lt;p style=\"text-align:right\"&gt;\n# Toggle cell visibility &lt;a href=\"javascript:code_toggle()\"&gt;here&lt;/a&gt;.&lt;/p&gt;''')\n# display(tag)\n\n\n\nToggle cell visibility here.\n\n\nIn mathematics, the Laplace transform, named after its inventor Pierre-Simon Laplace, is an integral transform that converts a function of a real variable \\(t\\) (often time) to a function of a complex variable \\(s\\) (complex frequency). The transform has many applications in science and engineering because it is a tool for solving differential equations. In particular, it transforms differential equations into algebraic equations and convolution into multiplication.\nIn this example, a simple ‘interactive table’ for Laplace transform is provided: upon function selection (via dropdown menu), the plot is generated for \\(f(t)\\), and the corresponding Laplace transform \\(F(s)\\) is given.\n\n%matplotlib inline\n#%config InlineBackend.close_figures=False \nfrom ipywidgets import interactive\nfrom ipywidgets import widgets\nfrom IPython.display import Latex, display, Markdown # For displaying Markdown and LaTeX code\nimport matplotlib.pyplot as plt\nimport numpy as np\nimport math\nimport random\nimport matplotlib.patches as mpatches\nfrom IPython.display import HTML, clear_output\nfrom IPython.display import display\nfrom ipywidgets.widgets.interaction import show_inline_matplotlib_plots\n\n# Ignore division by zero warning\n#np.seterr(divide='ignore')\n\n# Patches\nblue_patch = mpatches.Patch(color='blue', label='$f(t)$')\n\n# Layouts\npanel_layout = widgets.Layout(border='solid blue', width = '40%', height = '440px', padding='5px')\nplot_layout = widgets.Layout(border='solid red', width = '60%', height = '440px', padding='5px')\noutput_panel = widgets.Output(layout = panel_layout)\noutput_plot = widgets.Output(layout = plot_layout)\n\n# Widgets\nn_slider = widgets.IntSlider(description='n:', min=0, max=5, step=1, continuous_update=False)\nc_slider = widgets.FloatSlider(description='c:', min=0, max=4.5, step=0.25, continuous_update=False)\nk_slider_exp = widgets.IntSlider(description='k:', min=0, max=4, step=1, continuous_update=False)\na_slider_sin = widgets.FloatSlider(description='a:', min=0, max=10, step=0.25, continuous_update=False)\na_slider_cos = widgets.FloatSlider(description='a:', min=0, max=10, step=0.25, continuous_update=False)\na_slider_expsin = widgets.FloatSlider(description='a:', min=0, max=10, step=0.25, continuous_update=False)\nk_slider_expsin = widgets.IntSlider(description='k:', min=0, max=4, step=1, continuous_update=False)\na_slider_expcos = widgets.FloatSlider(description='a:', min=0, max=10, step=0.25, continuous_update=False)\nk_slider_expcos = widgets.IntSlider(description='k:', min=0, max=4, step=1, continuous_update=False)\n\n\nexample_select = widgets.Dropdown(\n    options=['linear function', 'constant function', 'potential function', 'exponential function', 'sine function', 'cosine function', 'damped sine function', 'damped cosine function'],\n    value='linear function',\n    description='Select function:',\n    disabled=False,\n    style = {'description_width': 'initial'},\n)\n\n\n#functions\ndef first():\n    with output_plot:\n        linear_fun()\n        \n    with output_panel:\n        output_panel.clear_output()\n        display(Markdown(r'Input function: $f(t) = t$'))\n        display(Markdown(r'Laplace transform:'))\n        display(Markdown(r'$\\mathcal{L}\\{F(t)\\} = F(s) = \\frac{1}{s^2}$'))\n        display(Markdown(r'with $Re(s) &gt; 0$'))\n\n        \ndef linear_fun():   \n    output_plot.clear_output()\n    \n    plt.figure(figsize=(10,5))\n    x_axis = np.linspace(0,5, num=1000)\n    plt.plot(x_axis, x_axis, 'b-')\n    plt.xlim(0, 5)\n    plt.ylim(0, 5)\n    plt.grid(True)\n    plt.legend(handles=[blue_patch])\n    plt.xlabel('t [s]')\n    plt.ylabel('f(t)')\n    plt.xticks(range(0,5,1))\n    plt.title(r'Graph of the function $f(t) = t$')\n    plt.show()\n    \n    with output_panel:\n        output_panel.clear_output()\n        display(Markdown(r'Input function: $f(t) = t$'))\n        display(Markdown(r'Laplace transform:'))\n        display(Markdown(r'$\\mathcal{L}\\{F(t)\\} = F(s) = \\frac{1}{s^2}$'))\n        display(Markdown(r'with $Re(s) &gt; 0$'))\n\n    \ndef constant_fun(c=1):\n    output_plot.clear_output()\n    display(c_slider)\n    \n    plt.figure(figsize=(10,5))\n    x_axis = np.linspace(0,5, num=1000)\n    plt.plot(x_axis, [c for t in x_axis], 'b-')\n    plt.xlim(0, 5)\n    plt.ylim(-1, 5)\n    plt.grid(True)\n    plt.legend(handles=[blue_patch])\n    plt.xlabel('t [s]')\n    plt.ylabel('f(t)')\n    plt.xticks(range(0,5,1))\n    plt.title(r'Graph of the function $f(t) = c$')\n    plt.show()\n        \n    with output_panel:\n        output_panel.clear_output(wait=True)\n        display(Markdown(r'Input function: $f(t) = c$'))\n        display(Markdown(r'Laplace transform:'))\n        display(Markdown(r'$\\mathcal{L}\\{F(t)\\} = F(s) = \\frac{c}{s}$'))\n        display(Markdown(r'with $Re(s) &gt; 0$'))\n        display(Markdown(r'For c = '+str(c_slider.value)+r': $F(s) = \\frac{'+str(c_slider.value)+r'}{s}$'))\n  \n    \ndef potential_fun(n=1):\n    output_plot.clear_output()\n    display(n_slider)\n    \n    plt.figure(figsize=(10,5))\n    x_axis = np.linspace(0,5, num=1000)\n    plt.plot(x_axis, [x**n for x in x_axis], 'b-')\n    plt.xlim(0, 5)\n    plt.ylim(0, 20)\n    plt.grid(True)\n    plt.legend(handles=[blue_patch])\n    plt.xlabel('t [s]')\n    plt.ylabel('f(t)')\n    plt.xticks(range(0,5,1))\n    plt.title(r'Graph of the function $f(t) = t^n$')\n    plt.show()\n        \n    with output_panel:\n        output_panel.clear_output()\n        display(Markdown(r'Input function: $f(t) = t^n$'))\n        display(Markdown(r'Laplace transform:'))\n        display(Markdown(r'$\\mathcal{L}\\{F(t)\\} = F(s) = \\frac{n!}{s^{n+1}}$'))\n        display(Markdown(r'with $Re(s) &gt; 0$'))\n        display(Markdown(r'For n = '+str(n_slider.value)+r': $F(s)= \\frac{'+str(math.factorial(n_slider.value))+r'}{s^'+str(n_slider.value+1)+r'}$'))\n\n        \ndef exponential_fun(k):\n    output_plot.clear_output()\n    display(k_slider_exp)\n    \n    plt.figure(figsize=(10,5))\n    x_axis = np.linspace(0,5, num=1000)\n    plt.plot(x_axis, [np.e**(k*x) for x in x_axis], 'b-')\n    plt.xlim(0, 4)\n    plt.ylim(0, 20)\n    plt.grid(True)\n    plt.legend(handles=[blue_patch])\n    plt.xlabel('t [s]')\n    plt.ylabel('f(t)')\n    plt.xticks(range(0,5,1))\n    plt.title(r'Graph of the function $f(t) = e^{kt}$')\n    plt.show()\n        \n    with output_panel:\n        output_panel.clear_output()\n        display(Markdown(r'Input function: $f(t) = e^{kt}$'))\n        display(Markdown(r'Laplace transform:'))\n        display(Markdown(r'$\\mathcal{L}\\{F(t)\\} = F(s) = \\frac{1}{s-k}$'))\n        display(Markdown(r'with $Re(s) &gt; Re(k)$'))\n        display(Markdown(r'For k = '+str(k_slider_exp.value)+r': $F(s)= \\frac{1}{s-'+str(k_slider_exp.value)+r'}$'))\n\n        \ndef sin_fun(a):\n    output_plot.clear_output()\n    display(a_slider_sin)\n    \n    plt.figure(figsize=(10,5))\n    x_axis = np.linspace(0,5, num=1000)\n    plt.plot(x_axis, [np.sin(2*np.pi*a*x)for x in x_axis], 'b-')\n    plt.xlim(0, 5)\n    plt.ylim(-2, 2)\n    plt.grid(True)\n    plt.legend(handles=[blue_patch])\n    plt.xlabel('t [s]')\n    plt.ylabel('f(t)')\n    plt.xticks(range(0,5,1))\n    plt.title(r'Graph of the function $f(t) = sin(at)$')\n    plt.show()\n\n    with output_panel:\n        output_panel.clear_output()\n        display(Markdown(r'Input function: $f(t) = sin(at)$'))\n        display(Markdown(r'Laplace transform:'))\n        display(Markdown(r'$\\mathcal{L}\\{F(t)\\} = F(s) = \\frac{a}{s^2 + a^2}$'))\n        display(Markdown(r'with $Re(s) &gt; 0$'))\n        display(Markdown(r'For a = '+str(a_slider_sin.value)+r': $F(s)= \\frac{'+str(a_slider_sin.value)+r'}{s^2+'+str(a_slider_sin.value**2)+r'}$'))\n    \n    \ndef cos_fun(a):\n    output_plot.clear_output()\n    display(a_slider_cos)\n    \n    plt.figure(figsize=(10,5))\n    x_axis = np.linspace(0,5, num=1000)\n    plt.plot(x_axis, [np.cos(2*np.pi*a*x)for x in x_axis], 'b-')\n    plt.xlim(0, 5)\n    plt.ylim(-2, 2)\n    plt.grid(True)\n    plt.legend(handles=[blue_patch])\n    plt.xlabel('t [s]')\n    plt.ylabel('f(t)')\n    plt.xticks(range(0,5,1))\n    plt.title(r'Graph of the function $f(t) = cos(at)$')\n    plt.show()\n\n    with output_panel:\n        output_panel.clear_output()\n        display(Markdown(r'Input function: $f(t) = cos(at)$'))\n        display(Markdown(r'Laplace transform:'))\n        display(Markdown(r'$\\mathcal{L}\\{F(t)\\} = F(s) = \\frac{s}{s^2 + a^2}$'))\n        display(Markdown(r'with $Re(s) &gt; 0$'))\n        display(Markdown(r'For a = '+str(a_slider_cos.value)+r': $F(s)= \\frac{s}{s^2+'+str(a_slider_cos.value**2)+r'}$'))    \n\n        \ndef exp_sin_fun(a, k):\n    output_plot.clear_output()\n    display(a_slider_expsin, k_slider_expsin)\n    \n    plt.figure(figsize=(10,5))\n    x_axis = np.linspace(0,5, num=1000)\n    plt.plot(x_axis, [np.e**(-k*x)* np.sin(2*np.pi*a*x) for x in x_axis], 'b-')\n    plt.xlim(0, 5)\n    plt.ylim(-2, 2)\n    plt.grid(True)\n    plt.legend(handles=[blue_patch])\n    plt.xlabel('t [s]')\n    plt.ylabel('f(t)')\n    plt.xticks(range(0,5,1))\n    plt.title(r'Graph of the function $f(t) = e^{-kt} sin(at)$')\n    plt.show()\n    \n    with output_panel:\n        output_panel.clear_output()\n        display(Markdown(r'Input function: $f(t) = e^{-kt} sin(at)$'))\n        display(Markdown(r'Laplace transform:'))\n        display(Markdown(r'$\\mathcal{L}\\{F(t)\\} = F(s) = \\frac{a}{(s+k)^2 + a^2}$'))\n        display(Markdown(r'with $Re(s) &gt; -k$'))\n        display(Markdown(r'For a, k = '+str(a_slider_expsin.value)+', '+str(k_slider_expsin.value)+r': $F(s)= \\frac{'+str(a_slider_expsin.value)+r'}{(s+'+str(k_slider_expsin.value)+r')^2+'+str(a_slider_expsin.value**2)+r'}$'))\n        \n        \ndef exp_cos_fun(a, k):\n    output_plot.clear_output()\n    display(a_slider_expcos, k_slider_expcos)\n    \n    plt.figure(figsize=(10,5))\n    x_axis = np.linspace(0,5, num=1000)\n    plt.plot(x_axis, [np.e**(-k*x)* np.cos(2*np.pi*a*x) for x in x_axis], 'b-')\n    plt.xlim(0, 5)\n    plt.ylim(-2, 2)\n    plt.grid(True)\n    plt.legend(handles=[blue_patch])\n    plt.xlabel('t [s]')\n    plt.ylabel('f(t)')\n    plt.xticks(range(0,5,1))\n    plt.title(r'Graph of the function $f(t) = e^{-kt} cos(at)$')\n    plt.show()\n\n    with output_panel:\n        output_panel.clear_output()\n        display(Markdown(r'Input function: $f(t) = e^{-kt} cos(at)$'))\n        display(Markdown(r'Laplace transform:'))\n        display(Markdown(r'$\\mathcal{L}\\{F(t)\\} = F(s) = \\frac{s+k}{(s+k)^2 + a^2}$'))\n        display(Markdown(r'with $Re(s) &gt; -k$'))\n        display(Markdown(r'For a, k = '+str(a_slider_expcos.value)+', '+str(k_slider_expcos.value)+r': $F(s)= \\frac{s+'+str(k_slider_expcos.value)+r'}{(s+'+str(k_slider_expcos.value)+r')^2+'+str(a_slider_expcos.value**2)+r'}$'))    \n        \n        \n# slider observers        \ndef slider_change(change, sender):\n    if sender == 'constant':\n        constant_fun(change['new'])\n    if sender == 'potential':\n        potential_fun(change['new'])\n    if sender == 'exponential':\n        exponential_fun(change['new'])\n    if sender == 'sin':\n        sin_fun(change['new'])\n    if sender == 'cos':\n        cos_fun(change['new'])\n    if sender == 'expsin_a':\n        exp_sin_fun(change['new'], k_slider_expsin.value)\n    if sender == 'expsin_k':\n        exp_sin_fun(a_slider_expsin.value, change['new'])\n    if sender == 'expcos_a':\n        exp_cos_fun(change['new'], k_slider_expcos.value)\n    if sender == 'expcos_k':\n        exp_cos_fun(a_slider_expcos.value, change['new'])\n\nc_slider.observe(lambda change: slider_change(change, 'constant'), names='value')\nn_slider.observe(lambda change: slider_change(change, 'potential'), names='value')\nk_slider_exp.observe(lambda change: slider_change(change, 'exponential'), names='value')\na_slider_sin.observe(lambda change: slider_change(change, 'sin'), names='value')\na_slider_cos.observe(lambda change: slider_change(change, 'cos'), names='value')\na_slider_expsin.observe(lambda change: slider_change(change, 'expsin_a'), names='value')\nk_slider_expsin.observe(lambda change: slider_change(change, 'expsin_k'), names='value')\na_slider_expcos.observe(lambda change: slider_change(change, 'expcos_a'), names='value')\nk_slider_expcos.observe(lambda change: slider_change(change, 'expcos_k'), names='value')\n\n    \n# dropdown selection handler    \ndef example_select_handler(change):\n    if example_select.value == 'linear function':\n        with output_plot:\n            linear_fun()\n    \n    if example_select.value == 'constant function':\n        with output_plot:\n             constant_fun(c_slider.value)\n    \n    if example_select.value == 'potential function':\n        with output_plot:\n            potential_fun(n_slider.value)        \n                 \n    if example_select.value == 'exponential function':\n        with output_plot:\n            exponential_fun(k_slider_exp.value)\n     \n    if example_select.value == 'sine function':\n        with output_plot:\n            sin_fun(a_slider_sin.value)\n           \n    if example_select.value =='cosine function':\n        with output_plot:\n            cos_fun(a_slider_cos.value)\n    \n    if example_select.value == 'damped sine function':\n        with output_plot:\n            exp_sin_fun(a_slider_expsin.value, k_slider_expsin.value)\n        \n    if example_select.value == 'damped cosine function':\n        with output_plot:\n            exp_cos_fun(a_slider_expcos.value, k_slider_expcos.value)\n            \n            \nexample_select.observe(example_select_handler, names='value')\ndisplay(example_select, widgets.HBox([output_plot, widgets.Label(\" \"), output_panel ]))\nfirst()"
  },
  {
    "objectID": "ICCT_en/examples/01/M-07_Functions_graphs.html",
    "href": "ICCT_en/examples/01/M-07_Functions_graphs.html",
    "title": "Functions and their graphs",
    "section": "",
    "text": "from IPython.display import HTML\n\n# Cell visibility - COMPLETE:\ntag = HTML('''&lt;style&gt;\ndiv.input {\n   display:none;\n}\n&lt;/style&gt;''')\ndisplay(tag)\n\n# #Cell visibility - TOGGLE:\n# tag = HTML('''&lt;script&gt;\n# code_show=true; \n# function code_toggle() {\n#     if (code_show){\n#         $('div.input').hide()\n#     } else {\n#         $('div.input').show()\n#     }\n#     code_show = !code_show\n# } \n# $( document ).ready(code_toggle);\n# &lt;/script&gt;\n# &lt;p style=\"text-align:right\"&gt;\n# Toggle cell visibility &lt;a href=\"javascript:code_toggle()\"&gt;here&lt;/a&gt;.&lt;/p&gt;''')\n# display(tag)\n\n\n\nToggle cell visibility here.\n\n\nIn this simple example, feel free to investigate the effects of frequency, amplitude, phase, decay, and other relevant parameters on some basic functions utilized in the Control Theory. For each function (selected via dropdown menu), a coresponding plot will visualize the given signal which can further be modified according to the values set by slider widgets. The following functions can be analyzed: * sine wave, * cosine wave, * damped wave, * impulse (or Dirac delta) function, * step function, * ramp function, * triangle wave.\n\n%matplotlib inline\n#%config InlineBackend.close_figures=False \nfrom ipywidgets import interactive\nfrom ipywidgets import widgets\nfrom IPython.display import Latex, display, Markdown # For displaying Markdown and LaTeX code\nimport matplotlib.pyplot as plt\nimport numpy as np\nimport math\nimport matplotlib.patches as mpatches\nfrom IPython.display import HTML, clear_output\nfrom IPython.display import display\n\n\n# Functions descriptions\nsine_text = \"Sine wave: A sine wave or sinusoid is a mathematical curve that describes a smooth periodic oscillation. A sine wave is a continuous wave. It is named after the sine function.\"\ncosine_text = \"Cosine eave: A cosine wave is a signal waveform with a shape identical to that of a sine wave, except each point on the cosine wave occurs exactly 1/4 cycle earlier than the corresponding point on the sine wave. A cosine wave and its corresponding sine wave have the same frequency, but the cosine wave leads the sine wave by 90 degrees of phase.\"\ndumped_text = \"Damped wave: A damped wave is a wave whose amplitude of oscillation decreases with time, eventually going to zero, an exponentially decaying sinusoidal wave. An ideal damped wave is an exponentially decreasing sinusoid; an oscillating sine (or cosine) wave in which the peak amplitude decreases from an initial maximum toward zero at an exponential rate.\"\ndelta_text = \"Impulse function: In mathematics, the impulse function or Dirac delta function or δ function is a generalized function or distribution introduced by physicist Paul Dirac. It is used to model the density of an idealized point mass or point charge as a function equal to zero everywhere except for zero and whose integral over the entire real line is equal to one.\"\nstep_text = \"Step function: In mathematics, a function on the real numbers is called a step function (or staircase function) if it can be written as a finite linear combination of indicator functions of intervals. Informally speaking, a step function is a piecewise constant function having only finitely many pieces. \"\nramp_text = 'Ramp function: The ramp function is a unary real function, whose graph is shaped like a ramp. It can be expressed by numerous definitions, for example \"0 for negative inputs, output equals input for non-negative inputs\". The term \"ramp\" can also be used for other functions obtained by scaling and shifting, and the function in this example is the unit ramp function (slope 1, starting at 0).'\ntriang_text = 'Triangle wave: A triangular wave or triangle wave is a non-sinusoidal waveform named for its triangular shape. It is a periodic, piecewise linear, continuous real function. '\n\n\n\n# Sine widgets\nslider_a = widgets.FloatSlider(description='Amplitude', min=0., max=4., step=0.25, continuous_update=False)\nslider_f = widgets.FloatSlider(description='Frequency', min=0., max=10., step=0.5, continuous_update=False)\nslider_p = widgets.FloatSlider(description='Phase', min=-10.0, max=10.0, step=0.5, continuous_update=False)\nslider_f.value = 5 \nslider_a.value = 2\nslider_p.value = 0 \nformula_sine = r'$f(t)= Asin(2{\\pi}ft + {\\varphi})$'\n\n# Cosine widgets\nslider_acos = widgets.FloatSlider(description='Amplitude', min=0., max=4., step=0.25, continuous_update=False)\nslider_fcos = widgets.FloatSlider(description='Frequency', min=0., max=10., step=0.5, continuous_update=False)\nslider_pcos = widgets.FloatSlider(description='Phase', min=-10.0, max=10.0, step=0.5, continuous_update=False)\nslider_fcos.value = 5 \nslider_acos.value = 2\nslider_pcos.value = 0 \nformula_cosine = r'$f(t)= Acos(2{\\pi}ft + {\\varphi})$'\n\n# Damping widgets\nslider_adamp = widgets.FloatSlider(description='Amplitude', min=0., max=4., step=0.25, continuous_update=False)\nslider_fdamp = widgets.FloatSlider(description='Frequency', min=0., max=10., step=0.5, continuous_update=False)\nslider_pdamp = widgets.FloatSlider(description='Phase', min=-10.0, max=10.0, step=0.5, continuous_update=False)\nslider_d = widgets.FloatSlider(description='Decay', min=0., max=3., step=0.2, continuous_update=False)\nslider_fdamp.value = 5 \nslider_adamp.value = 2\nslider_pdamp.value = 0 \nslider_d.value = 0 \nformula_damp = r'$f(t)= Ae^{-{\\lambda}t}cos(2{\\pi}ft + {\\varphi})$'\n\n# Delta widgets\nslider_adelta = widgets.FloatSlider(description='Parameter a', value = 0.01, min=0.01, max=1.5, step=0.01, continuous_update=False)\nformula = r'$\\delta_{a}(x)= \\frac{1}{|a|\\sqrt{\\pi}}e^{-(x/a)^2}$'\n\n# Step widget\nformula_step = r'$ f(x) = \\begin{cases} b, & \\mbox{if } x &gt; a \\\\ 0, & \\mbox{if } x \\leq a \\end{cases} $'\nslider_astep = widgets.FloatSlider(description='Parameter a', value = 0., min=-10, max=10, step=0.5, continuous_update=False)\nslider_bstep = widgets.FloatSlider(description='Parameter b', value = 1, min=0, max=5., step=0.5, continuous_update=False)\n\n# Ramp widgets\nformula_ramp = r'$ f(x) = \\begin{cases} x-a, & \\mbox{if } x &gt; a \\\\ 0, & \\mbox{if } x \\leq a \\end{cases} $'\nslider_aramp = widgets.FloatSlider(description='Parameter a', value = 0., min=-10, max=10, step=0.5, continuous_update=False)\n\n# Triangle widgets\nslider_atri = widgets.FloatSlider(description='Amplitude', min=1, max=4., step=0.5, continuous_update=False)\nslider_ptri = widgets.FloatSlider(description='Period', min=1, max=10., step=0.5, continuous_update=False)\nformula_triangle = r'$f(t)= \\frac{2a}{\\pi}arcsin(sin(\\frac{2\\pi}{p}t))$'\n\n# Layouts\ninfo_layout = widgets.Layout(border='solid black', width = '100%', height = '200', padding='5px')\npanel_layout = widgets.Layout(border='solid blue', width = '35%', height = '175', padding='5px')\nplot_layout = widgets.Layout(border='solid red', width = '65%', height = '175', padding='5px')\noutput_info = widgets.Output(layout = info_layout)\noutput_panel = widgets.Output(layout = panel_layout)\noutput_plot = widgets.Output(layout = plot_layout)\n\n# Dropdown widget\ndd_order = widgets.Dropdown(\n    options=['sine wave', 'cosine wave', 'damped wave', 'impulse function', 'step function', 'ramp function', 'triangle wave'],\n    value='sine wave',\n    description='Select function:',\n    disabled=False,\n    style = {'description_width': 'initial'},\n)\n\n# Functions\ndef f_sin(A, frequency, phase):\n    \n    plt.figure(figsize=(10,5))\n    t = np.linspace(-10, 10, num=1000)\n    plt.plot(t, A * np.sin(t*frequency + phase), 'b-')\n    plt.xlim(-10, 10)\n    plt.ylim(-5, 5)\n    plt.grid(True)\n    plt.xlabel('t [s]')\n    plt.ylabel('$f(t)$')\n    plt.axhline(y=0,lw=0.8,color='k')\n    plt.axvline(x=0,lw=0.8,color='k')\n    with output_plot:\n        output_plot.clear_output(wait=True)\n        plt.show()\n\ndef f_cos(A, frequency, phase):\n    plt.figure(figsize=(10,5))\n    t = np.linspace(-10, 10, num=1000)\n    plt.plot(t, A * np.cos(t*frequency + phase), 'r-')\n    plt.xlim(-10, 10)\n    plt.ylim(-5, 5)\n    plt.grid(True)\n    plt.xlabel('t [s]')\n    plt.ylabel('$f(t)$')\n    plt.axhline(y=0,lw=0.8,color='k')\n    plt.axvline(x=0,lw=0.8,color='k')\n    with output_plot:\n        output_plot.clear_output(wait=True)\n        plt.show()\n        \ndef f_damping(A, frequency, phase, decay):\n    plt.figure(figsize=(10,5))\n    x = np.linspace(0, 10, num=1000)\n    #plt.plot(x, [A * math.exp(-decay * t) *(np.cos(t*frequency + phase) + np.sin(t*frequency + phase)) for t in x])\n    plt.plot(x, [A * math.exp(-decay * t) *(np.cos(t*frequency + phase)) for t in x], \"g-\")\n    plt.xlim(0, 10)\n    plt.ylim(-5, 5)\n    plt.grid(True)\n    plt.xlabel('t [s]')\n    plt.ylabel('$f(t)$')\n    plt.axhline(y=0,lw=0.8,color='k')\n    plt.axvline(x=0,lw=0.8,color='k')\n    with output_plot:\n        output_plot.clear_output(wait=True)\n        plt.show()\n\ndef f_delta(a):\n    plt.figure(figsize=(10,5))\n    x = np.linspace(-10, 10, num=1000)\n    #plt.plot(x, [A * math.exp(-decay * t) *(np.cos(t*frequency + phase) + np.sin(t*frequency + phase)) for t in x])\n    plt.plot(x, [1 / (abs(a)*math.sqrt(np.pi)) * np.e **(-(t/a)**2) for t in x], \"b-\")\n    plt.xlim(-10, 10)\n    plt.ylim(-3, 6)\n    plt.grid(True)\n    plt.xlabel('t [s]')\n    plt.ylabel('$f(t)$')\n    plt.axhline(y=0,lw=0.8,color='k')\n    plt.axvline(x=0,lw=0.8,color='k')\n    with output_plot:\n        output_plot.clear_output(wait=True)\n        plt.show()\n\ndef f_step(a,b):\n    plt.figure(figsize=(10,5))\n    step = lambda x, a, b: b if x &gt; a else 0\n\n    x = np.linspace(-10, 10, num=1000)\n    #plt.plot(x, [A * math.exp(-decay * t) *(np.cos(t*frequency + phase) + np.sin(t*frequency + phase)) for t in x])\n    plt.plot(x, [step(t, a, b) for t in x] , \"r-\")\n    plt.xlim(-10, 10)\n    plt.ylim(-3, 6)\n    plt.grid(True)\n    plt.xlabel('t [s]')\n    plt.ylabel('$f(t)$')\n    plt.axhline(y=0,lw=0.8,color='k')\n    plt.axvline(x=0,lw=0.8,color='k')\n    with output_plot:\n        output_plot.clear_output(wait=True)\n        plt.show()\n\ndef f_ramp(a):\n    plt.figure(figsize=(10,5))\n    step = lambda x, a: x - a if x &gt; a else 0\n\n    x = np.linspace(-10, 10, num=1000)\n    #plt.plot(x, [A * math.exp(-decay * t) *(np.cos(t*frequency + phase) + np.sin(t*frequency + phase)) for t in x])\n    plt.plot(x, [step(t, a) for t in x] , \"g-\")\n    plt.xlim(-10, 10)\n    plt.ylim(-3, 6)\n    plt.grid(True)\n    plt.xlabel('t [s]')\n    plt.ylabel('$f(t)$')\n    plt.axhline(y=0,lw=0.8,color='k')\n    plt.axvline(x=0,lw=0.8,color='k')\n    with output_plot:\n        output_plot.clear_output(wait=True)\n        plt.show()\n    \ndef f_triangle(a, p):\n    plt.figure(figsize=(10,5))\n    t = np.linspace(-10, 10, num=1000)\n    plt.plot(t, [2 * a / np.pi * np.arcsin(np.sin(2*np.pi * x / p)) for x in t], 'b-')\n    plt.xlim(-10, 10)\n    plt.ylim(-5, 5)\n    plt.grid(True)\n    plt.xlabel('t [s]')\n    plt.ylabel('$f(t)$')\n    plt.axhline(y=0,lw=0.8,color='k')\n    plt.axvline(x=0,lw=0.8,color='k')    \n    with output_plot:\n        output_plot.clear_output(wait=True)\n        plt.show()    \n    \ndef first_setup():\n    with output_info:\n        output_info.clear_output()\n        display(Markdown(sine_text))\n                \n    with output_panel:\n        output_panel.clear_output()\n        display(Markdown(formula_sine))\n        display(interactive(f_sin, A=slider_a, frequency=slider_f, phase=slider_p))   \n\n\ndef dropdown_eventhandler(change):    \n    if (dd_order.value == 'sine wave'):\n        with output_info:\n            output_info.clear_output()\n            display(Markdown(sine_text))\n        \n        with output_panel:\n            output_panel.clear_output()\n            display(Markdown(formula_sine))\n            display(interactive(f_sin, A=slider_a, frequency=slider_f, phase=slider_p))  \n    \n    if (dd_order.value == 'cosine wave'):\n        with output_info:\n            output_info.clear_output()\n            display(Markdown(cosine_text))\n        \n        with output_panel:\n            output_panel.clear_output()\n            display(Markdown(formula_cosine))\n            display(interactive(f_cos, A=slider_acos, frequency=slider_fcos, phase=slider_pcos))\n        \n    if (dd_order.value == 'damped wave'):\n        with output_info:\n            output_info.clear_output()\n            display(Markdown(dumped_text))\n        \n        with output_panel:\n            output_panel.clear_output()\n            display(Markdown(formula_damp))\n            display(interactive(f_damping, A=slider_adamp, frequency=slider_fdamp, phase=slider_pdamp, decay=slider_d))\n    \n    if (dd_order.value == 'impulse function'):\n        with output_info:\n            output_info.clear_output()\n            display(Markdown(delta_text))\n        \n        with output_panel:\n            output_panel.clear_output()\n            display(Markdown(formula))\n            display(interactive(f_delta, a = slider_adelta))\n    \n    if (dd_order.value == 'step function'):\n        with output_info:\n            output_info.clear_output()\n            display(Markdown(step_text))\n        \n        with output_panel:\n            output_panel.clear_output()\n            display(Markdown(formula_step))\n            display(interactive(f_step, a = slider_astep, b = slider_bstep))\n    \n    if (dd_order.value == 'ramp function'):\n        with output_info:\n            output_info.clear_output()\n            display(Markdown(ramp_text))\n        \n        with output_panel:\n            output_panel.clear_output()\n            display(Markdown(formula_ramp))\n            display(interactive(f_ramp, a = slider_aramp))\n    \n    if (dd_order.value == 'triangle wave'):\n        with output_info:\n            output_info.clear_output()\n            display(Markdown(triang_text))\n        \n        with output_panel:\n            output_panel.clear_output()\n            display(Markdown(formula_triangle))\n            display(interactive(f_triangle, a = slider_atri, p = slider_ptri))\n    \ndisplay(dd_order, output_info, widgets.HBox([output_panel, widgets.Label(\" \"), output_plot]) )\nfirst_setup()\ndd_order.observe(dropdown_eventhandler, names='value')"
  },
  {
    "objectID": "ICCT_en/examples/01/M-05_Integrals_of_polynomials.html",
    "href": "ICCT_en/examples/01/M-05_Integrals_of_polynomials.html",
    "title": "Integrals of polynomials",
    "section": "",
    "text": "from IPython.display import HTML\n\n# Cell visibility - COMPLETE:\ntag = HTML('''&lt;style&gt;\ndiv.input {\n   display:none;\n}\n&lt;/style&gt;''')\ndisplay(tag)\n\n# #Cell visibility - TOGGLE:\n# tag = HTML('''&lt;script&gt;\n# code_show=true; \n# function code_toggle() {\n#     if (code_show){\n#         $('div.input').hide()\n#     } else {\n#         $('div.input').show()\n#     }\n#     code_show = !code_show\n# } \n# $( document ).ready(code_toggle);\n# &lt;/script&gt;\n# &lt;p style=\"text-align:right\"&gt;\n# Toggle cell visibility &lt;a href=\"javascript:code_toggle()\"&gt;here&lt;/a&gt;.&lt;/p&gt;''')\n# display(tag)\n\n\n\nToggle cell visibility here.\n\n\nIn this interactive example you can visualize some interesting aspects concerning the integral of a polynomial function. For a given polynomial (which can be set by making use of coefficient sliders), indefinite integral will be dynamically calculated and presented, both in the plot and in the mathematical notation.\nFurthermore, by setting lower and upper limit (using dedicated slider widgets), the respective area under curve will be highlighted and calculated. Please note that the lower limit has to be smaller than the upper limit, in order for definite integral to be valid.\n\nimport numpy as np\nimport matplotlib.pyplot as plt\nfrom matplotlib.patches import Polygon\nimport sympy as sym\nfrom IPython.display import Latex, display, clear_output, Markdown # For displaying Markdown and LaTeX code\nfrom ipywidgets import widgets\nfrom ipywidgets import interactive\nimport matplotlib.patches as mpatches\nfrom scipy.integrate import quad \nfrom IPython.display import HTML\n\nred_patch = mpatches.Patch(color='red', label='$f(x)$')\nblue_patch = mpatches.Patch(color='blue', label='Indefinite integral of $f(x)$')\ngray_patch = mpatches.Patch(color='lightgray', label='Area under the curve')\nXLIM = 10\nYLIM = 30\n\nx = sym.symbols('x')\n\n# Polynomial coeficients\na = 0\nb = 0\nc = 0\nd = 0\ne = 0\nC = 0\n\n\n# Sliders\nfs_a = widgets.FloatSlider(description='$a$', min=-10.0, max=10.0, step=0.5, continuous_update=False)\nfs_b = widgets.FloatSlider(description='$b$', min=-10.0, max=10.0, step=0.5, continuous_update=False)\nfs_c = widgets.FloatSlider(description='$c$',min=-10.0, max=10.0, step=0.5, continuous_update=False)\nfs_d = widgets.FloatSlider(description='$d$',min=-10.0, max=10.0, step=0.5, continuous_update=False)\nfs_e = widgets.FloatSlider(description='$e$',min=-10.0, max=10.0, step=0.5, continuous_update=False)\nw_C = widgets.FloatSlider(description='$C$:',min=-10.0, max=10.0, step=0.5, continuous_update=False)\nlower_limit = widgets.FloatSlider(description='Lower limit:',min=-10.0, max=10.0, step=0.5, continuous_update=False)\nupper_limit = widgets.FloatSlider(description='Upper limit:',min=-10.0, max=10.0, step=0.5, continuous_update=False)\n\n# Mathematical notation of a specific (user-defined) polynomial, shown as Markdown\nfourth_order = \"e + d * x + c * x ** 2 + b * x ** 3 + a * x ** 4\"\nthird_order = \"d + c * x + b * x ** 2 + a * x ** 3\"\nsecond_order = \"c + b * x + a * x ** 2\"\nfirst_order = \"b + a * x\"\nzero_order = \"a\"\ntf = sym.sympify(fourth_order)  \nw_mark = Markdown('$%s$' %sym.latex(tf))\n\n\n# General mathematical notation of a polynomial (shown in Label widget)\nfourth_order_html = \"$f(x)=ax^4$ + $bx^3$ + $cx^2$ + $dx$ + $e$\"\nthird_order_html = \"$f(x)=ax^3$ + $bx^2$ + $cx$ + $d$\"\nsecond_order_html = \"$f(x)=ax^2$ + $bx$ + $c$\"\nfirst_order_html = \"$f(x)=ax$ + $b$\"\nzero_order_html = \"$f(x)=a$\"\nw_funLabel = widgets.Label(layout=widgets.Layout(width='40%', margin='0px 0px 0px 50px'),)\n\n\n\ndd_order = widgets.Dropdown(\n    options=['4', '3', '2', '1', '0'],\n    value='4',\n    description='Select order of the polynomial [0-4]:',\n    disabled=False,\n    style = {'description_width': 'initial'},\n)\n\ndef dropdown_eventhandler(change):\n    fs_a.layout.visibility = 'hidden'\n    fs_b.layout.visibility = 'hidden'\n    fs_c.layout.visibility = 'hidden'\n    fs_d.layout.visibility = 'hidden'\n    fs_e.layout.visibility = 'hidden'\n    \n    if (dd_order.value == '4'):\n        fs_a.layout.visibility = 'visible'\n        fs_a.description = '$a$'\n        fs_b.layout.visibility = 'visible'\n        fs_b.description = '$b$'\n        fs_c.layout.visibility = 'visible'\n        fs_c.description = '$c$'\n        fs_d.layout.visibility = 'visible'\n        fs_d.description = '$d$'\n        fs_e.layout.visibility = 'visible'\n        fs_e.description = '$e$'\n        w_funLabel.value=fourth_order_html\n    if (dd_order.value == '3'):      \n        fs_a.value = 0\n        fs_b.layout.visibility = 'visible'\n        fs_b.description = '$a$'\n        fs_c.layout.visibility = 'visible'\n        fs_c.description = '$b$'\n        fs_d.layout.visibility = 'visible'\n        fs_d.description = '$c$'\n        fs_e.layout.visibility = 'visible'\n        fs_e.description = '$d$'\n        w_funLabel.value=third_order_html\n    if (dd_order.value == '2'):\n        fs_a.value = 0\n        fs_b.value = 0\n        fs_c.layout.visibility = 'visible'\n        fs_c.description = '$a$'\n        fs_d.layout.visibility = 'visible'\n        fs_d.description = '$b$'\n        fs_e.layout.visibility = 'visible'\n        fs_e.description = '$c$'\n        w_funLabel.value=second_order_html\n    if (dd_order.value == '1'):\n        fs_a.value = 0\n        fs_b.value = 0\n        fs_c.value = 0\n        fs_d.layout.visibility = 'visible'\n        fs_d.description = '$a$'\n        fs_e.layout.visibility = 'visible'\n        fs_e.description = '$b$'\n        w_funLabel.value=first_order_html\n    if (dd_order.value == '0'):\n        fs_a.value = 0\n        fs_b.value = 0\n        fs_c.value = 0\n        fs_d.value = 0\n        fs_e.layout.visibility = 'visible'\n        fs_e.description = '$a$'\n        w_funLabel.value=zero_order_html\n\ndd_order.observe(dropdown_eventhandler, names='value')\n\n\n\n# Functions\ndef polynomial_function(X_quad, X_cubed, X_squared, X, const, x):\n    return const + X * x + X_squared * x ** 2 + X_cubed * x ** 3 + X_quad * x ** 4\n\ndef fun(x):\n    global a, b, c, d, e\n    return e + d * x + c * x ** 2 + b * x ** 3 + a * x ** 4\n\ndef f_integral(fx):\n    if not fx.is_zero:\n        return sym.integrate(fx, x)\n    else:\n        return \"\"\n\ndef convert(base_text, ss):\n    if ss != \"\":\n        tf = sym.sympify(ss)  \n        display(Markdown(base_text + '$%s$' %sym.latex(tf)))\n         \n\n# Plotting \ndef plot_limits(X_quad, X_cubed, X_squared, X, const, ax, a_limit, b_limit):\n    ix = np.linspace(a_limit, b_limit)\n    iy = polynomial_function(X_quad, X_cubed, X_squared, X, const, ix)\n    verts = [(a_limit, 0), *zip(ix, iy), (b_limit, 0)]\n    poly = Polygon(verts, facecolor='0.9', edgecolor='0.5')\n    ax.add_patch(poly)\n\n    \ndef plot_function(X_quad, X_cubed, X_squared, X, const, C, llimit, ulimit):\n    global a, b, c, d, e, output, x\n    a = X_quad\n    b = X_cubed\n    c = X_squared\n    d = X\n    e = const\n    fig = plt.figure(figsize=(12,6))\n    ax = fig.add_subplot(1, 1, 1) \n    \n    # Plot input function\n    x_p = np.linspace(-XLIM, XLIM, num=1000)\n    y_p = polynomial_function(X_quad, X_cubed, X_squared, X, const, x_p)\n    plt.plot(x_p, y_p, 'r-')\n\n    # Plot indefinite integral of the input function\n    integ = f_integral(fun(x))\n    #integ = integ + str(C)\n    if integ != \"\":\n        if C &lt; 0:\n            integ = str(integ) + \"-\" + str(abs(C))\n        else:\n            integ = str(integ)+ \"+\" + str(C)\n        f_integrate = sym.lambdify(x, integ) # from str to function\n        x_p = np.linspace(-XLIM, XLIM, num=1000)\n        y_p = f_integrate(x_p)\n        ax.plot(x_p, y_p, 'b-', linewidth=2)\n\n    # Plot integral limits (area under curve)\n    if ulimit &lt; llimit:\n        display(Markdown('Upper limit and lower limit not consistent'))\n        res = \"\";\n    else:\n        plot_limits(X_quad, X_cubed, X_squared, X, const, ax, llimit, ulimit)\n        res, err = quad(fun, llimit, ulimit)\n    \n    plt.grid(True)\n    plt.xlim(-XLIM, XLIM)\n    plt.ylim(-YLIM, YLIM)\n    plt.axhline(y=0,lw=0.8,color='k')\n    plt.axvline(x=0,lw=0.8,color='k')\n    plt.xlabel('x')\n    plt.ylabel('$f(x)$, indefinite integral of $f(x)$')\n    plt.legend(handles=[red_patch, blue_patch, gray_patch])\n    plt.show()\n\n    convert(\"Input function $f(x)$: \", fun(x))\n    if integ != \"\":\n        if C == 0:\n            integ_str = str(integ) + \"+ C\" \n        else:\n            integ_str = str(integ)\n        convert(\"Indefinite integral of $f(x)$: \", integ_str)\n    if res != \"\":\n        display(Markdown('Area under the curve: ' + str(res)))\n\nw_funLabel.value=fourth_order_html\ncontrol_widgets = widgets.HBox()\ncontrol_widgets.children=[dd_order, w_funLabel]\ndisplay(control_widgets)\ninteractive(plot_function, const=fs_e, X=fs_d, X_squared=fs_c, X_cubed=fs_b, X_quad = fs_a, C = w_C, llimit=lower_limit, ulimit=upper_limit)"
  },
  {
    "objectID": "ICCT_en/examples/01/M-03_Power_of_a_complex_number.html",
    "href": "ICCT_en/examples/01/M-03_Power_of_a_complex_number.html",
    "title": "Power of a complex number",
    "section": "",
    "text": "from IPython.display import HTML\n\n# Cell visibility - COMPLETE:\ntag = HTML('''&lt;style&gt;\ndiv.input {\n   display:none;\n}\n&lt;/style&gt;''')\ndisplay(tag)\n\n# #Cell visibility - TOGGLE:\n# tag = HTML('''&lt;script&gt;\n# code_show=true; \n# function code_toggle() {\n#     if (code_show){\n#         $('div.input').hide()\n#     } else {\n#         $('div.input').show()\n#     }\n#     code_show = !code_show\n# } \n# $( document ).ready(code_toggle);\n# &lt;/script&gt;\n# &lt;p style=\"text-align:right\"&gt;\n# Toggle cell visibility &lt;a href=\"javascript:code_toggle()\"&gt;here&lt;/a&gt;.&lt;/p&gt;''')\n# display(tag)\n\n\n\n\nThis interactive example deals with raising a complex number to a given (integer) power. The selected complex number \\(z\\), as well as its power, will be visualized in a complex plane and represented via mathematical notation.\nYou can choose the target complex number (\\(z\\)) directly on the plot (by simple clicking), or/and use input field at the same time. Exponentiation value can be selected among predefined integers. Selections are constrained so as to provide better visibility of the respective vectors in the plot widget.\n\n%matplotlib notebook\nfrom ipywidgets import *\nimport matplotlib.pyplot as plt\nimport matplotlib.patches as mpatches\nimport numpy as np\nimport ipywidgets as widgets\nfrom IPython.display import display\nfrom IPython.display import HTML\n\nred_patch = mpatches.Patch(color='blue', label='$z$')\nblue_patch = mpatches.Patch(color='red', label='power')\n\n# Init values\n\nXLIM = 10\nYLIM = 10\nvectors_index_first = False;\nV = [None, None]\nV_complex = [None, None]\n\n# Complex plane\n\nfig = plt.figure(num='Power of a complex number')\nax = fig.add_subplot(1, 1, 1)\n\ndef get_interval(bottom, top):\n    offset = int(10. / 100 * top)\n    \n    bottom = bottom - offset\n    top = top + offset\n    \n    return bottom, top\n    \ndef set_ticks():\n    global XLIM, YLIM\n           \n    XLIMc = XLIM\n    YLIMc = YLIM\n    \n    _, XLIMc = get_interval(-XLIM, XLIM)\n    _, YLIMc = get_interval(-YLIMc, YLIMc)\n    \n    #print(stepx, stepy)\n    major_ticks = np.linspace(-XLIMc, XLIMc, 12)\n    major_ticks = [round(i) for i in major_ticks ]\n    major_ticks_y = np.linspace(-YLIMc, YLIMc, 12)\n    major_ticks_y = [round(i) for i in major_ticks_y ]\n    ax.set_xticks(major_ticks)\n    ax.set_yticks(major_ticks_y)\n    ax.grid(which='both')\n\ndef clear_plot():\n    plt.cla()\n    set_ticks()\n    ax.set_xlabel('Re')\n    ax.set_ylabel('Im')\n    plt.ylim([-YLIM, YLIM])\n    plt.xlim([-XLIM, XLIM])\n    plt.legend(handles=[red_patch, blue_patch])\n\nclear_plot()\nset_ticks()\nplt.show()\nset_ticks()\n\n# Set a complex number using direct manipulation on the plot \ndef set_vector(i, data_x, data_y):\n    clear_plot()\n    \n    #V_complex.insert(i, complex(round(data_x, 2), round(data_y, 2)))\n    ax.arrow(0, 0, data_x, data_y, head_width=0.25, head_length=0.5, color=\"b\", length_includes_head=True)\n    a1.value = round(data_x, 2)\n    b1.value =  round(data_y, 2)\n    max_bound()\n    \ndef onclick(event):\n    x = event.xdata\n    y = event.ydata\n    if (x &gt; 10):\n        x = 10.0\n    if (x &lt; - 10):\n        x = -10.0\n    \n    if (y &gt; 10):\n        y = 10.0\n        \n    if (y &lt; - 10):\n        y = -10.0\n    max_bound()\n    set_vector(0, x, y)\n    \n        \nfig.canvas.mpl_connect('button_press_event', onclick)\n\n    \n# Widgets\na1 = widgets.BoundedFloatText(layout=widgets.Layout(width='10%'), min = -10, max = 10, step = 0.5)\nb1 = widgets.BoundedFloatText(layout=widgets.Layout(width='10%', margin='0px 20px 0px 0px'), min = -10, max = 10, step = 0.5)\nbutton_set_z1 = widgets.Button(description=\"Plot z\")\n\nn = widgets.BoundedIntText(layout=widgets.Layout(width='10%', margin='0px 20px 0px 0px'), value = 1, min = 1, max = 5, step = 1)\npower_button = widgets.Button(description=\"Calculate power\")\nreset_button = widgets.Button(description=\"Reset\")\n\nbox_layout_1 = widgets.Layout(border='solid red', padding='10px', margin='0px 0px 20px 0px')\nbox_layout_2 = widgets.Layout(border='solid blue', padding='10px')\n\nitems_z1 = (widgets.Label(\"z = \"), a1, widgets.Label(\"+ i * \"), b1, button_set_z1)\n\nitems_2 = (widgets.Label(\"Power = \"), n, power_button, reset_button)\nbox1 = widgets.Box(children=items_z1, layout=box_layout_1)\nbox2 = widgets.Box(children=items_2, layout=box_layout_2)\ntogether = widgets.VBox([box1, box2])\n\n\ndisplay(together)\noutput = widgets.Output()\ndisplay(output)\n\n# Set complex number using input widgets (Text and Button)\ndef on_button_set_z1_clicked(b):\n    global XLIM, YLIM\n    \n    z1_old = V[0];\n    z1_new = (0, 0, a1.value, b1.value)\n    if z1_old != z1_new:\n        set_vector(0, a1.value, b1.value)\n    max_bound()\n    change_lims()\n    \ndef power_clicked(b):\n    clear_plot()\n    set_vector(0, a1.value, b1.value)\n    change_lims()\n    global XLIM, YLIM\n    re = a1.value\n    im = b1.value\n    \n    z = complex(re, im)\n    \n    z = z ** n.value\n    \n    v_color = \"r\"\n    ax.arrow(0, 0, round(z.real,2), round(z.imag,2), head_width=0.25, head_length=0.5, color=v_color, length_includes_head=True)\n    \n    if abs(z.real) &gt; XLIM:\n        XLIM = round(abs(z.real) + 1)\n    if abs(z.imag) &gt; YLIM:\n        YLIM = round(abs(z.imag) + 1)\n    change_lims()\n    \n    with output:\n        print(\"(\",round(re,2), \"+\", \"({})i\".format(round(im,2)),\")^\", n.value,\n             \"=\", round(z.real,2), \"+\", \"({})i\".format(round(z.imag,2)) )   \n    \n       \n        \n# Plot init methods        \ndef on_button_reset_clicked(b):\n    global V, V_complex, XLIM, YLIM\n    with output:\n        output.clear_output()\n        clear_plot()\n        vectors_index_first = False;\n        V = [None, None]\n        V_complex = [None, None]\n        a1.value = 0\n        b1.value = 0\n        XLIM = 10\n        YLIM = 10\n        change_lims()\n        \ndef clear_plot():\n    plt.cla()\n    set_ticks()\n    ax.set_xlabel('Re')\n    ax.set_ylabel('Im')\n    plt.ylim([-YLIM, YLIM])\n    plt.xlim([-XLIM, XLIM])\n    plt.legend(handles=[red_patch, blue_patch])\n\ndef change_lims():\n    set_ticks()\n    plt.ylim([-YLIM, YLIM])\n    plt.xlim([-XLIM, XLIM])\n    set_ticks()\n    \ndef max_bound():\n    global XLIM, YLIM\n    mx = 0\n    my = 0\n    z = complex(a1.value, b1.value)\n    if abs(z.real) &gt; mx:\n        mx = abs(z.real)\n    if abs(z.imag) &gt; my:\n        my = abs(z.imag)\n   \n    if mx &gt; XLIM:\n        XLIM = round(mx + 1)\n    else:\n        XLIM = 10\n    if my &gt; YLIM:\n        YLIM = round(my + 1)\n    else:\n        YLIM = 10\n    change_lims()\n\n# Button events\nbutton_set_z1.on_click(on_button_set_z1_clicked)\npower_button.on_click(power_clicked)\nreset_button.on_click(on_button_reset_clicked)"
  },
  {
    "objectID": "ICCT_en/examples/01/M-01_Complex_numbers_Cartesian_form.html",
    "href": "ICCT_en/examples/01/M-01_Complex_numbers_Cartesian_form.html",
    "title": "Complex numbers in Cartesian form",
    "section": "",
    "text": "from IPython.display import HTML\n\n# Cell visibility - COMPLETE:\ntag = HTML('''&lt;style&gt;\ndiv.input {\n   display:none;\n}\n&lt;/style&gt;''')\ndisplay(tag)\n\n# #Cell visibility - TOGGLE:\n# tag = HTML('''&lt;script&gt;\n# code_show=true; \n# function code_toggle() {\n#     if (code_show){\n#         $('div.input').hide()\n#     } else {\n#         $('div.input').show()\n#     }\n#     code_show = !code_show\n# } \n# $( document ).ready(code_toggle);\n# &lt;/script&gt;\n# &lt;p style=\"text-align:right\"&gt;\n# Toggle cell visibility &lt;a href=\"javascript:code_toggle()\"&gt;here&lt;/a&gt;.&lt;/p&gt;''')\n# display(tag)\n\n\n\n\nFeel free to use this interactive example to visualize complex numbers in a complex plane, utilizing the Cartesian form. Also, you can test basic mathematical operators while working with complex numbers: addition, subtraction, multiplying, and dividing. All results are presented in the respective plot, as well as in the typical mathematical notation.\nYou can manipulate complex numbers directly on the plot (by simple clicking), or/and use input fields at the same time. In order to provide better visibility of the respective vectors in the plot widget, the complex number coefficients are limited to \\(\\pm10\\).\n\n%matplotlib notebook\n\nimport matplotlib.pyplot as plt\nimport matplotlib.patches as mpatches\nimport numpy as np\nimport ipywidgets as widgets\nfrom IPython.display import display\n\nred_patch = mpatches.Patch(color='red', label='z1')\nblue_patch = mpatches.Patch(color='blue', label='z2')\ngreen_patch = mpatches.Patch(color='green', label='z1 + z2')\nyellow_patch = mpatches.Patch(color='yellow', label='z1 - z2')\nblack_patch = mpatches.Patch(color='black', label='z1 * z2')\nmagenta_patch = mpatches.Patch(color='magenta', label='z1 / z2')\n\n# Init values\n\nXLIM = 5\nYLIM = 5\nvectors_index_first = False;\nV = [None, None]\nV_complex = [None, None]\n\n# Complex plane\n\nfig = plt.figure(num='Complex numbers in Cartesian form')\nax = fig.add_subplot(1, 1, 1)\n\ndef get_interval(lim):\n    if lim &lt;= 10:\n        return 1\n    if lim &lt; 75:\n        return 5\n    if lim &gt; 100:\n        return 25\n    return 10\n    \ndef set_ticks():\n   \n    XLIMc = int((XLIM / 10) + 1) * 10\n    YLIMc = int((YLIM / 10) + 1) * 10\n        \n    if XLIMc &gt; 150:\n        XLIMc += 10\n    if YLIMc &gt; 150:\n        YLIMc += 10\n    \n    xstep = get_interval(XLIMc)\n    ystep = get_interval(YLIMc)\n    \n    \n    #print(stepx, stepy)\n    major_ticks = np.arange(-XLIMc, XLIMc, xstep)\n    major_ticks_y = np.arange(-YLIMc, YLIMc, ystep)\n    ax.set_xticks(major_ticks)\n    ax.set_yticks(major_ticks_y)\n    ax.grid(which='both')\n\ndef clear_plot():\n    plt.cla()\n    set_ticks()\n    ax.set_xlabel('Re')\n    ax.set_ylabel('Im')\n    plt.ylim([-YLIM, YLIM])\n    plt.xlim([-XLIM, XLIM])\n    plt.legend(handles=[red_patch, blue_patch, green_patch, yellow_patch, black_patch, magenta_patch])\n\nclear_plot()\nset_ticks()\nplt.show()\nset_ticks()\n\n# Set a complex number using direct manipulation on the plot \ndef set_vector(i, data_x, data_y):\n    clear_plot()\n    V.pop(i)\n    V.insert(i, (0, 0, round(data_x, 2), round(data_y, 2)))\n    V_complex.pop(i)\n    V_complex.insert(i, complex(round(data_x, 2), round(data_y, 2)))\n    if i == 0:\n        ax.arrow(*V[0], head_width=0.25, head_length=0.5, color=\"r\", length_includes_head=True)\n        a1.value = round(data_x, 2)\n        b1.value =  round(data_y, 2)\n        if V[1] != None:\n            ax.arrow(*V[1], head_width=0.25, head_length=0.5, color=\"b\", length_includes_head=True)\n    elif i == 1:\n        ax.arrow(*V[1], head_width=0.25, head_length=0.5, color=\"b\", length_includes_head=True) \n        a2.value = round(data_x, 2)\n        b2.value =  round(data_y, 2)\n        if V[0] != None:\n            ax.arrow(*V[0], head_width=0.25, head_length=0.5, color=\"r\", length_includes_head=True)\n    max_bound()\n        \n    \ndef onclick(event):\n    global vectors_index_first\n    vectors_index_first = not vectors_index_first\n    x = event.xdata\n    y = event.ydata\n    if (x &gt; 10):\n        x = 10.0\n    if (x &lt; - 10):\n        x = -10.0\n    \n    if (y &gt; 10):\n        y = 10.0\n        \n    if (y &lt; - 10):\n        y = -10.0\n        \n    if vectors_index_first:      \n        set_vector(0, x, y)\n    else:\n        set_vector(1, x, y)\n        \nfig.canvas.mpl_connect('button_press_event', onclick)\n\n    \n# Widgets\na1 = widgets.BoundedFloatText(layout=widgets.Layout(width='10%'), min = -10, max = 10, step = 0.5)\nb1 = widgets.BoundedFloatText(layout=widgets.Layout(width='10%'), min = -10, max = 10, step = 0.5)\nbutton_set_z1 = widgets.Button(description=\"Plot z1\")\n\na2 = widgets.BoundedFloatText(layout=widgets.Layout(width='10%'), min = -10, max = 10, step = 0.5)\nb2 = widgets.BoundedFloatText(layout=widgets.Layout(width='10%'), min = -10, max = 10, step = 0.5)\nbutton_set_z2 = widgets.Button(description=\"Plot z2\")\n\nbox_layout_z1 = widgets.Layout(border='solid red', padding='10px')\nbox_layout_z2 = widgets.Layout(border='solid blue', padding='10px')\nbox_layout_opers = widgets.Layout(border='solid black', padding='10px')\n\nitems_z1 = [widgets.Label(\"z1 = \"), a1, widgets.Label(\"+ j * \"), b1, button_set_z1]\nitems_z2 = [widgets.Label(\"z2 = \"), a2, widgets.Label(\"+ j * \"), b2, button_set_z2]\ndisplay(widgets.Box(children=items_z1, layout=box_layout_z1))\ndisplay(widgets.Box(children=items_z2, layout=box_layout_z2))\n\nbutton_add = widgets.Button(description=\"Add\")\nbutton_substract = widgets.Button(description=\"Subtract\")\nbutton_multiply = widgets.Button(description=\"Multiply\")\nbutton_divide = widgets.Button(description=\"Divide\")\nbutton_reset = widgets.Button(description=\"Reset\")\noutput = widgets.Output()\n\nprint('Complex number operations:')\nitems_operations = [button_add, button_substract, button_multiply, button_divide, button_reset]\ndisplay(widgets.Box(children=items_operations))\ndisplay(output)\n\n# Set complex number using input widgets (Text and Button)\ndef on_button_set_z1_clicked(b):\n    z1_old = V[0];\n    z1_new = (0, 0, a1.value, b1.value)\n    if z1_old != z1_new:\n        set_vector(0, a1.value, b1.value)\n    change_lims()\n    \ndef on_button_set_z2_clicked(b):\n    z2_old = V[1];\n    z2_new = (0, 0, a2.value, b2.value)\n    if z2_old != z2_new:\n        set_vector(1, a2.value, b2.value)\n    change_lims()   \n\n# Complex number operations:\ndef perform_operation(oper):\n    global XLIM, YLIM\n    if (V_complex[0] != None) and (V_complex[1] != None):\n        if (oper == '+'):\n            result = V_complex[0] + V_complex[1]\n            v_color = \"g\"\n        elif (oper == '-'):\n            result = V_complex[0] - V_complex[1]\n            v_color = \"y\"\n        elif (oper == '*'):\n            result = V_complex[0] * V_complex[1]\n            v_color = \"black\"\n        elif (oper == '/'):\n            result = V_complex[0] / V_complex[1]\n            v_color = \"magenta\"\n        result = complex(round(result.real, 2), round(result.imag, 2))\n        ax.arrow(0, 0, result.real, result.imag, head_width=0.25, head_length=0.5, color=v_color, length_includes_head=True)\n        \n        if abs(result.real) &gt; XLIM:\n            XLIM = round(abs(result.real) + 1)\n        if abs(result.imag) &gt; YLIM:\n            YLIM = round(abs(result.imag) + 1)\n        change_lims()\n        \n        with output:\n            print(V_complex[0], oper, V_complex[1], \"=\", result)\n        \n    \ndef on_button_add_clicked(b):\n    perform_operation(\"+\")\n                  \ndef on_button_substract_clicked(b):\n    perform_operation(\"-\")\n\ndef on_button_multiply_clicked(b):\n    perform_operation(\"*\")\n\ndef on_button_divide_clicked(b):\n    perform_operation(\"/\")\n          \n        \n# Plot init methods        \ndef on_button_reset_clicked(b):\n    global V, V_complex, XLIM, YLIM\n    with output:\n        output.clear_output()\n        clear_plot()\n        vectors_index_first = False;\n        V = [None, None]\n        V_complex = [None, None]\n        a1.value = 0\n        b1.value = 0\n        a2.value = 0\n        b2.value = 0\n        XLIM = 5\n        YLIM = 5\n        change_lims()\n        \ndef clear_plot():\n    plt.cla()\n    set_ticks()\n    ax.set_xlabel('Re')\n    ax.set_ylabel('Im')\n    plt.ylim([-YLIM, YLIM])\n    plt.xlim([-XLIM, XLIM])\n    plt.legend(handles=[red_patch, blue_patch, green_patch, yellow_patch, black_patch, magenta_patch])\n\ndef change_lims():\n    set_ticks()\n    plt.ylim([-YLIM, YLIM])\n    plt.xlim([-XLIM, XLIM])\n    set_ticks()\n    \ndef max_bound():\n    global XLIM, YLIM\n    mx = 0\n    my = 0\n    if V_complex[0] != None:\n        z = V_complex[0]\n        if abs(z.real) &gt; mx:\n            mx = abs(z.real)\n        if abs(z.imag) &gt; my:\n            my = abs(z.imag)\n    if V_complex[1] != None:\n        z = V_complex[1]\n        if abs(z.real) &gt; mx:\n            mx = abs(z.real)\n        if abs(z.imag) &gt; my:\n            my = abs(z.imag)\n    if mx &gt; XLIM:\n        XLIM = round(mx + 1)\n    elif mx &lt;=5:\n        XLIM = 5\n    if my &gt; YLIM:\n        YLIM = round(my + 1)\n    elif my &lt;=5:\n        YLIM = 5\n    change_lims()\n\n# Button events\nbutton_set_z1.on_click(on_button_set_z1_clicked)\nbutton_set_z2.on_click(on_button_set_z2_clicked)\nbutton_add.on_click(on_button_add_clicked)\nbutton_substract.on_click(on_button_substract_clicked)\nbutton_multiply.on_click(on_button_multiply_clicked)\nbutton_divide.on_click(on_button_divide_clicked)\nbutton_reset.on_click(on_button_reset_clicked)\n\n\n\n\n\n\n\n\n\n\n\n\n\nComplex number operations:"
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "This is Control Systems Course Notes."
  },
  {
    "objectID": "ICCT_en/examples/01/M-02_Complex_numbers_Polar_form.html",
    "href": "ICCT_en/examples/01/M-02_Complex_numbers_Polar_form.html",
    "title": "Complex numbers in polar form",
    "section": "",
    "text": "from IPython.display import HTML\n\n# Cell visibility - COMPLETE:\ntag = HTML('''&lt;style&gt;\ndiv.input {\n   display:none;\n}\n&lt;/style&gt;''')\ndisplay(tag)\n\n# #Cell visibility - TOGGLE:\n# tag = HTML('''&lt;script&gt;\n# code_show=true; \n# function code_toggle() {\n#     if (code_show){\n#         $('div.input').hide()\n#     } else {\n#         $('div.input').show()\n#     }\n#     code_show = !code_show\n# } \n# $( document ).ready(code_toggle);\n# &lt;/script&gt;\n# &lt;p style=\"text-align:right\"&gt;\n# Toggle cell visibility &lt;a href=\"javascript:code_toggle()\"&gt;here&lt;/a&gt;.&lt;/p&gt;''')\n# display(tag)\n\n\n\n\nFeel free to use this interactive example to visualize complex numbers in a complex plane, utilizing the polar form. The respective vectors are determined by a modulus and an argument. You can test basic mathematical operators while working with complex numbers: addition, subtraction, multiplying, and dividing. All results are presented in the given plot, as well as in the typical mathematical notations.\nYou can manipulate complex numbers directly on the plot (by simple clicking) , or/and use input fields (for changing modulus and argument) at the same time. In order to provide better visibility of the vectors in the plot widget, the complex number coefficients are limited to \\(\\pm10\\).\n\n%matplotlib notebook\n\nimport matplotlib.pyplot as plt\nimport matplotlib.patches as mpatches\nimport numpy as np\nimport ipywidgets as widgets\nfrom IPython.display import display\nfrom IPython.display import HTML\nimport math\n\nred_patch = mpatches.Patch(color='red', label='z1')\nblue_patch = mpatches.Patch(color='blue', label='z2')\ngreen_patch = mpatches.Patch(color='green', label='z1 + z2')\nyellow_patch = mpatches.Patch(color='yellow', label='z1 - z2')\nblack_patch = mpatches.Patch(color='black', label='z1 * z2')\nmagenta_patch = mpatches.Patch(color='magenta', label='z1 / z2')\n\n# Init values\n\nXLIM = 5\nYLIM = 5\nvectors_index_first = False;\nV = [None, None]\nV_complex = [None, None]\n\n# Complex plane\n\nfig = plt.figure(num='Complex numbers in polar form')\nax = fig.add_subplot(1, 1, 1)\n\ndef get_interval(lim):\n    if lim &lt;= 10:\n        return 1\n    if lim &lt; 75:\n        return 5\n    if lim &gt; 100:\n        return 25\n    return 10\n    \ndef set_ticks():\n   \n    XLIMc = int((XLIM / 10) + 1) * 10\n    YLIMc = int((YLIM / 10) + 1) * 10\n        \n    if XLIMc &gt; 150:\n        XLIMc += 10\n    if YLIMc &gt; 150:\n        YLIMc += 10\n    \n    xstep = get_interval(XLIMc)\n    ystep = get_interval(YLIMc)\n    \n    \n    #print(stepx, stepy)\n    major_ticks = np.arange(-XLIMc, XLIMc, xstep)\n    major_ticks_y = np.arange(-YLIMc, YLIMc, ystep)\n    ax.set_xticks(major_ticks)\n    ax.set_yticks(major_ticks_y)\n    ax.grid(which='both')\n\ndef clear_plot():\n    plt.cla()\n    set_ticks()\n    ax.set_xlabel('Re')\n    ax.set_ylabel('Im')\n    plt.ylim([-YLIM, YLIM])\n    plt.xlim([-XLIM, XLIM])\n    plt.legend(handles=[red_patch, blue_patch, green_patch, yellow_patch, black_patch, magenta_patch])\n\nclear_plot()\nset_ticks()\nplt.show()\nset_ticks()\n\n\n# Conversion functions\ndef com_to_trig(real, im):\n    r = math.sqrt(real**2 + im**2)\n    if abs(real) &lt;= 1e-6 and im &gt; 0:\n        arg = 90\n        return r, arg\n    \n    if abs(real) &lt; 1e-6 and im &lt; 0:\n        arg = 270\n        return r, arg\n    \n    if abs(im) &lt; 1e-6 and real &gt; 0:\n        arg = 0\n        return r, arg\n    \n    if abs(im) &lt; 1e-6 and real &lt; 0:\n        arg = 180\n        return r, arg\n    \n    if im != 0 and real !=0:\n        arg = np.arctan(im / real) * 180 / np.pi\n        if im &gt; 0 and real &lt; 0:\n            arg += 180\n            \n        if im &lt; 0 and real &gt; 0:\n            arg +=360\n            \n        if im &lt; 0 and real &lt; 0:\n            arg += 180\n        return r, arg\n    \n    if abs(im) &lt; 1e-6 and abs(real) &lt; 1e-6:\n        arg = 0\n        return r, arg\n    \ndef trig_to_com(r, arg):\n    re = r * np.cos(arg * np.pi / 180.)\n    im = r * np.sin(arg * np.pi / 180.)\n    return (re, im)\n\n# Set a complex number using direct manipulation on the plot \ndef set_vector(i, data_x, data_y):\n    clear_plot()\n    V.pop(i)\n    V.insert(i, (0, 0, round(data_x, 2), round(data_y, 2)))\n    V_complex.pop(i)\n    V_complex.insert(i, complex(round(data_x, 2), round(data_y, 2)))\n    if i == 0:\n        ax.arrow(*V[0], head_width=0.25, head_length=0.5, color=\"r\", length_includes_head=True)\n        z, arg = com_to_trig(data_x, data_y)\n        a1.value = round(z, 2)\n        b1.value =  round(arg, 2)\n        if V[1] != None:\n            ax.arrow(*V[1], head_width=0.25, head_length=0.5, color=\"b\", length_includes_head=True)\n    elif i == 1:\n        ax.arrow(*V[1], head_width=0.25, head_length=0.5, color=\"b\", length_includes_head=True) \n        z, arg = com_to_trig(data_x, data_y)\n        a2.value = round(z, 2)\n        b2.value =  round(arg, 2)\n        if V[0] != None:\n            ax.arrow(*V[0], head_width=0.25, head_length=0.5, color=\"r\", length_includes_head=True)\n    max_bound()\n        \n    \ndef onclick(event):\n    global vectors_index_first\n    vectors_index_first = not vectors_index_first\n    x = event.xdata\n    y = event.ydata\n    if (x &gt; 10):\n        x = 10.0\n    if (x &lt; - 10):\n        x = -10.0\n    \n    if (y &gt; 10):\n        y = 10.0\n        \n    if (y &lt; - 10):\n        y = -10.0\n        \n    if vectors_index_first:      \n        set_vector(0, x, y)\n    else:\n        set_vector(1, x, y)\n        \nfig.canvas.mpl_connect('button_press_event', onclick)\n\n    \n# Widgets\na1 = widgets.BoundedFloatText(layout=widgets.Layout(width='10%'), min = 0, max = 10, step = 0.5)\nb1 = widgets.BoundedFloatText(layout=widgets.Layout(width='10%'), min = 0, max = 360, step = 10)\nbutton_set_z1 = widgets.Button(description=\"Plot z1\")\n\na2 = widgets.BoundedFloatText(layout=widgets.Layout(width='10%'), min = 0, max = 10, step = 0.5)\nb2 = widgets.BoundedFloatText(layout=widgets.Layout(width='10%'), min = 0, max = 360, step = 10)\nbutton_set_z2 = widgets.Button(description=\"Plot z2\")\n\nbox_layout_z1 = widgets.Layout(border='solid red', padding='10px')\nbox_layout_z2 = widgets.Layout(border='solid blue', padding='10px')\nbox_layout_opers = widgets.Layout(border='solid black', padding='10px')\n\nitems_z1 = [widgets.Label(\"z1: Modulus (|z1|) = \"), a1, widgets.Label(\"Argument (\\u2221)= \"), b1, button_set_z1]\nitems_z2 = [widgets.Label(\"z2: Modulus (|z2|) = \"), a2, widgets.Label(\"Argument (\\u2221)= \"), b2, button_set_z2]\ndisplay(widgets.Box(children=items_z1, layout=box_layout_z1))\ndisplay(widgets.Box(children=items_z2, layout=box_layout_z2))\n\nbutton_add = widgets.Button(description=\"Add\")\nbutton_substract = widgets.Button(description=\"Subtract\")\nbutton_multiply = widgets.Button(description=\"Multiply\")\nbutton_divide = widgets.Button(description=\"Divide\")\nbutton_reset = widgets.Button(description=\"Reset\")\noutput = widgets.Output()\n\nprint('Complex number operations:')\nitems_operations = [button_add, button_substract, button_multiply, button_divide, button_reset]\ndisplay(widgets.Box(children=items_operations))\ndisplay(output)\n\n# Set complex number using input widgets (Text and Button)\ndef on_button_set_z1_clicked(b):\n    z1_old = V[0];\n    re, im = trig_to_com(a1.value, b1.value)\n    z1_new = (0, 0, re, im)\n    if z1_old != z1_new:\n        set_vector(0, re, im)\n    change_lims()\n    \ndef on_button_set_z2_clicked(b):\n    z2_old = V[1];\n    re, im = trig_to_com(a2.value, b2.value)\n    z2_new = (0, 0, re, im)\n    if z2_old != z2_new:\n        set_vector(1, re, im)\n    change_lims()   \n\n# Complex number operations:\ndef perform_operation(oper):\n    global XLIM, YLIM\n    if (V_complex[0] != None) and (V_complex[1] != None):\n        if (oper == '+'):\n            result = V_complex[0] + V_complex[1]\n            v_color = \"g\"\n        elif (oper == '-'):\n            result = V_complex[0] - V_complex[1]\n            v_color = \"y\"\n        elif (oper == '*'):\n            result = V_complex[0] * V_complex[1]\n            v_color = \"black\"\n        elif (oper == '/'):\n            result = V_complex[0] / V_complex[1]\n            v_color = \"magenta\"\n        result = complex(round(result.real, 2), round(result.imag, 2))\n        ax.arrow(0, 0, result.real, result.imag, head_width=0.25, head_length=0.15, color=v_color, length_includes_head=True)\n        \n        if abs(result.real) &gt; XLIM:\n            XLIM = round(abs(result.real) + 1)\n        if abs(result.imag) &gt; YLIM:\n            YLIM = round(abs(result.imag) + 1)\n        change_lims()\n        \n        with output:\n            z1, ang1 = com_to_trig(V_complex[0].real, V_complex[0].imag )\n            z2, ang2 = com_to_trig(V_complex[1].real, V_complex[1].imag)\n            z3, ang3 = com_to_trig(result.real, result.imag)\n            z1 = round(z1, 2)\n            ang1 = round(ang1, 2)\n            z2 = round(z2, 2)\n            ang2 = round(ang2, 2)\n            z3 = round(z3, 2)\n            ang3 = round(ang3, 2)\n            \n            print(\"{}*(cos({}) + i*sin({}))\".format(z1,ang1,ang1), oper, \n                 \"{}*(cos({}) + i*sin({}))\".format(z2,ang2,ang2), \"=\",\n                 \"{}*(cos({}) + i*sin({}))\".format(z3,ang3,ang3))\n            \n            print('{} \\u2221{}'.format(z1, ang1), oper,\n                  '{} \\u2221{}'.format(z2, ang2), \"=\",\n                 '{} \\u2221{}'.format(z3, ang3))\n        \n    \ndef on_button_add_clicked(b):\n    perform_operation(\"+\")\n                  \ndef on_button_substract_clicked(b):\n    perform_operation(\"-\")\n\ndef on_button_multiply_clicked(b):\n    perform_operation(\"*\")\n\ndef on_button_divide_clicked(b):\n    perform_operation(\"/\")\n          \n        \n# Plot init methods        \ndef on_button_reset_clicked(b):\n    global V, V_complex, XLIM, YLIM\n    with output:\n        output.clear_output()\n        clear_plot()\n        vectors_index_first = False;\n        V = [None, None]\n        V_complex = [None, None]\n        a1.value = 0\n        b1.value = 0\n        a2.value = 0\n        b2.value = 0\n        XLIM = 5\n        YLIM = 5\n        change_lims()\n        \ndef clear_plot():\n    plt.cla()\n    set_ticks()\n    ax.set_xlabel('Re')\n    ax.set_ylabel('Im')\n    plt.ylim([-YLIM, YLIM])\n    plt.xlim([-XLIM, XLIM])\n    plt.legend(handles=[red_patch, blue_patch, green_patch, yellow_patch, black_patch, magenta_patch])\n\ndef change_lims():\n    set_ticks()\n    plt.ylim([-YLIM, YLIM])\n    plt.xlim([-XLIM, XLIM])\n    set_ticks()\n    \ndef max_bound():\n    global XLIM, YLIM\n    mx = 0\n    my = 0\n    if V_complex[0] != None:\n        z = V_complex[0]\n        if abs(z.real) &gt; mx:\n            mx = abs(z.real)\n        if abs(z.imag) &gt; my:\n            my = abs(z.imag)\n    if V_complex[1] != None:\n        z = V_complex[1]\n        if abs(z.real) &gt; mx:\n            mx = abs(z.real)\n        if abs(z.imag) &gt; my:\n            my = abs(z.imag)\n    if mx &gt; XLIM:\n        XLIM = round(mx + 1)\n    elif mx &lt;=5:\n        XLIM = 5\n    if my &gt; YLIM:\n        YLIM = round(my + 1)\n    elif my &lt;=5:\n        YLIM = 5\n    change_lims()\n\n# Button events\nbutton_set_z1.on_click(on_button_set_z1_clicked)\nbutton_set_z2.on_click(on_button_set_z2_clicked)\nbutton_add.on_click(on_button_add_clicked)\nbutton_substract.on_click(on_button_substract_clicked)\nbutton_multiply.on_click(on_button_multiply_clicked)\nbutton_divide.on_click(on_button_divide_clicked)\nbutton_reset.on_click(on_button_reset_clicked)\n\n\n\n\n\n\n\n\n\n\n\n\n\nComplex number operations:"
  },
  {
    "objectID": "ICCT_en/examples/01/M-04_Derivation_of_polynomials.html",
    "href": "ICCT_en/examples/01/M-04_Derivation_of_polynomials.html",
    "title": "Derivation of polynomials",
    "section": "",
    "text": "from IPython.display import HTML\n\n# Cell visibility - COMPLETE:\ntag = HTML('''&lt;style&gt;\ndiv.input {\n   display:none;\n}\n&lt;/style&gt;''')\ndisplay(tag)\n\n# #Cell visibility - TOGGLE:\n# tag = HTML('''&lt;script&gt;\n# code_show=true; \n# function code_toggle() {\n#     if (code_show){\n#         $('div.input').hide()\n#     } else {\n#         $('div.input').show()\n#     }\n#     code_show = !code_show\n# } \n# $( document ).ready(code_toggle);\n# &lt;/script&gt;\n# &lt;p style=\"text-align:right\"&gt;\n# Toggle cell visibility &lt;a href=\"javascript:code_toggle()\"&gt;here&lt;/a&gt;.&lt;/p&gt;''')\n# display(tag)\n\n\n\n\nThis interactive example allows you to inspect and look closely at a derivation of a polynomial function. Feel free to explore the effects of changing polynomial coefficients (up to the fourth order) - the function thus determined will be shown in the respective plot, along with its first derivation. Both the target function (set by slider widgets) and the first derivation (accordingly calculated) will be presented in mathematical notation as well.\n\n%matplotlib inline\n#%config InlineBackend.close_figures=False \nfrom ipywidgets import interactive\nfrom ipywidgets import widgets\nfrom IPython.display import Latex, display, Markdown # For displaying Markdown and LaTeX code\nimport matplotlib.pyplot as plt\nimport numpy as np\nimport math\nimport sympy as sym\nimport matplotlib.patches as mpatches\nfrom IPython.display import HTML, clear_output\nfrom IPython.display import display\n\n\n# Mathematical notation of a specific (user-defined) polynomial, shown as Markdown\nfourth_order = \"e + d * x + c * x ** 2 + b * x ** 3 + a * x ** 4\"\nthird_order = \"d + c * x + b * x ** 2 + a * x ** 3\"\nsecond_order = \"c + b * x + a * x ** 2\"\nfirst_order = \"b + a * x\"\nzero_order = \"a\"\ntf = sym.sympify(fourth_order)  \nw_mark = Markdown('$%s$' %sym.latex(tf))\n\n\n# General mathematical notation of a polynomial (shown in Label widget)\nfourth_order_html = \"$f(x)=ax^4$ + $bx^3$ + $cx^2$ + $dx$ + $e$\"\nthird_order_html = \"$f(x)=ax^3$ + $bx^2$ + $cx$ + $d$\"\nsecond_order_html = \"$f(x)=ax^2$ + $bx$ + $c$\"\nfirst_order_html = \"$f(x)=ax$ + $b$\"\nzero_order_html = \"$f(x)=a$\"\nw_funLabel = widgets.Label(layout=widgets.Layout(width='40%', margin='0px 0px 0px 50px'),)\n\n\n# Input sliders for coefficients of a polynomial\nfs_a = widgets.FloatSlider(description='$a$', min=-10.0, max=10.0, step=0.5, continuous_update=False)\nfs_b = widgets.FloatSlider(description='$b$',min=-10.0, max=10.0, step=0.5, continuous_update=False)\nfs_c = widgets.FloatSlider(description='$c$',min=-10.0, max=10.0, step=0.5, continuous_update=False)\nfs_d = widgets.FloatSlider(description='$d$',min=-10.0, max=10.0, step=0.5, continuous_update=False)\nfs_e = widgets.FloatSlider(description='$e$',min=-10.0, max=10.0, step=0.5, continuous_update=False)\ninput_widgets = widgets.HBox([fs_a, fs_b, fs_c, fs_d, fs_e])\n\n\n# Dropdown: selecting the order of a ploynomial [0-4]\n# Selection will invoke showing/hiding particular slider widgets\ndd_order = widgets.Dropdown(\n    options=['4', '3', '2', '1', '0'],\n    value='4',\n    description='Select order of the polynomial [0-4]:',\n    disabled=False,\n    style = {'description_width': 'initial'},\n)\n\ndef dropdown_eventhandler(change):\n    fs_a.layout.visibility = 'hidden'\n    fs_b.layout.visibility = 'hidden'\n    fs_c.layout.visibility = 'hidden'\n    fs_d.layout.visibility = 'hidden'\n    fs_e.layout.visibility = 'hidden'\n    \n    if (dd_order.value == '4'):\n        fs_a.layout.visibility = 'visible'\n        fs_a.description = '$a$'\n        fs_b.layout.visibility = 'visible'\n        fs_b.description = '$b$'\n        fs_c.layout.visibility = 'visible'\n        fs_c.description = '$c$'\n        fs_d.layout.visibility = 'visible'\n        fs_d.description = '$d$'\n        fs_e.layout.visibility = 'visible'\n        fs_e.description = '$e$'\n        w_funLabel.value=fourth_order_html\n    if (dd_order.value == '3'):      \n        fs_a.value = 0\n        fs_b.layout.visibility = 'visible'\n        fs_b.description = '$a$'\n        fs_c.layout.visibility = 'visible'\n        fs_c.description = '$b$'\n        fs_d.layout.visibility = 'visible'\n        fs_d.description = '$c$'\n        fs_e.layout.visibility = 'visible'\n        fs_e.description = '$d$'\n        w_funLabel.value=third_order_html\n    if (dd_order.value == '2'):\n        fs_a.value = 0\n        fs_b.value = 0\n        fs_c.layout.visibility = 'visible'\n        fs_c.description = '$a$'\n        fs_d.layout.visibility = 'visible'\n        fs_d.description = '$b$'\n        fs_e.layout.visibility = 'visible'\n        fs_e.description = '$c$'\n        w_funLabel.value=second_order_html\n    if (dd_order.value == '1'):\n        fs_a.value = 0\n        fs_b.value = 0\n        fs_c.value = 0\n        fs_d.layout.visibility = 'visible'\n        fs_d.description = '$a$'\n        fs_e.layout.visibility = 'visible'\n        fs_e.description = '$b$'\n        w_funLabel.value=first_order_html\n    if (dd_order.value == '0'):\n        fs_a.value = 0\n        fs_b.value = 0\n        fs_c.value = 0\n        fs_d.value = 0\n        fs_e.layout.visibility = 'visible'\n        fs_e.description = '$a$'\n        w_funLabel.value=zero_order_html\n\ndd_order.observe(dropdown_eventhandler, names='value')\n\n\n# Utility functions\nx = sym.symbols('x')\n\ndef fprime(fx):\n    if not fx.is_zero:\n        return sym.diff(fx, x)\n    else:\n        return \"\"\n\ndef convert(base_text, ss):\n    if ss != \"\":\n        tf = sym.sympify(ss)  \n        display(Markdown(base_text + '$%s$' %sym.latex(tf)))\n        \ndef polynomial_function(X_quaded, X_cubed, X_squared, X, const, x):\n    return const + X * x + X_squared * x ** 2 + X_cubed * x ** 3 + X_quaded * x ** 4\n\ndef fun(x):\n    global a, b, c, d, e\n    return e + d * x + c * x **2 + b * x ** 3 + a * x ** 4\n\n\n#Plot\nred_patch = mpatches.Patch(color='red', label='$f(x)$')\nblue_patch = mpatches.Patch(color='green', label='1st derivative of $f(x)$')\n\nXLIM = 10\nYLIM = 20\nXTICK = 2\nYTICK = 5\n  \na = 0\nb = 0\nc = 0\nd = 0\ne = 0\n\ndef plot_function(X_quaded, X_cubed, X_squared, X, const):\n    \n        global a, b, c, d, e, x\n        a = X_quaded\n        b = X_cubed\n        c = X_squared\n        d = X\n        e = const\n        fig = plt.figure(figsize=(12,6))\n\n        x_p = np.linspace(-XLIM, XLIM, num=1000)\n        plt.plot(x_p, polynomial_function(X_quaded, X_cubed, X_squared, X, const, x_p), 'r-')\n        y_p = [polynomial_function(X_quaded, X_cubed, X_squared, X, const, num) for num in x_p]\n        dydx = np.diff(y_p) / np.diff(x_p)\n        plt.plot(x_p[:-1], dydx, 'g-')\n        plt.grid(True)\n        plt.xlabel('x')\n        plt.ylabel('$f(x)$, derivative of $f(x)$')\n        plt.xlim(-XLIM, XLIM)\n        plt.ylim(-YLIM, YLIM)\n        plt.axhline(y=0,lw=0.8,color='k')\n        plt.axvline(x=0,lw=0.8,color='k')\n        plt.legend(handles=[red_patch, blue_patch])\n        plt.show()\n\n        convert(\"Input function $f(x)$: \", fun(x))\n        deriv = fprime(fun(x))\n        convert(\"First derivative of $f(x)$: \", deriv)\n\n# Show and interact\nw_funLabel.value=fourth_order_html\ncontrol_widgets = widgets.HBox()\ncontrol_widgets.children=[dd_order, w_funLabel]\ndisplay(control_widgets)\ninteractive(plot_function, const=fs_e, X=fs_d, X_squared=fs_c, X_cubed=fs_b, X_quaded=fs_a)"
  },
  {
    "objectID": "ICCT_en/examples/01/M-06_Matrix_operations.html",
    "href": "ICCT_en/examples/01/M-06_Matrix_operations.html",
    "title": "Matrix operations",
    "section": "",
    "text": "from IPython.display import HTML\n\n# Cell visibility - COMPLETE:\ntag = HTML('''&lt;style&gt;\ndiv.input {\n   display:none;\n}\n&lt;/style&gt;''')\ndisplay(tag)\n\n# #Cell visibility - TOGGLE:\n# tag = HTML('''&lt;script&gt;\n# code_show=true; \n# function code_toggle() {\n#     if (code_show){\n#         $('div.input').hide()\n#     } else {\n#         $('div.input').show()\n#     }\n#     code_show = !code_show\n# } \n# $( document ).ready(code_toggle);\n# &lt;/script&gt;\n# &lt;p style=\"text-align:right\"&gt;\n# Toggle cell visibility &lt;a href=\"javascript:code_toggle()\"&gt;here&lt;/a&gt;.&lt;/p&gt;''')\n# display(tag)\n\n\n\nToggle cell visibility here.\n\n\nThis example provides the insight into basic matrix operations: addition, subtraction, multiplication, the transpose of a matrix, and matrix inversion.\nYou can define the size of two matrices \\(A\\) and \\(B\\) (up to \\(3\\times3\\)), and set all their element values using input fields. In addition, some random values will be generated while matrix is being initialized. According to the corresponding values, all operations will be performed (please use the respective buttons), and results will be displayed in a mathematical notation.\nOf course, not all operations will be valid for a given matrices. For example, matrix multiplication assumes that the number of columns in the first matrix (\\(A\\)) is equal to the number of rows in the second matrix (\\(B\\)).\n\nfrom ipywidgets import interactive, Button, HBox, VBox, GridBox, Layout, Text, Output, FloatText\nimport ipywidgets as widgets\nfrom IPython.display import Markdown\nimport matplotlib.pyplot as plt\nimport numpy as np\nimport math\nimport random\nfrom IPython.display import HTML\nfrom IPython.display import display\n\nstyle={'description_width': 'initial'}\n\ncols_A = widgets.Dropdown(\n    options=['1', '2', '3'],\n    value='2',\n    description='No. of columns in $A$:',\n    disabled=False,\n    style=style\n)\nrows_A = widgets.Dropdown(\n    options=['1', '2', '3'],\n    value='2',\n    description='No. of rows in $A$:',\n    disabled=False,\n    style=style\n)\ncols_B = widgets.Dropdown(\n    options=['1', '2', '3'],\n    value='2',\n    description='No. of columns in $B$:',\n    disabled=False,\n    style=style\n)\nrows_B = widgets.Dropdown(\n    options=['1', '2', '3'],\n    value='2',\n    description='No. of rows in $B$:',\n    disabled=False,\n    style=style\n)\n\nleft_box = VBox([cols_A, rows_A])\nright_box = VBox([cols_B, rows_B])\nmenu_box = HBox([left_box, right_box])\n\nbutton_create = widgets.Button(description=\"Create matrices\")\nbutton_add = widgets.Button(description='Add', layout=widgets.Layout(margin='10px 5px 5px 5px'))\nbutton_sub = widgets.Button(description='Subtract', layout=widgets.Layout(margin='5px'))\nbutton_multiply = widgets.Button(description='Multiply', layout=widgets.Layout(margin='5px'))\nbutton_transpose = widgets.Button(description='Transpose of A', layout=widgets.Layout(margin='5px'))\nbutton_inverze = widgets.Button(description='Inverse of A', layout=widgets.Layout(margin='5px'))\nbutton_reset = widgets.Button(description='Reset all', layout=widgets.Layout(margin='5px'))\nbox_layout_2 = widgets.Layout(border='solid blue', height='300px', width='40%')\nbox_layout_3 = widgets.Layout(border='solid black',  height = '300px', width='60%')\noutput = widgets.Output(layout = box_layout_2)\noutput_info = widgets.Output(layout = box_layout_3)\nbox_layout_1 = widgets.Layout(border='solid red', width='18%', align_items='center', margin='0px 2% 0px 0px')\nmy_v_box = widgets.VBox([button_add, button_sub, button_multiply, button_transpose, button_inverze, button_reset], layout = box_layout_1 )\nmy_h_box = widgets.HBox([my_v_box,widgets.Label(value=' '), output])\n\n\nfirst = True\ndef on_button_create_clicked(b):\n    global matrix_A, matrix_B, m_A, m_B\n    global first\n    title_A = Output()\n    title_B = Output()\n    \n    row_values = []\n    for i in range(int(rows_A.value)):\n        row = [FloatText(value=str(round(random.uniform(0, 10), 1)), layout=Layout(width='60px')) for i in range(int(cols_A.value))]\n        hbox_row = HBox(children=row)\n        row_values.append(hbox_row)\n    m_A = VBox(children=row_values)\n    \n    row_values = []\n    for i in range(int(rows_B.value)):\n        row = [FloatText(value=str(round(random.uniform(0, 10), 1)), layout=Layout(width='60px')) for i in range(int(cols_B.value))]\n        hbox_row = HBox(children=row)\n        row_values.append(hbox_row)\n    m_B = VBox(children=row_values)\n    \n    if (first):\n        output.layout.visibility = 'visible'\n        output_info.layout.visibility = 'visible'\n        my_h_box.layout.visibility = 'visible'\n        first = False\n        \n    with output_info:\n        output_info.clear_output()\n        display(title_A, m_A, title_B, m_B)\n\n    with title_A:\n        print(\"Matrix A input\")\n\n    with title_B:\n        print(\"Matrix B input\")\n       \n    if first == False:\n        with output:\n            output.clear_output()\n\n\n\ndef vmatrix(a):\n    if len(a.shape) &gt; 2:\n         raise ValueError('bmatrix can at most display two dimensions')\n    lines = str(a).replace('[', '').replace(']', '').splitlines()\n    rv = [r'\\begin{vmatrix}']\n    rv += ['  ' + ' & '.join(l.split()) + r'\\\\' for l in lines]\n    rv +=  [r'\\end{vmatrix}']\n    return '\\n'.join(rv)\n\ndef get_matrices():\n    global matrix_A, matrix_B\n    global m_A, m_B\n    \n    AA = []\n    for i in range(int(rows_A.value)):\n        single_hbox = m_A.children[i];\n        for j in range(int(cols_A.value)):\n            no = float(single_hbox.children[j].value);\n            AA.append(no)\n    \n    BB = []\n    for i in range(int(rows_B.value)):\n        single_hbox = m_B.children[i];\n        for j in range(int(cols_B.value)):\n            no = float(single_hbox.children[j].value);\n            BB.append(no)\n        \n    \n    AA = np.array(AA).reshape(int(rows_A.value), int(cols_A.value))\n    BB = np.array(BB).reshape(int(rows_B.value), int(cols_B.value))\n    \n    return AA, BB\n          \n    \n\ndef on_button_add_clicked(b):\n    A, B = get_matrices()\n    with output:\n        output.clear_output()\n        display(Markdown('Matrix A: $%s$' % vmatrix(A)))\n        display(Markdown('Matrix B: $%s$' % vmatrix(B)))\n    \n        nRowsA = len(A)\n        nColsA = len(A[0])\n        nRowsB = len(B)\n        nColsB = len(B[0])\n        \n        if (nRowsA != nRowsB):\n            print(\"Cannot add\")\n        elif (nColsA != nColsB):\n            print(\"Cannot add\")\n        else: \n            EE = np.add(A, B)\n            display(Markdown('A + B = $%s$' % vmatrix(EE)))\n        \ndef on_button_sub_clicked(b):\n    A, B = get_matrices()\n    with output:\n        output.clear_output()\n        display(Markdown('Matrix A: $%s$' % vmatrix(A)))\n        display(Markdown('Matrix B: $%s$' % vmatrix(B)))\n    \n        nRowsA = len(A)\n        nColsA = len(A[0])\n        nRowsB = len(B)\n        nColsB = len(B[0])\n        \n        if (nRowsA != nRowsB):\n            print(\"Cannot subtract\")\n        elif (nColsA != nColsB):\n            print(\"Cannot subtract\")\n        else: \n            EE = np.subtract(A, B)\n            display(Markdown('A - B = $%s$' % vmatrix(EE)))\n\ndef on_button_multiply_clicked(b):\n    A, B = get_matrices()\n    with output:\n        output.clear_output()\n        display(Markdown('Matrix A: $%s$' % vmatrix(A)))\n        display(Markdown('Matrix B: $%s$' % vmatrix(B)))\n    \n        try:\n            EE = np.matmul(A, B)\n        except:\n            print(\"Cannot multiply\")\n            pass\n        else:\n            display(Markdown('A * B = $%s$' % vmatrix(EE)))\n\ndef on_button_transpose_clicked(b):\n    A, B = get_matrices()\n    with output:\n        output.clear_output()\n        display(Markdown('Matrix A: $%s$' % vmatrix(A)))\n        display(Markdown('A transposed: $%s$' % vmatrix(A.T)))\n\ndef on_button_inverze_clicked(b):\n    A, B = get_matrices()\n    with output:\n        output.clear_output()\n        display(Markdown('Matrix A: $%s$' % vmatrix(A)))\n        try:\n            inverse = np.linalg.inv(A)\n        except np.linalg.LinAlgError:\n            print(\"A not invertible\")\n            pass\n        else:\n            display(Markdown('A-inverse: $%s$' % vmatrix(inverse)))\n\ndef on_button_reset_clicked(b):\n    global first\n    first = True\n    output.layout.visibility = 'hidden'\n    output_info.layout.visibility = 'hidden'\n    my_h_box.layout.visibility = 'hidden'\n    cols_A.value = '2'\n    cols_B.value = '2'\n    rows_A.value = '2'\n    rows_B.value = '2'\n    \nbutton_create.on_click(on_button_create_clicked)\nbutton_add.on_click(on_button_add_clicked)\nbutton_sub.on_click(on_button_sub_clicked)\nbutton_multiply.on_click(on_button_multiply_clicked)\nbutton_transpose.on_click(on_button_transpose_clicked)\nbutton_inverze.on_click(on_button_inverze_clicked)\nbutton_reset.on_click(on_button_reset_clicked)\ndisplay(menu_box, button_create)\ndisplay(output_info)\ndisplay(my_h_box)\nmy_h_box.layout.visibility = 'hidden'\noutput_info.layout.visibility = 'hidden'"
  },
  {
    "objectID": "ICCT_en/examples/01/M-08_Fast_Fourier_transform.html",
    "href": "ICCT_en/examples/01/M-08_Fast_Fourier_transform.html",
    "title": "Fast Fourier transform (FFT)",
    "section": "",
    "text": "from IPython.display import HTML\n\n# Cell visibility - COMPLETE:\ntag = HTML('''&lt;style&gt;\ndiv.input {\n   display:none;\n}\n&lt;/style&gt;''')\ndisplay(tag)\n\n# #Cell visibility - TOGGLE:\n# tag = HTML('''&lt;script&gt;\n# code_show=true; \n# function code_toggle() {\n#     if (code_show){\n#         $('div.input').hide()\n#     } else {\n#         $('div.input').show()\n#     }\n#     code_show = !code_show\n# } \n# $( document ).ready(code_toggle);\n# &lt;/script&gt;\n# &lt;p style=\"text-align:right\"&gt;\n# Toggle cell visibility &lt;a href=\"javascript:code_toggle()\"&gt;here&lt;/a&gt;.&lt;/p&gt;''')\n# display(tag)\n\n\n\n\nA fast Fourier transform (FFT) is an algorithm that computes the discrete Fourier transform (DFT) of a sequence, or its inverse (IDFT). Fourier analysis converts a signal from its original domain (often time or space) to a representation in the frequency domain and vice versa.\nIn this example you can inspect (graphically) transforming signals from time-domain to frequency-domain. You are able to set the properties of three signals, by determining corresponding parameters for selected functions. These functions will be automatically visualized in first two plots - as three distinct signals, and as a combined one. The third plot, showed at the very bottom, represents the FFT output. In addition, you can inspect the effect of adding noise into consideration.\nThe following functions can be used and combined together in this example: * sine wave, * cosine wave, * damped wave, * ramp function, * step function.\n\n%matplotlib inline\n#%config InlineBackend.close_figures=False \nfrom ipywidgets import interactive\nfrom ipywidgets import widgets\nfrom IPython.display import Latex, display, Markdown # For displaying Markdown and LaTeX code\nimport matplotlib.pyplot as plt\nimport numpy as np\nimport math\nimport matplotlib.patches as mpatches\nfrom IPython.display import HTML, clear_output\nfrom IPython.display import display\nfrom IPython.display import HTML\nfrom ipywidgets import interactive, interactive_output, VBox, HBox\nfrom ipywidgets import widgets\nfrom scipy import pi\nfrom scipy.fftpack import fft\nfrom scipy import signal\n\n### SLIDER WIDGETS\n# Sine widgets\nslider_a_1 = widgets.FloatSlider(description='Amplitude', min=0., max=4., step=0.25, continuous_update=False)\nslider_f_1 = widgets.FloatSlider(description='Frequency', min=0., max=30., step=0.5, continuous_update=False)\nslider_p_1 = widgets.FloatSlider(description='Phase', min=-10.0, max=10.0, step=0.5, continuous_update=False)\n\n# Cosine widgets\nslider_acos_1 = widgets.FloatSlider(description='Amplitude', min=0., max=4., step=0.25, continuous_update=False)\nslider_fcos_1 = widgets.FloatSlider(description='Frequency', min=0., max=30., step=0.5, continuous_update=False)\nslider_pcos_1 = widgets.FloatSlider(description='Phase', min=-10.0, max=10.0, step=0.5, continuous_update=False)\n\n# Damping widgets\nslider_adamp_1 = widgets.FloatSlider(description='Amplitude', min=0., max=4., step=0.25, continuous_update=False)\nslider_fdamp_1 = widgets.FloatSlider(description='Frequency', min=0., max=30., step=0.5, continuous_update=False)\nslider_pdamp_1 = widgets.FloatSlider(description='Phase', min=-10.0, max=10.0, step=0.5, continuous_update=False)\nslider_d_1 = widgets.FloatSlider(description='Decay', min=0., max=3., step=0.2, continuous_update=False)\n\n# Sine widgets\nslider_a_2 = widgets.FloatSlider(description='Amplitude', min=0., max=4., step=0.25, continuous_update=False)\nslider_f_2 = widgets.FloatSlider(description='Frequency', min=0., max=30., step=0.5, continuous_update=False)\nslider_p_2 = widgets.FloatSlider(description='Phase', min=-10.0, max=10.0, step=0.5, continuous_update=False)\n\n# Cosine widgets\nslider_acos_2 = widgets.FloatSlider(description='Amplitude', min=0., max=4., step=0.25, continuous_update=False)\nslider_fcos_2 = widgets.FloatSlider(description='Frequency', min=0., max=30., step=0.5, continuous_update=False)\nslider_pcos_2 = widgets.FloatSlider(description='Phase', min=-10.0, max=10.0, step=0.5, continuous_update=False)\n\n# Damping widgets\nslider_adamp_2 = widgets.FloatSlider(description='Amplitude', min=0., max=4., step=0.25, continuous_update=False)\nslider_fdamp_2 = widgets.FloatSlider(description='Frequency', min=0., max=30., step=0.5, continuous_update=False)\nslider_pdamp_2 = widgets.FloatSlider(description='Phase', min=-10.0, max=10.0, step=0.5, continuous_update=False)\nslider_d_2 = widgets.FloatSlider(description='Decay', min=0., max=3., step=0.2, continuous_update=False)\n\n# Sine widgets\nslider_a_3 = widgets.FloatSlider(description='Amplitude', min=0., max=4., step=0.25, continuous_update=False)\nslider_f_3 = widgets.FloatSlider(description='Frequency', min=0., max=30., step=0.5, continuous_update=False)\nslider_p_3 = widgets.FloatSlider(description='Phase', min=-10.0, max=10.0, step=0.5, continuous_update=False)\n\n# Cosine widgets\nslider_acos_3 = widgets.FloatSlider(description='Amplitude', min=0., max=4., step=0.25, continuous_update=False)\nslider_fcos_3 = widgets.FloatSlider(description='Frequency', min=0., max=30., step=0.5, continuous_update=False)\nslider_pcos_3 = widgets.FloatSlider(description='Phase', min=-10.0, max=10.0, step=0.5, continuous_update=False)\n\n# Damping widgets\nslider_adamp_3 = widgets.FloatSlider(description='Amplitude', min=0., max=4., step=0.25, continuous_update=False)\nslider_fdamp_3 = widgets.FloatSlider(description='Frequency', min=0., max=30., step=0.5, continuous_update=False)\nslider_pdamp_3 = widgets.FloatSlider(description='Phase', min=-10.0, max=10.0, step=0.5, continuous_update=False)\nslider_d_3 = widgets.FloatSlider(description='Decay', min=0., max=3., step=0.2, continuous_update=False)\n\n# Ramp widgets\nslider_aramp_1 = widgets.FloatSlider(description='Parameter a', value = 0.0, min=0.0, max=2., step=0.25, continuous_update=False)\nslider_aramp_2 = widgets.FloatSlider(description='Parameter a', value = 0.0, min=0.0, max=2., step=0.25, continuous_update=False)\nslider_aramp_3 = widgets.FloatSlider(description='Parameter a', value = 0.0, min=0.0, max=2., step=0.25, continuous_update=False)\n\n# Step widgets\nslider_astep_1 = widgets.FloatSlider(description='Parameter a', value = 0., min=0, max=2, step=0.1, continuous_update=False)\nslider_bstep_1 = widgets.FloatSlider(description='Parameter b', value = 1, min=0, max=4., step=0.25, continuous_update=False)\n\n# Step widgets\nslider_astep_2 = widgets.FloatSlider(description='Parameter a', value = 0., min=0, max=2, step=0.1, continuous_update=False)\nslider_bstep_2 = widgets.FloatSlider(description='Parameter b', value = 1, min=0, max=4., step=0.25, continuous_update=False)\n\n# Step widgets\nslider_astep_3 = widgets.FloatSlider(description='Parameter a', value = 0., min=0, max=2, step=0.1, continuous_update=False)\nslider_bstep_3 = widgets.FloatSlider(description='Parameter b', value = 1, min=0, max=4., step=0.25, continuous_update=False)\n\n# Parameters\nsample_rate = 1024\nN = (2 - 0) * sample_rate\ntime = np.linspace(0, 2, N)\nnoise = np.random.normal (0, 0.5, N)\nfrequency = np.linspace (0.0, 512, int (N/2))\nwaves = [0, 0, 0]\n\n\n# Layouts\nfun1_layout = widgets.Layout(border='solid blue', width = '33%', height = '400', padding='1px')\nfun2_layout = widgets.Layout(border='solid green', width = '33%', height = '400', padding='1px')\nfun3_layout = widgets.Layout(border='solid red', width = '33%', height = '400', padding='1px')\noutputs_layout = widgets.Layout(border='solid black', width = '100%', height = '200', padding='5px')\n\n# Dropdown widgets\ndd_fun1 = widgets.Dropdown(\n    options=['sine wave', 'cosine wave', 'damped wave', 'ramp function', 'step function'],\n    value='sine wave',\n    description='Function:',\n    disabled=False,\n    style = {'description_width': 'initial'},\n)\n\ndd_fun2 = widgets.Dropdown(\n    options=['sine wave', 'cosine wave', 'damped wave', 'ramp function', 'step function'],\n    value='sine wave',\n    description='Function:',\n    disabled=False,\n    style = {'description_width': 'initial'},\n)\n\ndd_fun3 = widgets.Dropdown(\n    options=['sine wave', 'cosine wave', 'damped wave', 'ramp function', 'step function'],\n    value='sine wave',\n    description='Function:',\n    disabled=False,\n    style = {'description_width': 'initial'},\n)\n\n    \n# Ploting\ndef plot_everything():\n    global waves\n    wave1 = np.array(waves[0])\n    wave2 = np.array(waves[1])\n    wave3 = np.array(waves[2])\n    \n    output_time1.clear_output(wait=True)\n    output_time2.clear_output(wait=True)\n    output_fft.clear_output(wait=True)\n    \n    # Plot 1: single functions\n    with output_time1:\n        #output_time1.clear_output()\n        plt.figure(figsize=(10,5))\n        plt.ylim(-5, 5)\n        plt.plot (time, wave1, label=\"Signal 1\", color=\"b\")\n        plt.plot (time, wave2, label=\"Signal 2\", color=\"g\")\n        plt.plot (time, wave3, label=\"Signal 3\", color=\"r\")\n        plt.title('Time domain: The three selected signals')\n        plt.xlabel ('Time [s]')\n        plt.ylabel ('Amplitude')\n        plt.grid(True)\n        plt.axhline(y=0,lw=0.8,color='k')\n        plt.axvline(x=0,lw=0.8,color='k')\n        plt.legend(loc=\"upper right\")\n        plt.show()\n       \n    # Plot 2: combined wave\n    add_noise = noise_widget.value\n    if add_noise == True:\n        time_data = wave1 + wave2 + wave3 + noise\n    else:\n         time_data = wave1 + wave2 + wave3 \n    \n    with output_time2:\n        #output_time2.clear_output()\n        plt.figure(figsize=(10,5))\n        plt.ylim(-5, 5)\n        plt.plot(time, time_data)\n        plt.title('Time domain: Combined signal')\n        plt.xlabel('Time [s]')\n        plt.ylabel('Amplitude')\n        plt.grid(True)\n        plt.axhline(y=0,lw=0.8,color='k')\n        plt.axvline(x=0,lw=0.8,color='k')\n        plt.show()\n        display(noise_widget)\n    \n    # Plot 3: FFT\n    freq_data = fft(time_data)\n    y = 2/N * np.abs (freq_data [0:np.int (N/2)])\n    \n    with output_fft:\n        #output_fft.clear_output()\n        plt.figure(figsize=(10,5))\n        plt.ylim(0, 5)\n        plt.xlim(0, 40)\n        plt.plot(frequency, y)\n        plt.title('Frequency domain')\n        plt.xlabel('Frequency [Hz]')\n        plt.ylabel('Magnitude')\n        plt.grid(True)\n        plt.axhline(y=0,lw=0.8,color='k')\n        plt.axvline(x=0,lw=0.8,color='k')\n        plt.show()\n\n\n# Initial view\ndef first():\n    global waves\n    frequency = 0\n    phase = 0\n    A = 0\n    function1 = [A * np.sin(2 * pi * x * frequency + phase) for x in time]\n    function2 = [A * np.sin(2 * pi * x * frequency + phase) for x in time]\n    function3 = [A * np.sin(2 * pi * x * frequency + phase) for x in time]\n    waves = [function1, function2, function3]\n    \n    with output_fun1:\n        display(slider_a_1, slider_f_1, slider_p_1)\n    \n    with output_fun2:\n        display(slider_a_2, slider_f_2, slider_p_2)\n        \n    with output_fun3:\n        display(slider_a_3, slider_f_3, slider_p_3)\n    \n    f_sine(1, slider_a_1.value, slider_f_1.value, slider_p_1.value)\n    \n\n#Function data\ndef f_sine(caller, A, frequency, phase):\n    global waves  \n    function1 = [A * np.sin(2 * pi * x *frequency + phase) for x in time]\n    if caller == 1:\n        waves[0] = function1\n    if caller == 2:\n        waves[1] = function1\n    if caller == 3:\n        waves[2] = function1\n    plot_everything()\n\ndef f_cos(caller, A, frequency, phase):\n    global waves\n    function2 = [A * np.cos(2 * pi * x * frequency + phase) for x in time]\n    if caller == 1:\n        waves[0] = function2\n    if caller == 2:\n        waves[1] = function2\n    if caller == 3:\n        waves[2] = function2\n    plot_everything()\n\ndef f_dwave(caller, A, frequency, phase, decay):\n    global waves\n    function3 = [A * math.exp(-decay * x) *(np.cos(2 * pi * x * frequency + phase)) for x in time]\n    if caller == 1:\n        waves[0] = function3\n    if caller == 2:\n        waves[1] = function3\n    if caller == 3:\n        waves[2] = function3\n    plot_everything()\n    \ndef f_ramp(caller, A):\n    global waves\n    step = lambda x, a: x - a if x &gt; a else 0\n    function4 = [step(t, A) for t in time]\n    if caller == 1:\n        waves[0] = function4\n    if caller == 2:\n        waves[1] = function4\n    if caller == 3:\n        waves[2] = function4\n    plot_everything()\n    \ndef f_step(caller, a, b):\n    global waves\n    step = lambda x, a, b: b if x &gt; a else 0\n    function5 = [step(t, a, b) for t in time]\n    if caller == 1:\n        waves[0] = function5\n    if caller == 2:\n        waves[1] = function5\n    if caller == 3:\n        waves[2] = function5\n    plot_everything()\n\n    \n# slider observers        \ndef slider_change(change, sender):\n    if sender == 'sin_a_1':\n        f_sine(1, change['new'], slider_f_1.value, slider_p_1.value)\n    if sender == 'sin_f_1':\n        f_sine(1, slider_a_1.value, change['new'], slider_p_1.value)\n    if sender == 'sin_p_1':\n        f_sine(1, slider_a_1.value, slider_f_1.value, change['new'])\n    \n    if sender == 'cos_a_1':\n        f_cos(1, change['new'], slider_fcos_1.value, slider_pcos_1.value)\n    if sender == 'cos_f_1':\n        f_cos(1, slider_acos_1.value, change['new'], slider_pcos_1.value)\n    if sender == 'cos_p_1':\n        f_cos(1, slider_acos_1.value, slider_fcos_1.value, change['new'])\n        \n    if sender == 'damp_a_1':\n        f_dwave(1, change['new'], slider_fdamp_1.value, slider_pdamp_1.value, slider_d_1.value)\n    if sender == 'damp_f_1':\n        f_dwave(1, slider_adamp_1.value, change['new'], slider_pdamp_1.value, slider_d_1.value)\n    if sender == 'damp_p_1':\n        f_dwave(1, slider_adamp_1.value, slider_fdamp_1.value, change['new'], slider_d_1.value)\n    if sender == 'damp_d_1':\n        f_dwave(1, slider_adamp_1.value, slider_fdamp_1.value, slider_pdamp_1.value, change['new'])\n        \n    if sender == 'ramp_a_1':\n        f_ramp(1, change['new'])\n        \n    if sender == 'step_a_1':\n        f_step(1, change['new'], slider_bstep_1.value)\n    if sender == 'step_b_1':\n        f_step(1, slider_astep_1.value, change['new'])\n    ###\n    if sender == 'sin_a_2':\n        f_sine(2, change['new'], slider_f_2.value, slider_p_2.value)\n    if sender == 'sin_f_2':\n        f_sine(2, slider_a_2.value, change['new'], slider_p_2.value)\n    if sender == 'sin_p_2':\n        f_sine(2, slider_a_2.value, slider_f_2.value, change['new'])\n    \n    if sender == 'cos_a_2':\n        f_cos(2, change['new'], slider_fcos_2.value, slider_pcos_2.value)\n    if sender == 'cos_f_2':\n        f_cos(2, slider_acos_2.value, change['new'], slider_pcos_2.value)\n    if sender == 'cos_p_2':\n        f_cos(2, slider_acos_2.value, slider_fcos_2.value, change['new'])\n        \n    if sender == 'damp_a_2':\n        f_dwave(2, change['new'], slider_fdamp_2.value, slider_pdamp_2.value, slider_d_2.value)\n    if sender == 'damp_f_2':\n        f_dwave(2, slider_adamp_2.value, change['new'], slider_pdamp_2.value, slider_d_2.value)\n    if sender == 'damp_p_2':\n        f_dwave(2, slider_adamp_2.value, slider_fdamp_2.value, change['new'], slider_d_2.value)\n    if sender == 'damp_d_2':\n        f_dwave(2, slider_adamp_2.value, slider_fdamp_2.value, slider_pdamp_2.value, change['new'])\n        \n    if sender == 'ramp_a_2':\n        f_ramp(2, change['new'])\n        \n    if sender == 'step_a_2':\n        f_step(2, change['new'], slider_bstep_2.value)\n    if sender == 'step_b_2':\n        f_step(2, slider_astep_2.value, change['new'])\n    ###\n    if sender == 'sin_a_3':\n        f_sine(3, change['new'], slider_f_3.value, slider_p_3.value)\n    if sender == 'sin_f_3':\n        f_sine(3, slider_a_3.value, change['new'], slider_p_3.value)\n    if sender == 'sin_p_3':\n        f_sine(3, slider_a_3.value, slider_f_3.value, change['new'])\n    \n    if sender == 'cos_a_3':\n        f_cos(3, change['new'], slider_fcos_3.value, slider_pcos_3.value)\n    if sender == 'cos_f_3':\n        f_cos(3, slider_acos_3.value, change['new'], slider_pcos_3.value)\n    if sender == 'cos_p_3':\n        f_cos(3, slider_acos_3.value, slider_fcos_3.value, change['new'])\n        \n    if sender == 'damp_a_3':\n        f_dwave(3, change['new'], slider_fdamp_3.value, slider_pdamp_3.value, slider_d_3.value)\n    if sender == 'damp_f_3':\n        f_dwave(3, slider_adamp_3.value, change['new'], slider_pdamp_3.value, slider_d_3.value)\n    if sender == 'damp_p_3':\n        f_dwave(3, slider_adamp_3.value, slider_fdamp_3.value, change['new'], slider_d_3.value)\n    if sender == 'damp_d_3':\n        f_dwave(3, slider_adamp_3.value, slider_fdamp_3.value, slider_pdamp_3.value, change['new'])\n        \n    if sender == 'ramp_a_3':\n        f_ramp(3, change['new'])\n        \n    if sender == 'step_a_3':\n        f_step(3, change['new'], slider_bstep_3.value)\n    if sender == 'step_b_3':\n        f_step(3, slider_astep_3.value, change['new'])\n\nslider_a_1.observe(lambda change: slider_change(change, 'sin_a_1'), names='value')\nslider_f_1.observe(lambda change: slider_change(change, 'sin_f_1'), names='value')\nslider_p_1.observe(lambda change: slider_change(change, 'sin_p_1'), names='value')\n\nslider_acos_1.observe(lambda change: slider_change(change, 'cos_a_1'), names='value')\nslider_fcos_1.observe(lambda change: slider_change(change, 'cos_f_1'), names='value')\nslider_pcos_1.observe(lambda change: slider_change(change, 'cos_p_1'), names='value')\n\nslider_adamp_1.observe(lambda change: slider_change(change, 'damp_a_1'), names='value')\nslider_fdamp_1.observe(lambda change: slider_change(change, 'damp_f_1'), names='value')\nslider_pdamp_1.observe(lambda change: slider_change(change, 'damp_p_1'), names='value')\nslider_d_1.observe(lambda change: slider_change(change, 'damp_d_1'), names='value')\n\nslider_aramp_1.observe(lambda change: slider_change(change, 'ramp_a_1'), names='value')\n\nslider_astep_1.observe(lambda change: slider_change(change, 'step_a_1'), names='value')\nslider_bstep_1.observe(lambda change: slider_change(change, 'step_b_1'), names='value')\n###    \nslider_a_2.observe(lambda change: slider_change(change, 'sin_a_2'), names='value')\nslider_f_2.observe(lambda change: slider_change(change, 'sin_f_2'), names='value')\nslider_p_2.observe(lambda change: slider_change(change, 'sin_p_2'), names='value')\n\nslider_acos_2.observe(lambda change: slider_change(change, 'cos_a_2'), names='value')\nslider_fcos_2.observe(lambda change: slider_change(change, 'cos_f_2'), names='value')\nslider_pcos_2.observe(lambda change: slider_change(change, 'cos_p_2'), names='value')\n\nslider_adamp_2.observe(lambda change: slider_change(change, 'damp_a_2'), names='value')\nslider_fdamp_2.observe(lambda change: slider_change(change, 'damp_f_2'), names='value')\nslider_pdamp_2.observe(lambda change: slider_change(change, 'damp_p_2'), names='value')\nslider_d_2.observe(lambda change: slider_change(change, 'damp_d_2'), names='value')\n\nslider_aramp_2.observe(lambda change: slider_change(change, 'ramp_a_2'), names='value')\n\nslider_astep_2.observe(lambda change: slider_change(change, 'step_a_2'), names='value')\nslider_bstep_2.observe(lambda change: slider_change(change, 'step_b_2'), names='value')\n###    \nslider_a_3.observe(lambda change: slider_change(change, 'sin_a_3'), names='value')\nslider_f_3.observe(lambda change: slider_change(change, 'sin_f_3'), names='value')\nslider_p_3.observe(lambda change: slider_change(change, 'sin_p_3'), names='value')\n\nslider_acos_3.observe(lambda change: slider_change(change, 'cos_a_3'), names='value')\nslider_fcos_3.observe(lambda change: slider_change(change, 'cos_f_3'), names='value')\nslider_pcos_3.observe(lambda change: slider_change(change, 'cos_p_3'), names='value')\n\nslider_adamp_3.observe(lambda change: slider_change(change, 'damp_a_3'), names='value')\nslider_fdamp_3.observe(lambda change: slider_change(change, 'damp_f_3'), names='value')\nslider_pdamp_3.observe(lambda change: slider_change(change, 'damp_p_3'), names='value')\nslider_d_3.observe(lambda change: slider_change(change, 'damp_d_3'), names='value')\n\nslider_aramp_3.observe(lambda change: slider_change(change, 'ramp_a_3'), names='value')\n\nslider_astep_3.observe(lambda change: slider_change(change, 'step_a_3'), names='value')\nslider_bstep_3.observe(lambda change: slider_change(change, 'step_b_3'), names='value')\n\n\n# dropdown(1) selection change\ndef fun1_dropdown(change):\n    if (dd_fun1.value == 'sine wave'): \n        with output_fun1:\n            output_fun1.clear_output(wait=True)\n            display(slider_a_1, slider_f_1, slider_p_1)\n        f_sine(1, slider_a_1.value, slider_f_1.value, slider_p_1.value)    \n    \n    if (dd_fun1.value == 'cosine wave'):\n        with output_fun1:\n            output_fun1.clear_output(wait=True)\n            display(slider_acos_1, slider_fcos_1, slider_pcos_1)\n        f_cos(1, slider_acos_1.value, slider_fcos_1.value, slider_pcos_1.value)   \n        \n    if (dd_fun1.value == 'damped wave'):\n        with output_fun1:\n            output_fun1.clear_output(wait=True)\n            display(slider_adamp_1, slider_fdamp_1, slider_pdamp_1, slider_d_1)\n        f_dwave(1, slider_adamp_1.value, slider_fdamp_1.value, slider_pdamp_1.value, slider_d_1.value) \n\n    if (dd_fun1.value == 'ramp function'):\n        with output_fun1:\n            output_fun1.clear_output(wait=True)\n            display(slider_aramp_1)\n        f_ramp(1, slider_aramp_1.value)   \n               \n    if (dd_fun1.value == 'step function'):\n        with output_fun1:\n            output_fun1.clear_output(wait=True)\n            display(slider_astep_1, slider_bstep_1)\n        f_step(1, slider_astep_1.value, slider_bstep_1.value) \n\n        \n# dropdown(2) selection change\ndef fun2_dropdown(change):\n    if (dd_fun2.value == 'sine wave'): \n        with output_fun2:\n            output_fun2.clear_output(wait=True)\n            display(slider_a_2, slider_f_2, slider_p_2)\n        f_sine(2, slider_a_2.value, slider_f_2.value, slider_p_2.value)    \n    \n    if (dd_fun2.value == 'cosine wave'):\n        with output_fun2:\n            output_fun2.clear_output(wait=True)\n            display(slider_acos_2, slider_fcos_2, slider_pcos_2)\n        f_cos(2, slider_acos_2.value, slider_fcos_2.value, slider_pcos_2.value)   \n        \n    if (dd_fun2.value == 'damped wave'):\n        with output_fun2:\n            output_fun2.clear_output(wait=True)\n            display(slider_adamp_2, slider_fdamp_2, slider_pdamp_2, slider_d_2)\n        f_dwave(2, slider_adamp_2.value, slider_fdamp_2.value, slider_pdamp_2.value, slider_d_2.value) \n\n    if (dd_fun2.value == 'ramp function'):\n        with output_fun2:\n            output_fun2.clear_output(wait=True)\n            display(slider_aramp_2)\n        f_ramp(2, slider_aramp_2.value)   \n               \n    if (dd_fun2.value == 'step function'):\n        with output_fun2:\n            output_fun2.clear_output(wait=True)\n            display(slider_astep_2, slider_bstep_2)\n        f_step(2, slider_astep_2.value, slider_bstep_2.value) \n         \n            \n# dropdown(3) selection change\ndef fun3_dropdown(change):\n    if (dd_fun3.value == 'sine wave'): \n        with output_fun3:\n            output_fun3.clear_output(wait=True)\n            display(slider_a_3, slider_f_3, slider_p_3)\n        f_sine(3, slider_a_3.value, slider_f_3.value, slider_p_3.value)    \n    \n    if (dd_fun3.value == 'cosine wave'):\n        with output_fun3:\n            output_fun3.clear_output(wait=True)\n            display(slider_acos_3, slider_fcos_3, slider_pcos_3)\n        f_cos(3, slider_acos_3.value, slider_fcos_3.value, slider_pcos_3.value)   \n        \n    if (dd_fun3.value == 'damped wave'):\n        with output_fun3:\n            output_fun3.clear_output(wait=True)\n            display(slider_adamp_3, slider_fdamp_3, slider_pdamp_3, slider_d_3)\n        f_dwave(3, slider_adamp_3.value, slider_fdamp_3.value, slider_pdamp_3.value, slider_d_3.value) \n\n    if (dd_fun3.value == 'ramp function'):\n        with output_fun3:\n            output_fun3.clear_output(wait=True)\n            display(slider_aramp_3)\n        f_ramp(3, slider_aramp_3.value)   \n               \n    if (dd_fun3.value == 'step function'):\n        with output_fun3:\n            output_fun3.clear_output(wait=True)\n            display(slider_astep_3, slider_bstep_3)\n        f_step(3, slider_astep_3.value, slider_bstep_3.value) \n            \n# dropdown observers   \ndd_fun1.observe(fun1_dropdown, names = 'value')\ndd_fun2.observe(fun2_dropdown, names = 'value')\ndd_fun3.observe(fun3_dropdown, names = 'value')\n\n# checkbox widget\ndef trigger(b):\n    plot_everything()\nnoise_widget = widgets.Checkbox(False, description='Add noise')\nnoise_widget.observe(trigger)\n\n\n# output layout\noutput_fun1 = widgets.Output()\noutput_fun2 = widgets.Output()\noutput_fun3 = widgets.Output()\noutput_time1 = widgets.Output(layout = outputs_layout)\noutput_time2 = widgets.Output(layout = outputs_layout)\noutput_fft = widgets.Output(layout = outputs_layout)\n\nbox1 = widgets.VBox([dd_fun1, output_fun1], layout = fun1_layout)\nbox2 = widgets.VBox([dd_fun2, output_fun2], layout = fun2_layout)\nbox3 = widgets.VBox([dd_fun3, output_fun3], layout = fun3_layout)\npanel_box = widgets.HBox([box1,  widgets.Label(\" \"), box2, widgets.Label(\" \"), box3])\ndisplay(panel_box, output_time1, output_time2, output_fft)\nfirst()"
  },
  {
    "objectID": "ICCT_en/examples/02/TD-01-Water-level-control-system.html",
    "href": "ICCT_en/examples/02/TD-01-Water-level-control-system.html",
    "title": "Water level control system",
    "section": "",
    "text": "# Erasmus+ ICCT project (2018-1-SI01-KA203-047081)\n\n# Toggle cell visibility\n\n# from IPython.display import HTML\n# tag = HTML('''&lt;script&gt;\n# code_show=true; \n# function code_toggle() {\n#     if (code_show){\n#         $('div.input').hide()\n#     } else {\n#         $('div.input').show()\n#     }\n#     code_show = !code_show\n# } \n# $( document ).ready(code_toggle);\n# &lt;/script&gt;\n# Toggle cell visibility &lt;a href=\"javascript:code_toggle()\"&gt;here&lt;/a&gt;.''')\n# display(tag)\n\n# Hide the code completely\n\nfrom IPython.display import HTML\ntag = HTML('''&lt;style&gt;\ndiv.input {\n    display:none;\n}\n&lt;/style&gt;''')\ndisplay(tag)\n\n\n\n\n\n%matplotlib notebook\nimport random\nimport matplotlib.pyplot as plt\nimport matplotlib.animation as animation\nimport numpy as np\nfrom ipywidgets import interact, interactive, fixed, interact_manual\nimport ipywidgets as widgets\nfrom IPython.display import Image, YouTubeVideo\n\nAn example of a very simple water level control system is shown schematically in the left figure below. The goal of the control system is to maintain the reference (desired) water level in the reservoir. The desired water level \\(H_{ref}\\) is also the input signal for the block diagram shown in the right figure below. The position of the gate valve can change if the float moves or if the position of the nut on the spindle is changed. The position of the nut on the spindle is in relation with \\(H_{ref}\\), the position of the float is of course related to the water level \\(H\\). The lever then transforms the difference between these two signals into the displacement (opening) of the gate valve. The output of the gate valve is the flow \\(Q_{in}\\). The opening of the globe valve is considered to be beyond the control of the system and is therefore denoted as a disturbance \\(d\\). It of course influences the outflow \\(Q_{out}\\). Signals \\(Q_{in}\\) and \\(Q_{out}\\) are inputs to the reservoir. The output signal of the reservoir is water level \\(H\\) which is also the output signal of the whole system. The float, which is used to measure the output of the system is the so called feedback, because it is used to compare the reference (desired) water level \\(H_{ref}\\) with the actual one \\(H\\).\n \n\n\n\nSchematic representation of the water level control system\n\n\nBlock diagram of the water level control system\n\n\n\n\n\n\n\n\n\n\n\n\n\nHow to use this notebook?\n\nMove the sliders to change the values of the desired water level (\\(H_{ref}\\)), proportional tuning coefficient (\\(K_p\\)) and the outflow (\\(Q_{out}\\)).\n\n\nh_ = 5 # water level\n\nA = 12000 # area of water tank\nTv = 400 # time discretisation for z-transform\n\n# geometry\nx_min = -15\nx_max = 60\ny_min = -10\ny_max = 55\nh_tank = 20\nl_tank = 37\nl_whole_tank = 40\nd_pipe = 2\nh_ventil = 5\nl_ventil = 4\nl_pipe1 = 6\nl1_pipe2 = 9\nl2_pipe2 = 4\nl_pipe3 = 6\nl_podpore = 5\nh_podpore = 4\n\n\n# lists of points for plot\n\nrob_x = np.array([x_min, x_max, x_max, x_min, x_min])\nrob_y = np.array([y_min, y_min, y_max, y_max, y_min])\n\ntank_x = np.array([0, 0, l_whole_tank, l_whole_tank, l_tank, l_tank])\ntank_y = np.array([h_tank, 0, 0, d_pipe, d_pipe, h_tank])\n\nventil_x = np.array([0, l_ventil, l_ventil, 0, 0])\nventil_y = np.array([(h_ventil - d_pipe) / 2, \n                     -(d_pipe + (h_ventil - d_pipe) / 2), (h_ventil - d_pipe) / 2,\n                     -(d_pipe + (h_ventil - d_pipe) / 2),\n                     (h_ventil - d_pipe) / 2])\n\npipe1_x = np.array([-l_pipe1, 0, 0, -l_pipe1])\npipe1_y = np.array([0, 0, -d_pipe, -d_pipe])\n\npipe2_x = np.array([l1_pipe2, l1_pipe2, 0, 0, l1_pipe2 - d_pipe,\n                   l1_pipe2 - d_pipe])\npipe2_y = np.array([-l2_pipe2, 0, 0, -d_pipe, -d_pipe, -l2_pipe2])\n\npipe3_x = np.array([l_pipe3, 0, 0, l_pipe3])\npipe3_y = np.array([0, 0, -d_pipe, -d_pipe])\n\npodpora_x = np.array([-(1/2+1/5)*l_podpore, -1/2*l_podpore, -1/4*l_podpore,\n                      -(1/4+1/5)*l_podpore, -1/4*l_podpore, 0, -1/5*l_podpore,\n                      0, 1/4*l_podpore, (1/4-1/5)*l_podpore, 1/4*l_podpore,\n                      0, -1/4*l_podpore, 1/2*l_podpore, (1/2-1/5)*l_podpore])\npodpora_y = np.array([-h_podpore, -3/4*h_podpore, -3/4*h_podpore,\n                      -h_podpore, -3/4*h_podpore, -3/4*h_podpore, -h_podpore,\n                      -3/4*h_podpore, -3/4*h_podpore, -h_podpore, -3/4*h_podpore,\n                      0, -3/4*h_podpore, -3/4*h_podpore, -h_podpore])\n\nt_x=np.array([])\n\n\nfig = plt.figure(figsize=(9.8, 4), num=\"Water level control system\")\nax = fig.add_subplot(1, 2, 1)\nax.set_axis_off()\ngraph = fig.add_subplot(1, 2, 2)\nlist_h_x =[]\nlist_h_y = []\nlist_h_desired_x = []\nlist_h_desired_y = []\n\n\nq_out = 1\nq_out_prev = q_out\nh_desired =5\nh_desired_prev = h_desired\nh_ = h_desired\nh_prev = h_\nK = 1\n\n# create slider widgets:\nset_h_desired = widgets.FloatSlider(value=3.,min=0.0,max=10,step=.1,description=r'\\(H_{ref}\\) [m]',\n                    disabled=False,continuous_update=True,orientation='horizontal',readout=True,readout_format='.2f')\nset_K = widgets.FloatSlider(value=.1,min=0.,max=.5,step=0.01,description=r'\\(K_p \\)',\n                    disabled=False,continuous_update=True,orientation='horizontal',readout=True,readout_format='.2f')\nset_q_out = widgets.FloatSlider(value=2.5,min=0.,max=5.,step=0.1,description=r'\\(Q_{out} \\) [m&lt;sup&gt;3&lt;/sup&gt;/s]',\n                    disabled=False,continuous_update=True,orientation='horizontal',readout=True,readout_format='.2f')\n\nvbox1 = widgets.VBox([set_h_desired, set_K, set_q_out])\ndisplay(vbox1)\n\ndef set_coefficients(set_h_desired, set_K, set_q_out):\n    global K, h_desired, q_out\n    K = set_K.value\n    h_desired = set_h_desired.value\n    q_out = set_q_out.value\n\n#interact(set_coefficients, set_h_desired=(0, 15.), set_K=(0., 5., 0.1), set_q_out=(0, 5.))\n\ndef update_figure(i):\n    global h_prev, h_desired_prev, q_out_prev, h_\n    set_coefficients(set_h_desired, set_K, set_q_out)\n\n    d = 33 - h_desired\n    x = K*(27-(-8 + l_ventil / 2))/(K+1) #za podporo\n    \n    # functions for calculating new height\n    def calculate_new_height(K, h_prev, h_desired, h_desired_prev, q_out, q_out_prev):\n        # z-transform (h_)\n        K = K*10 # for faster response\n        temp_result = - h_prev * (K - A * 2 / Tv) + h_desired * K + h_desired_prev * K - q_out - q_out_prev\n        return temp_result / (A * 2 / Tv + K)\n    def calculate_new_height_negative(h_prev, q_out, q_out_prev):\n        # calculated, if desired height is lower than current height\n        temp_result = - h_prev * (- A * 2 / Tv) - q_out - q_out_prev\n        return temp_result / (A * 2 / Tv)\n\n    if h_desired &lt; h_:\n        h_ = calculate_new_height_negative(h_prev, q_out, q_out_prev)\n    else:\n        h_ = calculate_new_height(K, h_prev, h_desired, h_desired_prev, q_out, q_out_prev)\n    \n    if (h_&lt;0):\n        h_ = 0\n\n    vzvod1_x = np.array([27.5, 27.5])\n    vzvod1_y = np.array([h_, h_ + 22])\n\n    vzvod2_x = np.array([27, 27, -8 + l_ventil / 2,\n                         -8 + l_ventil / 2])\n    vzvod2_y = np.array([h_ + d - 13, h_ + d, -(-33 + (h_ + d)) * K + 33,\n                         h_tank + 5 - d_pipe / 2])\n\n    # lists for water drops plot\n    koef_in_drops=int((h_desired-h_)*K*5*3)\n    if (koef_in_drops&lt;0):\n        koef_in_drops = 0\n    drops_in_x = np.array([random.randint(-10, 10)/12 for i in range(koef_in_drops)])\n    drops_in_y = np.array([random.randint(-10, 10)/2 for i in range(koef_in_drops)])\n    \n    koef_out_drops = int(q_out*3*5)\n    if h_ == 0:\n        koef_out_drops = int((h_desired)*K*5*3)\n    drops_out_x = np.array([random.randint(-10,10)/4 for i in range(koef_out_drops)])\n    drops_out_y = np.array([random.randint(-10, 10)/10 for i in range(koef_out_drops)])\n\n    drops_tank = int(h_)*50\n    drops_tank_x = np.array([random.randint(0, 370)/10 for i in range(drops_tank)])\n    drops_tank_y = np.array([random.randint(0, int(h_-1)*10)/10 for i in range(drops_tank)])\n\n    plovec_x = np.array([3, 3, -3, -3, 3])\n    plovec_y = np.array([0.3, -0.3, -0.3, 0.3, 0.3])\n            \n    # plot\n    ax.clear()\n    ax.plot(rob_x, rob_y, ',')\n    ax.plot([0, l_tank], [h_, h_], 'b', lw=3)\n    ax.plot(tank_x, tank_y, 'k')\n    ax.plot(ventil_x + l_whole_tank, ventil_y + d_pipe, 'k')\n    ax.plot(pipe1_x - 8, pipe1_y + h_tank + 5, 'k')\n    ax.plot(pipe2_x + l_ventil - 8, pipe2_y + h_tank + 5, 'k')\n    ax.plot(ventil_x - 8, ventil_y + h_tank + 5, 'k')\n    ax.plot(pipe3_x + l_whole_tank + l_ventil, pipe3_y + d_pipe, 'k')\n    ax.plot(podpora_x - 8 + l_ventil / 2 + x, podpora_y + 33, 'k')\n    ax.plot(vzvod2_x, vzvod2_y, 'r')\n    ax.plot(vzvod1_x, vzvod1_y, 'k')\n    ax.plot(plovec_x + 27, plovec_y + h_, 'r')\n    ax.plot(drops_in_x + l_ventil - 8 + l1_pipe2 - d_pipe / 2, drops_in_y + h_tank + 5 - l2_pipe2 - 7, 'b.')\n    ax.plot(drops_out_x + l_whole_tank + l_ventil + l_pipe3 + 4, drops_out_y + d_pipe / 2, 'b.')\n    ax.plot(drops_tank_x, drops_tank_y, 'b,')\n    ax.plot([27, -8+l_ventil/2, -8+l_ventil/2+x], [h_ + d, -(-33 + (h_ + d))*K + 33, 33-0.5], 'k.')\n    ax.plot(np.array([2,2,0.8,3.2]) + l_whole_tank, np.array([-1,3,3,3]) + d_pipe, 'k') # add \"T\" to the output valve\n\n    list_h_x.append(i*Tv/1000)\n    list_h_y.append(h_)\n    list_h_desired_x.append(i*Tv/1000)\n    list_h_desired_y.append(h_desired)\n    graph.clear()\n    graph.plot(list_h_desired_x, list_h_desired_y, 'g', label='desired level')\n    graph.plot(list_h_x, list_h_y, 'b', lw=2, label='actual level')\n     \n    ax.set_title('Schematic representation of a water level \\n control system')\n    ax.text(-17, 1.5, 'reservoir')\n    ax.text(32, -5, 'globe valve')\n    ax.text(-21, 18, 'gate valve')\n    ax.text(12, 36, 'lever')\n    ax.text(-10, -15, 'Actual water level: %.2f m' %h_)\n    ax.set_axis_off()\n    graph.set_xlabel('$t$ [s]')\n    graph.set_ylabel('water level [m]')\n    graph.set_title('Water level vs. time')\n    graph.legend(loc=1, fontsize=8)\n    \n    h_prev = h_\n    h_desired_prev = h_desired\n    q_out_prev = q_out \n    \n    \nani = animation.FuncAnimation(fig, update_figure, interval=Tv)"
  },
  {
    "objectID": "ICCT_en/examples/02/TD-03-Mechanical-systems.html",
    "href": "ICCT_en/examples/02/TD-03-Mechanical-systems.html",
    "title": "Mechanical systems",
    "section": "",
    "text": "# Erasmus+ ICCT project (2018-1-SI01-KA203-047081)\n\n# Toggle cell visibility\n\nfrom IPython.display import HTML\ntag = HTML('''&lt;script&gt;\ncode_show=true; \nfunction code_toggle() {\n    if (code_show){\n        $('div.input').hide()\n    } else {\n        $('div.input').show()\n    }\n    code_show = !code_show\n} \n$( document ).ready(code_toggle);\n&lt;/script&gt;\nToggle cell visibility &lt;a href=\"javascript:code_toggle()\"&gt;here&lt;/a&gt;.''')\ndisplay(tag)\n\n\nToggle cell visibility here.\n\n\n\n%matplotlib notebook\nimport numpy as np\nimport control as control\nimport matplotlib.pyplot as plt\nimport matplotlib.image as mpimg\nfrom ipywidgets import widgets\nfrom ipywidgets import interact\nimport scipy.signal as signal\nimport sympy as sym\n\n\n---------------------------------------------------------------------------\nModuleNotFoundError                       Traceback (most recent call last)\nCell In[2], line 3\n      1 get_ipython().run_line_magic('matplotlib', 'notebook')\n      2 import numpy as np\n----&gt; 3 import control as control\n      4 import matplotlib.pyplot as plt\n      5 import matplotlib.image as mpimg\n\nModuleNotFoundError: No module named 'control'\n\n\n\n\nGeneral mass-spring-damper model\n\nThe mass-spring-damper model consists of discrete mass nodes distributed throughout an object and interconnected via a network of springs and dampers. This model is well-suited for modelling object with complex material properties such as nonlinearity and viscoelasticity. (source: Wikipedia) #### 1/4 car model 1/4 car model is used to analyze the ride quality of automotive suspension systems. Mass \\(m_1\\) is the “sprung mass”, which is one-quarter of the vehicle mass that is supported by the suspension system. Mass \\(m_2\\) is the “unsprung mass”, which is lumped mass composed of one wheel and half-axle assembly, plus the shock absorber and suspensison springs. The stiffness and damping of the suspension system are modeled by the ideal spring constant \\(k_1\\) and friction coefficient \\(B\\), respecitvely. Tire stifness is modeled by spring constant \\(k_2\\). (source: Chegg Study)\n\n\n\n\nHow to use this notebook?\n\nToggle between mass-spring-damper and 1/4 car model system by clicking on a corresponding button.\nToggle betweeen step function, impulse function, ramp function, and sine function to select the function of the force \\(F\\).\nMove the sliders to change the values of the mass (\\(m\\); \\(m_1\\) and \\(m_2\\)), spring coefficients (\\(k\\); \\(k_1\\) and \\(k_2\\)), damping constant (\\(B\\)), input signal amplification and initial conditions (\\(x_0\\), \\(\\dot{x}_0\\), \\(y_0\\), \\(\\dot{y}_0\\)).\n\n\n\n\nMass-spring-damper\n\n\n1/4 car model\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n# create figure\nfig = plt.figure(figsize=(9.8, 4),num='Mechanical systems')\n\n# add sublot\nax = fig.add_subplot(111)\nax.set_title('Time Response')\nax.set_ylabel('input, output')\nax.set_xlabel('$t$ [s]')\n\nax.grid(which='both', axis='both', color='lightgray')\n\ninputf, = ax.plot([], [])\nresponsef, = ax.plot([], [])\nresponsef2, = ax.plot([], [])\narrowf, = ax.plot([],[])\n\nstyle = {'description_width': 'initial'}\n\nselectSystem=widgets.ToggleButtons(\n    options=[('mass-spring-damper',0),('1/4 car model',1)],\n    description='Select system: ', style=style) # define toggle buttons\nselectForce = widgets.ToggleButtons(\n    options=[('step function', 0), ('impulse function', 1), ('ramp function', 2), ('sine function', 3)],\n    description='Select $F$ function: ', style=style)\ndisplay(selectSystem)\ndisplay(selectForce)\n\ndef build_model(M,K,B,M1,M2,B1,K1,K2,amp,x0,xpika0,select_System,index):\n\n    num_of_samples = 1000\n    total_time = 25\n    t = np.linspace(0, total_time, num_of_samples) # time for which response is calculated (start, stop, step)\n    \n    global inputf, responsef, responsef2, arrowf\n    \n    if select_System==0:\n        \n        system0 = control.TransferFunction([1], [M, B, K])\n        \n        if index==0:\n            inputfunc = np.ones(len(t))*amp\n            time, response, xx = control.forced_response(system0, t, inputfunc, X0=[xpika0,x0*M]) \n            inputfunc[0]=0\n            \n        elif index==1:\n            inputfunc=signal.unit_impulse(1000, 0)*amp\n            time, response, xx = control.forced_response(system0, t, inputfunc, X0=[xpika0,x0*M]) \n    \n        elif index==2:\n            inputfunc=t;\n            time, response, xx = control.forced_response(system0, t, inputfunc, X0=[xpika0,x0*M]) \n       \n        elif index==3:\n            inputfunc=np.sin(t)*amp\n            time, response, xx = control.forced_response(system0, t, inputfunc, X0=[xpika0,x0*M])    \n    \n    elif select_System==1:\n        \n        system1 = control.TransferFunction([B1*K2, K1*K2],[M1*M2, M1*B1+M2*B1, M1*K1+M1*K2+M2*K1, B1*K2, K1*K2])\n        system2 = control.TransferFunction([M1*K2, B1*K2, K1*K2],[M1*M2, M1*B1+M2*B1, M1*K1+M1*K2+M2*K1, B1*K2, K1*K2])\n        \n        if index==0:\n            inputfunc = np.ones(len(t))*amp\n                 \n            time, response, xx = control.forced_response(system1, t, inputfunc, X0=[0,0,0,0])\n            time2, response2, xx2 = control.forced_response(system2, t, inputfunc, X0=[0,0,0,0])\n            inputfunc[0]=0\n        \n        elif index==1:\n            inputfunc=signal.unit_impulse(1000, 0)*amp\n            time, response, xx = control.forced_response(system1, t, inputfunc, X0=[0,0,0,0])\n            time2, response2, xx2 = control.forced_response(system2, t, inputfunc, X0=[0,0,0,0])\n       \n        elif index==2:\n            inputfunc=t;\n            time, response, xx = control.forced_response(system1, t, inputfunc, X0=[0,0,0,0])\n            time2, response2, xx2 = control.forced_response(system2, t, inputfunc, X0=[0,0,0,0])\n        \n        elif index==3:\n            inputfunc=np.sin(t)*amp\n            time, response, xx = control.forced_response(system1, t, inputfunc, X0=[0,0,0,0])\n            time2, response2, xx2 = control.forced_response(system2, t, inputfunc, X0=[0,0,0,0])\n\n    \n    ax.lines.remove(responsef)\n    ax.lines.remove(inputf)\n    ax.lines.remove(responsef2)\n    ax.lines.remove(arrowf)\n    \n    inputf, = ax.plot(t,inputfunc,label='$F$',color='C0')\n    responsef, = ax.plot(time, response,label='$x$',color='C3')\n    \n    if select_System==1:\n        responsef2, = ax.plot(time, response2,label='$y$',color='C2')\n    elif select_System==0:\n        responsef2, = ax.plot([],[])\n        \n    if index==1:\n        if amp&gt;0:\n            arrowf, = ax.plot([-0.1,0,0.1],[amp-((amp*0.05)/2),amp,amp-((amp*0.05)/2)],color='C0',linewidth=4)\n        elif amp==0:\n            arrowf, = ax.plot([],[])\n        elif amp&lt;0:\n            arrowf, = ax.plot([-0.1,0,0.1],[amp-((amp*0.05)/2),amp,amp-(amp*(0.05)/2)],color='C0',linewidth=4)\n    else:\n        arrowf, = ax.plot([],[])\n    \n    ax.relim()\n    ax.autoscale_view()\n    \n    ax.legend()    \n    \ndef update_sliders(index):\n    global m1_slider, b1_slider, k1_slider, m21_slider, m22_slider, b2_slider, k21_slider, k22_slider\n    global x0_slider, xpika0_slider\n\n    m1val = [0.1,0.1,0.1,0.1]\n    k1val = [1,1,1,1]\n    b1val = [0.1,0.1,0.1,0.1]\n    m21val = [0.1,0.1,0.1,0.1]\n    m22val = [0.1,0.1,0.1,0.1]\n    b2val = [0.1,0.1,0.1,0.1]\n    k21val = [1,1,1,1]\n    k22val = [1,1,1,1]\n    x0val = [0,0,0,0]\n    xpika0val = [0,0,0,0]\n    y0val = [0,0,0,0]\n    ypika0val = [0,0,0,0]\n    \n    m1_slider.value = m1val[index]\n    k1_slider.value = k1val[index]\n    b1_slider.value = b1val[index]\n    m21_slider.value = m21val[index]\n    m22_slider.value = m22val[index]\n    b2_slider.value = b2val[index]\n    k21_slider.value = k21val[index]\n    k22_slider.value = k22val[index]\n    x0_slider.value = x0val[index]\n    xpika0_slider.value = xpika0val[index]\n    \ndef draw_controllers(type_select,index):\n    \n    global m1_slider, b1_slider, k1_slider, m21_slider, m22_slider, b2_slider, k21_slider, k22_slider\n    global x0_slider, xpika0_slider\n    \n    if type_select==0:\n        \n        amp_slider = widgets.FloatSlider(value=1.,min=-2.,max=2.,step=0.1,\n            description='Input signal amplification:',disabled=False,continuous_update=False,orientation='horizontal',readout=True,readout_format='.1f',style=style)\n            \n        m1_slider = widgets.FloatSlider(value=.1, min=.01, max=1., step=.01,\n                                        description='$m$ [kg]:',disabled=False,continuous_update=False,\n                                        orientation='horizontal',readout=True,readout_format='.2f',)\n        k1_slider = widgets.FloatSlider(value=1.,min=0.,max=20.,step=.1,\n                                       description='$k$ [N/m]:',disabled=False,continuous_update=False,\n                                       orientation='horizontal',readout=True,readout_format='.1f',)\n        b1_slider = widgets.FloatSlider(value=.1,min=0.0,max=0.5,step=.01,\n                                        description='$B$ [Ns/m]:',disabled=False,continuous_update=False,\n                                        rientation='horizontal',readout=True,readout_format='.2f',)\n        m21_slider = widgets.FloatSlider(value=.1,min=.01,max=1.,step=.01,\n            description='$m_1$ [kg]:',disabled=True,continuous_update=False,orientation='horizontal',readout=True,readout_format='.2f',\n        )\n        m22_slider = widgets.FloatSlider(value=.1,min=.0,max=1.,step=.01,\n            description='$m_2$ [kg]:',disabled=True,continuous_update=False,orientation='horizontal',readout=True,readout_format='.2f',\n        )\n        b2_slider = widgets.FloatSlider(value=.1,min=0.0,max=2,step=.01,\n            description='$B$ [Ns/m]:',disabled=True,continuous_update=False,orientation='horizontal',readout=True,readout_format='.2f',\n        )\n        k21_slider = widgets.FloatSlider(value=1.,min=0.,max=20.,step=.1,\n            description='$k_1$ [N/m]:',disabled=True,continuous_update=False,orientation='horizontal',readout=True,readout_format='.1f',\n        )\n        k22_slider = widgets.FloatSlider(value=1.,min=0.,max=20.,step=.1,\n            description='$k_2$ [N/m]:',disabled=True,continuous_update=False,orientation='horizontal',readout=True,readout_format='.1f',\n        )\n        \n        x0_slider=widgets.FloatSlider(value=0, min=-1, max=1., step=.1,\n                                        description='$x_0$ [dm]:',disabled=False,continuous_update=False,\n                                        orientation='horizontal',readout=True,readout_format='.2f',)\n        xpika0_slider=widgets.FloatSlider(value=0, min=-1, max=1., step=.1,\n                                        description='${\\dot{x}}_0$ [dm/s]:',disabled=False,continuous_update=False,\n                                        orientation='horizontal',readout=True,readout_format='.2f',)\n    \n        #y0_slider=widgets.FloatSlider(value=0, min=-1, max=1., step=.1,\n        #                                description='$y_0$ [dm]:',disabled=True,continuous_update=False,\n        #                                orientation='horizontal',readout=True,readout_format='.2f',)\n        #ypika0_slider=widgets.FloatSlider(value=0, min=-1, max=1., step=.1,\n        #                                description='${\\dot{y}}_0$ [dm/s]:',disabled=True,continuous_update=False,\n        #                                orientation='horizontal',readout=True,readout_format='.2f',)\n    elif type_select==1:\n        \n        amp_slider = widgets.FloatSlider(value=1.,min=-2.,max=2.,step=0.1,\n            description='Input signal amplification:',disabled=False,continuous_update=False,orientation='horizontal',readout=True,readout_format='.1f',style=style)\n            \n        m1_slider = widgets.FloatSlider(value=.1, min=.01, max=1., step=.01,\n                                        description='$m$ [kg]:',disabled=True,continuous_update=False,\n                                        orientation='horizontal',readout=True,readout_format='.2f',)\n        k1_slider = widgets.FloatSlider(value=1.,min=0.,max=20.,step=.1,\n                                       description='$k$ [N/m]:',disabled=True,continuous_update=False,\n                                       orientation='horizontal',readout=True,readout_format='.1f',)\n        b1_slider = widgets.FloatSlider(value=.1,min=0.0,max=0.5,step=.01,\n                                        description='$B$ [Ns/m]:',disabled=True,continuous_update=False,\n                                        rientation='horizontal',readout=True,readout_format='.2f',)\n        m21_slider = widgets.FloatSlider(value=.1,min=.01,max=1.,step=.01,\n            description='$m_1$ [kg]:',disabled=False,continuous_update=False,orientation='horizontal',readout=True,readout_format='.2f',\n        )\n        m22_slider = widgets.FloatSlider(value=.1,min=.0,max=1.,step=.01,\n            description='$m_2$ [kg]:',disabled=False,continuous_update=False,orientation='horizontal',readout=True,readout_format='.2f',\n        )\n        b2_slider = widgets.FloatSlider(value=.1,min=0.0,max=2,step=.01,\n            description='$B$ [Ns/m]:',disabled=False,continuous_update=False,orientation='horizontal',readout=True,readout_format='.2f',\n        )\n        k21_slider = widgets.FloatSlider(value=1.,min=0.,max=20.,step=.1,\n            description='$k_1$ [N/m]:',disabled=False,continuous_update=False,orientation='horizontal',readout=True,readout_format='.1f',\n        )\n        k22_slider = widgets.FloatSlider(value=1.,min=0.,max=20.,step=.1,\n            description='$k_2$ [N/m]:',disabled=False,continuous_update=False,orientation='horizontal',readout=True,readout_format='.1f',\n        )\n        \n        x0_slider=widgets.FloatSlider(value=0, min=-1, max=1., step=.1,\n                                        description='$x_0$ [dm]:',disabled=True,continuous_update=False,\n                                        orientation='horizontal',readout=True,readout_format='.2f',)\n        xpika0_slider=widgets.FloatSlider(value=0, min=-1, max=1., step=.1,\n                                        description='${\\dot{x}}_0$ [dm/s]:',disabled=True,continuous_update=False,\n                                        orientation='horizontal',readout=True,readout_format='.2f',)\n    \n        #y0_slider=widgets.FloatSlider(value=0, min=-1, max=1., step=.1,\n        #                                description='$y_0$ [dm]:',disabled=True,continuous_update=False,\n        #                                orientation='horizontal',readout=True,readout_format='.2f',)\n        #ypika0_slider=widgets.FloatSlider(value=0, min=-1, max=1., step=.1,\n        #                                description='${\\dot{y}}_0$ [dm/s]:',disabled=True,continuous_update=False,\n        #                                orientation='horizontal',readout=True,readout_format='.2f',)    \n    input_data = widgets.interactive_output(build_model, {'M':m1_slider, 'K':k1_slider, 'B':b1_slider, 'M1':m21_slider,\n                                                    'M2':m22_slider, 'B1':b2_slider, 'K1':k21_slider, 'K2':k22_slider, 'amp':amp_slider,\n                                                    'x0':x0_slider,'xpika0':xpika0_slider,      \n                                                    'select_System':selectSystem,'index':selectForce})  \n    \n    input_data2 = widgets.interactive_output(update_sliders, {'index':selectForce})\n  \n    box_layout = widgets.Layout(border='1px solid black',\n                    width='auto',\n                    height='',\n                    flex_flow='row',\n                    display='flex')\n\n    buttons1=widgets.HBox([widgets.VBox([amp_slider],layout=widgets.Layout(width='auto')),\n                         widgets.VBox([x0_slider,xpika0_slider])],layout=box_layout)\n    display(widgets.VBox([widgets.Label('Select the values of the input signal amplification and intial conditions:'), buttons1]))\n    display(widgets.HBox([widgets.VBox([m1_slider,k1_slider,b1_slider], layout=widgets.Layout(width='45%')),\n                          widgets.VBox([m21_slider,m22_slider,k21_slider,k22_slider,b2_slider], layout=widgets.Layout(width='45%'))]), input_data)\n    \nwidgets.interactive_output(draw_controllers, {'type_select':selectSystem,'index':selectForce})"
  },
  {
    "objectID": "ICCT_en/examples/02/TD-05-Linearization-Functions.html",
    "href": "ICCT_en/examples/02/TD-05-Linearization-Functions.html",
    "title": "Linearization of a function",
    "section": "",
    "text": "# Erasmus+ ICCT project (2018-1-SI01-KA203-047081)\n\n# Toggle cell visibility\n\nfrom IPython.display import HTML\ntag = HTML('''&lt;script&gt;\ncode_show=true; \nfunction code_toggle() {\n    if (code_show){\n        $('div.input').hide()\n    } else {\n        $('div.input').show()\n    }\n    code_show = !code_show\n} \n$( document ).ready(code_toggle);\n&lt;/script&gt;\nToggle cell visibility &lt;a href=\"javascript:code_toggle()\"&gt;here&lt;/a&gt;.''')\ndisplay(tag)\n\n# Hide the code completely\n\n# from IPython.display import HTML\n# tag = HTML('''&lt;style&gt;\n# div.input {\n#     display:none;\n# }\n# &lt;/style&gt;''')\n# display(tag)\n\n\nToggle cell visibility here.\n\n\n\n%matplotlib notebook\nimport pylab\nimport matplotlib.pyplot as plt\nimport math\nimport sympy as sym\nimport numpy as np\nimport ipywidgets as widgets\nimport control as control\nimport math as math\nfrom ipywidgets import interact\nfrom IPython.display import Latex, display, Markdown\n\n\nIntroduction\n\nLinearization is defined as a process of finding a linear approximation of a function at a certain point. The linear approximation of a function is obtained by the Taylor expansion around the point of interest in which only the first two terms are kept. Linearization is an effective method for approximating the output of a function \\(y=f(x)\\) at any \\(x=x_0+\\Delta x\\) based on the value and the slope of the function at \\(x=x_0+\\Delta x\\), given that \\(f(x)\\) is differentiable on \\([x_0,x_0+\\Delta x]\\) (or \\([x_0+\\Delta x,x_0]\\)) and that \\(x_0\\) is close to \\(x_0+\\Delta x\\). In short, linearization approximates the output of a function near \\(x=x_0\\). (source: Wikipedia)\n\nIn this example, linearization is defined as:\n\\[\\begin{equation}\n    f(x)\\approx f(x_0)+f^{\\prime}(x_0) \\cdot (x-x_0),\n\\end{equation}\\]\nwhere \\(f^{\\prime}=\\frac{f(x_0+h)-f(x_0)}{h}\\) (\\(h\\) is set to \\(0.01\\) in order to calculate the derivative).\nUnit step function is defined as:\n\\[\\begin{equation}\n    u(x) =\n    \\begin{cases}\n      0; & \\text{$x&lt;0$}\\\\\n      1; & \\text{$x\\geq0$}\n    \\end{cases},\n\\end{equation}\\]\nand unit ramp function:\n\\[\\begin{equation}\n    r(x) =\n    \\begin{cases}\n      0; & \\text{$x&lt;0$}\\\\\n      x; & \\text{$x\\geq0$}      \n    \\end{cases}.\n\\end{equation}\\]\n\n\n\nHow to use this notebook?\nMove the slider to change the value of \\(x_0\\), i.e. the \\(x\\) value at which you want to linearize the function.\n\n# sinus, step, ramp, x^2, sqrt(x)\nfunctionSelect = widgets.ToggleButtons(\n    options=[('sine function', 0), ('unit step function', 1), ('unit ramp function', 2), ('parabolic function', 3), ('square root function', 4)],\n    description='Select: ')\n\nfig = plt.figure(num='Linearization of a function')\nfig.set_size_inches((9.8, 3))\nfig.set_tight_layout(True)\nf1 = fig.add_subplot(1, 1, 1)\n\nf1.grid(which='both', axis='both', color='lightgray')\n\nf1.set_xlabel('$x$')\nf1.set_ylabel('$f(x)$')\n\nf1.axhline(0,Color='black',linewidth=0.5)\nf1.axvline(0,Color='black',linewidth=0.5)\n\nfunc_plot, = f1.plot([],[])\ntang_plot, = f1.plot([],[])\npoint_plot, = f1.plot([],[])\n\nf1.set_xlim((-5,5))\nf1.set_ylim((-6,6))\n\ndef create_draw_functions(x0,index):\n    x=np.linspace(-5,5,1001)\n    h=0.001 # equal to \\Delta x\n    \n    global func_plot, tang_plot, point_plot\n       \n    if index==0:\n        y=np.sin(x)\n        fprime=(np.sin(x0+h)-np.sin(x0))/h\n        tang=np.sin(x0)+fprime*(x-x0)\n        fx0=np.sin(x0)        \n    elif index==1:\n        y=np.zeros(1001)\n        y[510:1001]=1\n    elif index==2:\n        y=np.zeros(1001)\n        y[500:1001]=np.linspace(0,5,501)\n    elif index==3:\n        y=x*x\n        fprime=((x0+h)*(x0+h)-(x0*x0))/h\n        tang=x0*x0+fprime*(x-x0)\n        fx0=x0*x0        \n    elif index==4:\n        x1=np.linspace(0,5,500)\n        y=np.sqrt(x1)\n        if x0&gt;=0:\n            fprime=(np.sqrt(x0+h)-np.sqrt(x0))/h\n            tang=np.sqrt(x0)+fprime*(x-x0)\n            fx0=np.sqrt(x0)\n    \n    f1.lines.remove(func_plot)\n    f1.lines.remove(tang_plot)\n    f1.lines.remove(point_plot)\n    \n    if index == 0:\n        func_plot, = f1.plot(x,y,label='$f(x)=sin(x)$',color='C0')\n        tang_plot, = f1.plot(x,tang,'--r',label='tangent')\n        point_plot, = f1.plot(x0,fx0,'om',label='$x_0$')\n        for txt in f1.texts: \n                txt.set_visible(False)\n    elif index == 1: # in case of the unit step function\n        if x0==0:\n            func_plot, = f1.step(x,y,label='$f(x)=u(x)$',color='C0')\n            tang_plot, = f1.plot([],[])\n            point_plot, = f1.plot([],[])    \n            f1.text(0.1,1.3,'Linearization at $x_0=0$ is not possible!',fontsize=14)\n        elif x0&lt;0:\n            tang=np.zeros(1001)\n            func_plot, = f1.step(x,y,label='$f(x)=u(x)$',color='C0')\n            tang_plot, = f1.plot(x,tang,'--r',label='tangent')\n            point_plot, = f1.plot(x0,[0],'om',label='$x_0$')\n            for txt in f1.texts: \n                txt.set_visible(False)\n        elif x0&gt;0:\n            tang=np.ones(1001)\n            func_plot, = f1.step(x,y,label='$f(x)=u(x)$',color='C0')\n            tang_plot, = f1.plot(x,tang,'--r',label='tangent')\n            point_plot, = f1.plot(x0,[1],'om',label='$x_0$')\n            for txt in f1.texts: \n                txt.set_visible(False)\n    elif index==2: # in case of the ramp\n        if x0&lt;0:\n            tang=np.zeros(1001)\n            func_plot, = f1.plot(x,y,label='$f(x)=R(x)$',color='C0')\n            tang_plot, = f1.plot(x,np.zeros(1001),'--r',label='tangent')\n            point_plot, = f1.plot(x0,[0],'om',label='$x_0$')\n            for txt in f1.texts: \n                txt.set_visible(False)\n        elif x0&gt;=0:\n            tang=x\n            func_plot, = f1.plot(x,y,label='$f(x)=R(x)$',color='C0')\n            tang_plot, = f1.plot(x,tang,'--r',label='tangent')\n            point_plot, = f1.plot(x0,x0,'om',label='$x_0$')\n            for txt in f1.texts: \n                txt.set_visible(False)\n    elif index==3:\n        func_plot, = f1.plot(x,y,label='$f(x)=x^2$',color='C0')\n        tang_plot, = f1.plot(x,tang,'--r',label='tangent')\n        point_plot, = f1.plot(x0,fx0,'om',label='$x_0$')\n        for txt in f1.texts: \n                txt.set_visible(False)        \n    elif index==4: #in case of the square root function\n        if x0&lt;0:\n            for txt in f1.texts: \n                txt.set_visible(False)\n            func_plot, = f1.plot(x1,y,label='$f(x)=\\sqrt{x}$',color='C0')\n            tang_plot, = f1.plot([],[])\n            point_plot, = f1.plot([],[])\n            f1.text(-4.9,1.3,'Square root function is not defined for $x&lt;0$!',fontsize=14)\n        else:\n            func_plot, = f1.plot(x1,y,label='$f(x)=\\sqrt{x}$',color='C0')\n            tang_plot, = f1.plot(x,tang,'--r',label='tangent')\n            point_plot, = f1.plot(x0,fx0,'om',label='$x_0$')\n            for txt in f1.texts: \n                txt.set_visible(False)\n    \n    if (index==1) and x0==0 or (index==4 and x0&lt;0):\n        display(Markdown('See comment on the figure.'))\n    else:\n        k=round(((tang[-1]-tang[0])/(x[-1]-x[0])),3)\n        n=round(((tang[-1]-k*x[-1])),3)\n        display(Markdown('Equation of the tangent: $y=%.3fx+%.3f$.'%(k,n)))\n    \n    f1.legend()\n    \n    f1.relim()\n    f1.relim()\n    f1.autoscale_view()\n    f1.autoscale_view()   \n\n    \nx0_slider = widgets.FloatSlider(value=1, min=-5, max=5, step=0.2, description='$x_0$',\n                          continuous_update=True, layout=widgets.Layout(width='auto', flex='5 5 auto'),readout_format='.1f')\n\ninput_data = widgets.interactive_output(create_draw_functions, {'x0':x0_slider, 'index':functionSelect})\n\ndef update_sliders(index):\n    global x0_slider\n    \n    x0val = [0.5, 0.5, 1, 1, 5, 10]\n    x0slider.value = x0val[index]\n    \ninput_data2 = widgets.interactive_output(update_sliders, {'index':functionSelect})\n\ndisplay(functionSelect)\n\ndisplay(x0_slider,input_data)\n\n# display(Markdown(\"The system can be represented as $f(x)=5$ for small excursions of x about x0.\"))"
  },
  {
    "objectID": "ICCT_en/examples/02/TD-07-Poles-zeros-and-system-response.html",
    "href": "ICCT_en/examples/02/TD-07-Poles-zeros-and-system-response.html",
    "title": "Poles, zeros and system response",
    "section": "",
    "text": "from IPython.display import HTML\ntag = HTML('''&lt;script&gt;\ncode_show=true; \nfunction code_toggle() {\n    if (code_show){\n        $('div.input').hide()\n    } else {\n        $('div.input').show()\n    }\n    code_show = !code_show\n} \n$( document ).ready(code_toggle);\n&lt;/script&gt;\nToggle cell visibility &lt;a href=\"javascript:code_toggle()\"&gt;here&lt;/a&gt;.''')\ndisplay(tag)\n\n\nToggle cell visibility here.\n\n\n\n%matplotlib notebook\nimport control as control\nimport ipywidgets as widgets\nimport numpy as np\n\nfrom IPython.display import display, HTML\nimport matplotlib.pyplot as plt\nfrom matplotlib.gridspec import GridSpec\n\nIn system analyis and design it is important to understand that when the system response is being analyzed based on the transfer function, both transfer function and the input signal (its Laplace transform to be more exact) are important.\nFor example, a response \\(Y(s)=\\frac{1}{s(s+1)(s+2)}\\) can be obtained if a system with a transfer function \\(P_1(s)=\\frac{1}{(s+1)(s+2)}\\) is being acted upon with an input signal \\(X_1(s)=\\frac{1}{s}\\) (unit transfer function), or if a system with a transfer function \\(P_2(s)=\\frac{1}{s(s+1)}\\) is being acted upon with an input signal \\(X_2(s)=\\frac{1}{s+2}\\).\nThis property is demonstrated in this example. Also the position of zeros and poles and their influence on the system response can be observed.\n\nHow to use this notebook?\n\nToggle between four different systems (see image below).\nUse the sliders to change the values of the coefficients \\(a\\), \\(b\\), \\(c\\) and \\(d\\) to define the input function and the transfer function of the system.\n\n\n\n\n\nSystem 1\n\n\nSystem 2\n\n\nSystem 3\n\n\nSystem 4\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n# Create figure and define the six subplots (2x3)\n\nfig1 = plt.figure()\ngs=GridSpec(3,3,figure=fig1)\n\nf1_1=fig1.add_subplot(gs[0,0])\nf1_2=fig1.add_subplot(gs[0,1])\nf1_3=fig1.add_subplot(gs[0,2])\nf1_4=fig1.add_subplot(gs[1,0])\nf1_5=fig1.add_subplot(gs[1,1])\nf1_6=fig1.add_subplot(gs[1,2])\nf1_7=fig1.add_subplot(gs[2,:])\n\n# fig1, ((f1_1, f1_2, f1_3), (f1_4, f1_5, f1_6), f1_7) = plt.subplots(3,3,num=' ')\nfig1.set_size_inches((9.8, 8))\nfig1.set_tight_layout(True)\n\noffset_text1 = f1_1.yaxis.get_offset_text()\noffset_text1.set_size(4)\noffset_text2 = f1_2.yaxis.get_offset_text()\noffset_text2.set_size(4)\noffset_text3 = f1_3.yaxis.get_offset_text()\noffset_text3.set_size(4)\noffset_text3x = f1_3.xaxis.get_offset_text()\noffset_text3x.set_size(4)\noffset_text4 = f1_4.yaxis.get_offset_text()\noffset_text4.set_size(4)\noffset_text5 = f1_5.yaxis.get_offset_text()\noffset_text5.set_size(4)\noffset_text6 = f1_6.yaxis.get_offset_text()\noffset_text6.set_size(4)\noffset_text6 = f1_7.yaxis.get_offset_text()\noffset_text6.set_size(4)\n\n# Initialize the subplots\nf1_line1, = f1_1.plot([], [])\nf1_line2, = f1_2.plot([],[])\nf1_line3, = f1_3.plot([], [])\nf1_line4, = f1_4.plot([], [])  \nf1_line5a, = f1_5.plot([], [])\nf1_line5b, = f1_5.plot([], [])\nf1_line5c, = f1_5.plot([], [])\nf1_line5d, = f1_5.plot([], [])\nf1_line6a, = f1_6.plot([], [])\nf1_line6b, = f1_6.plot([], [])\nf1_line7a, = f1_7.plot([], [])\nf1_line7b, = f1_7.plot([], [])\n\n# Titles, labels, ticks, lines\nf1_1.set_title('Input zeros', fontsize=11)\nf1_1.set_xlabel('Re', labelpad=0, fontsize=10)\nf1_1.set_ylabel('Im', labelpad=0, fontsize=10)\nf1_1.tick_params(axis='both', which='both', pad=0, labelsize=8)\nf1_1.axes.axhline(y=0,lw=0.8,color='k')\nf1_1.axes.axvline(x=0,lw=0.8,color='k')\n\nf1_2.set_title('Input poles', fontsize=11)\nf1_2.set_xlabel('Re', labelpad=0, fontsize=10)\nf1_2.set_ylabel('Im', labelpad=0, fontsize=10)\nf1_2.tick_params(axis='both', which='both', pad=0, labelsize=8)\nf1_2.axes.axhline(y=0,lw=0.8,color='k')\nf1_2.axes.axvline(x=0,lw=0.8,color='k')\n\nf1_3.set_title('System zeros', fontsize=11)\nf1_3.set_xlabel('Re', labelpad=0, fontsize=10)\nf1_3.set_ylabel('Im', labelpad=0, fontsize=10)\nf1_3.tick_params(axis='both', which='both', pad=0, labelsize=8)\nf1_3.axes.axhline(y=0,lw=0.8,color='k')\nf1_3.axes.axvline(x=0,lw=0.8,color='k')\n\nf1_4.set_title('System poles', fontsize=11)\nf1_4.set_xlabel('Re', labelpad=0, fontsize=10)\nf1_4.set_ylabel('Im', labelpad=0, fontsize=10)\nf1_4.tick_params(axis='both', which='both', pad=0, labelsize=8)\nf1_4.axes.axhline(y=0,lw=0.8,color='k')\nf1_4.axes.axvline(x=0,lw=0.8,color='k')\n\nf1_5.set_title('All poles and zeros (system+input)', fontsize=11)\nf1_5.set_xlabel('Re', labelpad=0, fontsize=10)\nf1_5.set_ylabel('Im', labelpad=0, fontsize=10)\nf1_5.tick_params(axis='both', which='both', pad=0, labelsize=8)\nf1_5.axes.axhline(y=0,lw=0.8,color='k')\nf1_5.axes.axvline(x=0,lw=0.8,color='k')\n\nf1_6.set_title('Pole-zero plot (system)', fontsize=11)\nf1_6.set_xlabel('', labelpad=0, fontsize=10)\nf1_6.set_ylabel('', labelpad=0, fontsize=10)\nf1_6.tick_params(axis='both', which='both', labelsize=8)\nf1_6.axes.axhline(y=0,lw=0.8,color='k')\nf1_6.axes.axvline(x=0,lw=0.8,color='k')\n\nf1_7.set_title('System response', fontsize=11)\nf1_7.set_xlabel('', labelpad=0, fontsize=10)\nf1_7.set_ylabel('', labelpad=0, fontsize=10)\nf1_7.tick_params(axis='both', which='both', labelsize=8)\nf1_7.axes.axhline(y=0,lw=0.8,color='k')\nf1_7.axes.axvline(x=0,lw=0.8,color='k')\n\n# # Define the appearance of the grid\nf1_1.grid(which='both', axis='both', color='lightgray')\nf1_2.grid(which='both', axis='both', color='lightgray')\nf1_3.grid(which='both', axis='both', color='lightgray')\nf1_4.grid(which='both', axis='both', color='lightgray')\nf1_5.grid(which='both', axis='both', color='lightgray')\nf1_6.grid(which='both', axis='both', color='lightgray')\nf1_7.grid(which='both', axis='both', color='lightgray')\n\n# Buttons for toggling between different models\nstyle = {'description_width': 'initial'} # style for description length\n\nmodelSelect = widgets.ToggleButtons(\n    options=[('System 1',0),('System 2',1),('System 3',2),('System 4',3)],\n    description='Select system: ', style=style) # define toggle buttons\n    \ndef build_model(a,b,c,d,model):\n\n    if model==0:  \n        zeros_in=np.roots([1])\n        poles_in=np.roots([1,a])\n        zeros_sys=np.roots([1])\n        poles_sys=np.roots([1,b])\n        W_sys=control.tf(np.array([1]),np.array([1,b]))\n        tout, yout = control.step_response(W_sys)\n    elif model==1:\n        zeros_in=np.roots([1])\n        poles_in=np.roots([1,a])\n        zeros_sys=np.roots([1,b])\n        poles_sys=np.roots([1,c])\n        W_sys=control.tf(np.array([1,b]),np.array([1,c]))\n        tout, yout = control.step_response(W_sys)\n    elif model==2:\n        zeros_in=np.roots([1])\n        poles_in=np.roots([1,a])\n        zeros_sys=np.roots([1,b])\n        poles_sys=np.roots([1,c,d])\n        W_sys=control.tf(np.array([1,b]),np.array([1,c,d]))\n        tout, yout = control.step_response(W_sys)\n    elif model==3:\n        zeros_in=np.roots([1,c])\n        poles_in=np.roots([1,2*a,a^2+b^2])\n        zeros_sys=np.roots([1])\n        poles_sys=np.roots([1,d])   \n        W_sys=control.tf(np.array([1,c]),np.array([1,d]))\n        tout, yout = control.step_response(W_sys)\n    \n    global f1_line1, f1_line2, f1_line3, f1_line4, f1_line5a, f1_line5b, f1_line5c, f1_line5d, f1_line6a, f1_line6b, f1_line7a, f1_line7b\n    \n    f1_1.lines.remove(f1_line1)\n    f1_2.lines.remove(f1_line2)\n    f1_3.lines.remove(f1_line3)\n    f1_4.lines.remove(f1_line4)\n    f1_5.lines.remove(f1_line5a), f1_5.lines.remove(f1_line5b), f1_5.lines.remove(f1_line5c), f1_5.lines.remove(f1_line5d) \n    f1_6.lines.remove(f1_line6a), f1_6.lines.remove(f1_line6b)\n    f1_7.lines.remove(f1_line7a), f1_7.lines.remove(f1_line7b)    \n    \n    if zeros_in.size&gt;0:\n        f1_line1, = f1_1.plot(np.real(zeros_in),np.imag(zeros_in),'og')\n    else:\n        f1_line1, = f1_1.plot([],[])    \n    f1_line2, = f1_2.plot(np.real(poles_in),np.imag(poles_in),'xr')\n    if zeros_sys.size&gt;0:\n        f1_line3, = f1_3.plot(np.real(zeros_sys),np.imag(zeros_sys),'og')\n    else: \n        f1_line3, = f1_3.plot([],[])\n    f1_line4, = f1_4.plot(np.real(poles_sys),np.imag(poles_sys),'xg')\n    f1_line5a, = f1_5.plot(np.real(poles_sys),np.imag(poles_sys),'xg',label='poles (sys)',markersize=15)\n    f1_line5b, = f1_5.plot(np.real(zeros_sys),np.imag(zeros_sys),'og',label='zeros (sys)',markersize=7)\n    f1_line5c, = f1_5.plot(np.real(poles_in),np.imag(poles_in),'xr',label='poles (in)',markersize=8)\n    f1_line5d, = f1_5.plot(np.real(zeros_in),np.imag(zeros_in),'or',label='zeros (in)',markersize=9)\n    f1_5.legend()\n    f1_line6a, = f1_6.plot(np.real(poles_sys),np.imag(poles_sys),'xg',label='poles')\n    f1_line6b, = f1_6.plot(np.real(zeros_sys),np.imag(zeros_sys),'og',label='zeros')\n    f1_6.legend()\n    tstep=np.linspace(0,tout[-1],1000)\n    u = np.ones_like(tstep)\n    u[0]=0\n    f1_line7b, = f1_7.plot(tstep,u,color='C1',label='input',linewidth=1)\n    f1_line7a, = f1_7.plot(tout,yout,color='C0',label='output',linewidth=2)\n    f1_7.legend()\n       \n    f1_1.relim(), f1_2.relim(), f1_3.relim(), f1_4.relim(), f1_5.relim(), f1_6.relim(), f1_7.relim()\n    f1_1.autoscale_view(), f1_2.autoscale_view(), f1_3.autoscale_view(), f1_4.autoscale_view(), f1_5.autoscale_view(), f1_6.autoscale_view(), f1_7.autoscale_view()\n    \n    f1_1.ticklabel_format(axis='both',useOffset=False)\ndef update_sliders(model):\n    \n    global a_slider, b_slider, c_slider, d_slider\n    \n    aval = [1, 1, 1, 1]\n    bval = [1, 1, 1, 1]\n    cval = [1, 1, 1, 1]\n    dval = [1, 1, 1, 1]\n    \n    a_slider.value = aval[model]\n    b_slider.value = bval[model]\n    c_slider.value = cval[model]\n    d_slider.value = dval[model]    \n    \ndef create_sliders(model):\n    \n    global a_slider, b_slider, c_slider, d_slider\n    \n    a_slider = widgets.IntSlider(value=1,min=-10, max=10,description='a: ',\n                                 continuous_update=False,layout=widgets.Layout(width='auto',flex='5 5 auto'))\n    b_slider = widgets.IntSlider(value=1,min=-10, max=10,description='b: ',\n                                 continuous_update=False,layout=widgets.Layout(width='auto',flex='5 5 auto'))\n    \n    if model==0:\n        c_slider = widgets.IntSlider(value=1,min=-10, max=10,description='c: ',\n                                 disabled=True, continuous_update=False,layout=widgets.Layout(width='auto',flex='5 5 auto'))\n        d_slider = widgets.IntSlider(value=1,min=-10, max=10,description='d: ',\n                                 disabled=True, continuous_update=False,layout=widgets.Layout(width='auto',flex='5 5 auto'))\n    elif model==1:\n        c_slider = widgets.IntSlider(value=1,min=-10, max=10,description='c: ',\n                                 continuous_update=False,layout=widgets.Layout(width='auto',flex='5 5 auto'))\n        d_slider = widgets.IntSlider(value=1,min=-10, max=10,description='d: ',\n                                 disabled=True, continuous_update=False,layout=widgets.Layout(width='auto',flex='5 5 auto'))\n    else:\n        c_slider = widgets.IntSlider(value=1,min=-10, max=10,description='c: ',\n                                 continuous_update=False,layout=widgets.Layout(width='auto',flex='5 5 auto'))\n        d_slider = widgets.IntSlider(value=1,min=-10, max=10,description='d: ',\n                                 continuous_update=False,layout=widgets.Layout(width='auto',flex='5 5 auto'))\n        \n    input_data=widgets.interactive_output(build_model, {'a':a_slider, 'b':b_slider, 'c':c_slider, 'd':d_slider, 'model':modelSelect})\n      \n    input_data2=widgets.interactive_output(update_sliders, {'model':modelSelect})\n    \n    display(modelSelect,input_data2)\n    \n    display(widgets.HBox([widgets.VBox([a_slider, b_slider], layout=widgets.Layout(width='45%')),\n                    widgets.VBox([c_slider, d_slider], layout=widgets.Layout(width='45%'))]), input_data)       \nwidgets.interactive_output(create_sliders, {'model':modelSelect})"
  },
  {
    "objectID": "ICCT_en/examples/02/TD-09-Partial-fraction-decomposition.html",
    "href": "ICCT_en/examples/02/TD-09-Partial-fraction-decomposition.html",
    "title": "Partial fraction decomposition - Input by function",
    "section": "",
    "text": "# Erasmus+ ICCT project (2018-1-SI01-KA203-047081)\n\n# Toggle cell visibility\n\nfrom IPython.display import HTML\ntag = HTML('''&lt;script&gt;\ncode_show=true; \nfunction code_toggle() {\n    if (code_show){\n        $('div.input').hide()\n    } else {\n        $('div.input').show()\n    }\n    code_show = !code_show\n} \n$( document ).ready(code_toggle);\n&lt;/script&gt;\nToggle cell visibility &lt;a href=\"javascript:code_toggle()\"&gt;here&lt;/a&gt;.''')\ndisplay(tag)\n\n# Hide the code completely\n\n# from IPython.display import HTML\n# tag = HTML('''&lt;style&gt;\n# div.input {\n#     display:none;\n# }\n# &lt;/style&gt;''')\n# display(tag)\n\n\nToggle cell visibility here.\n\n\n\n# Examples: \n# Factored form: 1/(x**2*(x**2 + 1))\n# Expanded form: 1/(x**4+x**2)\n\nimport sympy as sym\nfrom IPython.display import Latex, display, Markdown, Javascript, clear_output\nfrom ipywidgets import widgets, Layout # Interactivity module\n\nWhen Laplace transform is used for system analysis, the Laplace transform of the output signal is obtained as a product of the transfer function and the Laplace transform of the input signal. The result of this multiplication can usually be quite difficult to comprehend. In order to execute the inverse Laplace transform we first perform the partial fraction decomposition. This example demonstrates this procedure.\n\n\nHow to use this notebook?\nToggle between the option Input by function or Input by polynomial coefficients.\n\nInput by function:\n\n\nExample: To insert the function \\(\\frac{1}{x^2(x^2 + 1)}\\) (factored form) type 1/(x**2*(x**2 + 1)); to insert the same function in the expanded form (\\(\\frac{1}{x^4+x^2}\\)) type 1/(x**4+x**2).\n\n\nInput by polynomial coefficients:\n\n\nUse the sliders to select the order of the numerator and denominator of a rational function of interest.\nInsert the coefficients for both numerator and denominator in the dedicated textboxes and click Confirm.\n\n\n## System selector buttons\nstyle = {'description_width': 'initial'}\ntypeSelect = widgets.ToggleButtons(\n    options=[('Input by function', 0), ('Input by polynomial coefficients', 1),],\n    description='Select: ',style={'button_width':'230px'})\n\nbtnReset=widgets.Button(description=\"Reset\")\n\n# function\ntextbox=widgets.Text(description=('Insert the function:'),style=style)\nbtnConfirmFunc=widgets.Button(description=\"Confirm\") # ex btnConfirm\n\n# poly\nbtnConfirmPoly=widgets.Button(description=\"Confirm\") # ex btn\n\ndisplay(typeSelect)\n\ndef on_button_clickedReset(ev):\n    display(Javascript(\"Jupyter.notebook.execute_cells_below()\"))\n\ndef on_button_clickedFunc(ev):\n    eq = sym.sympify(textbox.value)\n\n    if eq==sym.factor(eq):\n        display(Markdown('Input function $%s$ is written in a factored form. ' %sym.latex(eq) + 'Its expanded form is $%s$.' %sym.latex(sym.expand(eq))))\n        \n    else:\n        display(Markdown('Input function $%s$ is written in an expanded form. ' %sym.latex(eq) + 'Its factored form is $%s$.' %sym.latex(sym.factor(eq))))\n    \n    display(Markdown('The result of the partial fraction decomposition is: $%s$' %sym.latex(sym.apart(eq)) + '.'))\n    display(btnReset)\n    \ndef transfer_function(num,denom):\n    num = np.array(num, dtype=np.float64)\n    denom = np.array(denom, dtype=np.float64)\n    len_dif = len(denom) - len(num)\n    if len_dif&lt;0:\n        temp = np.zeros(abs(len_dif))\n        denom = np.concatenate((temp, denom))\n        transferf = np.vstack((num, denom))\n    elif len_dif&gt;0:\n        temp = np.zeros(len_dif)\n        num = np.concatenate((temp, num))\n        transferf = np.vstack((num, denom))\n    return transferf\n\ndef f(orderNum, orderDenom):\n    global text1, text2\n    text1=[None]*(int(orderNum)+1)\n    text2=[None]*(int(orderDenom)+1)\n    display(Markdown('2. Insert the coefficients of the numerator.'))\n    for i in range(orderNum+1):\n        text1[i]=widgets.Text(description=(r'a%i'%(orderNum-i)))\n        display(text1[i])\n    display(Markdown('3. Insert the coefficients of the denominator.'))    \n    for j in range(orderDenom+1):\n        text2[j]=widgets.Text(description=(r'b%i'%(orderDenom-j)))\n        display(text2[j])\n    global orderNum1, orderDenom1\n    orderNum1=orderNum\n    orderDenom1=orderDenom\n\ndef on_button_clickedPoly(btn):\n    clear_output()\n    global num,denom\n    enacbaNum=\"\"\n    enacbaDenom=\"\"\n    num=[None]*(int(orderNum1)+1)\n    denom=[None]*(int(orderDenom1)+1)\n    for i in range(int(orderNum1)+1):\n        if text1[i].value=='' or text1[i].value=='Please insert a coefficient':\n            text1[i].value='Please insert a coefficient'\n        else:\n            try:\n                num[i]=int(text1[i].value)\n            except ValueError:\n                if text1[i].value!='' or text1[i].value!='Please insert a coefficient':\n                    num[i]=sym.var(text1[i].value)\n    \n    for i in range (len(num)-1,-1,-1):\n        if i==0:\n            enacbaNum=enacbaNum+str(num[len(num)-i-1])\n        elif i==1:\n            enacbaNum=enacbaNum+\"+\"+str(num[len(num)-i-1])+\"*x+\"\n        elif i==int(len(num)-1):\n            enacbaNum=enacbaNum+str(num[0])+\"*x**\"+str(len(num)-1)\n        else:\n            enacbaNum=enacbaNum+\"+\"+str(num[len(num)-i-1])+\"*x**\"+str(i) \n    \n    for j in range(int(orderDenom1)+1):\n        if text2[j].value=='' or text2[j].value=='Please insert a coefficient':\n            text2[j].value='Please insert a coefficient'\n        else:\n            try:\n                denom[j]=int(text2[j].value)\n            except ValueError:\n                if text2[j].value!='' or text2[j].value!='Please insert a coefficient':\n                    denom[j]=sym.var(text2[j].value)\n                    \n    for i in range (len(denom)-1,-1,-1):\n        if i==0:\n            enacbaDenom=enacbaDenom+\"+\"+str(denom[len(denom)-i-1])\n        elif i==1:\n            enacbaDenom=enacbaDenom+\"+\"+str(denom[len(denom)-i-1])+\"*x\"\n        elif i==int(len(denom)-1):\n            enacbaDenom=enacbaDenom+str(denom[0])+\"*x**\"+str(len(denom)-1)\n        else:\n            enacbaDenom=enacbaDenom+\"+\"+str(denom[len(denom)-i-1])+\"*x**\"+str(i)\n        \n    funcSym=sym.sympify('('+enacbaNum+')/('+enacbaDenom+')')\n\n    DenomSym=sym.sympify(enacbaDenom)\n    NumSym=sym.sympify(enacbaNum)\n    DenomSymFact=sym.factor(DenomSym);\n    funcFactSym=NumSym/DenomSymFact;\n    \n    if DenomSym==sym.expand(enacbaDenom):\n        if DenomSym==DenomSymFact:\n            display(Markdown('The function of interest is: $%s$. The numerator cannot be factored.' %sym.latex(funcSym)))\n        else:\n            display(Markdown('The function of interest is: $%s$. The numerator cannot be factored. The same function with the factored denominator can be written as: $%s$.' %(sym.latex(funcSym), sym.latex(funcFactSym))))\n\n    if sym.apart(funcSym)==funcSym:\n        display(Markdown('Partial fraction decomposition cannot be done.'))\n    else:\n        display(Markdown('The result of the partial fraction decomposition is: $%s$' %sym.latex(sym.apart(funcSym)) + '.'))\n        \n    btnReset.on_click(on_button_clickedReset)\n    display(btnReset)\n    \ndef partial_frac(index):\n\n    if index==0:\n        x = sym.Symbol('x')        \n        display(widgets.HBox((textbox, btnConfirmFunc)))\n        btnConfirmFunc.on_click(on_button_clickedFunc)\n        btnReset.on_click(on_button_clickedReset)\n    \n    elif index==1:\n        display(Markdown('1. Define the order of the numerator (orderNum) and denominator (orderDenom).'))\n        widgets.interact(f, orderNum=widgets.IntSlider(min=0,max=10,step=1,value=0),\n                 orderDenom=widgets.IntSlider(min=0,max=10,step=1,value=0));\n        btnConfirmPoly.on_click(on_button_clickedPoly)\n        display(btnConfirmPoly)      \n\ninput_data=widgets.interactive_output(partial_frac,{'index':typeSelect})\ndisplay(input_data)"
  },
  {
    "objectID": "ICCT_en/examples/02/TD-11-Time-response-First-order-system.html",
    "href": "ICCT_en/examples/02/TD-11-Time-response-First-order-system.html",
    "title": "Time response of the first-order system",
    "section": "",
    "text": "# Erasmus+ ICCT project (2018-1-SI01-KA203-047081)\n\n# Toggle cell visibility\n\nfrom IPython.display import HTML\ntag = HTML('''&lt;script&gt;\ncode_show=true; \nfunction code_toggle() {\n    if (code_show){\n        $('div.input').hide()\n    } else {\n        $('div.input').show()\n    }\n    code_show = !code_show\n} \n$( document ).ready(code_toggle);\n&lt;/script&gt;\nToggle cell visibility &lt;a href=\"javascript:code_toggle()\"&gt;here&lt;/a&gt;.''')\ndisplay(tag)\n\n# Hide the code completely\n\n# from IPython.display import HTML\n# tag = HTML('''&lt;style&gt;\n# div.input {\n#     display:none;\n# }\n# &lt;/style&gt;''')\n# display(tag)\n\n\nToggle cell visibility here.\n\n\n\n%matplotlib notebook\nimport numpy as np\nimport control as control\nimport matplotlib.pyplot as plt\nimport ipywidgets as widgets\nimport scipy.signal as signal\ncontinuous_update=False\n\nThe transfer function of the selected first-order system is defined as\n\\[\\begin{equation}\n    \\frac{K_p}{\\tau_p s+1},\n\\end{equation}\\]\nwhere \\(K_p\\) and \\(\\tau_p\\) are parameters of the system.\nSystem response depends on the input signal. In this example unit step function (with the Laplace transform \\(\\frac{1}{s}\\)), unit impulse function (with the Laplace transform \\(1\\)), unit ramp function (with the Laplace transform \\(\\frac{1}{s^2}\\)) and a sine signal (with the Laplace transform \\(\\frac{1}{s^2+1}\\)) are used as possible input signals.\nThe plot below shows the input signal and the corresponding output signal for the chosen values of parameters \\(K_p\\) and \\(\\tau_p\\).\n\nHow to use this notebook?\nToogle between different input functions (unit step, unit impulse, unit ramp or sine). Move the sliders to change the values of \\(K_p\\) and \\(\\tau_p\\).\n\n# sinus, step, ramp, x^2, sqrt(x)\nfunctionSelect = widgets.ToggleButtons(\n    options=[('unit step function', 0), ('unit impulse function', 1), ('unit ramp function', 2), ('sine function', 3)],\n    description='Select: ')\n\nfig = plt.figure(num='Time response of the first-order system')\nfig.set_size_inches((9.8, 3))\nfig.set_tight_layout(True)\nf1 = fig.add_subplot(1, 1, 1)\n\nf1.grid(which='both', axis='both', color='lightgray')\n\nf1.set_xlabel('$t$ [s]')\nf1.set_ylabel('input, output')\n\nf1.axhline(0,Color='black',linewidth=0.5)\nf1.axvline(0,Color='black',linewidth=0.5)\n\ninputf, = f1.plot([],[])\nresponsef, = f1.plot([],[])\narrowf, = f1.plot([],[])\n\nnum_samples=2041\n\ndef create_draw_functions(Kp,taup,index):\n    t=np.linspace(-0.1,5,num_samples)\n\n    num=[Kp]\n    den=[taup,1]\n    Wsys=control.tf(num,den)\n    \n    global inputf,responsef, arrowf\n       \n    if index==0:\n        yin=np.zeros(2041)\n        yin[40:num_samples]=1\n        tnew=np.linspace(0,5,2001)\n        tout,yout=control.step_response(Wsys, T=tnew)\n    elif index==1:\n        yin=signal.unit_impulse(2001, 0)\n        tnew=np.linspace(0,5,2001)\n        t=tnew\n        tout,yout=control.impulse_response(Wsys,tnew,X0=0)\n    elif index==2:\n        yin=np.zeros(num_samples)\n        yin[40:num_samples]=np.linspace(0,5,2001)\n        tnew=np.linspace(0,5,2001)\n        tout,yout,xx=control.forced_response(Wsys,tnew,yin[40:])\n    elif index==3:        \n        yin=np.sin(np.linspace(0,30,2001))\n        tnew=np.linspace(0,30,2001)\n        t=tnew\n        tout,yout,xx=control.forced_response(Wsys,tnew,yin)\n        \n    f1.lines.remove(inputf)\n    f1.lines.remove(responsef)\n    f1.lines.remove(arrowf)\n    \n    inputf, = f1.plot(t,yin,color='C0',label='input')\n    responsef, = f1.plot(tout,yout,color='C1',label='output')\n\n    if index == 1:\n        arrowf, = f1.plot([-0.1,0,0.1],[0.95,1,0.95],color='C0')\n    else:\n        arrowf, = f1.plot([],[])\n    \n  \n    f1.legend()\n    \n    f1.relim()\n    f1.relim()\n    f1.autoscale_view()\n    f1.autoscale_view()\n    \nKp_slider = widgets.FloatSlider(value=1, min=0, max=2, step=0.1, description='$K_p$',\n                          continuous_update=True, layout=widgets.Layout(width='auto', flex='5 5 auto'),readout_format='.1f')\n\ntaup_slider = widgets.FloatSlider(value=1, min=0, max=2, step=0.1, description='$\\\\tau_p$',\n                          continuous_update=True, layout=widgets.Layout(width='auto', flex='5 5 auto'),readout_format='.1f')\n\n\ninput_data = widgets.interactive_output(create_draw_functions, {'Kp':Kp_slider,\n                                                                'taup':taup_slider,\n                                                                'index':functionSelect})\n\ndef update_sliders(index):\n    global x0_slider\n    \n    Kpval = [1,1,1,1]\n    Kp_slider.value = Kpval[index]\n    taupval = [1,1,1,1]\n    taup_slider.value = taupval[index]    \n    \ninput_data2 = widgets.interactive_output(update_sliders, {'index':functionSelect})\n\ndisplay(functionSelect)\n\ndisplay(Kp_slider,taup_slider,input_data)\n\n# display(Markdown(\"The system can be represented as $f(x)=5$ for small excursions of x about x0.\"))"
  },
  {
    "objectID": "ICCT_en/examples/02/TD-13-Loading-problem.html",
    "href": "ICCT_en/examples/02/TD-13-Loading-problem.html",
    "title": "Loading problem",
    "section": "",
    "text": "# Erasmus+ ICCT project (2018-1-SI01-KA203-047081)\n\n# Toggle cell visibility\n\nfrom IPython.display import HTML\ntag = HTML('''&lt;script&gt;\ncode_show=true; \nfunction code_toggle() {\n    if (code_show){\n        $('div.input').hide()\n    } else {\n        $('div.input').show()\n    }\n    code_show = !code_show\n} \n$( document ).ready(code_toggle);\n&lt;/script&gt;\nToggle cell visibility &lt;a href=\"javascript:code_toggle()\"&gt;here&lt;/a&gt;.''')\ndisplay(tag)\n\n# Hide the code completely\n\n# from IPython.display import HTML\n# tag = HTML('''&lt;style&gt;\n# div.input {\n#     display:none;\n# }\n# &lt;/style&gt;''')\n# display(tag)\n\n\nToggle cell visibility here.\n\n\n\n# Erasmus+ ICCT project (2018-1-SI01-KA203-047081)\n\n%matplotlib notebook\nimport scipy.signal as signal\nimport matplotlib.pyplot as plt\nimport matplotlib.image as mpimg\nimport numpy as np\nfrom ipywidgets import widgets\nfrom ipywidgets import interact\n\nWhen a systems is represented by a block diagram, the main idea is that an input signal influences the output signal. The output of a selected blovk can then be used as an input for a next block. The implicit suppositon is however that when a new block is connected, nothing will change in the previous block. This is however not true. This fact is usually stated as the »Loading problem«. As an example, lets take a look at the two systems shown below.\n\n\n\nSchematic representation of the loading problem\n\n\n\n\n\n\n\n\n\n\nFrom the control theory point of view each of them could be analyzed separately and transfer functions \\(P_1(s)\\) and \\(P_2(s)\\) can be obtained. If the blocks are then connected, we might think that the transfer function of the combined system \\(P(s)\\) is equal to \\(P_1(s) \\cdot P_2(s)\\), because the output of the first system is the input for the second system. The step response for this transfer function is shown in orange in the plot below (“control theory” response).\nIf we however analyze the system from the electrical engineering point of view, we end up with a different transfer function. The associated step response is shown in green in the plot below (“electrical engineering” response). The difference between the two is due to the loading problem. If however the input impedance of the second system is much higher than the output impedance of the first one, the difference is negligible for all practical purposes.\n\n\nHow to use this notebook?\nMove the sliders to change the values of \\(R_1\\), \\(R_2\\), \\(L_1\\) and \\(L_2\\) and observe the “control theory” and “electrical engineering” response together with the corresponding transfer functions.\n\nnum_of_samples = 100\ntotal_time = 25\nt = np.linspace(0, total_time, num_of_samples*10)# time for which response is calculated (start, stop, step)\n\n# making step function (for plotting)\nstep_function = np.ones(len(t))\nstep_function[0]=0\n\n# make figure\nfig = plt.figure(figsize=(9.8, 3),num='Loading problem - Time response')\n\n# add axes\nax = fig.add_subplot(111)\nax.set_xlabel('t [s]')\nax.set_ylabel('input, output')\n\nax.grid(which='both', axis='both', color='lightgray')\n\n\n# plot step function and responses (initalisation)\nax.plot(t, step_function, lw=.5, label='input')\n\nresp1, = ax.plot([], [], lw=1.5, label='\"control theory\" response')\nresp2, = ax.plot([], [], lw=1.5, label='\"electrical engineering\" response')\nax.legend(loc=1, fontsize=8)\n\nR1=1\nL1=1\nR2=1\nL2=1\n\neq = ax.text((-ax.get_xlim()[0]+ax.get_xlim()[1])*.4, (-ax.get_ylim()[0]+ax.get_ylim()[1])*.5, '',fontsize=8)\n# eq.set_bbox(dict(facecolor='b', alpha=0.07, edgecolor='red'))\n\nplt.show()\n\ndef set_input(R1=10, R2=20, L1=20, L2=4):\n    # make transfer functions (with scipy)\n    control_transfer = signal.TransferFunction([R2*L1, 0], [L1*L2, R2*L1+R1*L2, R1*R2])\n    electro_transfer = signal.TransferFunction([R2*L1, 0], [L1*L2, R2*L1+R1*L1+R1*L2, R1*R2])\n    # calculate step response (with scipy)\n    time1, response1 = signal.step(control_transfer, T=t)\n    time2, response2 = signal.step(electro_transfer, T=t)\n\n    # update responses plots\n    resp1.set_data(time1, response1)\n    resp2.set_data(time2, response2)\n    \n    plt.show()\n    \n    #update strings for equations\n    niz_gor_con = str(R2*L1) + 's'\n    niz_dol_con = str(L1*L2) + 's^2 + ' + str(R2*L1+R1*L2) + 's + ' + str(R1*R2)\n    niz_gor_ele = str(R2*L1) + 's'\n    niz_dol_ele = str(L1*L2) + 's^2 + ' + str(R2*L1+R1*L1+R1*L2) + 's + ' + str(R1*R2)\n    #update equations\n    tekst = 'Transfer functions:\\n\\nControl: $\\dfrac{' + niz_gor_con + '}{' + niz_dol_con + '}$\\nElectro: $\\dfrac{' + niz_gor_ele + '}{' + niz_dol_ele + '}$'\n    eq.set_text(tekst)\n\n# make string to show equations\nniz_gor_con = str(R2*L1) + 's'\nniz_dol_con = str(L1*L2) + 's^2 + ' + str(R2*L1+R1*L2) + 's + ' + str(R1*R2)\nniz_gor_ele = str(R2*L1) + 's'\nniz_dol_ele = str(L1*L2) + 's^2 + ' + str(R2*L1+R1*L1+R1*L2) + 's + ' + str(R1*R2)\n\ninteract(set_input, R1=widgets.IntSlider(min=1,max=300,step=1,value=10,description='$R_1$'),\n         R2=widgets.IntSlider(min=1,max=300,step=1,value=10,description='$R_2$'),\n         L1=widgets.IntSlider(min=1,max=300,step=1,value=10,description='$L_1$'),\n         L2=widgets.IntSlider(min=1,max=300,step=1,value=10,description='$L_2$'));"
  },
  {
    "objectID": "ICCT_en/examples/02/TD-15-PID-controller-Time-response.html",
    "href": "ICCT_en/examples/02/TD-15-PID-controller-Time-response.html",
    "title": "PID controller - time response",
    "section": "",
    "text": "# Erasmus+ ICCT project (2018-1-SI01-KA203-047081)\n\n# Toggle cell visibility\n\nfrom IPython.display import HTML\ntag = HTML('''&lt;script&gt;\ncode_show=true; \nfunction code_toggle() {\n    if (code_show){\n        $('div.input').hide()\n    } else {\n        $('div.input').show()\n    }\n    code_show = !code_show\n} \n$( document ).ready(code_toggle);\n&lt;/script&gt;\nToggle cell visibility &lt;a href=\"javascript:code_toggle()\"&gt;here&lt;/a&gt;.''')\ndisplay(tag)\n\n# Hide the code completely\n\n# from IPython.display import HTML\n# tag = HTML('''&lt;style&gt;\n# div.input {\n#     display:none;\n# }\n# &lt;/style&gt;''')\n# display(tag)\n\n\nToggle cell visibility here.\n\n\n\n%matplotlib notebook\nimport scipy.signal as signal\nimport matplotlib.pyplot as plt\nfrom ipywidgets import widgets\nfrom ipywidgets import interact\nimport numpy as np\nimport sympy as sym\n\nA proportional–integral–derivative (PID) control algorithm is by far the most common control algorithm. Its transfer function is\n\\[\\begin{equation}\n    P(s)=K_p \\cdot \\left( 1 + \\frac{1}{T_i s} + T_d s \\right).\n\\end{equation}\\]\nIt is made as a sum of proportional, integral and derivative channels. Not all of them have to be present, so PI or PD control algorithms are also used. In this example the response of a P, PI, PD or PID controller is shown for unit step, unit impulse, unit ramp or sine input.\n\n\nHow to use this notebook?\n\nToggle between unit step function, unit impulse function, unit ramp function and sine function to select the input signal.\nClick on the P, PI, PD or PID button to toogle between proportional, proportional-integral, proportional-derivative or proportional–integral–derivative control algorithm types.\nMove the sliders to change the values of proportional (\\(K_p\\)), integral (\\(T_i\\)) and derivative (\\(T_d\\)) PID tunning coefficients.\nMove the slider \\(t_{max}\\) to change the maximum value of the time on x axis.\n\n\na = 0.1\n\n# make figure\nfig = plt.figure(figsize=(9.8, 5),num='PID controller')\n# add axes\nax = fig.add_subplot(111)\nax.grid(which='both', axis='both', color='lightgray')\nax.set_title('Time response')\n# plot step function and responses (initalisation)\ninput_plot, = ax.plot([],[],'C0', linewidth=1,label='input')\nresponse_plot, = ax.plot([],[], 'C1', linewidth=2,label='output')\nax.axhline(linewidth=.5, color='k')\nax.axvline(linewidth=.5, color='k')\nax.legend()\n\nax.set_xlabel('$t$ [s]')\nax.set_ylabel('input, output')\nplt.show()\n\nP, I, D, s = sym.symbols('P, I, D, s')\n\ninput_type = 'unit step function' #input function\nTime_span = 10 # max time on x-axis plot\n\n#initialize global variables\nKP = 1.\nTI = 1.\nTD = 1.\nnum = []\nden = []\n\ndef update_plot():\n    global num, den, input_type, Time_span\n    num_temp = [float(i.subs(P,KP).subs(I,TI).subs(D,TD)) for i in num]\n    den_temp = [float(i.subs(P,KP).subs(I,TI).subs(D,TD)) for i in den]\n    \n    system = signal.TransferFunction(num_temp, den_temp)\n    \n    #time, response = signal.step(system) #only for setting time borders (for nicer plot. could also calculate dominant frequency)\n    #time = np.linspace(0,time[-1],1000)\n    time = np.linspace(0, Time_span, 600)\n    \n    if input_type == 'unit step function':\n        u = np.ones_like(time)\n        u = np.concatenate((np.array([0]),u))\n        time, response = signal.step(system, T=time)\n        time = np.concatenate((np.array([0]), time))\n        response = np.concatenate((np.array([0]), response))\n    elif input_type == 'unit impulse function':\n        u = np.zeros_like(time)\n        u = np.concatenate((np.array([10]), u))\n        time, response = signal.impulse(system, T=time)\n        time = np.concatenate((np.array([0]), time))\n        response = np.concatenate((np.array([0]), response))\n    elif input_type == 'sine function':\n        u = np.sin(time*2*np.pi)\n        time, response, _ = signal.lsim(system, U=u, T=time)\n    elif input_type == 'unit ramp function':\n        u = time\n        time, response, _ = signal.lsim(system, U=u, T=time)\n    else:\n        raise Exception(\"Error in the program. Please restart simulation.\")\n    \n    response_plot.set_data(time, response)\n    input_plot.set_data(time, u)\n    ax.set_ylim([min([np.min(u), min(response),-.1]),min(100,max([max(response)*1.05, 1, 1.05*np.max(u[1:])]))])\n    ax.set_xlim([-0.1,max(time)])\n    plt.show()\n    \n\ndef transfer_func(controller_type):\n    global num, den\n    proportional = P\n    integral = P/(I*s)\n    differential = P*D*s/(a*D*s+1)\n    if controller_type =='P':\n        controller_func = proportional\n        Kp_widget.disabled=False\n        Ti_widget.disabled=True\n        Td_widget.disabled=True\n    elif controller_type =='PI':\n        controller_func = proportional+integral\n        Kp_widget.disabled=False\n        Ti_widget.disabled=False\n        Td_widget.disabled=True\n    elif controller_type == 'PD':\n        controller_func = proportional+differential\n        Kp_widget.disabled=False\n        Ti_widget.disabled=True\n        Td_widget.disabled=False\n    else:\n        controller_func = proportional+integral+differential\n        Kp_widget.disabled=False\n        Ti_widget.disabled=False\n        Td_widget.disabled=False\n    system_func = controller_func\n    \n    num = [sym.fraction(system_func.factor())[0].expand().coeff(s, i) for i in reversed(range(1+sym.degree(sym.fraction(system_func.factor())[0], gen=s)))]\n    den = [sym.fraction(system_func.factor())[1].expand().coeff(s, i) for i in reversed(range(1+sym.degree(sym.fraction(system_func.factor())[1], gen=s)))]\n    update_plot()\n    \ndef func(Kp, Ti, Td, time_span):\n    global KP, TI, TD, Time_span\n    KP = Kp\n    TI = Ti\n    TD = Td\n    Time_span = time_span\n    update_plot()\n    \nstyle = {'description_width': 'initial'}\n\ndef buttons_controller_clicked(event):\n    controller = buttons_controller.options[buttons_controller.index]\n    transfer_func(controller)\nbuttons_controller = widgets.ToggleButtons(\n    options=['P', 'PI', 'PD', 'PID'],\n    description='Select the control algorithm type:',\n    disabled=False,\n    style=style)\nbuttons_controller.observe(buttons_controller_clicked)\n\ndef buttons_input_clicked(event):\n    global input_type\n    input_type = buttons_input.options[buttons_input.index]\n    update_plot()\nbuttons_input = widgets.ToggleButtons(\n    options=['unit step function','unit impulse function', 'unit ramp function', 'sine function'],\n    description='Select the input signal:',\n    disabled=False,\n    style=style)\nbuttons_input.observe(buttons_input_clicked)\n\n\nKp_widget = widgets.IntSlider(value=20,min=1,max=100,step=1,description=r'\\(K_p \\)',\n    disabled=False,continuous_update=True,orientation='horizontal',readout=True,readout_format='.1d')\nTi_widget = widgets.FloatSlider(value=.1,min=0.001,max=3.,step=0.001,description=r'\\(T_{i} \\)',\n    disabled=False,continuous_update=True,orientation='horizontal',readout=True,readout_format='.3f')\nTd_widget = widgets.FloatSlider(value=.1,min=0.001,max=3.,step=0.001,description=r'\\(T_{d} \\)',\n    disabled=False,continuous_update=True,orientation='horizontal',readout=True,readout_format='.3f')\n\ntime_span_widget = widgets.FloatSlider(value=10.,min=.5,max=50.,step=0.1,description=r'\\(t_{max} \\)',\n    disabled=False,continuous_update=True,orientation='horizontal',readout=True,readout_format='.1f')\n\ntransfer_func('P')\n\ndisplay(buttons_input)\ndisplay(buttons_controller)\n\ninteract(func, Kp=Kp_widget, Ti=Ti_widget, Td=Td_widget, time_span=time_span_widget);"
  },
  {
    "objectID": "ICCT_en/examples/02/TD-17-Steady-state-error.html",
    "href": "ICCT_en/examples/02/TD-17-Steady-state-error.html",
    "title": "Steady state error - Unity feedback sytems",
    "section": "",
    "text": "# Erasmus+ ICCT project (2018-1-SI01-KA203-047081)\n\n# Toggle cell visibility\n\nfrom IPython.display import HTML\ntag = HTML('''&lt;script&gt;\ncode_show=true; \nfunction code_toggle() {\n    if (code_show){\n        $('div.input').hide()\n    } else {\n        $('div.input').show()\n    }\n    code_show = !code_show\n} \n$( document ).ready(code_toggle);\n&lt;/script&gt;\nToggle cell visibility &lt;a href=\"javascript:code_toggle()\"&gt;here&lt;/a&gt;.''')\ndisplay(tag)\n\n# Hide the code completely\n\n# from IPython.display import HTML\n# tag = HTML('''&lt;style&gt;\n# div.input {\n#     display:none;\n# }\n# &lt;/style&gt;''')\n# display(tag)\n\n\nToggle cell visibility here.\n\n\n\n%matplotlib notebook\n\nimport numpy as np\nimport control as control\nimport matplotlib.pyplot as plt\nimport ipywidgets as widgets\nimport sympy as sym\n# from IPython.display import Markdown # For displaying Markdown and LaTeX code\n\nsym.init_printing()\ncontinuous_update=False\n\nGiven the input transfer function \\(I(s)\\) and the open-loop system transfer function \\(G(s)\\), the steady-state error \\(e(\\infty)\\) of the closed-loop system can in the case of a unity feedback be determined by:\n\\[\\begin{equation}\n    e(\\infty)=\\lim_{s\\to0}\\frac{sI(s)}{1+G(s)}.\n\\end{equation}\\]\nIn the case of a unit step input function \\(I(s)=\\frac{1}{s}\\) we get:\n\\[\\begin{equation}\n    e_{step}(\\infty)=\\frac{1}{1+\\lim_{s\\to0}G(s)},\n\\end{equation}\\]\nin the case of a unit ramp input function \\(I(s)=\\frac{1}{s^2}\\):\n\\[\\begin{equation}\n    e_{ramp}(\\infty)=\\frac{1}{\\lim_{s\\to0}sG(s)},\n\\end{equation}\\]\nand in the case of a parabolic input function \\(I(s)=\\frac{1}{s^3}\\):\n\\[\\begin{equation}\n    e_{parabolic}(\\infty)=\\frac{1}{\\lim_{s\\to0}s^2G(s)}.\n\\end{equation}\\]\n\nSystems with no integrations\nAn example of a transfer function \\(G(s)\\) of a system with no integrations can be defined as:\n\\[\\begin{equation}\n    G(s) = \\frac{K}{as^2 + bs + c}\n\\end{equation}\\]\nSteady-state error in the case of systems with no integrations in the forward path is infinite for ramp and parabolic function inputs.\n\n\nSystems with one integration\nAn example of a transfer function \\(G(s)\\) of a system with one integration can be defined as:\n\\[\\begin{equation}\n    G(s) = \\frac{K(as^2 + bs + c)}{s(ds^2 + es + fc)}\n\\end{equation}\\]\nSteady-state error in the case of systems with one integration in the forward path is infinite for parabolic function inputs.\n\n\n\nHow to use this notebook?\n\nToggle between a system with no integrations and a system with one integration.\nMove the sliders to change the values of \\(a\\), \\(b\\), \\(c\\) (coefficients of the transfer function) and \\(K\\) (amplification).\n\n\nstyle = {'description_width': 'initial'}\n\nlayout1 = widgets.Layout(width='auto', height='auto') #set width and height\n\nsystemSelect = widgets.ToggleButtons(\n    options=[('no integrations', 0), ('one integration', 1)],\n    description='Select system: ',style=style)\nfunctionSelect = widgets.ToggleButtons(\n    options=[('unit step function', 0), ('unit ramp function', 1), ('parabolic function', 2)],\n    description='Select input function: ',style=style)\n\nfig=plt.figure(num='Steady-state error')\nfig.set_size_inches((9.8,3))\nfig.set_tight_layout(True)\nf1 = fig.add_subplot(1, 1, 1)\n\nf1.grid(which='both', axis='both', color='lightgray')\n\nf1.set_ylabel('Input, output')\nf1.set_xlabel('$t$ [s]')\n\ninputf, = f1.plot([],[])\nresponsef, = f1.plot([],[])\nerrorf, = f1.plot([],[])\n\nann1=f1.annotate(\"\", xy=([0], [0]), xytext=([0], [0]))\nann2=f1.annotate(\"\", xy=([0], [0]), xytext=([0], [0]))\n\ndisplay(systemSelect)\ndisplay(functionSelect)\n\ndef create_draw_functions(K,a,b,c,index_system,index_input):\n    \n    num_of_samples = 1000\n    total_time = 150\n    t = np.linspace(0, total_time, num_of_samples) # time for which response is calculated (start, stop, step)\n    \n    if index_system == 0:\n        \n        Wsys = control.tf([K], [a, b, c])\n        ess, G_s, s, n  = sym.symbols('e_{step}(\\infty), G(s), s, n')\n        sys1 = control.feedback(Wsys)\n    \n    elif index_system == 1:\n        \n        Wsys = control.tf([K,K,K*a], [1, b, c, 0])\n        ess, G_s, s, n  = sym.symbols('e_{step}(\\infty), G(s), s, n')\n        sys1 = control.feedback(Wsys)    \n            \n    global inputf, responsef, ann1, ann2\n    \n    if index_input==0:\n        infunction = np.ones(len(t))\n        infunction[0]=0\n        tout, yout = control.step_response(sys1,t)\n        s=sym.Symbol('s')\n        if index_system == 0:\n            limit_val = sym.limit((K/(a*s**2+b*s+c)),s,0)\n        elif index_system == 1:\n            limit_val = sym.limit((K*s*s+K*s+K*a)/(s*s*s+b*s*s+c*s),s,0)\n        e_inf=1/(1+limit_val)\n            \n    elif index_input==1:\n        infunction=t;\n        tout, yout, xx = control.forced_response(sys1, t, infunction)\n        if index_system == 0:\n            limit_val = sym.limit(s*(K/(a*s**2+b*s+c)),s,0)            \n        elif index_system == 1:\n            limit_val = sym.limit(s*((K*s*s+K*s+K*a)/(s*s*s+b*s*s+c*s)),s,0)\n        e_inf=1/limit_val\n        \n    elif index_input==2:\n        infunction=t*t\n        tout, yout, xx = control.forced_response(sys1, t, infunction)\n        if index_system == 0:\n            limit_val = sym.limit(s*s*(K/(a*s**2+b*s+c)),s,0)\n        elif index_system == 1:\n            limit_val = sym.limit(s*s*((K*s*s+K*s+K*a)/(s*s*s+b*s*s+c*s)),s,0)\n        e_inf=1/limit_val\n        \n    ann1.remove()\n    ann2.remove() \n    \n    if type(e_inf) == sym.numbers.ComplexInfinity:\n        print('Steady-state error is infinite.')\n    elif e_inf==0:\n        print('Steady-state error is zero.')\n    else:\n        print('Steady-state error is equal to %f.'% (e_inf,)) \n        \n#     if type(e_inf) == sym.numbers.ComplexInfinity:\n#         display(Markdown('Steady-state error is infinite.'))\n#     elif e_inf==0:\n#         display(Markdown('Steady-state error is zero.'))\n#     else:\n#         display(Markdown('Steady-state error is equal to %f.'%(e_inf,)))\n\n    \n    if type(e_inf) != sym.numbers.ComplexInfinity and e_inf&gt;0:  \n        ann1=plt.annotate(\"\", xy=(tout[-60],infunction[-60]), xytext=(tout[-60],yout[-60]), arrowprops=dict(arrowstyle=\"|-|\", connectionstyle=\"arc3\"))\n        ann2=plt.annotate(\"$e(\\infty)$\", xy=(145, 1.), xytext=(145, (yout[-60]+(infunction[-60]-yout[-60])/2)))\n    elif type(e_inf) == sym.numbers.ComplexInfinity:\n        ann1=plt.annotate(\"\", xy=(0,0), xytext=(0,0), arrowprops=dict(arrowstyle=\"|-|\", connectionstyle=\"arc3\"))\n        ann2=plt.annotate(\"\", xy=(134, 1.), xytext=(134, (1 - infunction[-10])/2 + infunction[-10]))\n    elif type(e_inf) != sym.numbers.ComplexInfinity and e_inf==0: \n        ann1=plt.annotate(\"\", xy=(0,0), xytext=(0,0), arrowprops=dict(arrowstyle=\"|-|\", connectionstyle=\"arc3\"))\n        ann2=plt.annotate(\"\", xy=(134, 1.), xytext=(134, (1 - yout[-10])/2 + yout[-10]))\n    \n    f1.lines.remove(inputf)\n    f1.lines.remove(responsef)\n    \n    inputf, = f1.plot(t,infunction,label='input',color='C0')\n    responsef, = f1.plot(tout,yout,label='output',color='C1')\n    \n    f1.relim()\n    f1.autoscale_view()\n    \n    f1.legend()\n\nK_slider=widgets.IntSlider(min=1,max=8,step=1,value=1,description='$K$',continuous_update=False)\na_slider=widgets.IntSlider(min=0,max=8,step=1,value=1,description='$a$',continuous_update=False)\nb_slider=widgets.IntSlider(min=0,max=8,step=1,value=1,description='$b$',continuous_update=False)\nc_slider=widgets.IntSlider(min=1,max=8,step=1,value=1,description='$c$',continuous_update=False)\n\ninput_data=widgets.interactive_output(create_draw_functions,\n                                     {'K':K_slider,'a':a_slider,'b':b_slider,'c':c_slider,\n                                      'index_system':systemSelect,'index_input':functionSelect})\n\ndef update_sliders(index):\n    global K_slider, a_slider, b_slider, c_slider\n    \n    Kval=[1, 1, 1]\n    aval=[1, 1, 1]\n    bval=[2, 2, 2]\n    cval=[6, 6, 6]\n    \n    K_slider.value=Kval[index]\n    a_slider.value=aval[index]\n    b_slider.value=bval[index]\n    c_slider.value=cval[index]\n    \ninput_data2=widgets.interactive_output(update_sliders,\n                                       {'index':functionSelect})\n\n\ndisplay(K_slider,a_slider,b_slider,c_slider,input_data)"
  },
  {
    "objectID": "ICCT_en/examples/03/FD-01_Transfer_Functions.html",
    "href": "ICCT_en/examples/03/FD-01_Transfer_Functions.html",
    "title": "Transfer functions",
    "section": "",
    "text": "%matplotlib notebook\nimport control as c\nimport ipywidgets as w\nimport numpy as np\n\nfrom IPython.display import display, HTML\nimport matplotlib.pyplot as plt\nimport matplotlib.animation as animation\n\ndisplay(HTML('&lt;script&gt; $(document).ready(function() { $(\"div.input\").hide(); }); &lt;/script&gt;'))\n\n\n\n\nIn the following example, we will take a look at the formulation of transfer functions. While used in various fields, in control theory transfer functions describe the frequency transfer characteristics of a Linear Time-invariant (LTI) system.\nGenerally, a transfer function describes the relationship between the Laplace transform of the input \\(u(t)\\) and output \\(y(t)\\) signals:\n\\[U(s)=\\mathcal{L}\\{u(t)\\} \\quad Y(s)=\\mathcal{L}\\{y(t)\\}\\]\n\\[Y(s)=G(s)U(s)\\]\n\nIn the case of LTI systems, the transfer function can be described as a fraction of two polynomials:\n\\[G(s)=\\frac{\\sum\\limits_{j=0}^{m}b_js^j}{\\sum\\limits_{i=0}^{n}a_is^i},\\]\nwhere the denominator \\(a(s)\\) is the characteristic polynomial of the system. Normalizing the components to \\(a^n=1\\), the resulting forms are:\n\\[a(s) = s^n + a_{n-1}s^{n-1} + a_{n-2}s^{n-2} + ... + a_1s^1 + a_0\\] \\[b(s) = b_ms^m + b_{m-1}s^{m-1} + b_{m-2}s^{m-2} + ... + b_1s^1 + b_0\\]\nFor physical systems, the degree of the numerator is less than the degree of the denominator; this type is called a strictly proper transfer function. In this case, the frequency transfer converges to zero at infinity.\nAssemble a transfer function by selecting the polynomial terms!\n\nb = {}\na = {}\n\nb[0] = w.FloatText(value=1.0, description='', disabled=False, step=0.1, layout=w.Layout(width='11%'))\nb[1] = w.FloatText(value=1.0, description='', disabled=False, step=0.1, layout=w.Layout(width='11%'))\nb[2] = w.FloatText(value=0.0, description='', disabled=False, step=0.1, layout=w.Layout(width='11%'))\nb[3] = w.FloatText(value=0.0, description='', disabled=False, step=0.1, layout=w.Layout(width='11%'))\nb[4] = w.FloatText(value=0.0, description='', disabled=False, step=0.1, layout=w.Layout(width='11%'))\n\na[0] = w.FloatText(value=10.0, description='', disabled=False, step=0.1, layout=w.Layout(width='11%'))\na[1] = w.FloatText(value=1.0, description='', disabled=False, step=0.1, layout=w.Layout(width='11%'))\na[2] = w.FloatText(value=0.0, description='', disabled=False, step=0.1, layout=w.Layout(width='11%'))\na[3] = w.FloatText(value=0.0, description='', disabled=False, step=0.1, layout=w.Layout(width='11%'))\na[4] = w.FloatText(value=0.0, description='', disabled=False, step=0.1, layout=w.Layout(width='11%'))\na[5] = w.FloatText(value=0.0, description='', disabled=False, step=0.1, layout=w.Layout(width='11%'))\n\ndef transfer_function(a0, a1, a2, a3, a4, a5, b0, b1, b2, b3, b4):\n\n    b1c = b1\n    b2c = b2\n    b3c = b3\n    b4c = b4\n    \n    global b\n    \n    if a5 == 0:\n        b[4].disabled=True\n        b4c = 0\n    else:\n        b[4].disabled=False\n        \n    if a5 == 0 and a4==0:\n        b[3].disabled=True\n        b3c = 0\n    else:\n        b[3].disabled=False    \n        \n    if a5 == 0 and a4 == 0 and a3 == 0:\n        b[2].disabled=True\n        b2c = 0\n    else:\n        b[2].disabled=False    \n        \n    if a5 == 0 and a4 == 0 and a3 == 0 and a2 == 0:\n        b[1].disabled=True\n        b1c = 0\n    else:\n        b[1].disabled=False   \n    \n    G = c.tf([b4c, b3c, b2c, b1c, b0], [a5, a4, a3, a2, a1, a0]) # Transfer function\n\n    print('The resulting transfer function:')\n    print(G)\n\ninput_data = w.interactive_output(transfer_function, {'a0':a[0], 'a1':a[1], 'a2':a[2], 'a3':a[3], 'a4':a[4], 'a5':a[5],\n                                                      'b0':b[0], 'b1':b[1], 'b2':b[2], 'b3':b[3], 'b4':b[4]})\n\ndisplay(w.HBox([w.VBox([w.Label('$G(s)=$')], layout=w.Layout(justify_content=\"center\", align_items='flex-start')),\n        w.VBox([w.HBox([b[4], w.Label('$s^4+$'), b[3], w.Label('$s^3+$'), b[2], w.Label('$s^2+$'),\n                    b[1], w.Label('$s+$'), b[0]], layout=w.Layout(justify_content='center')),\n                    w.HBox([w.HTML(value='&lt;hr style=\"border-top: 1px solid black\"&gt;', layout=w.Layout(width='100%'))],\n                           layout=w.Layout(justify_content='center')),\n                    w.HBox([a[5], w.Label('$s^5+$'), a[4], w.Label('$s^4+$'), a[3], w.Label('$s^3+$'), a[2], w.Label('$s^2+$'),\n                    a[1], w.Label('$s+$'), a[0]], layout=w.Layout(justify_content='center')) ],\n               layout=w.Layout(width='70%'))], layout=w.Layout(justify_content='center') ), input_data)\n\n\n\n\n\n\n\nThe solutions of the numerator and denominator polynomials are called the system’s zeros and poles, respectively. They can be used to determine system’s stability and evaluate its performance.\nBoth zeros and poles are either real numbers or complex conjugate pairs (if the system’s differential equations are real-valued).\nExperiment with the polynomial terms and observe the changes in the pole-zero map!\n\nfig1, (f1_ax1) = plt.subplots(1, 1)\nfig1.set_size_inches((5, 5))\nfig1.set_tight_layout(True)\n\nf1_line1, = f1_ax1.plot([], [], 'rs')\nf1_line2, = f1_ax1.plot([], [], 'bo') \n\nf1_ax1.axhline(y=0, color='k', lw=0.5)\nf1_ax1.axvline(x=0, color='k', lw=0.5)\n\nf1_ax1.grid(which='both', axis='both', color='lightgray')\nf1_ax1.autoscale(enable=True, axis='both')\n\nf1_ax1.set_title('Pole-Zero Map', fontsize=12)\nf1_ax1.set_xlabel('Re', labelpad=0, fontsize=10)\nf1_ax1.set_ylabel('Im', labelpad=0, fontsize=10)\nf1_ax1.tick_params(axis='both', which='both', pad=0, labelsize=8)\n\nf1_ax1.legend([f1_line1, f1_line2], ['Zeros', 'Poles'])\n\ndef pz_map(a0, a1, a2, a3, a4, a5, b0, b1, b2, b3, b4):\n    \n    b1c = b1\n    b2c = b2\n    b3c = b3\n    b4c = b4\n    \n    if a5 == 0:\n        b4c = 0\n        \n    if a5 == 0 and a4==0:\n        b3c = 0\n    \n    if a5 == 0 and a4 == 0 and a3 == 0:\n        b2c = 0\n   \n    if a5 == 0 and a4 == 0 and a3 == 0 and a2 == 0:\n        b1c = 0\n\n    G = c.tf([b4c, b3c, b2c, b1c, b0], [a5, a4, a3, a2, a1, a0]) # Transfer function\n    \n    p = c.pole(G)  # Poles\n    z = c.zero(G)  # Zeros\n    \n    px = [x.real for x in p] \n    py = [x.imag for x in p]\n    \n    zx = [x.real for x in z]\n    zy = [x.imag for x in z]\n    \n    global f1_line1, f1_line2\n    \n    try:\n        f1_ax1.lines.remove(f1_line1)\n        f1_ax1.lines.remove(f1_line2)\n    except:\n        pass\n    \n    f1_line1, = f1_ax1.plot(zx, zy, 'rs') \n    f1_line2, = f1_ax1.plot(px, py, 'bo')\n    \n    f1_ax1.relim()\n    f1_ax1.autoscale_view()\n    \n    \n    \nw.interactive_output(pz_map, {'a0':a[0], 'a1':a[1], 'a2':a[2], 'a3':a[3], 'a4':a[4], 'a5':a[5],\n                              'b0':b[0], 'b1':b[1], 'b2':b[2], 'b3':b[3], 'b4':b[4]})\n\n\n\n\n\n\n\n\n\n\nThe time-domain counterpart of the transfer function is the impulse response: \\(g(t)\\). As the Laplace transform of the Dirac delta function is the constant 1, the transfer function of an LTI system can be matched with its impulse response.\n\\[\\mathcal{L}\\{\\delta(t)\\} = 1\\]\n\\[1\\cdot G(s) \\; \\xrightarrow{\\mathcal{L}^{-1}} \\; \\delta(t)*g(t)\\]\n\\[Y(s) = G(s)U(s) \\; \\xrightarrow{\\mathcal{L}^{-1}} \\; y(t) = \\int\\limits_{-\\infty}^{\\infty}g(t-\\tau)u(\\tau) d\\tau,\\]\nwhere, according to Laplace transformation rules, multiplication in the frequency domain is matched with convolution in the time domain, and convolving a function with the Dirac delta returns the same function.\nObserve the changes in the impulse response between various configurations!\n\nfig2, (f2_ax1) = plt.subplots(1, 1)\nfig2.set_size_inches((9.8, 5))\nfig2.set_tight_layout(True)\n\nf2_line1, = f2_ax1.plot([], [])\n\nf2_ax1.grid(which='both', axis='both', color='lightgray')\nf2_ax1.autoscale(enable=True, axis='both')\n\nf2_ax1.set_title('Impulse Response', fontsize=12)\nf2_ax1.set_xlabel(r'$t$ [s]', labelpad=0, fontsize=10)\nf2_ax1.set_ylabel(r'$y(t)$ [/]', labelpad=0, fontsize=10)\nf2_ax1.tick_params(axis='both', which='both', pad=0, labelsize=8)\n\ndef inp_resp(a0, a1, a2, a3, a4, a5, b0, b1, b2, b3, b4):\n    \n    b1c = b1\n    b2c = b2\n    b3c = b3\n    b4c = b4\n    \n    if a5 == 0:\n        b4c = 0\n        \n    if a5 == 0 and a4==0:\n        b3c = 0\n    \n    if a5 == 0 and a4 == 0 and a3 == 0:\n        b2c = 0\n   \n    if a5 == 0 and a4 == 0 and a3 == 0 and a2 == 0:\n        b1c = 0\n\n    G = c.tf([b4c, b3c, b2c, b1c, b0], [a5, a4, a3, a2, a1, a0]) # Transfer function\n    \n    tout, yout = c.impulse_response(G)\n    \n    global f2_line1\n    \n    try:\n        f2_ax1.lines.remove(f2_line1)\n    except:\n        pass\n\n    f2_line1, = f2_ax1.plot(np.concatenate(([0], tout)), np.concatenate(([0], yout)), '-b') \n    \n    f2_ax1.relim()\n    f2_ax1.autoscale_view()\n    \n    \nw.interactive_output(inp_resp, {'a0':a[0], 'a1':a[1], 'a2':a[2], 'a3':a[3], 'a4':a[4], 'a5':a[5],\n                              'b0':b[0], 'b1':b[1], 'b2':b[2], 'b3':b[3], 'b4':b[4]})"
  },
  {
    "objectID": "ICCT_en/examples/03/FD-03_Nyquist_Diagram_Formulation.html",
    "href": "ICCT_en/examples/03/FD-03_Nyquist_Diagram_Formulation.html",
    "title": "Nyquist diagram formulation",
    "section": "",
    "text": "%matplotlib notebook\nimport control as c\nimport ipywidgets as w\nimport numpy as np\n\nfrom IPython.display import display, HTML, Math\nimport matplotlib.pyplot as plt\nimport matplotlib.animation as animation\n\ndisplay(HTML('&lt;script&gt; $(document).ready(function() { $(\"div.input\").hide(); }); &lt;/script&gt;'))\n\n\n\n\nThroughout this example, we’ll take a look at the Nyquist diagram, a plot designed to represent the frequency response characteristics of a Linear Time-Invariant (LTI) system. The plot can be constructed in two ways:\n\n\nEither as a parametric curve on the complex plane, where the frequency (\\(j\\omega\\)) is the parameter, along which the complex values of the transfer function is plotted.\n\n\nOr it can be defined in a polar coordinate system, where the gain of the transfer function is the radial value, and the angular coordinate is the phase.\n\n\nSelect a system type!\n\ndef print_model(model):\n    \n    print ('\\nThe selected system model:')\n\n    if model == 0:\n        display(Math(r'$$G(s)=\\frac{s-Z}{s-P}$$'))\n    elif model == 1:\n        display(Math(r'$$G(s)=\\frac{K_i(s-Z)}{s(s-P)}$$'))\n    elif model == 2:\n        display(Math(r'$$G(s)=\\frac{K_d\\cdot s}{(s-P)}$$'))\n    elif model == 3:\n        display(Math(r'$$G(s)=\\frac{s-Z}{(s-P_1)(s-P_2)}$$'))\n    else:\n        display(Math(r'$$G(s)=\\frac{s-Z}{s^2+2\\zeta\\omega_0s+{\\omega_0}^2}$$'))\n            \n\nsystemSelect = w.ToggleButtons(\n    options=[('First-Order', 0), ('First-Order Integrating', 1), ('First-Order Differentiating', 2),\n             ('Second-Order Overdamped', 3), ('Second-Order Underdamped', 4)],\n    description='System: ', layout=w.Layout(width='100%'))\n\nsystemSelect.style.button_width='48%'\n\ninput_data = w.interactive_output(print_model, {'model': systemSelect})\n\ndisplay(systemSelect, input_data)\n\n\n\n\n\n\n\nSelect parameters for the system; observe the changes in the Nyquist plot!\n\ndef calculate_tf(P1, P2, Z, Zb, model, P1s, P2s, Zs):\n    \n    if P1s:\n        p1_sig = -1\n    else:\n        p1_sig = 1\n        \n    if P2s:\n        p2_sig = -1\n    else:\n        p2_sig = 1\n        \n    if Zs:\n        z_sig = -1\n    else:\n        z_sig = 1\n    \n    if model == 0:\n        if Zb:\n            W = c.tf([1, z_sig*Z], [1, p1_sig*P1])\n        else:\n            W = c.tf([1], [1, p1_sig*P1])\n    elif model == 1:\n        if Zb:\n            W = c.tf([p2_sig*P2, z_sig*p2_sig*P2*Z], [1, -p1_sig*P1, 0])\n        else:\n            W = c.tf([p2_sig*P2], [1, p1_sig*P1, 0])\n    elif model == 2:\n         W = c.tf([p2_sig*P2, 0], [1, p1_sig*P1])\n    elif model == 3:\n        if Zb:\n            W = c.tf([1, z_sig*Z], [1, p1_sig*P1+p2_sig*P2, p1_sig*P1*p2_sig*P2])\n        else:\n            W = c.tf([1], [1, p1_sig*P1+p2_sig*P2, p1_sig*P1*p2_sig*P2])\n    else:\n        if Zb:\n            W = c.tf([1, z_sig*Z], [1, 2*p1_sig*P1*p2_sig*P2, p1_sig*p1_sig*P1*P1])\n        else:\n            W = c.tf([1], [1, 2*p1_sig*P1*p2_sig*P2, p1_sig*p1_sig*P1*P1])\n\n    print('\\n The resulting transfer function:')\n    print(W)\n    \n    poles, zeros = c.pzmap(W, Plot=False)\n    \n    print('Zeros of the model:')\n    print(zeros)\n    print('Poles of the model:')\n    print(poles)\n\ndef draw_controllers(model):\n    \n    global P1_slider, P2_slider, Z_slider, Z_button, P1s_button, P2s_button, Zs_button\n\n    if model == 0:\n        \n        P1_slider = w.FloatLogSlider(value=0.5, base=10, min=-3, max=3, description='Pole', continuous_update=False,\n                                 layout=w.Layout(width='auto', flex='5 5 auto'), disabled=False)\n        P2_slider = w.FloatLogSlider(value=1, base=10, min=-3, max=3, description='', continuous_update=False,\n                                 layout=w.Layout(width='auto', flex='5 5 auto'), disabled=True)\n        Z_slider = w.FloatLogSlider(value=1, base=10, min=-3, max=3, description='Zero', continuous_update=False,\n                                 layout=w.Layout(width='auto', flex='5 5 auto'), disabled=False)\n        Z_button = w.ToggleButton(value=True, description='Add/remove zero',\n                               layout=w.Layout(width='auto'), disabled=False)\n        P1s_button = w.ToggleButton(value=False, description='-', layout=w.Layout(width='auto'), disabled=False)\n        P2s_button = w.ToggleButton(value=False, description='-', layout=w.Layout(width='auto'), disabled=True)\n        Zs_button = w.ToggleButton(value=False, description='-', layout=w.Layout(width='auto'), disabled=False)\n\n    elif model == 1:\n        P1_slider = w.FloatLogSlider(value=0.5, base=10, min=-3, max=3, description='Pole', continuous_update=False,\n                                 layout=w.Layout(width='auto', flex='5 5 auto'), disabled=False)\n        P2_slider = w.FloatLogSlider(value=1, base=10, min=-3, max=3, description='Ki', continuous_update=False,\n                                 layout=w.Layout(width='auto', flex='5 5 auto'), disabled=False)\n        Z_slider = w.FloatLogSlider(value=1, base=10, min=-3, max=3, description='Zero', continuous_update=False,\n                                 layout=w.Layout(width='auto', flex='5 5 auto'), disabled=False)\n        Z_button = w.ToggleButton(value=True, description='Add/remove zero',\n                               layout=w.Layout(width='auto'), disabled=False)\n        P1s_button = w.ToggleButton(value=False, description='-', layout=w.Layout(width='auto'), disabled=False)\n        P2s_button = w.ToggleButton(value=False, description='-', layout=w.Layout(width='auto'), disabled=False)\n        Zs_button = w.ToggleButton(value=False, description='-', layout=w.Layout(width='auto'), disabled=False)\n\n        \n    elif model == 2:\n        P1_slider = w.FloatLogSlider(value=0.5, base=10, min=-3, max=3, description='Pole', continuous_update=False,\n                                 layout=w.Layout(width='auto', flex='5 5 auto'), disabled=False)\n        P2_slider = w.FloatLogSlider(value=1, base=10, min=-3, max=3, description='Kd', continuous_update=False,\n                                 layout=w.Layout(width='auto', flex='5 5 auto'), disabled=False)\n        Z_slider = w.FloatLogSlider(value=1, base=10, min=-3, max=3, description='', continuous_update=False,\n                                 layout=w.Layout(width='auto', flex='5 5 auto'), disabled=True)\n        Z_button = w.ToggleButton(value=True, description='Add/remove zero',\n                               layout=w.Layout(width='auto'), disabled=True)\n        P1s_button = w.ToggleButton(value=False, description='-', layout=w.Layout(width='auto'), disabled=False)\n        P2s_button = w.ToggleButton(value=False, description='-', layout=w.Layout(width='auto'), disabled=False)\n        Zs_button = w.ToggleButton(value=False, description='-', layout=w.Layout(width='auto'), disabled=True)\n        \n    elif model == 3:\n        P1_slider = w.FloatLogSlider(value=0.5, base=10, min=-3, max=3, description='Pole 1', continuous_update=False,\n                                 layout=w.Layout(width='auto', flex='5 5 auto'), disabled=False)\n        P2_slider = w.FloatLogSlider(value=1, base=10, min=-3, max=3, description='Pole 2', continuous_update=False,\n                                 layout=w.Layout(width='auto', flex='5 5 auto'), disabled=False)\n        Z_slider = w.FloatLogSlider(value=1, base=10, min=-3, max=3, description='Zero', continuous_update=False,\n                                 layout=w.Layout(width='auto', flex='5 5 auto'), disabled=False)\n        Z_button = w.ToggleButton(value=True, description='Add/remove zero',\n                               layout=w.Layout(width='auto'), disabled=False)\n        P1s_button = w.ToggleButton(value=False, description='-', layout=w.Layout(width='auto'), disabled=False)\n        P2s_button = w.ToggleButton(value=False, description='-', layout=w.Layout(width='auto'), disabled=False)\n        Zs_button = w.ToggleButton(value=False, description='-', layout=w.Layout(width='auto'), disabled=False)\n        \n    else:\n        P1_slider = w.FloatLogSlider(value=0.5, base=10, min=-3, max=3, description=r'$\\omega_0$', continuous_update=False,\n                                 layout=w.Layout(width='auto', flex='5 5 auto'), disabled=False)\n        P2_slider = w.FloatLogSlider(value=1, base=10, min=-4, max=1, description=r'$\\zeta$', continuous_update=False,\n                                 layout=w.Layout(width='auto', flex='5 5 auto'), disabled=False)\n        Z_slider = w.FloatLogSlider(value=1, base=10, min=-3, max=3, description='Zero', continuous_update=False,\n                                 layout=w.Layout(width='auto', flex='5 5 auto'), disabled=False)\n        Z_button = w.ToggleButton(value=True, description='Add/remove zero',\n                               layout=w.Layout(width='auto'), disabled=False)\n        P1s_button = w.ToggleButton(value=False, description='-', layout=w.Layout(width='auto'), disabled=True)\n        P2s_button = w.ToggleButton(value=False, description='-', layout=w.Layout(width='auto'), disabled=False)\n        Zs_button = w.ToggleButton(value=False, description='-', layout=w.Layout(width='auto'), disabled=False)\n        \n    \n    input_data2 = w.interactive_output(calculate_tf, {'P1': P1_slider, 'P2': P2_slider, 'Z': Z_slider,\n                                                      'Zb': Z_button, 'model': systemSelect,\n                                                      'P1s': P1s_button, 'P2s': P2s_button, 'Zs': Zs_button})\n    \n    display(w.HBox([P1s_button, P1_slider, P2s_button, P2_slider, Z_button, Zs_button, Z_slider]), input_data2)\n    \n    \nw.interactive_output(draw_controllers, {'model': systemSelect})\n\n\n\n\nThe Nyquist diagram around the \\(j\\omega\\rightarrow\\infty\\) region is representative of the shape of the transfer function; based on its slope, it’s possible to determine whether the function is proper or strictly proper. \\[ \\lim_{s\\to\\infty}G(s) = \\lim_{s\\to\\infty}\\frac{b_ms^m + b_{m-1}s^{m-1}+ ... + b_0}{s^n + a_{n-1}s^{n-1}+ ... + a_0} \\approx \\frac{b_ms^m}{s^n}\\]\n\n\nFor non-proper transfer functions, the endpoint cannot be plotted (\\(\\pm\\infty\\)).\n\n\nFor proper transfer functions, where the degree of the numerator and denominator polynomials are equal (\\(m=n\\)), the endpoint is a non-zero real number.\n\n\nFor strictly proper transfer functions, the endpoint is at the origin.\n\n\nThe starting point of the plot can be similarly calculated:\n\n\nFor integrating systems, the starting point can not be plotted.\n\n\nFor differentiating systems, the starting point is at the origin.\n\n\nOtherwise, the starting point is a non-zero real number.\n\n\nExperiment with these properties of the Nyquist diagram!\n\n# Figure definition\n\nfig1, ((f1_ax1, f1_ax2), (f1_ax3, f1_ax4)) = plt.subplots(2, 2)\nfig1.set_size_inches((9.8, 9.8))\nfig1.set_tight_layout(True)\n\nf1_line1, = f1_ax1.plot([], [], lw=1)\nf1_line2, = f1_ax2.plot([], [], lw=1)\nf1_line3, = f1_ax3.plot([], [], 'rs')\nf1_line4, = f1_ax3.plot([], [], 'bo')\nf1_line5, = f1_ax4.plot([], [], lw=1)\n\nf1_ax2.axhline(y=0, color='k', lw=0.5)\nf1_ax2.axvline(x=0, color='k', lw=0.5)\nf1_ax3.axhline(y=0, color='k', lw=0.5)\nf1_ax3.axvline(x=0, color='k', lw=0.5)\n\nf1_ax1.grid(which='both', axis='both', color='lightgray')\nf1_ax2.grid(which='both', axis='both', color='lightgray')\nf1_ax3.grid(which='both', axis='both', color='lightgray')\nf1_ax4.grid(which='both', axis='both', color='lightgray')\n\nf1_ax1.autoscale(enable=True, axis='both')\nf1_ax2.autoscale(enable=True, axis='both')\nf1_ax3.autoscale(enable=True, axis='both')\nf1_ax4.autoscale(enable=True, axis='both')\n\nf1_ax1.set_title('Imaginary Part', fontsize=12)\nf1_ax1.set_xscale('log')\nf1_ax1.set_xlabel(r'$\\omega\\/[\\frac{rad}{s}]$', labelpad=0, fontsize=10)\nf1_ax1.set_ylabel(r'Im', labelpad=0, fontsize=10)\nf1_ax1.tick_params(axis='both', which='both', pad=0, labelsize=8)\n\nf1_ax2.set_title('Nyquist Plot', fontsize=12)\nf1_ax2.set_xlabel(r'Re', labelpad=0, fontsize=10)\nf1_ax2.set_ylabel(r'Im', labelpad=0, fontsize=10)\nf1_ax2.tick_params(axis='both', which='both', pad=0, labelsize=8)\n\nf1_ax3.set_title('Pole-Zero Map', fontsize=12)\nf1_ax3.set_xlabel(r'Re', labelpad=0, fontsize=10)\nf1_ax3.set_ylabel(r'Im', labelpad=0, fontsize=10)\nf1_ax3.tick_params(axis='both', which='both', pad=0, labelsize=8)\n\nf1_ax4.set_title('Real Part', fontsize=12)\nf1_ax4.set_yscale('log')\nf1_ax4.set_xlabel(r'Re', labelpad=0, fontsize=10)\nf1_ax4.set_ylabel(r'$\\omega\\/[\\frac{rad}{s}]$', labelpad=0, fontsize=10)\nf1_ax4.tick_params(axis='both', which='both', pad=0, labelsize=8)\n\nf1_ax3.legend([f1_line3, f1_line4], ['Zeros', 'Poles'])\n\n\n# System model\n\ndef draw_nyquist(P1, P2, Z, Zb, model, P1s, P2s, Zs):\n    \n    if P1s:\n        p1_sig = -1\n    else:\n        p1_sig = 1\n        \n    if P2s:\n        p2_sig = -1\n    else:\n        p2_sig = 1\n        \n    if Zs:\n        z_sig = -1\n    else:\n        z_sig = 1\n    \n    if model == 0:\n        if Zb:\n            W = c.tf([1, z_sig*Z], [1, p1_sig*P1])\n        else:\n            W = c.tf([1], [1, p1_sig*P1])\n    elif model == 1:\n        if Zb:\n            W = c.tf([p2_sig*P2, z_sig*p2_sig*P2*Z], [1, -p1_sig*P1, 0])\n        else:\n            W = c.tf([p2_sig*P2], [1, p1_sig*P1, 0])\n    elif model == 2:\n         W = c.tf([p2_sig*P2, 0], [1, p1_sig*P1])\n    elif model == 3:\n        if Zb:\n            W = c.tf([1, z_sig*Z], [1, p1_sig*P1+p2_sig*P2, p1_sig*P1*p2_sig*P2])\n        else:\n            W = c.tf([1], [1, p1_sig*P1+p2_sig*P2, p1_sig*P1*p2_sig*P2])\n    else:\n        if Zb:\n            W = c.tf([1, z_sig*Z], [1, 2*p1_sig*P1*p2_sig*P2, p1_sig*p1_sig*P1*P1])\n        else:\n            W = c.tf([1], [1, 2*p1_sig*P1*p2_sig*P2, p1_sig*p1_sig*P1*P1])  \n            \n            \n    _, _, ob = c.nyquist_plot(W, Plot=False)   # Small resolution plot to determine bounds        \n    \n    real, imag, omega = c.nyquist_plot(W, omega=np.logspace(np.log10(ob[0]), np.log10(ob[-1]), 1000), Plot=False) # Nyquist-plot      \n    poles, zeros = c.pzmap(W, Plot=False) # Poles and zeros   \n    \n    px = [x.real for x in poles] \n    py = [x.imag for x in poles]\n    \n    zx = [x.real for x in zeros]\n    zy = [x.imag for x in zeros]\n            \n    global f1_line1, f1_line2, f1_line3, f1_line4, f1_line5\n    \n    f1_ax1.lines.remove(f1_line1)\n    f1_ax2.lines.remove(f1_line2)\n    try:\n        f1_ax3.lines.remove(f1_line3)\n        f1_ax3.lines.remove(f1_line4)\n    except:\n        pass\n    f1_ax4.lines.remove(f1_line5)\n\n    f1_line1, = f1_ax1.plot(omega, imag, lw=1, color='red')    \n    f1_line2, = f1_ax2.plot(real, imag, lw=2, color='limegreen')\n    f1_line3, = f1_ax3.plot(zx, zy, 'rs') \n    f1_line4, = f1_ax3.plot(px, py, 'bo')\n    f1_line5, = f1_ax4.plot(real, omega, lw=1, color='blue')    \n    \n    f1_ax1.relim()\n    f1_ax2.relim()\n    f1_ax3.relim()\n    f1_ax4.relim()\n    f1_ax1.autoscale_view()\n    f1_ax2.autoscale_view()\n    f1_ax3.autoscale_view()\n    f1_ax4.autoscale_view()\n    \n\ndef link_controls(model):\n    w.interactive_output(draw_nyquist, {'P1': P1_slider, 'P2': P2_slider, 'Z': Z_slider,\n                                     'Zb': Z_button, 'model': systemSelect,\n                                     'P1s': P1s_button, 'P2s': P2s_button, 'Zs': Zs_button})\n    \nw.interactive_output(link_controls, {'model': systemSelect})"
  },
  {
    "objectID": "ICCT_en/examples/03/FD-05_Gain_and_Phase_Margin.html",
    "href": "ICCT_en/examples/03/FD-05_Gain_and_Phase_Margin.html",
    "title": "Gain- and phase margin",
    "section": "",
    "text": "%matplotlib notebook\nimport control as c\nimport ipywidgets as w\nimport numpy as np\n\nfrom IPython.display import display, HTML\nimport matplotlib.pyplot as plt\nimport matplotlib.animation as animation\nimport matplotlib.gridspec as gridspec\n\ndisplay(HTML('&lt;script&gt; $(document).ready(function() { $(\"div.input\").hide(); }); &lt;/script&gt;'))\n\n\n\n\nIn the following example, we will examine the definition and calculation of gain- and phase margins and their relation to the Bode stability criterion. We define the first occurrence of the phase curve passing \\(\\pm180°\\) as the phase crossover point, and the magnitude curve passing \\(0\\) dB as the gain crossover point. The gain margin is the magnitude value at the phase crossover (pc) point with a negative sign, and the phase margin is the difference from \\(\\pm180°\\) at the gain crossover (gc). If calculated on an open-loop system, these values express the closeness of the negative feedback closed-loop system to instability.\n\\[\\Phi_m=\\angle G(j\\omega_{gc})-(-180°)\\qquad A_m = -|G(j\\omega_{pc})|\\]\nBased on these values, the stability of a negative-feedback system can be determined: if the gain margin of the open-loop system is greater than \\(0\\) dB, the system is stable (Bode stability criterion).\nSelect a system type!\n\n# System type selector\ntypeSelect = w.ToggleButtons(\n    options=[('Second-order', 0), ('Third-order', 1), ('Fourth-order', 2)],\n    description='System type: ', layout=w.Layout(width='100%'))\n\ndisplay(typeSelect)\n\n\n\n\nChose polynomial coefficients for the open-loop transfer function!\n\ndef calculate_tf(b0, b1, a0, a1, a2, b2=0, b3=0, a3=0, a4=0):\n    \n    W = c.tf([b3, b2, b1, b0], [a4, a3, a2, a1, a0]) # Transfer function\n    \n    print('The open loop transfer function:')\n    print(W)\n\ndef draw_controllers(model):\n    \n    global b0i, b1i, b2i, b3i, a0i, a1i, a2i, a3i, a4i\n    \n    if model == 0: # 2nd order\n        \n        b0i = w.FloatText(value=1.0, description='', disabled=False, step=0.1, layout=w.Layout(width='19%'))\n        b1i = w.FloatText(value=0.0, description='', disabled=False, step=0.1, layout=w.Layout(width='19%'))\n\n        a0i = w.FloatText(value=10.0, description='', disabled=False, step=0.1, layout=w.Layout(width='19%'))\n        a1i = w.FloatText(value=1.0, description='', disabled=False, step=0.1, layout=w.Layout(width='19%'))\n        a2i = w.BoundedFloatText(value=1.0, min=0.01, description='', disabled=False, step=0.1, layout=w.Layout(width='19%'))\n        \n        input_data = w.interactive_output(calculate_tf, {'b0': b0i, 'b1': b1i,\n                                                         'a0': a0i, 'a1': a1i, 'a2': a2i})\n        display(w.HBox([w.VBox([w.Label('$G_{ol}(s)=$')], layout=w.Layout(justify_content=\"center\", align_items='flex-start')),\n                w.VBox([w.HBox([b1i, w.Label('$s+$'), b0i],\n                               layout=w.Layout(justify_content='center')),\n                        w.HBox([w.HTML(value='&lt;hr style=\"border-top: 1px solid black\"&gt;', layout=w.Layout(width='100%'))],\n                               layout=w.Layout(justify_content='center')),\n                        w.HBox([a2i, w.Label('$s^2+$'), a1i, w.Label('$s+$'), a0i],\n                               layout=w.Layout(justify_content='center')) ],\n                        layout=w.Layout(width='40%'))], layout=w.Layout(justify_content='center') ), input_data)\n        \n    elif model == 1: # 3rd order\n        \n        b0i = w.FloatText(value=1.0, description='', disabled=False, step=0.1, layout=w.Layout(width='15%'))\n        b1i = w.FloatText(value=0.0, description='', disabled=False, step=0.1, layout=w.Layout(width='15%'))\n        b2i = w.FloatText(value=0.0, description='', disabled=False, step=0.1, layout=w.Layout(width='15%'))\n\n        a0i = w.FloatText(value=10.0, description='', disabled=False, step=0.1, layout=w.Layout(width='15%'))\n        a1i = w.FloatText(value=1.0, description='', disabled=False, step=0.1, layout=w.Layout(width='15%'))\n        a2i = w.FloatText(value=0.0, description='', disabled=False, step=0.1, layout=w.Layout(width='15%'))\n        a3i = w.BoundedFloatText(value=1.0, min=0.01, description='', disabled=False, step=0.1, layout=w.Layout(width='15%'))\n        \n        input_data = w.interactive_output(calculate_tf, {'b0': b0i, 'b1': b1i, 'b2': b2i,\n                                                         'a0': a0i, 'a1': a1i, 'a2': a2i, 'a3': a3i})\n        display(w.HBox([w.VBox([w.Label('$G_{ol}(s)=$')], layout=w.Layout(justify_content=\"center\", align_items='flex-start')),\n                w.VBox([w.HBox([b2i, w.Label('$s^2+$'), b1i, w.Label('$s+$'), b0i],\n                               layout=w.Layout(justify_content='center')),\n                        w.HBox([w.HTML(value='&lt;hr style=\"border-top: 1px solid black\"&gt;', layout=w.Layout(width='100%'))],\n                               layout=w.Layout(justify_content='center')),\n                        w.HBox([a3i, w.Label('$s^3+$'), a2i, w.Label('$s^2+$'), a1i, w.Label('$s+$'), a0i],\n                               layout=w.Layout(justify_content='center')) ],\n                        layout=w.Layout(width='50%'))], layout=w.Layout(justify_content='center') ), input_data)\n        \n    else : # 4th order\n    \n        b0i = w.FloatText(value=1.0, description='', disabled=False, step=0.1, layout=w.Layout(width='12%'))\n        b1i = w.FloatText(value=0.0, description='', disabled=False, step=0.1, layout=w.Layout(width='12%'))\n        b2i = w.FloatText(value=0.0, description='', disabled=False, step=0.1, layout=w.Layout(width='12%'))\n        b3i = w.FloatText(value=0.0, description='', disabled=False, step=0.1, layout=w.Layout(width='12%'))\n\n        a0i = w.FloatText(value=10.0, description='', disabled=False, step=0.1, layout=w.Layout(width='12%'))\n        a1i = w.FloatText(value=1.0, description='', disabled=False, step=0.1, layout=w.Layout(width='12%'))\n        a2i = w.FloatText(value=0.0, description='', disabled=False, step=0.1, layout=w.Layout(width='12%'))\n        a3i = w.FloatText(value=0.0, description='', disabled=False, step=0.1, layout=w.Layout(width='12%'))\n        a4i = w.BoundedFloatText(value=1, min=0.01, description='', disabled=False, step=0.1, layout=w.Layout(width='12%'))\n        \n        input_data = w.interactive_output(calculate_tf, {'b0': b0i, 'b1': b1i, 'b2': b2i, 'b3': b3i,\n                                                         'a0': a0i, 'a1': a1i, 'a2': a2i, 'a3': a3i, 'a4': a4i})\n        display(w.HBox([w.VBox([w.Label('$G_{ol}(s)=$')], layout=w.Layout(justify_content=\"center\", align_items='flex-start')),\n                w.VBox([w.HBox([b3i, w.Label('$s^3+$'), b2i, w.Label('$s^2+$'), b1i, w.Label('$s+$'), b0i],\n                               layout=w.Layout(justify_content='center')),\n                        w.HBox([w.HTML(value='&lt;hr style=\"border-top: 1px solid black\"&gt;', layout=w.Layout(width='100%'))],\n                               layout=w.Layout(justify_content='center')),\n                        w.HBox([a4i, w.Label('$s^4+$'), a3i, w.Label('$s^3+$'), a2i, w.Label('$s^2+$'),\n                                a1i, w.Label('$s+$'), a0i],\n                               layout=w.Layout(justify_content='center')) ],\n                        layout=w.Layout(width='60%'))], layout=w.Layout(justify_content='center') ), input_data)\n    \n    \nw.interactive_output(draw_controllers, {'model': typeSelect})\n\n\n\n\nRead the gain and phase margin values from the Bode plot!\n\nfig1, ((f1_ax1), (f1_ax2)) = plt.subplots(2, 1)\nfig1.set_size_inches((9.8, 5))\nfig1.set_tight_layout(True)\n\nf1_line1, = f1_ax1.plot([], [], lw=1, color='blue')\nf1_line2, = f1_ax2.plot([], [], lw=1, color='blue')\nf1_line3, = f1_ax1.plot([], [], lw=1, color='red')\nf1_line4, = f1_ax1.plot([], [], lw=1, color='magenta')\nf1_line5, = f1_ax2.plot([], [], lw=1, color='red')\nf1_line6, = f1_ax2.plot([], [], lw=1, color='magenta')\n\nf1_ax1.grid(which='both', axis='both', color='lightgray')\nf1_ax2.grid(which='both', axis='both', color='lightgray')\n\nf1_ax1.autoscale(enable=True, axis='x', tight=True)\nf1_ax2.autoscale(enable=True, axis='x', tight=True)\nf1_ax1.autoscale(enable=True, axis='y', tight=False)\nf1_ax2.autoscale(enable=True, axis='y', tight=False)\n\nf1_ax1.set_title('Bode magnitude plot', fontsize=11)\nf1_ax1.set_xscale('log')\nf1_ax1.set_xlabel(r'$\\omega\\/[\\frac{rad}{s}]$', labelpad=0, fontsize=10)\nf1_ax1.set_ylabel(r'$A\\/$[dB]', labelpad=0, fontsize=10)\nf1_ax1.tick_params(axis='both', which='both', pad=0, labelsize=8)\n\nf1_ax2.set_title('Bode phase plot', fontsize=11)\nf1_ax2.set_xscale('log')\nf1_ax2.set_xlabel(r'$\\omega\\/[\\frac{rad}{s}]$', labelpad=0, fontsize=10)\nf1_ax2.set_ylabel(r'$\\phi\\/$[°]', labelpad=0, fontsize=10)\nf1_ax2.tick_params(axis='both', which='both', pad=0, labelsize=8)\n\nf1_ax1.axhline(0, color='limegreen', ls='--')\nf1_ax2.axhline(-180, color='limegreen', ls='--')\nf1_ax2.axhline(180, color='limegreen', ls='--')\n\nf1_ax1.legend([f1_line3, f1_line4], ['Gain Margin', 'Phase Margin'], loc='upper right')\nf1_ax2.legend([f1_line5, f1_line6], ['Gain Margin', 'Phase Margin'], loc='upper right')\n\ndef calculate_margin(b0, b1, a0, a1, a2, b2=0, b3=0, a3=0, a4=0):\n    \n    W = c.tf([b3, b2, b1, b0], [a4, a3, a2, a1, a0]) # Transfer function\n    \n    _, _, ob = c.bode_plot(W, Plot=False)   # Small resolution plot to determine bounds   \n    mag, phase, omega = c.bode_plot(W, omega=np.logspace(np.log10(ob[0]), np.log10(ob[-1]), 100), Plot=False)   # Bode-plot \n    gm, pm, wg, wp = c.margin(W)    # Gain and phase margin\n    \n    global f1_line1, f1_line2, f1_line3, f1_line4, f1_line5, f1_line6\n    \n    f1_ax1.lines.remove(f1_line1)\n    f1_ax2.lines.remove(f1_line2)\n    \n    try:\n        f1_ax1.lines.remove(f1_line3)\n        f1_ax1.lines.remove(f1_line4)\n        f1_ax2.lines.remove(f1_line5)\n        f1_ax2.lines.remove(f1_line6)\n    except:\n        pass\n    \n    f1_line1, = f1_ax1.plot(omega, 20*np.log10(mag), lw=1, color='blue')\n    f1_line2, = f1_ax2.plot(omega, phase*180/np.pi, lw=1, color='blue') \n    \n    if wg &gt; 0:\n        f1_line3 = f1_ax1.axvline(wg, lw=1, color='red')\n        f1_line5 = f1_ax2.axvline(wg, lw=1, color='red')\n    else:\n        f1_line3, = f1_ax1.plot([], [], lw=1, color='red')\n        f1_line5, = f1_ax2.plot([], [], lw=1, color='red')\n        \n    if wp &gt; 0:\n        f1_line4 = f1_ax1.axvline(wp, lw=1, color='magenta')\n        f1_line6 = f1_ax2.axvline(wp, lw=1, color='magenta')\n    else:\n        f1_line4, = f1_ax1.plot([], [], lw=1, color='magenta')\n        f1_line6, = f1_ax2.plot([], [], lw=1, color='magenta') \n    \n    f1_ax1.relim()\n    f1_ax2.relim()\n    f1_ax1.autoscale_view()\n    f1_ax2.autoscale_view()\n\ndef link_controllers(model):\n    global b0i, b1i, b2i, b3i, a0i, a1i, a2i, a3i, a4i\n    \n    if model == 0: # 2nd order\n        w.interactive_output(calculate_margin, {'b0': b0i, 'b1': b1i,\n                                                'a0': a0i, 'a1': a1i, 'a2': a2i})        \n    elif model == 1: # 3rd order\n        w.interactive_output(calculate_margin, {'b0': b0i, 'b1': b1i, 'b2': b2i,\n                                                'a0': a0i, 'a1': a1i, 'a2': a2i, 'a3': a3i})\n    else : # 4th order\n        w.interactive_output(calculate_margin, {'b0': b0i, 'b1': b1i, 'b2': b2i, 'b3': b3i,\n                                                'a0': a0i, 'a1': a1i, 'a2': a2i, 'a3': a3i, 'a4': a4i})\n        \nw.interactive_output(link_controllers, {'model': typeSelect})    \n\n\n\n\n\n\n\n\n\n\nIs the closed-loop stable or unstable?\n\nout = w.Output()\n\ndef print_margin(b0, b1, a0, a1, a2, b2=0, b3=0, a3=0, a4=0):\n    \n    global out\n    \n    W = c.tf([b3, b2, b1, b0], [a4, a3, a2, a1, a0]) # Transfer function\n    gm, pm, wg, wp = c.margin(W)    # Gain and phase margin\n    \n    out.clear_output()\n    with out:\n        print('Gain margin: {:.2f} dB'.format(20*np.log10(gm)))\n        print('Phase margin: {:.2f}°'.format(pm))\n        if (20*np.log10(gm) &gt; 0):\n            print('\\n(stable)')\n        else:\n            print('\\n(unstable)')\n\ndef link_controllers2(model):\n    global b0i, b1i, b2i, b3i, a0i, a1i, a2i, a3i, a4i\n    \n    if model == 0: # 2nd order\n        w.interactive_output(print_margin, {'b0': b0i, 'b1': b1i,\n                                            'a0': a0i, 'a1': a1i, 'a2': a2i})        \n    elif model == 1: # 3rd order\n        w.interactive_output(print_margin, {'b0': b0i, 'b1': b1i, 'b2': b2i,\n                                            'a0': a0i, 'a1': a1i, 'a2': a2i, 'a3': a3i})\n    else : # 4th order\n        w.interactive_output(print_margin, {'b0': b0i, 'b1': b1i, 'b2': b2i, 'b3': b3i,\n                                            'a0': a0i, 'a1': a1i, 'a2': a2i, 'a3': a3i, 'a4': a4i})\n        \nw.interactive_output(link_controllers2, {'model': typeSelect})\n\ndisplay(out)"
  },
  {
    "objectID": "ICCT_en/examples/03/FD-07_PID_Control_of_First-Order_Systems.html",
    "href": "ICCT_en/examples/03/FD-07_PID_Control_of_First-Order_Systems.html",
    "title": "PID control of a First-Order system",
    "section": "",
    "text": "%matplotlib notebook\nimport control as c\nimport ipywidgets as w\nimport numpy as np\n\nfrom IPython.display import display, HTML\nimport matplotlib.pyplot as plt\nimport matplotlib.animation as animation\n\ndisplay(HTML('&lt;script&gt; $(document).ready(function() { $(\"div.input\").hide(); }); &lt;/script&gt;'))\n\nTraceback (most recent call last):\n  File \"C:\\Users\\Uporabnik\\Anaconda3\\envs\\icct2\\lib\\site-packages\\matplotlib\\cbook\\__init__.py\", line 216, in process\n    func(*args, **kwargs)\n  File \"C:\\Users\\Uporabnik\\Anaconda3\\envs\\icct2\\lib\\site-packages\\matplotlib\\animation.py\", line 1465, in _stop\n    self.event_source.remove_callback(self._loop_delay)\nAttributeError: 'NoneType' object has no attribute 'remove_callback'\n\n\n\n\n\nIn the following example, we will be using a PID controller (or one of its subtypes) to control a first-order LTI (linear time-invariant system).\nA first-order system is the simplest model that has non-linear frequency characteristics. It consists of a single-pole that can be expressed using the system’s time constant.  \\[G(s)=\\frac{1}{\\tau s + 1}\\]  A typical example of a first-order system is a serial RC circuit:    Where the transfer function can be expressed as:  \\[G(s) = \\frac{V_{out}(s)}{V_{in}(s)} = \\frac{1}{RCs+1} \\qquad \\tau=RC\\]  Choose a time constant for the system!\n\n# Figure definition\n\nfig1, ((f1_ax1), (f1_ax2)) = plt.subplots(2, 1)\nfig1.set_size_inches((9.8, 5))\nfig1.set_tight_layout(True)\n\nf1_line1, = f1_ax1.plot([], [])\nf1_line2, = f1_ax2.plot([], [])  \n\nf1_ax1.grid(which='both', axis='both', color='lightgray')\nf1_ax2.grid(which='both', axis='both', color='lightgray')\n\nf1_ax1.autoscale(enable=True, axis='both', tight=True)\nf1_ax2.autoscale(enable=True, axis='both', tight=True)\n\nf1_ax1.set_title('Bode magnitude plot', fontsize=11)\nf1_ax1.set_xscale('log')\nf1_ax1.set_xlabel(r'$f\\/$[Hz]', labelpad=0, fontsize=10)\nf1_ax1.set_ylabel(r'$A\\/$[dB]', labelpad=0, fontsize=10)\nf1_ax1.tick_params(axis='both', which='both', pad=0, labelsize=8)\n\nf1_ax2.set_title('Bode phase plot', fontsize=11)\nf1_ax2.set_xscale('log')\nf1_ax2.set_xlabel(r'$f\\/$[Hz]', labelpad=0, fontsize=10)\nf1_ax2.set_ylabel(r'$\\phi\\/$[°]', labelpad=0, fontsize=10)\nf1_ax2.tick_params(axis='both', which='both', pad=0, labelsize=8)   \n\n\n# System model\n\ndef system_model(T1):\n\n    W_sys = c.tf([1], [T1, 1])\n\n    print('System transfer function:')\n    print(W_sys)\n\n    # System analysis\n\n    poles = c.pole(W_sys)     # Poles\n\n    print('System poles:\\n')\n    print(poles)\n    \n    global f1_line1, f1_line2\n    \n    f1_ax1.lines.remove(f1_line1)\n    f1_ax2.lines.remove(f1_line2)\n\n    mag, phase, omega = c.bode_plot(W_sys, Plot=False)   # Bode-plot\n\n    f1_line1, = f1_ax1.plot(omega/2/np.pi, 20*np.log10(mag), lw=1, color='blue')\n    f1_line2, = f1_ax2.plot(omega/2/np.pi, phase*180/np.pi, lw=1, color='blue')   \n\n    f1_ax1.relim()\n    f1_ax2.relim()\n    f1_ax1.autoscale_view()\n    f1_ax2.autoscale_view()\n    \n# GUI widgets\n    \nT1_slider = w.FloatLogSlider(value=0.1, base=10, min=-4, max=1, description='Time constant [s] :', continuous_update=False,\n                             layout=w.Layout(width='75%'), style={'description_width':'50%'})\n\ninput_data = w.interactive_output(system_model, {'T1':T1_slider})\n\ndisplay(w.HBox([T1_slider]), input_data)\n\n\n\n\n\n\n\n\n\n\n\n\n\nAfter observing the system’s characteristics, select a controller type!\n\n#Controller type select\n\ntypeSelect = w.ToggleButtons(\n    options=[('P', 0), ('PI', 1), ('PD', 2), ('PID', 3), ('PID Realistic', 4)],\n    description='Controller type: ', style={'description_width':'15%'})\n\ndisplay(typeSelect)\n\n\n\n\nTune the selected controller so that rising/settling time, overshoot, or remaining error is minimized! It is not possible to get the best results for each parameter in a single setup. Create multiple solutions, one for each type!\n\n# PID control\n\n# Figure definition\nfig2, ((f2_ax1, f2_ax2, f2_ax3), (f2_ax4, f2_ax5, f2_ax6)) = plt.subplots(2, 3)\nfig2.set_size_inches((9.8, 5))\nfig2.set_tight_layout(True)\n\nf2_line1, = f2_ax1.plot([], [])\nf2_line2, = f2_ax2.plot([], []) \nf2_line3, = f2_ax3.plot([], [])\nf2_line4, = f2_ax4.plot([], [])  \nf2_line5, = f2_ax5.plot([], [])\nf2_line6, = f2_ax6.plot([], [])\n\nf2_ax1.grid(which='both', axis='both', color='lightgray')\nf2_ax2.grid(which='both', axis='both', color='lightgray')\nf2_ax3.grid(which='both', axis='both', color='lightgray')\nf2_ax4.grid(which='both', axis='both', color='lightgray')\nf2_ax5.grid(which='both', axis='both', color='lightgray')\nf2_ax6.grid(which='both', axis='both', color='lightgray')\n\nf2_ax1.autoscale(enable=True, axis='both', tight=True)\nf2_ax2.autoscale(enable=True, axis='both', tight=True)\nf2_ax3.autoscale(enable=True, axis='both', tight=True)\nf2_ax4.autoscale(enable=True, axis='both', tight=True)\nf2_ax5.autoscale(enable=True, axis='both', tight=True)\nf2_ax6.autoscale(enable=True, axis='both', tight=True)\n\nf2_ax1.set_title('Closed loop step response', fontsize=9)\nf2_ax1.set_xlabel(r'$t\\/$[s]', labelpad=0, fontsize=8)\nf2_ax1.set_ylabel(r'$x\\/$[m]', labelpad=0, fontsize=8)\nf2_ax1.tick_params(axis='both', which='both', pad=0, labelsize=6)\n\nf2_ax2.set_title('Nyquist diagram', fontsize=9)\nf2_ax2.set_xlabel(r'Re', labelpad=0, fontsize=8)\nf2_ax2.set_ylabel(r'Im', labelpad=0, fontsize=8)\nf2_ax2.tick_params(axis='both', which='both', pad=0, labelsize=6)\n\nf2_ax3.set_title('Bode magnitude plot', fontsize=9)\nf2_ax3.set_xscale('log')\nf2_ax3.set_xlabel(r'$f\\/$[Hz]', labelpad=0, fontsize=8)\nf2_ax3.set_ylabel(r'$A\\/$[dB]', labelpad=0, fontsize=8)\nf2_ax3.tick_params(axis='both', which='both', pad=0, labelsize=6)\n\nf2_ax4.set_title('Closed loop impulse response', fontsize=9)\nf2_ax4.set_xlabel(r'$t\\/$[s]', labelpad=0, fontsize=8)\nf2_ax4.set_ylabel(r'$x\\/$[m]', labelpad=0, fontsize=8)\nf2_ax4.tick_params(axis='both', which='both', pad=0, labelsize=6)\n\nf2_ax5.set_title('Open loop step response', fontsize=9)\nf2_ax5.set_xlabel(r'$t\\/$[s]', labelpad=0, fontsize=8)\nf2_ax5.set_ylabel(r'$x\\/$[m]', labelpad=0, fontsize=8)\nf2_ax5.tick_params(axis='both', which='both', pad=0, labelsize=6)\n\nf2_ax6.set_title('Bode phase plot', fontsize=9)\nf2_ax6.set_xscale('log')\nf2_ax6.set_xlabel(r'$f\\/$[Hz]', labelpad=0, fontsize=8)\nf2_ax6.set_ylabel(r'$\\phi\\/$[°]', labelpad=0, fontsize=8)\nf2_ax6.tick_params(axis='both', which='both', pad=0, labelsize=6)\n\ndef pid_control(Kp, Ti, Td, Fd, type_select, T1):\n    \n    W_sys = c.tf([1], [T1, 1])\n    \n    if type_select in (1, 3, 4):\n        Ti0 = 1\n    else:\n        Ti0 = 0\n        \n    if type_select in (2, 3, 4):\n        Td0 = 1\n    else :\n        Td0 = 0\n        \n    if type_select == 4:\n        Fd0 = 1\n    else:\n        Fd0 = 0\n    \n    # PID Controller\n    \n    P = Kp             # Proportional term\n    I = Kp / Ti        # Integral term\n    D = Kp * Td        # Derivative term\n    Td_f = Td / Fd     # Derivative term filter\n    \n    W_PID = c.parallel(c.tf([P], [1]),\n                       c.tf([I * Ti0], [1 * Ti0, 1 * (not Ti0)]),\n                       c.tf([D * Td0, 0], [Td_f * Td0 * Fd0, 1]))  # PID controller in time constant format\n    \n    W_open = c.series(W_PID, W_sys)         # Open loop\n    W_closed = c.feedback(W_open, 1, -1)    # Closed loop with negative feedback\n                        \n    # Display\n                        \n    global f2_line1, f2_line2, f2_line3, f2_line4, f2_line5, f2_line6\n    \n    f2_ax1.lines.remove(f2_line1)\n    f2_ax2.lines.remove(f2_line2)\n    f2_ax3.lines.remove(f2_line3)\n    f2_ax4.lines.remove(f2_line4)\n    f2_ax5.lines.remove(f2_line5)\n    f2_ax6.lines.remove(f2_line6)\n    \n    tout, yout = c.step_response(W_closed)\n    f2_line1, = f2_ax1.plot(tout, yout, lw=1, color='blue') \n\n    \n    _, _, ob = c.nyquist_plot(W_open, Plot=False)   # Small resolution plot to determine bounds        \n    real, imag, freq = c.nyquist_plot(W_open, omega=np.logspace(np.log10(ob[0]), np.log10(ob[-1]), 1000), Plot=False)\n    f2_line2, = f2_ax2.plot(real, imag, lw=1, color='blue')\n    \n    mag, phase, omega = c.bode_plot(W_open, Plot=False)\n    f2_line3, = f2_ax3.plot(omega/2/np.pi, 20*np.log10(mag), lw=1, color='blue')\n    f2_line6, = f2_ax6.plot(omega/2/np.pi, phase*180/np.pi, lw=1, color='blue')\n\n    tout, yout = c.impulse_response(W_closed)\n    f2_line4, = f2_ax4.plot(tout, yout, lw=1, color='blue')   \n    \n    tout, yout = c.step_response(W_open)\n    f2_line5, = f2_ax5.plot(tout, yout, lw=1, color='blue') \n    \n    f2_ax1.relim()\n    f2_ax2.relim()\n    f2_ax3.relim()\n    f2_ax4.relim()\n    f2_ax5.relim()\n    f2_ax6.relim()\n    f2_ax1.autoscale_view()\n    f2_ax2.autoscale_view()\n    f2_ax3.autoscale_view()\n    f2_ax4.autoscale_view()\n    f2_ax5.autoscale_view()\n    f2_ax6.autoscale_view()\n    \n# GUI widgets\n\ndef draw_controllers(type_select):\n    \n    global Kp_slider\n    global Ti_slider\n    global Td_slider\n    global Fd_slider\n    \n    Kp_slider = w.FloatLogSlider(value=0.5, base=10, min=-1, max=4, description='Kp:', continuous_update=False,\n                                 layout=w.Layout(width='auto', flex='5 5 auto'))\n    \n    if type_select in (1, 3, 4):\n        Ti_slider = w.FloatLogSlider(value=0.0035, base=10, min=-4, max=1, description='Ti:', continuous_update=False,\n                                     layout=w.Layout(width='auto', flex='5 5 auto'))\n    else:\n        Ti_slider = w.FloatLogSlider(value=0.0035, base=10, min=-4, max=1, description='Ti:', continuous_update=False,\n                                     layout=w.Layout(width='auto', flex='5 5 auto'), disabled=True)\n        \n    if type_select in (2, 3, 4):\n        Td_slider = w.FloatLogSlider(value=1, base=10, min=-4, max=1, description='Td:', continuous_update=False,\n                                     layout=w.Layout(width='auto', flex='5 5 auto'))\n    else:\n        Td_slider = w.FloatLogSlider(value=1, base=10, min=-4, max=1, description='Td:', continuous_update=False,\n                                     layout=w.Layout(width='auto', flex='5 5 auto'), disabled=True)\n    \n    if type_select == 4:\n        Fd_slider = w.FloatLogSlider(value=1, base=10, min=0, max=3, description='Fd:', continuous_update=False,\n                                     layout=w.Layout(width='auto', flex='5 5 auto'))\n    else:\n        Fd_slider = w.FloatLogSlider(value=1, base=10, min=0, max=3, description='Fd:', continuous_update=False,\n                                     layout=w.Layout(width='auto', flex='5 5 auto'), disabled=True)\n\n\n    input_data = w.interactive_output(pid_control, {'Kp': Kp_slider, 'Ti': Ti_slider, 'Td': Td_slider,\n                                      'Fd': Fd_slider, 'type_select':typeSelect, 'T1':T1_slider})\n\n    display(w.HBox([Kp_slider, Ti_slider, Td_slider, Fd_slider]), input_data)\n    \nw.interactive_output(draw_controllers, {'type_select':typeSelect})\n\n\n\n\n\n\n\n\n\n\nYou can test the controlled system’s signal following capabilities using the simulated scope. Readjust your controller so that it can follow a sine wave acceptably!  (The animations are scaled to fit the frame through the whole simulation. Because of this, unstable solutions might not seem to move until the very last second.)\n\n# Simulation data\n\nanim_fig = plt.figure()\nanim_fig.set_size_inches((9.8, 4))\nanim_fig.set_tight_layout(True)\n\nanim_ax1 = anim_fig.add_subplot(111)\n\nframe_count=1000\nscope_rounds=4\n\nl1 = anim_ax1.plot([], [], lw=1, color='blue')\nl2 = anim_ax1.plot([], [], lw=2, color='red')\n\nline1 = l1[0]\nline2 = l2[0]\n\nanim_ax1.legend(l1+l2, ['Reference', 'Output'], loc=1)\n\nanim_ax1.set_title('Scope', fontsize=12)\nanim_ax1.set_xlabel(r'$t\\/$[s]', labelpad=0, fontsize=10)\nanim_ax1.set_ylabel(r'$y\\/$[/]', labelpad=0, fontsize=10)\nanim_ax1.tick_params(axis='both', which='both', pad=0, labelsize=8)\n\nanim_ax1.grid(which='both', axis='both', color='lightgray')\n\nT_plot = []\nX_plot = []\nR_plot = []\n\n#Simulation function\n\ndef simulation(Kp, Ti, Td, Fd, type_select, T1, T, dt, X, Xf, Xa):\n    \n    W_sys = c.tf([1], [T1, 1])\n    \n    if type_select in (1, 3, 4):\n        Ti0 = 1\n    else:\n        Ti0 = 0\n        \n    if type_select in (2, 3, 4):\n        Td0 = 1\n    else :\n        Td0 = 0\n        \n    if type_select == 4:\n        Fd0 = 1\n    else:\n        Fd0 = 0\n    \n    # Controller\n    P = Kp            # Proportional term\n    I = Kp / Ti       # Integral term\n    D = Kp * Td       # Derivative term\n    Td_f = Td * Fd    # Derivative term filter\n    \n    W_PID = c.parallel(c.tf([P], [1]),\n                       c.tf([I * Ti0], [1 * Ti0, 1 * (not Ti0)]),\n                       c.tf([D * Td0, 0], [Td_f * Td0 * Fd0, 1]))    # PID controller\n    \n    # Model\n    W_open = c.series(W_PID, W_sys)         # Open loop\n    W_closed = c.feedback(W_open, 1, -1)    # Closed loop with negative feedback\n    \n    # Reference and disturbance signals\n\n    T_sim = np.arange(0, T, dt, dtype=np.float64)\n    \n    if X == 0:   # Sine wave reference\n        X_sim = np.sin(2 * np.pi * Xf * T_sim) * Xa\n    elif X == 1:   # Square wave reference\n        X_sim = np.sign(np.sin(2 * np.pi * Xf * T_sim)) * Xa\n    \n    # System response\n        \n    Tx, youtx, xoutx = c.forced_response(W_closed, T_sim, X_sim)\n    R_sim = youtx\n    \n    # Display\n    \n    XR_max = max(np.amax(np.absolute(np.concatenate((X_sim, R_sim)))), Xa)\n    \n    anim_ax1.set_ylim((-1.2 * XR_max, 1.2 * XR_max))\n    \n    global T_plot, X_plot, R_plot\n    \n    T_plot = np.linspace(0, T, frame_count*(scope_rounds+1), dtype=np.float32)\n    X_plot = np.interp(T_plot, T_sim, X_sim)\n    R_plot = np.interp(T_plot, T_sim, R_sim)\n        \ndef anim_init():\n    line1.set_data([], [])\n    line2.set_data([], [])\n    anim_ax1.set_xlim((0, T_plot[frame_count-1]))\n    \n    return (line1, line2, anim_ax1,)\n\ndef animate(i):\n    line1.set_data(T_plot[scope_rounds*i:scope_rounds*i+frame_count-1], X_plot[scope_rounds*i:scope_rounds*i+frame_count-1])\n    line2.set_data(T_plot[scope_rounds*i:scope_rounds*i+frame_count-1], R_plot[scope_rounds*i:scope_rounds*i+frame_count-1])\n    anim_ax1.set_xlim((T_plot[i*scope_rounds], T_plot[i*scope_rounds+frame_count-1]))\n    \n    return (line1, line2, anim_ax1,)\n\nanim = animation.FuncAnimation(anim_fig, animate, init_func=anim_init,\n                               frames=frame_count, interval=10, blit=True,\n                               repeat=True)\n\n# Controllers\n\nT_slider = w.FloatLogSlider(value=10, base=10, min=-0.7, max=1, step=0.01,\n                            description='Duration [s]:', continuous_update=False,\n                            orientation='vertical', layout=w.Layout(width='auto', height='auto', flex='1 1 auto'))\n\ndt_slider = w.FloatLogSlider(value=0.1, base=10, min=-3, max=-1, step=0.01,\n                             description='Timestep [s]:', continuous_update=False,\n                             orientation='vertical', layout=w.Layout(width='auto', height='auto', flex='1 1 auto'))\n       \nX_type = w.Dropdown(options=[('Sine', 0), ('Square', 1)], value=1,\n                    description='Reference: ', continuous_update=False, layout=w.Layout(width='auto', flex='3 3 auto'))    \nXf_slider = w.FloatLogSlider(value=0.5, base=10, min=-2, max=2, step=0.01,\n                             description='Frequency [Hz]:', continuous_update=False,\n                             orientation='vertical', layout=w.Layout(width='auto', height='auto', flex='1 1 auto'))\nXa_slider = w.FloatLogSlider(value=1, base=10, min=-2, max=2, step=0.01,\n                             description='Amplitude [/]:', continuous_update=False,\n                             orientation='vertical', layout=w.Layout(width='auto', height='auto', flex='1 1 auto'))    \n\ninput_data = w.interactive_output(simulation, {'Kp': Kp_slider, 'Ti': Ti_slider, 'Td': Td_slider,\n                                               'Fd': Fd_slider, 'type_select': typeSelect, 'T1': T1_slider,\n                                               'T': T_slider, 'dt': dt_slider,\n                                               'X': X_type, 'Xf': Xf_slider, 'Xa': Xa_slider})\n\ndisplay(w.HBox([w.HBox([T_slider, dt_slider], layout=w.Layout(width='25%')),\n                w.Box([], layout=w.Layout(width='5%')),\n                w.VBox([X_type, w.HBox([Xf_slider, Xa_slider])], layout=w.Layout(width='30%')),\n                w.Box([], layout=w.Layout(width='5%'))],\n                layout=w.Layout(width='100%', justify_content='center')), input_data)\n\n\n\n\n\n\n\n\n\n\n\n\n\nThe duration parameter controls the simulated timeframe and does not affect the runtime of the animation. In contrast, the timestep controls the model sampling and can refine the results in exchange for higher computational resources."
  },
  {
    "objectID": "ICCT_en/examples/03/FD-09_PID_Control_of_First-Order_Systems_with_Time_Delay.html",
    "href": "ICCT_en/examples/03/FD-09_PID_Control_of_First-Order_Systems_with_Time_Delay.html",
    "title": "PID control of a First-Order system with Time Delay",
    "section": "",
    "text": "%matplotlib notebook\nimport control as c\nimport ipywidgets as w\nimport numpy as np\n\nfrom IPython.display import display, HTML\nimport matplotlib.pyplot as plt\nimport matplotlib.animation as animation\n\ndisplay(HTML('&lt;script&gt; $(document).ready(function() { $(\"div.input\").hide(); }); &lt;/script&gt;'))\n\n\n\n\nIn the following example, we will be using a PID controller (or one of its subtypes) to control an LTI (linear time-invariant system) that is approximating a first-order system with a time delay.\nThe time delay is simulated using the Padé approximation, allowing the system to remain linear. The approximant is a fraction of two large polynomials that can be included in the transfer function as the feedback system.\n \\[G_{Padé}(s)=\\frac{\\sum_{i=0}^{m}a_ix^i}{1+\\sum_{j=1}^{n}b_jx^j}\\]  Choose a time constant for the system, along with the desired time delay and the degree of the approximating polynomial!\n\n# Figure definition\n\nfig1, ((f1_ax1), (f1_ax2)) = plt.subplots(2, 1)\nfig1.set_size_inches((9.8, 5))\nfig1.set_tight_layout(True)\n\nf1_line1, = f1_ax1.plot([], [])\nf1_line2, = f1_ax2.plot([], [])  \n\nf1_ax1.grid(which='both', axis='both', color='lightgray')\nf1_ax2.grid(which='both', axis='both', color='lightgray')\n\nf1_ax1.autoscale(enable=True, axis='both', tight=True)\nf1_ax2.autoscale(enable=True, axis='both', tight=True)\n\nf1_ax1.set_title('Bode magnitude plot', fontsize=11)\nf1_ax1.set_xscale('log')\nf1_ax1.set_xlabel(r'$f\\/$[Hz]', labelpad=0, fontsize=10)\nf1_ax1.set_ylabel(r'$A\\/$[dB]', labelpad=0, fontsize=10)\nf1_ax1.tick_params(axis='both', which='both', pad=0, labelsize=8)\n\nf1_ax2.set_title('Bode phase plot', fontsize=11)\nf1_ax2.set_xscale('log')\nf1_ax2.set_xlabel(r'$f\\/$[Hz]', labelpad=0, fontsize=10)\nf1_ax2.set_ylabel(r'$\\phi\\/$[°]', labelpad=0, fontsize=10)\nf1_ax2.tick_params(axis='both', which='both', pad=0, labelsize=8)   \n\n\n# System model\n\ndef system_model(T1, Tdelay, pade_deg):\n\n    del_num, del_den = c.pade(Tdelay, pade_deg, -1)\n    W_sysnodel = c.tf([1], [T1, 1])\n    W_sys = c.series(W_sysnodel, c.tf(del_num, del_den))\n\n    print('Transfer function of the non-delayed system:')\n    print(W_sysnodel)\n\n    # System analysis\n\n    poles = c.pole(W_sysnodel)  # Poles\n\n    print('Poles of the non-delayed system:\\n')\n    print(poles)\n    \n    global f1_line1, f1_line2\n    \n    f1_ax1.lines.remove(f1_line1)\n    f1_ax2.lines.remove(f1_line2)\n\n    mag, phase, omega = c.bode_plot(W_sys, Plot=False)   # Bode-plot\n\n    f1_line1, = f1_ax1.plot(omega/2/np.pi, 20*np.log10(mag), lw=1, color='blue')\n    f1_line2, = f1_ax2.plot(omega/2/np.pi, phase*180/np.pi, lw=1, color='blue')   \n\n    f1_ax1.relim()\n    f1_ax2.relim()\n    f1_ax1.autoscale_view()\n    f1_ax2.autoscale_view()\n    \n# GUI widgets\n    \nT1_slider = w.FloatLogSlider(value=0.1, base=10, min=-4, max=1, description='T1 [s] :', continuous_update=False,\n                             layout=w.Layout(width='75%'))\nTdelay_slider = w.FloatLogSlider(value=0.1, base=10, min=-2, max=0, description='Delay [s] :', continuous_update=False,\n                             layout=w.Layout(width='75%'))\ndeg_slider = w.IntSlider(value=1, min=1, max=10, step=1, description='Pade denominator degree:', continuous_update=False,\n                         layout=w.Layout(width='75%'), style={'description_width':'50%'})\n\ninput_data = w.interactive_output(system_model, {'T1':T1_slider, 'Tdelay':Tdelay_slider, 'pade_deg':deg_slider})\n\ndisplay(w.HBox([T1_slider, Tdelay_slider, deg_slider]), input_data)\n\n\n\n\n\n\n\n\n\n\n\n\n\nAfter observing the system’s characteristics, select a controller type!\n\n#Controller type select\n\ntypeSelect = w.ToggleButtons(\n    options=[('P', 0), ('PI', 1), ('PD', 2), ('PID', 3), ('PID Realistic', 4)],\n    description='Controller type: ', style={'description_width':'15%'})\n\ndisplay(typeSelect)\n\n\n\n\nTune the selected controller so that rising/settling time, overshoot, or remaining error is minimized! It is not possible to get the best results for each parameter in a single setup. Create multiple solutions, one for each type!\n\n# PID control\n\n# Figure definition\nfig2, ((f2_ax1, f2_ax2, f2_ax3), (f2_ax4, f2_ax5, f2_ax6)) = plt.subplots(2, 3)\nfig2.set_size_inches((9.8, 5))\nfig2.set_tight_layout(True)\n\nf2_line1, = f2_ax1.plot([], [])\nf2_line2, = f2_ax2.plot([], []) \nf2_line3, = f2_ax3.plot([], [])\nf2_line4, = f2_ax4.plot([], [])  \nf2_line5, = f2_ax5.plot([], [])\nf2_line6, = f2_ax6.plot([], [])\n\nf2_ax1.grid(which='both', axis='both', color='lightgray')\nf2_ax2.grid(which='both', axis='both', color='lightgray')\nf2_ax3.grid(which='both', axis='both', color='lightgray')\nf2_ax4.grid(which='both', axis='both', color='lightgray')\nf2_ax5.grid(which='both', axis='both', color='lightgray')\nf2_ax6.grid(which='both', axis='both', color='lightgray')\n\nf2_ax1.autoscale(enable=True, axis='both', tight=True)\nf2_ax2.autoscale(enable=True, axis='both', tight=True)\nf2_ax3.autoscale(enable=True, axis='both', tight=True)\nf2_ax4.autoscale(enable=True, axis='both', tight=True)\nf2_ax5.autoscale(enable=True, axis='both', tight=True)\nf2_ax6.autoscale(enable=True, axis='both', tight=True)\n\nf2_ax1.set_title('Closed loop step response', fontsize=9)\nf2_ax1.set_xlabel(r'$t\\/$[s]', labelpad=0, fontsize=8)\nf2_ax1.set_ylabel(r'$x\\/$[m]', labelpad=0, fontsize=8)\nf2_ax1.tick_params(axis='both', which='both', pad=0, labelsize=6)\n\nf2_ax2.set_title('Nyquist diagram', fontsize=9)\nf2_ax2.set_xlabel(r'Re', labelpad=0, fontsize=8)\nf2_ax2.set_ylabel(r'Im', labelpad=0, fontsize=8)\nf2_ax2.tick_params(axis='both', which='both', pad=0, labelsize=6)\n\nf2_ax3.set_title('Bode magnitude plot', fontsize=9)\nf2_ax3.set_xscale('log')\nf2_ax3.set_xlabel(r'$f\\/$Hz]', labelpad=0, fontsize=8)\nf2_ax3.set_ylabel(r'$A\\/$[dB]', labelpad=0, fontsize=8)\nf2_ax3.tick_params(axis='both', which='both', pad=0, labelsize=6)\n\nf2_ax4.set_title('Closed loop impulse response', fontsize=9)\nf2_ax4.set_xlabel(r'$t\\/$[s]', labelpad=0, fontsize=8)\nf2_ax4.set_ylabel(r'$x\\/$[m]', labelpad=0, fontsize=8)\nf2_ax4.tick_params(axis='both', which='both', pad=0, labelsize=6)\n\nf2_ax5.set_title('Open loop step response', fontsize=9)\nf2_ax5.set_xlabel(r'$t\\/$[s]', labelpad=0, fontsize=8)\nf2_ax5.set_ylabel(r'$x\\/$[m]', labelpad=0, fontsize=8)\nf2_ax5.tick_params(axis='both', which='both', pad=0, labelsize=6)\n\nf2_ax6.set_title('Bode phase plot', fontsize=9)\nf2_ax6.set_xscale('log')\nf2_ax6.set_xlabel(r'$f\\/$[Hz]', labelpad=0, fontsize=8)\nf2_ax6.set_ylabel(r'$\\phi\\/$[°]', labelpad=0, fontsize=8)\nf2_ax6.tick_params(axis='both', which='both', pad=0, labelsize=6)\n\ndef pid_control(Kp, Ti, Td, Fd, type_select, T1, Tdelay, pade_deg):\n    \n    del_num, del_den = c.pade(Tdelay, pade_deg, -1)\n    W_sys = c.series( c.tf([1], [T1, 1]), c.tf(del_num, del_den))\n    \n    if type_select in (1, 3, 4):\n        Ti0 = 1\n    else:\n        Ti0 = 0\n        \n    if type_select in (2, 3, 4):\n        Td0 = 1\n    else :\n        Td0 = 0\n        \n    if type_select == 4:\n        Fd0 = 1\n    else:\n        Fd0 = 0\n    \n    # PID Controller\n    \n    P = Kp             # Proportional term\n    I = Kp / Ti        # Integral term\n    D = Kp * Td        # Derivative term\n    Td_f = Td / Fd     # Derivative term filter\n    \n    W_PID = c.parallel(c.tf([P], [1]),\n                       c.tf([I * Ti0], [1 * Ti0, 1 * (not Ti0)]),\n                       c.tf([D * Td0, 0], [Td_f * Td0 * Fd0, 1]))  # PID controller in time constant format\n    \n    W_open = c.series(W_PID, W_sys)         # Open loop\n    W_closed = c.feedback(W_open, 1, -1)    # Closed loop with negative feedback\n                        \n    # Display\n                        \n    global f2_line1, f2_line2, f2_line3, f2_line4, f2_line5, f2_line6\n    \n    f2_ax1.lines.remove(f2_line1)\n    f2_ax2.lines.remove(f2_line2)\n    f2_ax3.lines.remove(f2_line3)\n    f2_ax4.lines.remove(f2_line4)\n    f2_ax5.lines.remove(f2_line5)\n    f2_ax6.lines.remove(f2_line6)\n    \n    tout, yout = c.step_response(W_closed)\n    f2_line1, = f2_ax1.plot(tout, yout, lw=1, color='blue') \n\n    _, _, ob = c.nyquist_plot(W_open, Plot=False)   # Small resolution plot to determine bounds        \n    real, imag, freq = c.nyquist_plot(W_open, omega=np.logspace(np.log10(ob[0]), np.log10(ob[-1]), 1000), Plot=False)\n    f2_line2, = f2_ax2.plot(real, imag, lw=1, color='blue')\n    \n    mag, phase, omega = c.bode_plot(W_open, Plot=False)\n    f2_line3, = f2_ax3.plot(omega/2/np.pi, 20*np.log10(mag), lw=1, color='blue')\n    f2_line6, = f2_ax6.plot(omega/2/np.pi, phase*180/np.pi, lw=1, color='blue')\n\n    tout, yout = c.impulse_response(W_closed)\n    f2_line4, = f2_ax4.plot(tout, yout, lw=1, color='blue')   \n    \n    tout, yout = c.step_response(W_open)\n    f2_line5, = f2_ax5.plot(tout, yout, lw=1, color='blue') \n    \n    f2_ax1.relim()\n    f2_ax2.relim()\n    f2_ax3.relim()\n    f2_ax4.relim()\n    f2_ax5.relim()\n    f2_ax6.relim()\n    f2_ax1.autoscale_view()\n    f2_ax2.autoscale_view()\n    f2_ax3.autoscale_view()\n    f2_ax4.autoscale_view()\n    f2_ax5.autoscale_view()\n    f2_ax6.autoscale_view()\n    \n# GUI widgets\n\ndef draw_controllers(type_select):\n    \n    global Kp_slider\n    global Ti_slider\n    global Td_slider\n    global Fd_slider\n    \n    Kp_slider = w.FloatLogSlider(value=0.5, base=10, min=-1, max=4, description='Kp:', continuous_update=False,\n                                 layout=w.Layout(width='auto', flex='5 5 auto'))\n    \n    if type_select in (1, 3, 4):\n        Ti_slider = w.FloatLogSlider(value=0.0035, base=10, min=-4, max=1, description='Ti:', continuous_update=False,\n                                     layout=w.Layout(width='auto', flex='5 5 auto'))\n    else:\n        Ti_slider = w.FloatLogSlider(value=0.0035, base=10, min=-4, max=1, description='Ti:', continuous_update=False,\n                                     layout=w.Layout(width='auto', flex='5 5 auto'), disabled=True)\n        \n    if type_select in (2, 3, 4):\n        Td_slider = w.FloatLogSlider(value=1, base=10, min=-4, max=1, description='Td:', continuous_update=False,\n                                     layout=w.Layout(width='auto', flex='5 5 auto'))\n    else:\n        Td_slider = w.FloatLogSlider(value=1, base=10, min=-4, max=1, description='Td:', continuous_update=False,\n                                     layout=w.Layout(width='auto', flex='5 5 auto'), disabled=True)\n    \n    if type_select == 4:\n        Fd_slider = w.FloatLogSlider(value=1, base=10, min=0, max=3, description='Fd:', continuous_update=False,\n                                     layout=w.Layout(width='auto', flex='5 5 auto'))\n    else:\n        Fd_slider = w.FloatLogSlider(value=1, base=10, min=0, max=3, description='Fd:', continuous_update=False,\n                                     layout=w.Layout(width='auto', flex='5 5 auto'), disabled=True)\n\n\n    input_data = w.interactive_output(pid_control, {'Kp': Kp_slider, 'Ti': Ti_slider, 'Td': Td_slider,\n                                      'Fd': Fd_slider, 'type_select':typeSelect, 'T1':T1_slider, 'Tdelay':Tdelay_slider,\n                                      'pade_deg':deg_slider})\n\n    display(w.HBox([Kp_slider, Ti_slider, Td_slider, Fd_slider]), input_data)\n    \nw.interactive_output(draw_controllers, {'type_select':typeSelect})\n\n\n\n\n\n\n\n\n\n\nYou can test the controlled system’s signal following capabilities using the simulated scope. Readjust your controller so that it can follow a sine wave acceptably!  (The animations are scaled to fit the frame through the whole simulation. Because of this, unstable solutions might not seem to move until the very last second.)\n\n# Simulation data\n\nanim_fig = plt.figure()\nanim_fig.set_size_inches((9.8, 4))\nanim_fig.set_tight_layout(True)\n\nanim_ax1 = anim_fig.add_subplot(111)\n\nframe_count=1000\nscope_rounds=4\n\nl1 = anim_ax1.plot([], [], lw=1, color='blue')\nl2 = anim_ax1.plot([], [], lw=2, color='red')\n\nline1 = l1[0]\nline2 = l2[0]\n\nanim_ax1.legend(l1+l2, ['Reference', 'Output'], loc=1)\n\nanim_ax1.set_title('Scope', fontsize=12)\nanim_ax1.set_xlabel(r'$t\\/$[s]', labelpad=0, fontsize=10)\nanim_ax1.set_ylabel(r'$y\\/$[/]', labelpad=0, fontsize=10)\nanim_ax1.tick_params(axis='both', which='both', pad=0, labelsize=8)\n\nanim_ax1.grid(which='both', axis='both', color='lightgray')\n\nT_plot = []\nX_plot = []\nR_plot = []\n\n#Simulation function\n\ndef simulation(Kp, Ti, Td, Fd, type_select, T1, Tdelay, pade_deg, T, dt, X, Xf, Xa):\n    \n    del_num, del_den = c.pade(Tdelay, pade_deg)\n    W_sys = c.series( c.tf([1], [T1, 1]), c.tf(del_num, del_den))\n    \n    if type_select in (1, 3, 4):\n        Ti0 = 1\n    else:\n        Ti0 = 0\n        \n    if type_select in (2, 3, 4):\n        Td0 = 1\n    else :\n        Td0 = 0\n        \n    if type_select == 4:\n        Fd0 = 1\n    else:\n        Fd0 = 0\n    \n    # Controller\n    P = Kp            # Proportional term\n    I = Kp / Ti       # Integral term\n    D = Kp * Td       # Derivative term\n    Td_f = Td * Fd    # Derivative term filter\n    \n    W_PID = c.parallel(c.tf([P], [1]),\n                       c.tf([I * Ti0], [1 * Ti0, 1 * (not Ti0)]),\n                       c.tf([D * Td0, 0], [Td_f * Td0 * Fd0, 1]))    # PID controller\n    \n    # Model\n    W_open = c.series(W_PID, W_sys)         # Open loop\n    W_closed = c.feedback(W_open, 1, -1)    # Closed loop with negative feedback\n    \n    # Reference and disturbance signals\n\n    T_sim = np.arange(0, T, dt, dtype=np.float64)\n    \n    if X == 0:   # Sine wave reference\n        X_sim = np.sin(2 * np.pi * Xf * T_sim) * Xa\n    elif X == 1:   # Square wave reference\n        X_sim = np.sign(np.sin(2 * np.pi * Xf * T_sim)) * Xa\n    \n    # System response\n        \n    Tx, youtx, xoutx = c.forced_response(W_closed, T_sim, X_sim)\n    R_sim = youtx\n    \n    # Display\n    \n    XR_max = max(np.amax(np.absolute(np.concatenate((X_sim, R_sim)))), Xa)\n    if not np.isnan(XR_max):\n        anim_ax1.set_ylim((-1.2 * XR_max, 1.2 * XR_max))\n    \n    global T_plot, X_plot, R_plot\n    \n    T_plot = np.linspace(0, T, frame_count*(scope_rounds+1), dtype=np.float32)\n    X_plot = np.interp(T_plot, T_sim, X_sim)\n    R_plot = np.interp(T_plot, T_sim, R_sim)\n        \ndef anim_init():\n    line1.set_data([], [])\n    line2.set_data([], [])\n    anim_ax1.set_xlim((0, T_plot[frame_count-1]))\n    \n    return (line1, line2, anim_ax1,)\n\ndef animate(i):\n    line1.set_data(T_plot[scope_rounds*i:scope_rounds*i+frame_count-1], X_plot[scope_rounds*i:scope_rounds*i+frame_count-1])\n    line2.set_data(T_plot[scope_rounds*i:scope_rounds*i+frame_count-1], R_plot[scope_rounds*i:scope_rounds*i+frame_count-1])\n    anim_ax1.set_xlim((T_plot[i*scope_rounds], T_plot[i*scope_rounds+frame_count-1]))\n    \n    return (line1, line2, anim_ax1,)\n\nanim = animation.FuncAnimation(anim_fig, animate, init_func=anim_init,\n                               frames=frame_count, interval=10, blit=True,\n                               repeat=True)\n\n# Controllers\n\nT_slider = w.FloatLogSlider(value=10, base=10, min=-0.7, max=1, step=0.01,\n                            description='Duration [s]:', continuous_update=False,\n                            orientation='vertical', layout=w.Layout(width='auto', height='auto', flex='1 1 auto'))\n\ndt_slider = w.FloatLogSlider(value=0.1, base=10, min=-3, max=-1, step=0.01,\n                             description='Timestep [s]:', continuous_update=False,\n                             orientation='vertical', layout=w.Layout(width='auto', height='auto', flex='1 1 auto'))\n       \nX_type = w.Dropdown(options=[('Sine', 0), ('Square', 1)], value=1,\n                    description='Reference: ', continuous_update=False, layout=w.Layout(width='auto', flex='3 3 auto'))    \nXf_slider = w.FloatLogSlider(value=0.5, base=10, min=-2, max=2, step=0.01,\n                             description='Frequency [Hz]:', continuous_update=False,\n                             orientation='vertical', layout=w.Layout(width='auto', height='auto', flex='1 1 auto'))\nXa_slider = w.FloatLogSlider(value=1, base=10, min=-2, max=2, step=0.01,\n                             description='Amplitude [/]:', continuous_update=False,\n                             orientation='vertical', layout=w.Layout(width='auto', height='auto', flex='1 1 auto'))    \n\ninput_data = w.interactive_output(simulation, {'Kp': Kp_slider, 'Ti': Ti_slider, 'Td': Td_slider,'Fd': Fd_slider,\n                                               'type_select': typeSelect, 'T1': T1_slider,\n                                               'Tdelay':Tdelay_slider, 'pade_deg':deg_slider,\n                                               'T': T_slider, 'dt': dt_slider,\n                                               'X': X_type, 'Xf': Xf_slider, 'Xa': Xa_slider})\n\ndisplay(w.HBox([w.HBox([T_slider, dt_slider], layout=w.Layout(width='25%')),\n                w.Box([], layout=w.Layout(width='5%')),\n                w.VBox([X_type, w.HBox([Xf_slider, Xa_slider])], layout=w.Layout(width='30%')),\n                w.Box([], layout=w.Layout(width='5%'))],\n                layout=w.Layout(width='100%', justify_content='center')), input_data)\n\n\n\n\n\n\n\n\n\n\n\n\n\nThe duration parameter controls the simulated timeframe and does not affect the runtime of the animation. In contrast, the timestep controls the model sampling and can refine the results in exchange for higher computational resources."
  },
  {
    "objectID": "ICCT_en/examples/03/FD-11_PID_Control_of_Second-Order_Underdamped_Systems.html",
    "href": "ICCT_en/examples/03/FD-11_PID_Control_of_Second-Order_Underdamped_Systems.html",
    "title": "PID control of an Underdamped Second-Order system",
    "section": "",
    "text": "%matplotlib notebook\nimport control as c\nimport ipywidgets as w\nimport numpy as np\n\nfrom IPython.display import display, HTML\nimport matplotlib.pyplot as plt\nimport matplotlib.animation as animation\n\ndisplay(HTML('&lt;script&gt; $(document).ready(function() { $(\"div.input\").hide(); }); &lt;/script&gt;'))\n\nTraceback (most recent call last):\n  File \"C:\\Users\\Uporabnik\\Anaconda3\\envs\\icct2\\lib\\site-packages\\matplotlib\\cbook\\__init__.py\", line 216, in process\n    func(*args, **kwargs)\n  File \"C:\\Users\\Uporabnik\\Anaconda3\\envs\\icct2\\lib\\site-packages\\matplotlib\\animation.py\", line 1465, in _stop\n    self.event_source.remove_callback(self._loop_delay)\nAttributeError: 'NoneType' object has no attribute 'remove_callback'\n\n\n\n\n\nIn the following example, we will be using a PID controller (or one of its subtypes) to control an underdamped second-order LTI (linear time-invariant) system.\nThe two poles form a complex pole pair, resulting in a rise of the magnitude transfer at the cutoff frequency. The transfer function is expressed based on the components of the complex vector as absolute values.  \\[G(s)=\\frac{1}{s^2+2R_es+(R_e+I_m j)\\cdot(R_e-I_m j)}\\]  A typical example of an underdamped second-order system can be constructed using a serial RLC circuit design: \n\nUnderdamped system \\(\\left(\\frac{R}{2}\\sqrt{\\frac{C}{L}}&lt;1 \\right)\\)\n\n Where the transfer function can be expressed as:   \\[G(s) = \\frac{V_{out}(s)}{V_{in}(s)} = K\\frac{1}{s^2+2\\zeta\\omega_0 s+\\omega_0^2}=\\frac{1}{LC}\\frac{1}{s^2+\\frac{R}{L}+\\frac{1}{LC}} \\qquad \\omega_0=\\frac{1}{LC} \\qquad \\zeta=\\frac{R}{2}\\sqrt{\\frac{C}{L}}&lt;1\\]  Choose the complex components for the poles of the system!\n\n# Figure definition\n\nfig1, ((f1_ax1), (f1_ax2)) = plt.subplots(2, 1)\nfig1.set_size_inches((9.8, 5))\nfig1.set_tight_layout(True)\n\nf1_line1, = f1_ax1.plot([], [])\nf1_line2, = f1_ax2.plot([], [])  \n\nf1_ax1.grid(which='both', axis='both', color='lightgray')\nf1_ax2.grid(which='both', axis='both', color='lightgray')\n\nf1_ax1.autoscale(enable=True, axis='both', tight=True)\nf1_ax2.autoscale(enable=True, axis='both', tight=True)\n\nf1_ax1.set_title('Bode magnitude plot', fontsize=11)\nf1_ax1.set_xscale('log')\nf1_ax1.set_xlabel(r'$f\\/$[Hz]', labelpad=0, fontsize=10)\nf1_ax1.set_ylabel(r'$A\\/$[dB]', labelpad=0, fontsize=10)\nf1_ax1.tick_params(axis='both', which='both', pad=0, labelsize=8)\n\nf1_ax2.set_title('Bode phase plot', fontsize=11)\nf1_ax2.set_xscale('log')\nf1_ax2.set_xlabel(r'$f\\/$[Hz]', labelpad=0, fontsize=10)\nf1_ax2.set_ylabel(r'$\\phi\\/$[°]', labelpad=0, fontsize=10)\nf1_ax2.tick_params(axis='both', which='both', pad=0, labelsize=8)   \n\n\n# System model\n\ndef system_model(Im, Re):\n\n    W_sys = c.tf([1], [1, 2*Re, (Re+Im*1j)*(Re-Im*1j)])\n\n    print('System transfer function:')\n    print(W_sys)\n\n    # System analysis\n\n    poles = c.pole(W_sys)     # Poles\n\n    print('System poles:\\n')\n    print(poles)\n    \n    global f1_line1, f1_line2\n    \n    f1_ax1.lines.remove(f1_line1)\n    f1_ax2.lines.remove(f1_line2)\n\n    mag, phase, omega = c.bode_plot(W_sys, Plot=False)   # Bode-plot\n\n    f1_line1, = f1_ax1.plot(omega/2/np.pi, 20*np.log10(mag), lw=1, color='blue')\n    f1_line2, = f1_ax2.plot(omega/2/np.pi, phase*180/np.pi, lw=1, color='blue')   \n\n    f1_ax1.relim()\n    f1_ax2.relim()\n    f1_ax1.autoscale_view()\n    f1_ax2.autoscale_view()\n    \n# GUI widgets\n    \nRe_slider = w.FloatLogSlider(value=0.05, base=10, min=-4, max=1, description='Pole.Re (negative) :', continuous_update=False,\n                             layout=w.Layout(width='75%'), style={'description_width':'50%'})\nIm_slider = w.FloatLogSlider(value=0.1, base=10, min=-4, max=1, description='Pole.Im :', continuous_update=False,\n                             layout=w.Layout(width='75%'), style={'description_width':'50%'})\n\ninput_data = w.interactive_output(system_model, {'Re':Re_slider, 'Im':Im_slider})\n\ndisplay(w.HBox([Re_slider, Im_slider]), input_data)\n\n\n\n\n\n\n\n\n\n\n\n\n\nAfter observing the system’s characteristics, select a controller type!\n\n#Controller type select\n\ntypeSelect = w.ToggleButtons(\n    options=[('P', 0), ('PI', 1), ('PD', 2), ('PID', 3), ('PID Realistic', 4)],\n    description='Controller type: ', style={'description_width':'15%'})\n\ndisplay(typeSelect)\n\n\n\n\nTune the selected controller so that rising/settling time, overshoot, or remaining error is minimized! It is not possible to get the best results for each parameter in a single setup. Create multiple solutions, one for each type!\n\n# PID control\n\n# Figure definition\nfig2, ((f2_ax1, f2_ax2, f2_ax3), (f2_ax4, f2_ax5, f2_ax6)) = plt.subplots(2, 3)\nfig2.set_size_inches((9.8, 5))\nfig2.set_tight_layout(True)\n\nf2_line1, = f2_ax1.plot([], [])\nf2_line2, = f2_ax2.plot([], []) \nf2_line3, = f2_ax3.plot([], [])\nf2_line4, = f2_ax4.plot([], [])  \nf2_line5, = f2_ax5.plot([], [])\nf2_line6, = f2_ax6.plot([], [])\n\nf2_ax1.grid(which='both', axis='both', color='lightgray')\nf2_ax2.grid(which='both', axis='both', color='lightgray')\nf2_ax3.grid(which='both', axis='both', color='lightgray')\nf2_ax4.grid(which='both', axis='both', color='lightgray')\nf2_ax5.grid(which='both', axis='both', color='lightgray')\nf2_ax6.grid(which='both', axis='both', color='lightgray')\n\nf2_ax1.autoscale(enable=True, axis='both', tight=True)\nf2_ax2.autoscale(enable=True, axis='both', tight=True)\nf2_ax3.autoscale(enable=True, axis='both', tight=True)\nf2_ax4.autoscale(enable=True, axis='both', tight=True)\nf2_ax5.autoscale(enable=True, axis='both', tight=True)\nf2_ax6.autoscale(enable=True, axis='both', tight=True)\n\nf2_ax1.set_title('Closed loop step response', fontsize=9)\nf2_ax1.set_xlabel(r'$t\\/$[s]', labelpad=0, fontsize=8)\nf2_ax1.set_ylabel(r'$x\\/$[m]', labelpad=0, fontsize=8)\nf2_ax1.tick_params(axis='both', which='both', pad=0, labelsize=6)\n\nf2_ax2.set_title('Nyquist diagram', fontsize=9)\nf2_ax2.set_xlabel(r'Re', labelpad=0, fontsize=8)\nf2_ax2.set_ylabel(r'Im', labelpad=0, fontsize=8)\nf2_ax2.tick_params(axis='both', which='both', pad=0, labelsize=6)\n\nf2_ax3.set_title('Bode magnitude plot', fontsize=9)\nf2_ax3.set_xscale('log')\nf2_ax3.set_xlabel(r'$f\\/$[Hz]', labelpad=0, fontsize=8)\nf2_ax3.set_ylabel(r'$A\\/$[dB]', labelpad=0, fontsize=8)\nf2_ax3.tick_params(axis='both', which='both', pad=0, labelsize=6)\n\nf2_ax4.set_title('Closed loop impulse response', fontsize=9)\nf2_ax4.set_xlabel(r'$t\\/$[s]', labelpad=0, fontsize=8)\nf2_ax4.set_ylabel(r'$x\\/$[m]', labelpad=0, fontsize=8)\nf2_ax4.tick_params(axis='both', which='both', pad=0, labelsize=6)\n\nf2_ax5.set_title('Open loop step response', fontsize=9)\nf2_ax5.set_xlabel(r'$t\\/$[s]', labelpad=0, fontsize=8)\nf2_ax5.set_ylabel(r'$x\\/$[m]', labelpad=0, fontsize=8)\nf2_ax5.tick_params(axis='both', which='both', pad=0, labelsize=6)\n\nf2_ax6.set_title('Bode phase plot', fontsize=9)\nf2_ax6.set_xscale('log')\nf2_ax6.set_xlabel(r'$f\\/$[Hz]', labelpad=0, fontsize=8)\nf2_ax6.set_ylabel(r'$\\phi\\/$[°]', labelpad=0, fontsize=8)\nf2_ax6.tick_params(axis='both', which='both', pad=0, labelsize=6)\n\ndef pid_control(Kp, Ti, Td, Fd, type_select, Im, Re):\n    \n    W_sys = c.tf([1], [1, 2*Re, (Re+Im*1j)*(Re-Im*1j)])\n    \n    if type_select in (1, 3, 4):\n        Ti0 = 1\n    else:\n        Ti0 = 0\n        \n    if type_select in (2, 3, 4):\n        Td0 = 1\n    else :\n        Td0 = 0\n        \n    if type_select == 4:\n        Fd0 = 1\n    else:\n        Fd0 = 0\n    \n    # PID Controller\n    \n    P = Kp             # Proportional term\n    I = Kp / Ti        # Integral term\n    D = Kp * Td        # Derivative term\n    Td_f = Td / Fd     # Derivative term filter\n    \n    W_PID = c.parallel(c.tf([P], [1]),\n                       c.tf([I * Ti0], [1 * Ti0, 1 * (not Ti0)]),\n                       c.tf([D * Td0, 0], [Td_f * Td0 * Fd0, 1]))  # PID controller in time constant format\n    \n    W_open = c.series(W_PID, W_sys)         # Open loop\n    W_closed = c.feedback(W_open, 1, -1)    # Closed loop with negative feedback\n                        \n    # Display\n                        \n    global f2_line1, f2_line2, f2_line3, f2_line4, f2_line5, f2_line6\n    \n    f2_ax1.lines.remove(f2_line1)\n    f2_ax2.lines.remove(f2_line2)\n    f2_ax3.lines.remove(f2_line3)\n    f2_ax4.lines.remove(f2_line4)\n    f2_ax5.lines.remove(f2_line5)\n    f2_ax6.lines.remove(f2_line6)\n    \n    tout, yout = c.step_response(W_closed)\n    f2_line1, = f2_ax1.plot(tout, yout, lw=1, color='blue') \n\n    _, _, ob = c.nyquist_plot(W_open, Plot=False)   # Small resolution plot to determine bounds        \n    real, imag, freq = c.nyquist_plot(W_open, omega=np.logspace(np.log10(ob[0]), np.log10(ob[-1]), 1000), Plot=False)\n    f2_line2, = f2_ax2.plot(real, imag, lw=1, color='blue')\n    \n    mag, phase, omega = c.bode_plot(W_open, Plot=False)\n    f2_line3, = f2_ax3.plot(omega/2/np.pi, 20*np.log10(mag), lw=1, color='blue')\n    f2_line6, = f2_ax6.plot(omega/2/np.pi, phase*180/np.pi, lw=1, color='blue')\n\n    tout, yout = c.impulse_response(W_closed)\n    f2_line4, = f2_ax4.plot(tout, yout, lw=1, color='blue')   \n    \n    tout, yout = c.step_response(W_open)\n    f2_line5, = f2_ax5.plot(tout, yout, lw=1, color='blue') \n    \n    f2_ax1.relim()\n    f2_ax2.relim()\n    f2_ax3.relim()\n    f2_ax4.relim()\n    f2_ax5.relim()\n    f2_ax6.relim()\n    f2_ax1.autoscale_view()\n    f2_ax2.autoscale_view()\n    f2_ax3.autoscale_view()\n    f2_ax4.autoscale_view()\n    f2_ax5.autoscale_view()\n    f2_ax6.autoscale_view()\n    \n# GUI widgets\n\ndef draw_controllers(type_select):\n    \n    global Kp_slider\n    global Ti_slider\n    global Td_slider\n    global Fd_slider\n    \n    Kp_slider = w.FloatLogSlider(value=0.5, base=10, min=-1, max=4, description='Kp:', continuous_update=False,\n                                 layout=w.Layout(width='auto', flex='5 5 auto'))\n    \n    if type_select in (1, 3, 4):\n        Ti_slider = w.FloatLogSlider(value=0.0035, base=10, min=-4, max=1, description='Ti:', continuous_update=False,\n                                     layout=w.Layout(width='auto', flex='5 5 auto'))\n    else:\n        Ti_slider = w.FloatLogSlider(value=0.0035, base=10, min=-4, max=1, description='Ti:', continuous_update=False,\n                                     layout=w.Layout(width='auto', flex='5 5 auto'), disabled=True)\n        \n    if type_select in (2, 3, 4):\n        Td_slider = w.FloatLogSlider(value=1, base=10, min=-4, max=1, description='Td:', continuous_update=False,\n                                     layout=w.Layout(width='auto', flex='5 5 auto'))\n    else:\n        Td_slider = w.FloatLogSlider(value=1, base=10, min=-4, max=1, description='Td:', continuous_update=False,\n                                     layout=w.Layout(width='auto', flex='5 5 auto'), disabled=True)\n    \n    if type_select == 4:\n        Fd_slider = w.FloatLogSlider(value=1, base=10, min=0, max=3, description='Fd:', continuous_update=False,\n                                     layout=w.Layout(width='auto', flex='5 5 auto'))\n    else:\n        Fd_slider = w.FloatLogSlider(value=1, base=10, min=0, max=3, description='Fd:', continuous_update=False,\n                                     layout=w.Layout(width='auto', flex='5 5 auto'), disabled=True)\n\n\n    input_data = w.interactive_output(pid_control, {'Kp': Kp_slider, 'Ti': Ti_slider, 'Td': Td_slider,\n                                      'Fd': Fd_slider, 'type_select':typeSelect, 'Im':Im_slider, 'Re':Re_slider})\n\n    display(w.HBox([Kp_slider, Ti_slider, Td_slider, Fd_slider]), input_data)\n    \nw.interactive_output(draw_controllers, {'type_select':typeSelect})\n\n\n\n\n\n\n\n\n\n\nYou can test the controlled system’s signal following capabilities using the simulated scope. Readjust your controller so that it can follow a sine wave acceptably!  (The animations are scaled to fit the frame through the whole simulation. Because of this, unstable solutions might not seem to move until the very last second.)\n\n# Simulation data\n\nanim_fig = plt.figure()\nanim_fig.set_size_inches((9.8, 4))\nanim_fig.set_tight_layout(True)\n\nanim_ax1 = anim_fig.add_subplot(111)\n\nframe_count=1000\nscope_rounds=4\n\nl1 = anim_ax1.plot([], [], lw=1, color='blue')\nl2 = anim_ax1.plot([], [], lw=2, color='red')\n\nline1 = l1[0]\nline2 = l2[0]\n\nanim_ax1.legend(l1+l2, ['Reference', 'Output'], loc=1)\n\nanim_ax1.set_title('Scope', fontsize=12)\nanim_ax1.set_xlabel(r'$t\\/$[s]', labelpad=0, fontsize=10)\nanim_ax1.set_ylabel(r'$y\\/$[/]', labelpad=0, fontsize=10)\nanim_ax1.tick_params(axis='both', which='both', pad=0, labelsize=8)\n\nanim_ax1.grid(which='both', axis='both', color='lightgray')\n\nT_plot = []\nX_plot = []\nR_plot = []\n\n#Simulation function\n\ndef simulation(Kp, Ti, Td, Fd, type_select, Im, Re, T, dt, X, Xf, Xa):\n    \n    W_sys = c.tf([1], [1, 2*Re, (Re+Im*1j)*(Re-Im*1j)])\n    \n    if type_select in (1, 3, 4):\n        Ti0 = 1\n    else:\n        Ti0 = 0\n        \n    if type_select in (2, 3, 4):\n        Td0 = 1\n    else :\n        Td0 = 0\n        \n    if type_select == 4:\n        Fd0 = 1\n    else:\n        Fd0 = 0\n    \n    # Controller\n    P = Kp            # Proportional term\n    I = Kp / Ti       # Integral term\n    D = Kp * Td       # Derivative term\n    Td_f = Td * Fd    # Derivative term filter\n    \n    W_PID = c.parallel(c.tf([P], [1]),\n                       c.tf([I * Ti0], [1 * Ti0, 1 * (not Ti0)]),\n                       c.tf([D * Td0, 0], [Td_f * Td0 * Fd0, 1]))    # PID controller\n    \n    # Model\n    W_open = c.series(W_PID, W_sys)         # Open loop\n    W_closed = c.feedback(W_open, 1, -1)    # Closed loop with negative feedback\n    \n    # Reference and disturbance signals\n\n    T_sim = np.arange(0, T, dt, dtype=np.float64)\n    \n    if X == 0:   # Sine wave reference\n        X_sim = np.sin(2 * np.pi * Xf * T_sim) * Xa\n    elif X == 1:   # Square wave reference\n        X_sim = np.sign(np.sin(2 * np.pi * Xf * T_sim)) * Xa\n    \n    # System response\n        \n    Tx, youtx, xoutx = c.forced_response(W_closed, T_sim, X_sim)\n    R_sim = youtx\n    \n    # Display\n    \n    XR_max = max(np.amax(np.absolute(np.concatenate((X_sim, R_sim)))), Xa)\n    \n    anim_ax1.set_ylim((-1.2 * XR_max, 1.2 * XR_max))\n    \n    global T_plot, X_plot, R_plot\n    \n    T_plot = np.linspace(0, T, frame_count*(scope_rounds+1), dtype=np.float32)\n    X_plot = np.interp(T_plot, T_sim, X_sim)\n    R_plot = np.interp(T_plot, T_sim, R_sim)\n        \ndef anim_init():\n    line1.set_data([], [])\n    line2.set_data([], [])\n    anim_ax1.set_xlim((0, T_plot[frame_count-1]))\n    \n    return (line1, line2, anim_ax1,)\n\ndef animate(i):\n    line1.set_data(T_plot[scope_rounds*i:scope_rounds*i+frame_count-1], X_plot[scope_rounds*i:scope_rounds*i+frame_count-1])\n    line2.set_data(T_plot[scope_rounds*i:scope_rounds*i+frame_count-1], R_plot[scope_rounds*i:scope_rounds*i+frame_count-1])\n    anim_ax1.set_xlim((T_plot[i*scope_rounds], T_plot[i*scope_rounds+frame_count-1]))\n    \n    return (line1, line2, anim_ax1,)\n\nanim = animation.FuncAnimation(anim_fig, animate, init_func=anim_init,\n                               frames=frame_count, interval=10, blit=True,\n                               repeat=True)\n\n# Controllers\n\nT_slider = w.FloatLogSlider(value=10, base=10, min=-0.7, max=1, step=0.01,\n                            description='Duration [s]:', continuous_update=False,\n                            orientation='vertical', layout=w.Layout(width='auto', height='auto', flex='1 1 auto'))\n\ndt_slider = w.FloatLogSlider(value=0.1, base=10, min=-3, max=-1, step=0.01,\n                             description='Timestep [s]:', continuous_update=False,\n                             orientation='vertical', layout=w.Layout(width='auto', height='auto', flex='1 1 auto'))\n       \nX_type = w.Dropdown(options=[('Sine', 0), ('Square', 1)], value=1,\n                    description='Reference: ', continuous_update=False, layout=w.Layout(width='auto', flex='3 3 auto'))    \nXf_slider = w.FloatLogSlider(value=0.5, base=10, min=-2, max=2, step=0.01,\n                             description='Frequency [Hz]:', continuous_update=False,\n                             orientation='vertical', layout=w.Layout(width='auto', height='auto', flex='1 1 auto'))\nXa_slider = w.FloatLogSlider(value=1, base=10, min=-2, max=2, step=0.01,\n                             description='Amplitude [/]:', continuous_update=False,\n                             orientation='vertical', layout=w.Layout(width='auto', height='auto', flex='1 1 auto'))    \n\ninput_data = w.interactive_output(simulation, {'Kp': Kp_slider, 'Ti': Ti_slider, 'Td': Td_slider,'Fd': Fd_slider,\n                                               'type_select': typeSelect, 'Im': Im_slider, 'Re':Re_slider,\n                                               'T': T_slider, 'dt': dt_slider,\n                                               'X': X_type, 'Xf': Xf_slider, 'Xa': Xa_slider})\n\ndisplay(w.HBox([w.HBox([T_slider, dt_slider], layout=w.Layout(width='25%')),\n                w.Box([], layout=w.Layout(width='5%')),\n                w.VBox([X_type, w.HBox([Xf_slider, Xa_slider])], layout=w.Layout(width='30%')),\n                w.Box([], layout=w.Layout(width='5%'))],\n                layout=w.Layout(width='100%', justify_content='center')), input_data)\n\n\n\n\n\n\n\n\n\n\n\n\n\nThe duration parameter controls the simulated timeframe and does not affect the runtime of the animation. In contrast, the timestep controls the model sampling and can refine the results in exchange for higher computational resources."
  },
  {
    "objectID": "ICCT_en/examples/03/FD-13_PID_Disturbance_Rejection.html",
    "href": "ICCT_en/examples/03/FD-13_PID_Disturbance_Rejection.html",
    "title": "PID controller Disturbance Rejection",
    "section": "",
    "text": "%matplotlib notebook\nimport control as c\nimport ipywidgets as w\nimport numpy as np\n\nfrom IPython.display import display, HTML\nimport matplotlib.pyplot as plt\nimport matplotlib.animation as animation\n\ndisplay(HTML('&lt;script&gt; $(document).ready(function() { $(\"div.input\").hide(); }); &lt;/script&gt;'))\n\n\n\n\nIn the following example, we examine the disturbance rejecting capabilities of a PID controller in a negative feedback system, where the disturbance enters the system at its output.\nFor the test, we are using an underdamped second-order model:  \\[G(s)=\\frac{1}{s^2+2R_es+(R_e+I_m j)\\cdot(R_e-I_m j)}\\]  The disturbance signal can be added after the system (as presented in the figure) or in-between the plant and the controller: \nChoose the complex components for the poles of the system!\n\n# Figure definition\n\nfig1, ((f1_ax1), (f1_ax2)) = plt.subplots(2, 1)\nfig1.set_size_inches((9.8, 5))\nfig1.set_tight_layout(True)\n\nf1_line1, = f1_ax1.plot([], [])\nf1_line2, = f1_ax2.plot([], [])  \n\nf1_ax1.grid(which='both', axis='both', color='lightgray')\nf1_ax2.grid(which='both', axis='both', color='lightgray')\n\nf1_ax1.autoscale(enable=True, axis='both', tight=True)\nf1_ax2.autoscale(enable=True, axis='both', tight=True)\n\nf1_ax1.set_title('Bode magnitude plot', fontsize=11)\nf1_ax1.set_xscale('log')\nf1_ax1.set_xlabel(r'$f\\/$[Hz]', labelpad=0, fontsize=10)\nf1_ax1.set_ylabel(r'$A\\/$[dB]', labelpad=0, fontsize=10)\nf1_ax1.tick_params(axis='both', which='both', pad=0, labelsize=8)\n\nf1_ax2.set_title('Bode phase plot', fontsize=11)\nf1_ax2.set_xscale('log')\nf1_ax2.set_xlabel(r'$f\\/$[Hz]', labelpad=0, fontsize=10)\nf1_ax2.set_ylabel(r'$\\phi\\/$[°]', labelpad=0, fontsize=10)\nf1_ax2.tick_params(axis='both', which='both', pad=0, labelsize=8)   \n\n\n# System model\n\ndef system_model(Im, Re):\n\n    W_sys = c.tf([1], [1, 2*Re, (Re+Im*1j)*(Re-Im*1j)])\n\n    print('System transfer function:')\n    print(W_sys)\n\n    # System analysis\n\n    poles = c.pole(W_sys)     # Poles\n\n    print('System poles:\\n')\n    print(poles)\n    \n    global f1_line1, f1_line2\n    \n    f1_ax1.lines.remove(f1_line1)\n    f1_ax2.lines.remove(f1_line2)\n\n    mag, phase, omega = c.bode_plot(W_sys, Plot=False)   # Bode-plot\n\n    f1_line1, = f1_ax1.plot(omega/2/np.pi, 20*np.log10(mag), lw=1, color='blue')\n    f1_line2, = f1_ax2.plot(omega/2/np.pi, phase*180/np.pi, lw=1, color='blue')   \n\n    f1_ax1.relim()\n    f1_ax2.relim()\n    f1_ax1.autoscale_view()\n    f1_ax2.autoscale_view()\n    \n# GUI widgets\n    \nRe_slider = w.FloatLogSlider(value=0.1, base=10, min=-4, max=1, description='Pole.Re (negative) :', continuous_update=False,\n                             layout=w.Layout(width='75%'), style={'description_width':'50%'})\nIm_slider = w.FloatLogSlider(value=0.1, base=10, min=-4, max=1, description='Pole.Im :', continuous_update=False,\n                             layout=w.Layout(width='75%'), style={'description_width':'50%'})\n\ninput_data = w.interactive_output(system_model, {'Re':Re_slider, 'Im':Im_slider})\n\ndisplay(w.HBox([Re_slider, Im_slider]), input_data)\n\n\n\n\n\n\n\n\n\n\n\n\n\nAfter observing the system characteristics, select a controller type!\n\n#Controller type select\n\ntypeSelect = w.ToggleButtons(\n    options=[('P', 0), ('PI', 1), ('PD', 2), ('PID', 3), ('PID Realistic', 4)],\n    description='Controller type: ', style={'description_width':'15%'})\n\ndisplay(typeSelect)\n\n\n\n\nTune the selected controller so that the effect of the disturbance is minimized! While the objective is to keep the effect of the disturbance minimal, the controller is still supposed to serve its purpose!\n\n# PID control\n\n# Figure definition\nfig2, ((f2_ax1, f2_ax2, f2_ax3), (f2_ax4, f2_ax5, f2_ax6)) = plt.subplots(2, 3)\nfig2.set_size_inches((9.8, 5))\nfig2.set_tight_layout(True)\n\nf2_line1, = f2_ax1.plot([], [])\nf2_line2, = f2_ax2.plot([], []) \nf2_line3, = f2_ax3.plot([], [])\nf2_line4, = f2_ax4.plot([], [])  \nf2_line5, = f2_ax5.plot([], [])\nf2_line6, = f2_ax6.plot([], [])\n\nf2_ax1.grid(which='both', axis='both', color='lightgray')\nf2_ax2.grid(which='both', axis='both', color='lightgray')\nf2_ax3.grid(which='both', axis='both', color='lightgray')\nf2_ax4.grid(which='both', axis='both', color='lightgray')\nf2_ax5.grid(which='both', axis='both', color='lightgray')\nf2_ax6.grid(which='both', axis='both', color='lightgray')\n\nf2_ax1.autoscale(enable=True, axis='both', tight=True)\nf2_ax2.autoscale(enable=True, axis='both', tight=True)\nf2_ax3.autoscale(enable=True, axis='both', tight=True)\nf2_ax4.autoscale(enable=True, axis='both', tight=True)\nf2_ax5.autoscale(enable=True, axis='both', tight=True)\nf2_ax6.autoscale(enable=True, axis='both', tight=True)\n\nf2_ax1.set_title('Closed loop step response', fontsize=9)\nf2_ax1.set_xlabel(r'$t\\/$[s]', labelpad=0, fontsize=8)\nf2_ax1.set_ylabel(r'$x\\/$[m]', labelpad=0, fontsize=8)\nf2_ax1.tick_params(axis='both', which='both', pad=0, labelsize=6)\n\nf2_ax2.set_title('Nyquist diagram', fontsize=9)\nf2_ax2.set_xlabel(r'Re', labelpad=0, fontsize=8)\nf2_ax2.set_ylabel(r'Im', labelpad=0, fontsize=8)\nf2_ax2.tick_params(axis='both', which='both', pad=0, labelsize=6)\n\nf2_ax3.set_title('Bode magnitude plot', fontsize=9)\nf2_ax3.set_xscale('log')\nf2_ax3.set_xlabel(r'$f\\/$[Hz]', labelpad=0, fontsize=8)\nf2_ax3.set_ylabel(r'$A\\/$[dB]', labelpad=0, fontsize=8)\nf2_ax3.tick_params(axis='both', which='both', pad=0, labelsize=6)\n\nf2_ax4.set_title('Disturbance step response', fontsize=9)\nf2_ax4.set_xlabel(r'$t\\/$[s]', labelpad=0, fontsize=8)\nf2_ax4.set_ylabel(r'$x\\/$[m]', labelpad=0, fontsize=8)\nf2_ax4.tick_params(axis='both', which='both', pad=0, labelsize=6)\n\nf2_ax5.set_title('Disturbance impulse response', fontsize=9)\nf2_ax5.set_xlabel(r'$t\\/$[s]', labelpad=0, fontsize=8)\nf2_ax5.set_ylabel(r'$x\\/$[m]', labelpad=0, fontsize=8)\nf2_ax5.tick_params(axis='both', which='both', pad=0, labelsize=6)\n\nf2_ax6.set_title('Bode phase plot', fontsize=9)\nf2_ax6.set_xscale('log')\nf2_ax6.set_xlabel(r'$f\\/$[Hz]', labelpad=0, fontsize=8)\nf2_ax6.set_ylabel(r'$\\phi\\/$[°]', labelpad=0, fontsize=8)\nf2_ax6.tick_params(axis='both', which='both', pad=0, labelsize=6)\n\ndef pid_control(Kp, Ti, Td, Fd, type_select, Im, Re):\n    \n    W_sys = c.tf([1], [1, 2*Re, (Re+Im*1j)*(Re-Im*1j)])\n    \n    if type_select in (1, 3, 4):\n        Ti0 = 1\n    else:\n        Ti0 = 0\n        \n    if type_select in (2, 3, 4):\n        Td0 = 1\n    else :\n        Td0 = 0\n        \n    if type_select == 4:\n        Fd0 = 1\n    else:\n        Fd0 = 0\n    \n    # PID Controller\n    \n    P = Kp             # Proportional term\n    I = Kp / Ti        # Integral term\n    D = Kp * Td        # Derivative term\n    Td_f = Td / Fd     # Derivative term filter\n    \n    W_PID = c.parallel(c.tf([P], [1]),\n                       c.tf([I * Ti0], [1 * Ti0, 1 * (not Ti0)]),\n                       c.tf([D * Td0, 0], [Td_f * Td0 * Fd0, 1]))  # PID controller in time constant format\n    \n    W_open = c.series(W_PID, W_sys)         # Open loop\n    W_closed = c.feedback(W_open, 1, -1)    # Closed loop with negative feedback\n    \n    W_load = c.feedback(W_sys, W_PID, -1)   # Transfer function of the disturbance based errors  \n                        \n    # Display\n                        \n    global f2_line1, f2_line2, f2_line3, f2_line4, f2_line5, f2_line6\n    \n    f2_ax1.lines.remove(f2_line1)\n    f2_ax2.lines.remove(f2_line2)\n    f2_ax3.lines.remove(f2_line3)\n    f2_ax4.lines.remove(f2_line4)\n    f2_ax5.lines.remove(f2_line5)\n    f2_ax6.lines.remove(f2_line6)\n    \n    tout, yout = c.step_response(W_closed)\n    f2_line1, = f2_ax1.plot(tout, yout, lw=1, color='blue') \n\n    _, _, ob = c.nyquist_plot(W_open, Plot=False)   # Small resolution plot to determine bounds        \n    real, imag, freq = c.nyquist_plot(W_open, omega=np.logspace(np.log10(ob[0]), np.log10(ob[-1]), 1000), Plot=False)\n    f2_line2, = f2_ax2.plot(real, imag, lw=1, color='blue')\n    \n    mag, phase, omega = c.bode_plot(W_open, Plot=False)\n    f2_line3, = f2_ax3.plot(omega/2/np.pi, 20*np.log10(mag), lw=1, color='blue')\n    f2_line6, = f2_ax6.plot(omega/2/np.pi, phase*180/np.pi, lw=1, color='blue')\n\n    tout, yout = c.step_response(W_load)\n    f2_line4, = f2_ax4.plot(tout, yout, lw=1, color='blue')   \n    \n    tout, yout = c.impulse_response(W_load)\n    f2_line5, = f2_ax5.plot(tout, yout, lw=1, color='blue') \n    \n    f2_ax1.relim()\n    f2_ax2.relim()\n    f2_ax3.relim()\n    f2_ax4.relim()\n    f2_ax5.relim()\n    f2_ax6.relim()\n    f2_ax1.autoscale_view()\n    f2_ax2.autoscale_view()\n    f2_ax3.autoscale_view()\n    f2_ax4.autoscale_view()\n    f2_ax5.autoscale_view()\n    f2_ax6.autoscale_view()\n    \n# GUI widgets\n\ndef draw_controllers(type_select):\n    \n    global Kp_slider\n    global Ti_slider\n    global Td_slider\n    global Fd_slider\n    \n    Kp_slider = w.FloatLogSlider(value=0.5, base=10, min=-1, max=4, description='Kp:', continuous_update=False,\n                                 layout=w.Layout(width='auto', flex='5 5 auto'))\n    \n    if type_select in (1, 3, 4):\n        Ti_slider = w.FloatLogSlider(value=0.0035, base=10, min=-4, max=1, description='Ti:', continuous_update=False,\n                                     layout=w.Layout(width='auto', flex='5 5 auto'))\n    else:\n        Ti_slider = w.FloatLogSlider(value=0.0035, base=10, min=-4, max=1, description='Ti:', continuous_update=False,\n                                     layout=w.Layout(width='auto', flex='5 5 auto'), disabled=True)\n        \n    if type_select in (2, 3, 4):\n        Td_slider = w.FloatLogSlider(value=1, base=10, min=-4, max=1, description='Td:', continuous_update=False,\n                                     layout=w.Layout(width='auto', flex='5 5 auto'))\n    else:\n        Td_slider = w.FloatLogSlider(value=1, base=10, min=-4, max=1, description='Td:', continuous_update=False,\n                                     layout=w.Layout(width='auto', flex='5 5 auto'), disabled=True)\n    \n    if type_select == 4:\n        Fd_slider = w.FloatLogSlider(value=1, base=10, min=0, max=3, description='Fd:', continuous_update=False,\n                                     layout=w.Layout(width='auto', flex='5 5 auto'))\n    else:\n        Fd_slider = w.FloatLogSlider(value=1, base=10, min=0, max=3, description='Fd:', continuous_update=False,\n                                     layout=w.Layout(width='auto', flex='5 5 auto'), disabled=True)\n\n\n    input_data = w.interactive_output(pid_control, {'Kp': Kp_slider, 'Ti': Ti_slider, 'Td': Td_slider,\n                                      'Fd': Fd_slider, 'type_select':typeSelect, 'Im':Im_slider, 'Re':Re_slider})\n\n    display(w.HBox([Kp_slider, Ti_slider, Td_slider, Fd_slider]), input_data)\n    \nw.interactive_output(draw_controllers, {'type_select':typeSelect})\n\n\n\n\n\n\n\n\n\n\nYou can test the controlled system’s signal following capabilities using the simulated scope while also applying disturbing signals. Readjust your controller so that it can follow a sine wave acceptably, but with a detectable level of disturbance!  (The animations are scaled to fit the frame through the whole simulation. Because of this, unstable solutions might not seem to move until the very last second.)\n\n# Simulation data\n\nanim_fig = plt.figure()\nanim_fig.set_size_inches((9.8, 4))\nanim_fig.set_tight_layout(True)\n\nanim_ax1 = anim_fig.add_subplot(111)\nanim_ax2 = anim_ax1.twinx()\n\nframe_count=1000\nscope_rounds=4\n\nl1 = anim_ax1.plot([], [], lw=1, color='blue')\nl2 = anim_ax1.plot([], [], lw=2, color='red')\nl3 = anim_ax2.plot([], [], lw=1, color='grey')\n\nline1 = l1[0]\nline2 = l2[0]\nline3 = l3[0]\n\nanim_ax1.legend(l1+l2+l3, ['Reference', 'Output', 'Disturbance'], loc=1)\n\nanim_ax1.set_title('Scope', fontsize=12)\nanim_ax1.set_xlabel(r'$t\\/$[s]', labelpad=0, fontsize=10)\nanim_ax1.set_ylabel(r'$x\\/$[/]', labelpad=0, fontsize=10)\nanim_ax1.tick_params(axis='both', which='both', pad=0, labelsize=8)\nanim_ax2.set_ylabel(r'$d\\/$[/]', labelpad=0, fontsize=10)\nanim_ax2.tick_params(axis='both', which='both', pad=0, labelsize=8)\n\nanim_ax1.grid(which='both', axis='both', color='lightgray')\n\nT_plot = []\nX_plot = []\nL_plot = []\nR_plot = []\n\n\n#Simulation function\n\ndef simulation(Kp, Ti, Td, Fd, type_select, Im, Re, T, dt, X, Xf, Xa, L, Lf, La, Lo):\n    \n    W_sys = c.tf([1], [1, 2*Re, (Re+Im*1j)*(Re-Im*1j)])\n    \n    if type_select in (1, 3, 4):\n        Ti0 = 1\n    else:\n        Ti0 = 0\n        \n    if type_select in (2, 3, 4):\n        Td0 = 1\n    else :\n        Td0 = 0\n        \n    if type_select == 4:\n        Fd0 = 1\n    else:\n        Fd0 = 0\n    \n    # Controller\n    P = Kp            # Proportional term\n    I = Kp / Ti       # Integral term\n    D = Kp * Td       # Derivative term\n    Td_f = Td * Fd    # Derivative term filter\n    \n    W_PID = c.parallel(c.tf([P], [1]),\n                       c.tf([I * Ti0], [1 * Ti0, 1 * (not Ti0)]),\n                       c.tf([D * Td0, 0], [Td_f * Td0 * Fd0, 1]))    # PID controller\n    \n    # Model\n    W_open = c.series(W_PID, W_sys)         # Open loop\n    W_closed = c.feedback(W_open, 1, -1)    # Closed loop with negative feedback\n    \n    W_load = c.feedback(W_sys, W_PID, -1)   # Transfer function of the disturbance based errors  \n    \n    # Reference and disturbance signals\n\n    T_sim = np.arange(0, T, dt, dtype=np.float64)\n    \n    if X == 0:   # Sine wave reference\n        X_sim = np.sin(2 * np.pi * Xf * T_sim) * Xa\n    elif X == 1:   # Square wave reference\n        X_sim = np.sign(np.sin(2 * np.pi * Xf * T_sim)) * Xa\n        \n    if L == 0:     # Constant load\n        L_sim = np.full_like(T_sim, La * Lo)\n    elif L == 1:   # Sine wave load\n        L_sim = (np.sin(2 * np.pi * Lf * T_sim) + Lo) * La\n    elif L == 2:   # Square wave load\n        L_sim = (np.sign(np.sin(2 * np.pi * Lf * T_sim)) + Lo) * La\n    elif L_type.value == 3:   # Noise form load\n        L_sim = np.interp(T_sim, np.linspace(0, T, int(T * Lf) + 2),\n                          np.random.normal(loc=(Lo * La), scale=La, size=int(T * Lf) + 2))\n    \n    # System response\n    \n    Tx, youtx, xoutx = c.forced_response(W_closed, T_sim, X_sim)\n    Tl, youtl, xoutl = c.forced_response(W_load, T_sim, L_sim)\n    R_sim = np.nan_to_num(youtx + youtl)\n    \n    # Display\n    \n    XR_max = max(np.amax(np.absolute(np.concatenate((X_sim, R_sim)))), Xa)\n    L_max = max(np.amax(np.absolute(L_sim)), La)\n    \n    anim_ax1.set_xlim((0, T))\n    anim_ax1.set_ylim((-1.2 * XR_max, 1.2 * XR_max))\n    anim_ax2.set_ylim((-1.5 * L_max, 1.5 * L_max))\n    \n    global T_plot, X_plot, L_plot, R_plot\n    \n    T_plot = np.linspace(0, T, frame_count*(scope_rounds+1), dtype=np.float32)\n    X_plot = np.interp(T_plot, T_sim, X_sim)\n    L_plot = np.interp(T_plot, T_sim, L_sim)\n    R_plot = np.interp(T_plot, T_sim, R_sim)\n        \ndef anim_init():\n    line1.set_data([], [])\n    line2.set_data([], [])\n    line3.set_data([], [])\n    anim_ax1.set_xlim((0, T_plot[frame_count-1]))\n    \n    return (line1, line2, line3, anim_ax1,)\n\ndef animate(i):\n    line1.set_data(T_plot[scope_rounds*i:scope_rounds*i+frame_count-1], X_plot[scope_rounds*i:scope_rounds*i+frame_count-1])\n    line2.set_data(T_plot[scope_rounds*i:scope_rounds*i+frame_count-1], R_plot[scope_rounds*i:scope_rounds*i+frame_count-1])\n    line3.set_data(T_plot[scope_rounds*i:scope_rounds*i+frame_count-1], L_plot[scope_rounds*i:scope_rounds*i+frame_count-1])\n    anim_ax1.set_xlim((T_plot[i*scope_rounds], T_plot[i*scope_rounds+frame_count-1]))\n    \n    return (line1, line2, line3, anim_ax1,)\n\nanim = animation.FuncAnimation(anim_fig, animate, init_func=anim_init,\n                               frames=frame_count, interval=10, blit=True,\n                               repeat=True)\n\n# Controllers\n\nT_slider = w.FloatLogSlider(value=10, base=10, min=-0.7, max=1, step=0.01,\n                            description='Duration [s]:', continuous_update=False,\n                            orientation='vertical', layout=w.Layout(width='auto', height='auto', flex='1 1 auto'))\n\ndt_slider = w.FloatLogSlider(value=0.1, base=10, min=-3, max=-1, step=0.01,\n                             description='Timestep [s]:', continuous_update=False,\n                             orientation='vertical', layout=w.Layout(width='auto', height='auto', flex='1 1 auto'))\n       \nX_type = w.Dropdown(options=[('Sine', 0), ('Square', 1)], value=1,\n                    description='Reference: ', continuous_update=False, layout=w.Layout(width='auto', flex='3 3 auto'))    \nXf_slider = w.FloatLogSlider(value=0.5, base=10, min=-2, max=2, step=0.01,\n                             description='Frequency [Hz]:', continuous_update=False,\n                             orientation='vertical', layout=w.Layout(width='auto', height='auto', flex='1 1 auto'))\nXa_slider = w.FloatLogSlider(value=1, base=10, min=-2, max=2, step=0.01,\n                             description='Amplitude [/]:', continuous_update=False,\n                             orientation='vertical', layout=w.Layout(width='auto', height='auto', flex='1 1 auto'))   \n\nL_type = w.Dropdown(options=[('Constant', 0), ('Sine', 1), ('Square', 2), ('Noise', 3)], value=2,\n                     description='Load: ', continuous_update=False, layout=w.Layout(width='auto', flex='3 3 auto'))    \nLf_slider = w.FloatLogSlider(value=1, base=10, min=-2, max=2, step=0.01,\n                             description='Frequency [Hz]:', continuous_update=False,\n                             orientation='vertical', layout=w.Layout(width='auto', height='auto', flex='1 1 auto'))\nLa_slider = w.FloatLogSlider(value=0.1, base=10, min=-2, max=2, step=0.01,\n                             description='Amplitude [/]:', continuous_update=False,\n                             orientation='vertical', layout=w.Layout(width='auto', height='auto', flex='1 1 auto'))\nLo_slider = w.FloatSlider(value=0, min=-10, max=10, description='Offset/Ampl:', continuous_update=False,\n                              orientation='vertical', layout=w.Layout(width='auto', height='auto', flex='1 1 auto'))\n\ninput_data = w.interactive_output(simulation, {'Kp': Kp_slider, 'Ti': Ti_slider, 'Td': Td_slider,'Fd': Fd_slider,\n                                               'type_select': typeSelect, 'Im': Im_slider, 'Re':Re_slider,\n                                               'T': T_slider, 'dt': dt_slider,\n                                               'X': X_type, 'Xf': Xf_slider, 'Xa': Xa_slider,\n                                               'L': L_type, 'Lf': Lf_slider, 'La': La_slider, 'Lo': Lo_slider})\n\ndisplay(w.HBox([w.HBox([T_slider, dt_slider], layout=w.Layout(width='25%')),\n                w.Box([], layout=w.Layout(width='5%')),\n                w.VBox([X_type, w.HBox([Xf_slider, Xa_slider])], layout=w.Layout(width='30%')),\n                w.Box([], layout=w.Layout(width='5%')),\n                w.VBox([L_type, w.HBox([Lf_slider, La_slider, Lo_slider])], layout=w.Layout(width='30%'))],\n                layout=w.Layout(width='100%', justify_content='center')), input_data)\n\n\n\n\n\n\n\n\n\n\n\n\n\nThe duration parameter controls the simulated timeframe and does not affect the runtime of the animation. In contrast, the timestep controls the model sampling and can refine the results in exchange for higher computational resources."
  },
  {
    "objectID": "ICCT_en/examples/03/FD-15_Discrete_PID_Control_of_Continuous_Second-Order_Systems.html",
    "href": "ICCT_en/examples/03/FD-15_Discrete_PID_Control_of_Continuous_Second-Order_Systems.html",
    "title": "Discrete PID control of a Second-Order system",
    "section": "",
    "text": "%matplotlib notebook\nimport control as c\nimport ipywidgets as w\nimport numpy as np\n\nfrom IPython.display import display, HTML\nimport matplotlib.pyplot as plt\nimport matplotlib.animation as animation\n\ndisplay(HTML('&lt;script&gt; $(document).ready(function() { $(\"div.input\").hide(); }); &lt;/script&gt;'))\n\n\n\n\nIn the following example, we will explore the effect of discrete-time sampling on a PID controller driven, underdamped, second-order system. The PID controller is designed and tuned with continuous-time parameters, but it is then converted to discrete-time by a zero-order hold (ZOH) or pole matching. The controller signal is returned to continuous time using yet another ZOH and is then supplied to the system.\n \\[G(s)=\\frac{1}{s^2+2R_es+(R_e+I_m j)\\cdot(R_e-I_m j)}\\]    Choose the complex components for the poles of the system and a sampling period for discretization!\n\n# Figure definition\n\nfig1, ((f1_ax1), (f1_ax2)) = plt.subplots(2, 1)\nfig1.set_size_inches((9.8, 5))\nfig1.set_tight_layout(True)\n\nf1_line1, = f1_ax1.plot([], [])\nf1_line2, = f1_ax2.plot([], [])  \n\nf1_ax1.grid(which='both', axis='both', color='lightgray')\nf1_ax2.grid(which='both', axis='both', color='lightgray')\n\nf1_ax1.autoscale(enable=True, axis='both', tight=True)\nf1_ax2.autoscale(enable=True, axis='both', tight=True)\n\nf1_ax1.set_title('Bode magnitude plot', fontsize=11)\nf1_ax1.set_xscale('log')\nf1_ax1.set_xlabel(r'$f\\/$[Hz]', labelpad=0, fontsize=10)\nf1_ax1.set_ylabel(r'$A\\/$[dB]', labelpad=0, fontsize=10)\nf1_ax1.tick_params(axis='both', which='both', pad=0, labelsize=8)\n\nf1_ax2.set_title('Bode phase plot', fontsize=11)\nf1_ax2.set_xscale('log')\nf1_ax2.set_xlabel(r'$f\\/$[Hz]', labelpad=0, fontsize=10)\nf1_ax2.set_ylabel(r'$\\phi\\/$[°]', labelpad=0, fontsize=10)\nf1_ax2.tick_params(axis='both', which='both', pad=0, labelsize=8)   \n\n\n# System model\n\ndef system_model(Im, Re, dts):\n\n    W_syscont = c.tf([1], [1, 2*Re, (Re+Im*1j)*(Re-Im*1j)])\n    W_sys = c.sample_system(W_syscont, dts, method='zoh')\n    # Zero Order Hold conversion to include continuous system in discrete model\n\n    print('System transfer function:')\n    print(W_syscont)\n    print('\\nDiscretized transfer function:')\n    print(W_sys)\n\n    # System analysis\n\n    poles_cont = c.pole(W_syscont)     # Poles\n    poles = c.pole(W_sys)\n\n    print('\\nSystem poles:')\n    print(poles_cont)\n    print('\\nDiscrete time system poles:')\n    print(poles)\n    \n    global f1_line1, f1_line2\n    \n    f1_ax1.lines.remove(f1_line1)\n    f1_ax2.lines.remove(f1_line2)\n\n    mag, phase, omega = c.bode_plot(W_sys, Plot=False)   # Bode-plot\n\n    f1_line1, = f1_ax1.plot(omega/2/np.pi, 20*np.log10(mag), lw=1, color='blue')\n    f1_line2, = f1_ax2.plot(omega/2/np.pi, phase*180/np.pi, lw=1, color='blue')   \n\n    f1_ax1.relim()\n    f1_ax2.relim()\n    f1_ax1.autoscale_view()\n    f1_ax2.autoscale_view()\n    \n# GUI widgets\n    \nRe_slider = w.FloatLogSlider(value=0.2, base=10, min=-4, max=1, description='Pole.Re (negative) :', continuous_update=False,\n                             layout=w.Layout(width='50%'), style={'description_width':'50%'})\nIm_slider = w.FloatLogSlider(value=0.2, base=10, min=-4, max=1, description='Pole.Im :', continuous_update=False,\n                             layout=w.Layout(width='50%'), style={'description_width':'30%'})\ndts_slider = w.FloatLogSlider(value=0.002, base=10, min=-4, max=0, description='dts [s] :', continuous_update=False,\n                                 layout=w.Layout(width='50%'))\n\ninput_data = w.interactive_output(system_model, {'Re':Re_slider, 'Im':Im_slider, 'dts':dts_slider})\n\ndisplay(w.HBox([Re_slider, Im_slider, dts_slider]), input_data)\n\n\n\n\n\n\n\n\n\n\n\n\n\nAfter observing the system characteristics, select a controller type!\n\n#Controller type select\n\ntypeSelect = w.ToggleButtons(\n    options=[('P (matched)', 0), ('PI (ZOH)', 1), ('PD (matched)', 2), ('PD Realistic (ZOH)', 3), ('PID Realistic (ZOH)', 4)],\n    description='Controller type: ', style={'description_width':'15%'})\n\ndisplay(typeSelect)\n\n\n\n\nTune the selected controller so that rising/settling time, overshoot, or remaining error is minimized! It is not possible to get the best out of each parameter in a single setup. Create multiple solutions, one for each type!\n\n# PID control\n\n# Figure definition\nfig2, ((f2_ax1, f2_ax2, f2_ax3), (f2_ax4, f2_ax5, f2_ax6)) = plt.subplots(2, 3)\nfig2.set_size_inches((9.8, 5))\nfig2.set_tight_layout(True)\n\nf2_line1, = f2_ax1.plot([], [])\nf2_line2, = f2_ax2.plot([], []) \nf2_line3, = f2_ax3.plot([], [])\nf2_line4, = f2_ax4.plot([], [])  \nf2_line5, = f2_ax5.plot([], [])\nf2_line6, = f2_ax6.plot([], [])\n\nf2_ax1.grid(which='both', axis='both', color='lightgray')\nf2_ax2.grid(which='both', axis='both', color='lightgray')\nf2_ax3.grid(which='both', axis='both', color='lightgray')\nf2_ax4.grid(which='both', axis='both', color='lightgray')\nf2_ax5.grid(which='both', axis='both', color='lightgray')\nf2_ax6.grid(which='both', axis='both', color='lightgray')\n\nf2_ax1.autoscale(enable=True, axis='both', tight=True)\nf2_ax2.autoscale(enable=True, axis='both', tight=True)\nf2_ax3.autoscale(enable=True, axis='both', tight=True)\nf2_ax4.autoscale(enable=True, axis='both', tight=True)\nf2_ax5.autoscale(enable=True, axis='both', tight=True)\nf2_ax6.autoscale(enable=True, axis='both', tight=True)\n\nf2_ax1.set_title('Closed loop step response', fontsize=9)\nf2_ax1.set_xlabel(r'$t\\/$[s]', labelpad=0, fontsize=8)\nf2_ax1.set_ylabel(r'$x\\/$[m]', labelpad=0, fontsize=8)\nf2_ax1.tick_params(axis='both', which='both', pad=0, labelsize=6)\n\nf2_ax2.set_title('Nyquist diagram', fontsize=9)\nf2_ax2.set_xlabel(r'Re', labelpad=0, fontsize=8)\nf2_ax2.set_ylabel(r'Im', labelpad=0, fontsize=8)\nf2_ax2.tick_params(axis='both', which='both', pad=0, labelsize=6)\n\nf2_ax3.set_title('Bode magnitude plot', fontsize=9)\nf2_ax3.set_xscale('log')\nf2_ax3.set_xlabel(r'$f\\/$[Hz]', labelpad=0, fontsize=8)\nf2_ax3.set_ylabel(r'$A\\/$[dB]', labelpad=0, fontsize=8)\nf2_ax3.tick_params(axis='both', which='both', pad=0, labelsize=6)\n\nf2_ax4.set_title('Closed loop impulse response', fontsize=9)\nf2_ax4.set_xlabel(r'$t\\/$[s]', labelpad=0, fontsize=8)\nf2_ax4.set_ylabel(r'$x\\/$[m]', labelpad=0, fontsize=8)\nf2_ax4.tick_params(axis='both', which='both', pad=0, labelsize=6)\n\nf2_ax5.set_title('Open loop step response', fontsize=9)\nf2_ax5.set_xlabel(r'$t\\/$[s]', labelpad=0, fontsize=8)\nf2_ax5.set_ylabel(r'$x\\/$[m]', labelpad=0, fontsize=8)\nf2_ax5.tick_params(axis='both', which='both', pad=0, labelsize=6)\n\nf2_ax6.set_title('Bode phase plot', fontsize=9)\nf2_ax6.set_xscale('log')\nf2_ax6.set_xlabel(r'$f\\/$[Hz]', labelpad=0, fontsize=8)\nf2_ax6.set_ylabel(r'$\\phi\\/$[°]', labelpad=0, fontsize=8)\nf2_ax6.tick_params(axis='both', which='both', pad=0, labelsize=6)\n\ndef pid_control(Kp, Ti, Td, Fd, type_select, Im, Re, dts):\n    \n    W_syscont = c.tf([1], [1, 2*Re, (Re+Im*1j)*(Re-Im*1j)])\n    W_sys = c.sample_system(W_syscont, dts, method='zoh')\n    # Zero Order Hold conversion to include continuous system in discrete model\n    \n    if type_select in (1, 4):\n        Ti0 = 1\n    else:\n        Ti0 = 0\n        \n    if type_select in (2, 3, 4):\n        Td0 = 1\n    else :\n        Td0 = 0\n        \n    if type_select in (3, 4):\n        Fd0 = 1\n    else:\n        Fd0 = 0\n    \n    if type_select in (0, 2):\n        convmet = \"matched\"\n    else:\n        convmet = \"zoh\"\n    \n    # PID Controller\n    \n    P = Kp             # Proportional term\n    I = Kp / Ti        # Integral term\n    D = Kp * Td        # Derivative term\n    Td_f = Td / Fd     # Derivative term filter\n    \n    W_PID_cont = c.parallel(c.tf([P], [1]),\n                            c.tf([I * Ti0], [1 * Ti0, 1 * (not Ti0)]),\n                            c.tf([D * Td0, 0], [Td_f * Td0 * Fd0, 1]))  # PID controller in time constant format    \n    \n    W_PID = c.sample_system(W_PID_cont, dts, method=convmet) # PID discretization\n    \n    W_open = c.series(W_PID, W_sys)      # Open loop\n    W_closed = c.feedback(W_open, 1, -1)    # Closed loop with negative feedback\n    \n    # Display\n                        \n    global f2_line1, f2_line2, f2_line3, f2_line4, f2_line5, f2_line6\n\n    try:\n        f2_ax1.lines.remove(f2_line1)\n        f2_ax2.lines.remove(f2_line2)\n        f2_ax3.lines.remove(f2_line3)\n        f2_ax4.lines.remove(f2_line4)\n        f2_ax5.lines.remove(f2_line5)\n        f2_ax6.lines.remove(f2_line6)\n    except:\n        pass\n    \n    tin = np.arange(0, 10/abs(Re+Im*1j), dts)\n\n    if tin.size &gt; 1:\n    \n        tout, yout = c.step_response(W_closed, tin)\n        maxint = min(tout.size, yout.size)\n        f2_line1, = f2_ax1.plot(tout[0:maxint], yout[0:maxint], lw=1, color='blue')\n\n        _, _, ob = c.nyquist_plot(W_open, Plot=False)   # Small resolution plot to determine bounds        \n        real, imag, freq = c.nyquist_plot(W_open, omega=np.logspace(np.log10(ob[0]), np.log10(ob[-1]), 1000), Plot=False)\n        f2_line2, = f2_ax2.plot(real, imag, lw=1, color='blue')\n\n        mag, phase, omega = c.bode_plot(W_open, Plot=False)\n        f2_line3, = f2_ax3.plot(omega/2/np.pi, 20*np.log10(mag), lw=1, color='blue')\n        f2_line6, = f2_ax6.plot(omega/2/np.pi, phase*180/np.pi, lw=1, color='blue')\n\n        tout, yout = c.impulse_response(W_closed, tin)\n        maxint = min(tout.size, yout.size)\n        f2_line4, = f2_ax4.plot(tout[0:maxint], yout[0:maxint], lw=1, color='blue')\n\n        tout, yout = c.step_response(W_open, tin)\n        maxint = min(tout.size, yout.size)\n        f2_line5, = f2_ax5.plot(tout[0:maxint], yout[0:maxint], lw=1, color='blue')\n\n    f2_ax1.relim()\n    f2_ax2.relim()\n    f2_ax3.relim()\n    f2_ax4.relim()\n    f2_ax5.relim()\n    f2_ax6.relim()\n\n    f2_ax1.autoscale_view()\n    f2_ax2.autoscale_view()\n    f2_ax3.autoscale_view()\n    f2_ax4.autoscale_view()\n    f2_ax5.autoscale_view()\n    f2_ax6.autoscale_view()\n    \n# GUI widgets\n\ndef draw_controllers(type_select):\n    \n    global Kp_slider\n    global Ti_slider\n    global Td_slider\n    global Fd_slider\n    \n    Kp_slider = w.FloatLogSlider(value=0.5, base=10, min=-1, max=4, description='Kp:', continuous_update=False,\n                                 layout=w.Layout(width='auto', flex='5 5 auto'))\n    \n    if type_select in (1, 4):\n        Ti_slider = w.FloatLogSlider(value=0.0035, base=10, min=-4, max=1, description='Ti:', continuous_update=False,\n                                     layout=w.Layout(width='auto', flex='5 5 auto'))\n    else:\n        Ti_slider = w.FloatLogSlider(value=0.0035, base=10, min=-4, max=1, description='Ti:', continuous_update=False,\n                                     layout=w.Layout(width='auto', flex='5 5 auto'), disabled=True)\n        \n    if type_select in (2, 3, 4):\n        Td_slider = w.FloatLogSlider(value=1, base=10, min=-4, max=1, description='Td:', continuous_update=False,\n                                     layout=w.Layout(width='auto', flex='5 5 auto'))\n    else:\n        Td_slider = w.FloatLogSlider(value=1, base=10, min=-4, max=1, description='Td:', continuous_update=False,\n                                     layout=w.Layout(width='auto', flex='5 5 auto'), disabled=True)\n    \n    if type_select in (3, 4):\n        Fd_slider = w.FloatLogSlider(value=1, base=10, min=0, max=3, description='Fd:', continuous_update=False,\n                                     layout=w.Layout(width='auto', flex='5 5 auto'))\n    else:\n        Fd_slider = w.FloatLogSlider(value=1, base=10, min=0, max=3, description='Fd:', continuous_update=False,\n                                     layout=w.Layout(width='auto', flex='5 5 auto'), disabled=True)\n\n\n    input_data = w.interactive_output(pid_control, {'Kp': Kp_slider, 'Ti': Ti_slider, 'Td': Td_slider,\n                                      'Fd': Fd_slider, 'type_select': typeSelect,\n                                      'Re': Re_slider, 'Im': Im_slider, 'dts': dts_slider})\n\n    display(w.HBox([Kp_slider, Ti_slider, Td_slider, Fd_slider]), input_data)\n    \nw.interactive_output(draw_controllers, {'type_select':typeSelect})\n\n\n\n\n\n\n\n\n\n\nYou can test the controlled system’s signal following capabilities using the simulated scope. Readjust your controller so that it can follow a sine wave acceptably!\n\n# Simulation data\n\nanim_fig = plt.figure()\nanim_fig.set_size_inches((9.8, 4))\nanim_fig.set_tight_layout(True)\n\nanim_ax1 = anim_fig.add_subplot(111)\n\nframe_count=1000\nscope_rounds=4\n\nl1 = anim_ax1.plot([], [], lw=1, color='blue')\nl2 = anim_ax1.plot([], [], lw=2, color='red')\n\nline1 = l1[0]\nline2 = l2[0]\n\nanim_ax1.legend(l1+l2, ['Reference', 'Output'], loc=1)\n\nanim_ax1.set_title('Scope', fontsize=12)\nanim_ax1.set_xlabel(r'$t\\/$[s]', labelpad=0, fontsize=10)\nanim_ax1.set_ylabel(r'$y\\/$[/]', labelpad=0, fontsize=10)\nanim_ax1.tick_params(axis='both', which='both', pad=0, labelsize=8)\n\nanim_ax1.grid(which='both', axis='both', color='lightgray')\n\nT_plot = []\nX_plot = []\nR_plot = []\n\n#Simulation function\n\ndef simulation(Kp, Ti, Td, Fd, type_select, Im, Re, dts, T, X, Xf, Xa):\n    \n    W_syscont = c.tf([1], [1, 2*Re, (Re+Im*1j)*(Re-Im*1j)])\n    W_sys = c.sample_system(W_syscont, dts, method='zoh')\n    # Zero Order Hold conversion to include continuous system in discrete model\n    \n    \n    if type_select in (1, 4):\n        Ti0 = 1\n    else:\n        Ti0 = 0\n        \n    if type_select in (2, 3, 4):\n        Td0 = 1\n    else :\n        Td0 = 0\n        \n    if type_select in (3, 4):\n        Fd0 = 1\n    else:\n        Fd0 = 0\n    \n    if type_select in (0, 2):\n        convmet = \"matched\"\n    else:\n        convmet = \"zoh\"\n    \n    # Controller\n    \n    P = Kp             # Proportional term\n    I = Kp / Ti        # Integral term\n    D = Kp * Td        # Derivative term\n    Td_f = Td * Fd     # Derivative term filter\n    \n    W_PID_cont = c.parallel(c.tf([P], [1]),\n                            c.tf([I * Ti0], [1 * Ti0, 1 * (not Ti0)]),\n                            c.tf([D * Td0, 0], [Td_f * Td0 * Fd0, 1]))  # PID controller in time constant format    \n    \n    # Model\n    \n    W_PID = c.sample_system(W_PID_cont, dts, method=convmet) # PID discretization\n    W_open = c.series(W_PID, W_sys)      # Open loop\n    W_closed = c.feedback(W_open, 1, -1)    # Closed loop with negative feedback\n    \n    # Reference and disturbance signals\n\n    T_sim = np.arange(0, T, dts, dtype=np.float64)\n    \n    if X == 0:   # Sine wave reference\n        X_sim = np.sin(2 * np.pi * Xf * T_sim) * Xa\n    elif X == 1:   # Square wave reference\n        X_sim = np.sign(np.sin(2 * np.pi * Xf * T_sim)) * Xa\n    \n    # System response\n        \n    Tx, youtx, xoutx = c.forced_response(W_closed, T_sim, X_sim)\n    \n    # Display\n    \n    XR_max = max(np.amax(np.absolute(np.concatenate((X_sim, youtx)))), Xa)\n    if not np.isnan(XR_max):\n        anim_ax1.set_ylim((-1.2 * XR_max, 1.2 * XR_max))\n    \n    global T_plot, X_plot, R_plot\n    \n    T_plot = np.linspace(0, T, frame_count*(scope_rounds+1), dtype=np.float32)\n    X_plot = np.interp(T_plot, T_sim, X_sim)\n    R_plot = np.interp(T_plot, T_sim, youtx)\n        \ndef anim_init():\n    line1.set_data([], [])\n    line2.set_data([], [])\n    anim_ax1.set_xlim((0, T_plot[frame_count-1]))\n    \n    return (line1, line2, anim_ax1,)\n\ndef animate(i):\n    line1.set_data(T_plot[scope_rounds*i:scope_rounds*i+frame_count-1], X_plot[scope_rounds*i:scope_rounds*i+frame_count-1])\n    line2.set_data(T_plot[scope_rounds*i:scope_rounds*i+frame_count-1], R_plot[scope_rounds*i:scope_rounds*i+frame_count-1])\n    anim_ax1.set_xlim((T_plot[i*scope_rounds], T_plot[i*scope_rounds+frame_count-1]))\n    \n    return (line1, line2, anim_ax1,)\n\nanim = animation.FuncAnimation(anim_fig, animate, init_func=anim_init,\n                               frames=frame_count, interval=10, blit=True,\n                               repeat=True)\n\n# Controllers\n\nT_slider = w.FloatLogSlider(value=10, base=10, min=-0.7, max=1, step=0.01,\n                            description='Duration [s]:', continuous_update=False,\n                            orientation='vertical', layout=w.Layout(width='auto', height='auto', flex='1 1 auto'))\n       \nX_type = w.Dropdown(options=[('Sine', 0), ('Square', 1)], value=1,\n                    description='Reference: ', continuous_update=False, layout=w.Layout(width='auto', flex='3 3 auto'))    \nXf_slider = w.FloatLogSlider(value=0.5, base=10, min=-2, max=2, step=0.01,\n                             description='Frequency [Hz]:', continuous_update=False,\n                             orientation='vertical', layout=w.Layout(width='auto', height='auto', flex='1 1 auto'))\nXa_slider = w.FloatLogSlider(value=1, base=10, min=-2, max=2, step=0.01,\n                             description='Amplitude [/]:', continuous_update=False,\n                             orientation='vertical', layout=w.Layout(width='auto', height='auto', flex='1 1 auto'))    \n\ninput_data = w.interactive_output(simulation, {'Kp': Kp_slider, 'Ti': Ti_slider, 'Td': Td_slider,'Fd': Fd_slider,\n                                               'type_select': typeSelect, 'Re': Re_slider, 'Im': Im_slider,\n                                               'dts': dts_slider, 'T': T_slider,\n                                               'X': X_type, 'Xf': Xf_slider, 'Xa': Xa_slider})\n\ndisplay(w.HBox([w.HBox([T_slider], layout=w.Layout(width='25%')),\n                w.Box([], layout=w.Layout(width='5%')),\n                w.VBox([X_type, w.HBox([Xf_slider, Xa_slider])], layout=w.Layout(width='30%')),\n                w.Box([], layout=w.Layout(width='5%'))],\n                layout=w.Layout(width='100%', justify_content='center')), input_data)\n\n\n\n\n\n\n\n\n\n\n\n\n\nThe duration parameter controls the simulated timeframe and does not affect the runtime of the animation."
  },
  {
    "objectID": "ICCT_en/examples/03/FD-17_OpAmp_PI_Controller.html",
    "href": "ICCT_en/examples/03/FD-17_OpAmp_PI_Controller.html",
    "title": "Creating a PI-controller using Operational Amplifiers",
    "section": "",
    "text": "%matplotlib notebook\nimport control as c\nimport ipywidgets as w\nimport numpy as np\n\nfrom IPython.display import display, HTML\nimport matplotlib.pyplot as plt\nimport matplotlib.animation as animation\n\ndisplay(HTML('&lt;script&gt; $(document).ready(function() { $(\\\"div.input\\\").hide(); }); &lt;/script&gt;'))\n\n\n\n\nIn analog electronics, operational amplifiers are generally used for the realization of Proportional-Integral-Derivating (PID) controllers. While the mathematical model for Linear Time-Invariant (LTI) systems assumes ideal conditions, the realistic circuits may not entirely match them.\nIn most cases, the ideal model returns acceptable results, but the frequency characteristics can be approximated better by expanding the model with the amplifier’s open-loop gain:  \\[G_{ideal}(s)=\\frac{V_{out}}{V_{in}}=-\\frac{Z_F}{Z_G}\\qquad\\qquad G_{approx}(s)=\\frac{V_{out}}{V_{in}}=-\\frac{\\frac{-A\\cdot Z_F}{Z_G+Z_F}}{1+\\frac{A\\cdot Z_G}{Z_G+Z_F}}\\] \nIn this example, we’ll explore some of the operational amplifier based PI controller configurations. First, select an open-loop gain value for the calculations!\n\n# Model selector\nopampGain = w.ToggleButtons(\n    options=[('10 000', 10000), ('50 000', 50000), ('200 000', 200000),],\n    description='Operational amplifier gain: ', style={'description_width':'30%'})\n\ndisplay(opampGain)\n\n\n\n\nThe PI controller can be implemented using a resistor in the feedforward and a capacitor in the feedback path. The ideal model matches exactly the mathematical form of the controller. But after the inclusion of the open-loop gain, the integrator is replaced by a first-order system with a huge time constant, limiting the magnitude at low frequencies.    Adjust the passive components so that the non-ideal model is the closest to the ideal! Where do the characteristics significantly deviate from the ideal? What can be said about the phase plot?\n\n# Figure definition\n\nfig1, ((f1_ax1), (f1_ax2)) = plt.subplots(2, 1)\nfig1.set_size_inches((9.8, 5))\nfig1.set_tight_layout(True)\n\nl1 = f1_ax1.plot([], [], color='red')\nl2 = f1_ax2.plot([], [], color='red') \nl3 = f1_ax1.plot([], [], color='blue')\nl4 = f1_ax2.plot([], [], color='blue')  \n\nf1_line1 = l1[0]\nf1_line2 = l2[0]\nf1_line3 = l3[0]\nf1_line4 = l4[0]\n    \nf1_ax1.legend(l1+l3, ['Non-ideal', 'Ideal'], loc=1)\nf1_ax2.legend(l2+l4, ['Non-ideal', 'Ideal'], loc=1)\n\nf1_ax1.grid(which='both', axis='both', color='lightgray')\nf1_ax2.grid(which='both', axis='both', color='lightgray')\n\nf1_ax1.autoscale(enable=True, axis='x', tight=True)\nf1_ax2.autoscale(enable=True, axis='x', tight=True)\nf1_ax1.autoscale(enable=True, axis='y', tight=False)\nf1_ax2.autoscale(enable=True, axis='y', tight=False)\n\nf1_ax1.set_title('Bode magnitude plot', fontsize=11)\nf1_ax1.set_xscale('log')\nf1_ax1.set_xlabel(r'$f\\/$[Hz]', labelpad=0, fontsize=10)\nf1_ax1.set_ylabel(r'$A\\/$[dB]', labelpad=0, fontsize=10)\nf1_ax1.tick_params(axis='both', which='both', pad=0, labelsize=8)\n\nf1_ax2.set_title('Bode phase plot', fontsize=11)\nf1_ax2.set_xscale('log')\nf1_ax2.set_xlabel(r'$f\\/$[Hz]', labelpad=0, fontsize=10)\nf1_ax2.set_ylabel(r'$\\phi\\/$[°]', labelpad=0, fontsize=10)\nf1_ax2.tick_params(axis='both', which='both', pad=0, labelsize=8) \n\n# System model\n\ndef system_model(rg, cf, a):\n\n    Rg = rg / 1000   # Convert to Ohm\n    Cf = cf * 1000000   # Convert to Farad\n\n    W_ideal = c.tf([-1], [Rg*Cf, 0])\n    W_ac = c.tf([-a], [Cf*Rg*(1+a), 1])\n    \n    global f1_line1, f1_line2, f1_line3, f1_line4\n    \n    f1_ax1.lines.remove(f1_line1)\n    f1_ax2.lines.remove(f1_line2)\n    f1_ax1.lines.remove(f1_line3)\n    f1_ax2.lines.remove(f1_line4)\n\n    mag, phase, omega = c.bode_plot(W_ac, Plot=False)   # Non-ideal Bode-plot\n    f1_line1, = f1_ax1.plot(omega/2/np.pi, 20*np.log10(mag), lw=1, color='red')\n    f1_line2, = f1_ax2.plot(omega/2/np.pi, phase*180/np.pi, lw=1, color='red') \n    \n    mag, phase, omega = c.bode_plot(W_ideal, omega=omega, Plot=False)   # Ideal Bode-plot at the non-ideal points\n    f1_line3, = f1_ax1.plot(omega/2/np.pi, 20*np.log10(mag), lw=1, color='blue')\n    f1_line4, = f1_ax2.plot(omega/2/np.pi, phase*180/np.pi, lw=1, color='blue')   \n\n    f1_ax1.relim()\n    f1_ax2.relim()\n    \n    f1_ax1.autoscale_view()\n    f1_ax2.autoscale_view()\n    \n    print('Ideal PI transfer function:')\n    print(W_ideal)\n    print('\\nNon-ideal PI transfer function:')\n    print(W_ac)\n    \n# GUI widgets\n    \nrg_slider = w.FloatLogSlider(value=1, base=10, min=-3, max=3, description=r'$R_g\\ [k\\Omega]\\ :$', continuous_update=False,\n                             layout=w.Layout(width='75%'), style={'description_width':'30%'})\ncf_slider = w.FloatLogSlider(value=1, base=10, min=-3, max=3, description=r'$C_f\\ [\\mu H]\\ :$', continuous_update=False,\n                             layout=w.Layout(width='75%'), style={'description_width':'30%'})\n\ninput_data = w.interactive_output(system_model, {'rg':rg_slider, 'cf':cf_slider, 'a':opampGain})\n\ndisplay(w.HBox([rg_slider, cf_slider]), input_data)\n\n\n\n\n\n\n\n\n\n\n\n\n\nThis PI controller might be simple, but it is not possible to control the DC gain through the passive components. That’s why usually, a parallel resistor is inserted into the feedback path.    Adjust the passive components so that the non-ideal model is the closest to the ideal! What are the differences compared to the previous model?\n\n# Filtered PI - parallel\n\nfig2, ((f2_ax1), (f2_ax2)) = plt.subplots(2, 1)\nfig2.set_size_inches((9.8, 5))\nfig2.set_tight_layout(True)\n\nl1 = f2_ax1.plot([], [], color='red')\nl2 = f2_ax2.plot([], [], color='red') \nl3 = f2_ax1.plot([], [], color='blue')\nl4 = f2_ax2.plot([], [], color='blue')  \n\nf2_line1 = l1[0]\nf2_line2 = l2[0]\nf2_line3 = l3[0]\nf2_line4 = l4[0]\n\nf2_ax1.legend(l1+l3, ['Non-ideal', 'Ideal'], loc=1)\nf2_ax2.legend(l2+l4, ['Non-ideal', 'Ideal'], loc=1)\n\nf2_ax1.grid(which='both', axis='both', color='lightgray')\nf2_ax2.grid(which='both', axis='both', color='lightgray')\n\nf2_ax1.autoscale(enable=True, axis='x', tight=True)\nf2_ax2.autoscale(enable=True, axis='x', tight=True)\nf2_ax1.autoscale(enable=True, axis='y', tight=False)\nf2_ax2.autoscale(enable=True, axis='y', tight=False)\n\nf2_ax1.set_title('Bode magnitude plot', fontsize=11)\nf2_ax1.set_xscale('log')\nf2_ax1.set_xlabel(r'$f\\/$[Hz]', labelpad=0, fontsize=10)\nf2_ax1.set_ylabel(r'$A\\/$[dB]', labelpad=0, fontsize=10)\nf2_ax1.tick_params(axis='both', which='both', pad=0, labelsize=8)\n\nf2_ax2.set_title('Bode phase plot', fontsize=11)\nf2_ax2.set_xscale('log')\nf2_ax2.set_xlabel(r'$f\\/$[Hz]', labelpad=0, fontsize=10)\nf2_ax2.set_ylabel(r'$\\phi\\/$[°]', labelpad=0, fontsize=10)\nf2_ax2.tick_params(axis='both', which='both', pad=0, labelsize=8)\n\n# System model\n\ndef system2_model(rg, rf, cf, a):\n\n    Rg = rg / 1000   # Convert to Ohm\n    Rf = rf / 1000\n    Cf = cf * 1000000   # Convert to Farad\n\n    W_ideal = c.tf([-1], [Rg*Cf, Rg/Rf])\n    W_ac = c.tf([-a], [Cf*Rg*(a+1), Rg*(a+1)/Rf+1])\n    \n    global f2_line1, f2_line2, f2_line3, f2_line4\n    \n    f2_ax1.lines.remove(f2_line1)\n    f2_ax2.lines.remove(f2_line2)\n    f2_ax1.lines.remove(f2_line3)\n    f2_ax2.lines.remove(f2_line4)\n\n    mag, phase, omega = c.bode_plot(W_ac, Plot=False)   # Non-ideal Bode-plot\n    f2_line1, = f2_ax1.plot(omega/2/np.pi, 20*np.log10(mag), lw=1, color='red')\n    f2_line2, = f2_ax2.plot(omega/2/np.pi, phase*180/np.pi, lw=1, color='red') \n    \n    mag, phase, omega = c.bode_plot(W_ideal, omega=omega, Plot=False)   # Ideal Bode-plot at the non-ideal points\n    f2_line3, = f2_ax1.plot(omega/2/np.pi, 20*np.log10(mag), lw=1, color='blue')\n    f2_line4, = f2_ax2.plot(omega/2/np.pi, phase*180/np.pi, lw=1, color='blue')   \n\n    f2_ax1.relim()\n    f2_ax2.relim()\n\n    f2_ax1.autoscale_view()\n    f2_ax2.autoscale_view()\n    \n    print('Ideal filtered PI transfer function:')\n    print(W_ideal)\n    print('\\nNon-ideal filtered PI transfer function:')\n    print(W_ac)\n    \n# GUI widgets\n    \nrg2_slider = w.FloatLogSlider(value=1, base=10, min=-3, max=3, description=r'$R_g$ [k$\\Omega$]', continuous_update=False,\n                             layout=w.Layout(width='75%'), style={'description_width':'30%'})\nrf2_slider = w.FloatLogSlider(value=1, base=10, min=-3, max=3, description=r'$R_f$ [k$\\Omega$]', continuous_update=False,\n                             layout=w.Layout(width='75%'), style={'description_width':'30%'})\ncf2_slider = w.FloatLogSlider(value=1, base=10, min=-3, max=3, description=r'$C_f$ [$\\mu$H]', continuous_update=False,\n                             layout=w.Layout(width='75%'), style={'description_width':'30%'})\n\ninput_data = w.interactive_output(system2_model, {'rg':rg2_slider, 'rf':rf2_slider, 'cf':cf2_slider, 'a':opampGain})\n\ndisplay(w.HBox([rg2_slider, rf2_slider, cf2_slider]), input_data)"
  },
  {
    "objectID": "ICCT_en/examples/03/FD-19_OpAmp_PID_Controller.html",
    "href": "ICCT_en/examples/03/FD-19_OpAmp_PID_Controller.html",
    "title": "Creating a PID-controller using Operational Amplifiers",
    "section": "",
    "text": "%matplotlib notebook\nimport control as c\nimport ipywidgets as w\nimport numpy as np\n\nfrom IPython.display import display, HTML\nimport matplotlib.pyplot as plt\nimport matplotlib.animation as animation\n\ndisplay(HTML('&lt;script&gt; $(document).ready(function() { $(\"div.input\").hide(); }); &lt;/script&gt;'))\n\nIn analog electronics, operational amplifiers are generally used for the realization of Proportional-Integral-Derivating (PID) controllers. While the mathematical model of Linear Time-invariant (LTI) systems assumes ideal conditions, the realistic circuits may not entirely match them.\nIn most cases, the ideal model returns acceptable results, but the frequency characteristics can be approximated better by expanding the model with the amplifier’s open-loop gain:  \\[G_{ideal}(s)=\\frac{V_{out}}{V_{in}}=-\\frac{Z_F}{Z_G}\\qquad\\qquad G_{approx}(s)=\\frac{V_{out}}{V_{in}}=-\\frac{\\frac{-A\\cdot Z_F}{Z_G+Z_F}}{1+\\frac{A\\cdot Z_G}{Z_G+Z_F}}\\] \nIn this example, we will explore some of the operational amplifier based PID controller configurations. First, select an open-loop gain value for the calculations!\n\n# Model selector\nopampGain = w.ToggleButtons(\n    options=[('2 000', 2000), ('10 000', 10000), ('50 000', 50000), ('200 000', 200000), ('500 000', 500000)],\n    description='Operational amplifier gain: ', style={'description_width':'18%'})\n\ndisplay(opampGain)\n\n\n\n\nThere is a wide variety of PID controller configurations, but they generally have to include capacitors and resistors both in the feedforward and the feedback path. In our example, the feedforward path contains a serially connected capacitor-resistor pair parallelly connected to a second resistor, while the feedback path consists of yet another serially connected capacitor-resistor pair.    Adjust the passive components so that the non-ideal model is the closest to the ideal! Where do the characteristics significantly deviate from the ideal? What can be said about the phase plot?\n\n# Figure definition\n\nfig1, ((f1_ax1), (f1_ax2)) = plt.subplots(2, 1)\nfig1.set_size_inches((9.8, 5))\nfig1.set_tight_layout(True)\n\nl1 = f1_ax1.plot([], [], color='red')\nl2 = f1_ax2.plot([], [], color='red') \nl3 = f1_ax1.plot([], [], color='blue')\nl4 = f1_ax2.plot([], [], color='blue')  \n\nf1_line1 = l1[0]\nf1_line2 = l2[0]\nf1_line3 = l3[0]\nf1_line4 = l4[0]\n    \nf1_ax1.legend(l1+l3, ['Non-ideal', 'Ideal'], loc=1)\nf1_ax2.legend(l2+l4, ['Non-ideal', 'Ideal'], loc=1)\n\nf1_ax1.grid(which='both', axis='both', color='lightgray')\nf1_ax2.grid(which='both', axis='both', color='lightgray')\n\nf1_ax1.autoscale(enable=True, axis='x', tight=True)\nf1_ax2.autoscale(enable=True, axis='x', tight=True)\nf1_ax1.autoscale(enable=True, axis='y', tight=False)\nf1_ax2.autoscale(enable=True, axis='y', tight=False)\n\nf1_ax1.set_title('Bode magnitude plot', fontsize=11)\nf1_ax1.set_xscale('log')\nf1_ax1.set_xlabel(r'$f\\/$[Hz]', labelpad=0, fontsize=10)\nf1_ax1.set_ylabel(r'$A\\/$[dB]', labelpad=0, fontsize=10)\nf1_ax1.tick_params(axis='both', which='both', pad=0, labelsize=8)\n\nf1_ax2.set_title('Bode phase plot', fontsize=11)\nf1_ax2.set_xscale('log')\nf1_ax2.set_xlabel(r'$f\\/$[Hz]', labelpad=0, fontsize=10)\nf1_ax2.set_ylabel(r'$\\phi\\/$[°]', labelpad=0, fontsize=10)\nf1_ax2.tick_params(axis='both', which='both', pad=0, labelsize=8)  \n\n# System model\n\ndef system_model(cg, r1, r2, cf, rf, a):\n\n    Rf = rf / 1000      # Convert to Ohm\n    R1 = r1 / 1000\n    R2 = r2 / 1000\n    Cf = cf * 1000000   # Convert to Farad\n    Cg = cg * 1000000\n\n    A = Rf*(R1+R2)*Cf*Cg\n    B = Rf*Cf+(R1+R2)*Cg\n    C = R1*R2*Cf*Cg\n    D = Cf*R2\n    \n    W_ideal = c.tf([-A, -B, -1], [C, D, 0])\n    W_ac = c.tf([-a*A, -a*B, -a], [A+(a+1)*C, B+(a+1)*D, 1])\n    \n    global f1_line1, f1_line2, f1_line3, f1_line4\n    \n    f1_ax1.lines.remove(f1_line1)\n    f1_ax2.lines.remove(f1_line2)\n    f1_ax1.lines.remove(f1_line3)\n    f1_ax2.lines.remove(f1_line4)\n\n    mag, phase, omega = c.bode_plot(W_ac, Plot=False)   # Non-ideal Bode-plot\n    f1_line1, = f1_ax1.plot(omega/2/np.pi, 20*np.log10(mag), lw=1, color='red')\n    f1_line2, = f1_ax2.plot(omega/2/np.pi, phase*180/np.pi, lw=1, color='red') \n    \n    mag, phase, omega = c.bode_plot(W_ideal, omega=omega, Plot=False)   # Ideal Bode-plot at the non-ideal points\n    f1_line3, = f1_ax1.plot(omega/2/np.pi, 20*np.log10(mag), lw=1, color='blue')\n    f1_line4, = f1_ax2.plot(omega/2/np.pi, phase*180/np.pi, lw=1, color='blue')   \n\n    f1_ax1.relim()\n    f1_ax2.relim()\n    \n    f1_ax1.autoscale_view()\n    f1_ax2.autoscale_view()\n    \n    print('Ideal PID transfer function:')\n    print(W_ideal)\n    print('\\nNon-ideal PID transfer function:')\n    print(W_ac)\n    \n# GUI widgets\n\ncg_slider = w.FloatLogSlider(value=0.01, base=10, min=-3, max=3, description=r'$C_g$$\\ [\\mu H]\\ :$', continuous_update=False,\n                             layout=w.Layout(width='75%'), style={'description_width':'30%'})    \nr1_slider = w.FloatLogSlider(value=0.1, base=10, min=-3, max=3, description=r'$R_1$$\\ [k\\Omega]\\ :$', continuous_update=False,\n                             layout=w.Layout(width='75%'), style={'description_width':'30%'})\nr2_slider = w.FloatLogSlider(value=1, base=10, min=-3, max=3, description=r'$R_2$$\\ [k\\Omega]\\ :$', continuous_update=False,\n                             layout=w.Layout(width='75%'), style={'description_width':'30%'})\ncf_slider = w.FloatLogSlider(value=0.1, base=10, min=-3, max=3, description=r'$C_f$$\\ [\\mu H]\\ :$', continuous_update=False,\n                             layout=w.Layout(width='75%'), style={'description_width':'30%'})\nrf_slider = w.FloatLogSlider(value=1, base=10, min=-3, max=3, description=r'$R_f$$\\ [k\\Omega]\\ :$', continuous_update=False,\n                             layout=w.Layout(width='75%'), style={'description_width':'30%'})\n\ninput_data = w.interactive_output(system_model, {'cg':cg_slider, 'r1':r1_slider, 'r2':r2_slider,\n                                                 'cf':cf_slider, 'rf':rf_slider, 'a':opampGain})\n\ndisplay(w.VBox([w.HBox([cg_slider, r1_slider, r2_slider]),\n                w.HBox([cf_slider, rf_slider])]), input_data)"
  },
  {
    "objectID": "ICCT_en/examples/03/FD-21_Ball_and_Beam.html",
    "href": "ICCT_en/examples/03/FD-21_Ball_and_Beam.html",
    "title": "Control design for a Ball and Beam system",
    "section": "",
    "text": "%matplotlib notebook\nimport control as c\nimport ipywidgets as w\nimport numpy as np\n\nfrom IPython.display import display, HTML\nimport matplotlib.pyplot as plt\nimport matplotlib.patches as patches\nimport matplotlib.transforms as transforms\nimport matplotlib.animation as animation\n\ndisplay(HTML('&lt;script&gt; $(document).ready(function() { $(\"div.input\").hide(); }); &lt;/script&gt;'))\n\nTraceback (most recent call last):\n  File \"/opt/tljh/user/lib/python3.6/site-packages/matplotlib/cbook/__init__.py\", line 216, in process\n    func(*args, **kwargs)\n  File \"/opt/tljh/user/lib/python3.6/site-packages/matplotlib/animation.py\", line 1465, in _stop\n    self.event_source.remove_callback(self._loop_delay)\nAttributeError: 'NoneType' object has no attribute 'remove_callback'\n\n\n\n\n\nThe following example is a control design task for a ball and beam system. The structure consists of a ball or cylinder rolling atop of a straight beam, rotated either by direct position input or through a driving mechanism. The objective is to control the ball’s position. \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nDirect drive\n\n\n\n\nDrive through mechanism\n\n\n\n\n\n\nWhile the system is non-linear, thus falls outside of the reach of classical control, after linearization and a set of simplifications, it is still possible to control it near to its steady state. Keep in mind, though, that results containing larger movements will violate these assumptions.\nThe linearized motion equations are:  \\[\\left(\\frac{J}{r^2}+m\\right)\\cdot\\ddot x=-m\\cdot g\\cdot\\alpha\\qquad\\left(\\frac{J}{r^2}+m\\right)\\cdot\\ddot x=-\\frac{m\\cdot g\\cdot d}{L}\\cdot\\varphi\\]  Where:  \\[J=\\frac{2}{5}m\\cdot r^2\\]  After the Laplace transformation of the differential equations, the transfer functions can be expressed as:  \\[G_{dir}(s)=-\\frac{m\\cdot g}{\\left(\\frac{J}{r^2}+m\\right)\\cdot s^2}\\qquad G_{mech}(s)=-\\frac{m\\cdot g\\cdot d}{L\\cdot\\left(\\frac{J}{r^2}+m\\right)\\cdot s^2}\\]  Your task is to choose a controller type, and tune it to acceptable levels of performance!\nFirst, choose a system model! Toggle between different realistic models with randomly preselected values (buttons Model 1 - Model 6). By clicking the Preset button default, valid predetermined controller parameters are set and cannot be tuned further. The two types are formally equivalent due to the simplifications.\n\n# Model selector buttons\ntypeSelect = w.ToggleButtons(\n    options=[('Direct drive', 0), ('Drive mechanism', 1),],\n    description='System: ')\n\ndisplay(typeSelect)\n\n\n\n\n\n# System parameters\n\ng = 9.81   # m/s^2 - gravitational acceleration\n\n# Figure definition\n\nfig1, ((f1_ax1), (f1_ax2)) = plt.subplots(2, 1)\nfig1.set_size_inches((9.8, 5))\nfig1.set_tight_layout(True)\n\nf1_line1, = f1_ax1.plot([], [])\nf1_line2, = f1_ax2.plot([], [])  \n\nf1_ax1.grid(which='both', axis='both', color='lightgray')\nf1_ax2.grid(which='both', axis='both', color='lightgray')\n\nf1_ax1.autoscale(enable=True, axis='both', tight=True)\nf1_ax2.autoscale(enable=True, axis='both', tight=True)\n\nf1_ax1.set_title('Bode magnitude plot', fontsize=11)\nf1_ax1.set_xscale('log')\nf1_ax1.set_xlabel(r'$f\\/$[Hz]', labelpad=0, fontsize=10)\nf1_ax1.set_ylabel(r'$A\\/$[dB]', labelpad=0, fontsize=10)\nf1_ax1.tick_params(axis='both', which='both', pad=0, labelsize=8)\n\nf1_ax2.set_title('Bode phase plot', fontsize=11)\nf1_ax2.set_xscale('log')\nf1_ax2.set_xlabel(r'$f\\/$[Hz]', labelpad=0, fontsize=10)\nf1_ax2.set_ylabel(r'$\\phi\\/$[°]', labelpad=0, fontsize=10)\nf1_ax2.tick_params(axis='both', which='both', pad=0, labelsize=8)\n\ndef build_base_model(m, r, d, L, type_select):\n   \n    J=2/5*m*r*r\n    if type_select:\n        W_sys = c.tf([m*g*d], [L*(J/(r*r)+m), 0, 0])\n    else:\n        W_sys = c.tf([m*g], [J/(r*r)+m, 0, 0])\n    \n    print('System transfer function:')\n    print(W_sys)\n    \n    # System analysis\n    \n    poles = c.pole(W_sys)     # Poles\n    \n    print('System poles:\\n')\n    print(poles)\n    \n    global f1_line1, f1_line2\n    \n    f1_ax1.lines.remove(f1_line1)\n    f1_ax2.lines.remove(f1_line2)\n    \n    mag, phase, omega = c.bode_plot(W_sys, Plot=False)   # Bode-plot\n    \n    f1_line1, = f1_ax1.plot(omega/2/np.pi, 20*np.log10(mag), lw=1, color='blue')\n    f1_line2, = f1_ax2.plot(omega/2/np.pi, phase*180/np.pi, lw=1, color='blue')   \n    \n    f1_ax1.relim()\n    f1_ax2.relim()\n    f1_ax1.autoscale_view()\n    f1_ax2.autoscale_view()\n    \ndef update_sliders(index, model):\n    global m_slider, r_slider, d_slider, L_slider\n\n    mval = [0.05, 0.05, 0.1, 0.1, 0.5, 0.5, 0.25]\n    rval = [0.01, 0.05, 0.05, 0.1, 0.1, 0.15, 0.075]\n    dval = [0.025, 0.01, 0.05, 0.2, 0.2, 0.4, 0.2]\n    Lval = [0.1, 0.1, 0.5, 1, 2, 2, 1]\n\n    m_slider.value = mval[index]\n    r_slider.value = rval[index]\n    d_slider.value = dval[index]\n    L_slider.value = Lval[index]\n    \n    if index == -1:\n        m_slider.disabled = True;\n        r_slider.disabled = True;\n        d_slider.disabled = True;\n        L_slider.disabled = True;\n    else:\n        m_slider.disabled = False;\n        r_slider.disabled = False;\n        \n        if model == 0:\n            d_slider.disabled = False;\n            L_slider.disabled = False;\n        else:\n            d_slider.disabled = True;\n            L_slider.disabled = True; \n    \n# GUI widgets\n    \ntypeSelect2 = w.ToggleButtons(\n    options=[('Model 1', 0), ('Model 2', 1), ('Model 3', 2), ('Model 4', 3), ('Model 5', 4), ('Model 6', 5),\n             ('Preset', -1)],\n    value=-1, description='System: ', layout=w.Layout(width='60%'))\n\nm_slider = w.FloatLogSlider(value=1, base=10, min=-2, max=1, description='m [kg] :', continuous_update=False,\n                            layout=w.Layout(width='auto', flex='5 5 auto'))\nr_slider = w.FloatLogSlider(value=0.1, base=10, min=-3, max=0, description='r [m] :', continuous_update=False,\n                            layout=w.Layout(width='auto', flex='5 5 auto'))\n\nd_slider = w.FloatLogSlider(value=0.1, base=10, min=-3, max=0, description='d [m] :', continuous_update=False,\n                            layout=w.Layout(width='auto', flex='5 5 auto'))\nL_slider = w.FloatLogSlider(value=0, base=10, min=-1, max=2, description='L [m] :', continuous_update=False,\n                            layout=w.Layout(width='auto', flex='5 5 auto'))\n\ninput_data = w.interactive_output(build_base_model, {'m':m_slider, 'r':r_slider, 'd':d_slider, 'L':L_slider,\n                                                     'type_select':typeSelect})  \n\ninput_data2 = w.interactive_output(update_sliders, {'index':typeSelect2, 'model':typeSelect})\n\ndisplay(typeSelect2, input_data2)\n\ndisplay(w.HBox([w.VBox([m_slider, r_slider], layout=w.Layout(width='45%')),\n                w.VBox([d_slider, L_slider], layout=w.Layout(width='45%'))]), input_data)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nDue to the massive simplifications, the system is reduced to an ideal double integrator. Select an appropriate controller configuration! Which one is the best for your system? Why? Set up your controller for the fastest settling time with no overshoot!\nYou can turn on/off each of the I and D components, and if D is active, you can apply the first-order filter as well, based on the derivating time constant.\n\n# PID ball balancer\n\nfig2, ((f2_ax1, f2_ax2, f2_ax3), (f2_ax4, f2_ax5, f2_ax6)) = plt.subplots(2, 3)\nfig2.set_size_inches((9.8, 5))\nfig2.set_tight_layout(True)\n\nf2_line1, = f2_ax1.plot([], [])\nf2_line2, = f2_ax2.plot([], []) \nf2_line3, = f2_ax3.plot([], [])\nf2_line4, = f2_ax4.plot([], [])  \nf2_line5, = f2_ax5.plot([], [])\nf2_line6, = f2_ax6.plot([], [])\n\nf2_ax1.grid(which='both', axis='both', color='lightgray')\nf2_ax2.grid(which='both', axis='both', color='lightgray')\nf2_ax3.grid(which='both', axis='both', color='lightgray')\nf2_ax4.grid(which='both', axis='both', color='lightgray')\nf2_ax5.grid(which='both', axis='both', color='lightgray')\nf2_ax6.grid(which='both', axis='both', color='lightgray')\n\nf2_ax1.autoscale(enable=True, axis='both', tight=True)\nf2_ax2.autoscale(enable=True, axis='both', tight=True)\nf2_ax3.autoscale(enable=True, axis='both', tight=True)\nf2_ax4.autoscale(enable=True, axis='both', tight=True)\nf2_ax5.autoscale(enable=True, axis='both', tight=True)\nf2_ax6.autoscale(enable=True, axis='both', tight=True)\n\n\nf2_ax1.set_title('Closed loop step response', fontsize=9)\nf2_ax1.set_xlabel(r'$t\\/$[s]', labelpad=0, fontsize=8)\nf2_ax1.set_ylabel(r'$x\\/$[m]', labelpad=0, fontsize=8)\nf2_ax1.tick_params(axis='both', which='both', pad=0, labelsize=6)\n\nf2_ax2.set_title('Nyquist diagram', fontsize=9)\nf2_ax2.set_xlabel(r'Re', labelpad=0, fontsize=8)\nf2_ax2.set_ylabel(r'Im', labelpad=0, fontsize=8)\nf2_ax2.tick_params(axis='both', which='both', pad=0, labelsize=6)\n\nf2_ax3.set_title('Bode magniture plot', fontsize=9)\nf2_ax3.set_xscale('log')\nf2_ax3.set_xlabel(r'$f\\/$[Hz]', labelpad=0, fontsize=8)\nf2_ax3.set_ylabel(r'$A\\/$[dB]', labelpad=0, fontsize=8)\nf2_ax3.tick_params(axis='both', which='both', pad=0, labelsize=6)\n\nf2_ax4.set_title('Closed loop impulse response', fontsize=9)\nf2_ax4.set_xlabel(r'$t\\/$[s]', labelpad=0, fontsize=8)\nf2_ax4.set_ylabel(r'$x\\/$[m]', labelpad=0, fontsize=8)\nf2_ax4.tick_params(axis='both', which='both', pad=0, labelsize=6)\n\nf2_ax5.set_title('Load transfer step response', fontsize=9)\nf2_ax5.set_xlabel(r'$t\\/$[s]', labelpad=0, fontsize=8)\nf2_ax5.set_ylabel(r'$x\\/$[m]', labelpad=0, fontsize=8)\nf2_ax5.tick_params(axis='both', which='both', pad=0, labelsize=6)\n\nf2_ax6.set_title('Bode phase plot', fontsize=9)\nf2_ax6.set_xscale('log')\nf2_ax6.set_xlabel(r'$f\\/$[Hz]', labelpad=0, fontsize=8)\nf2_ax6.set_ylabel(r'$\\phi\\/$[°]', labelpad=0, fontsize=8)\nf2_ax6.tick_params(axis='both', which='both', pad=0, labelsize=6)\n\ndef position_control(Kp, Ti, Td, Fd, Ti0, Td0, m, r, d, L, type_select):\n    \n    J=2/5*m*r*r\n    if type_select:\n        W_sys = c.tf([m*g*d], [L*(J/(r*r)+m), 0, 0])\n    else:\n        W_sys = c.tf([m*g], [J/(r*r)+m, 0, 0])\n    \n    # PID Controller\n    \n    P = Kp             # Proportional term\n    I = Kp / Ti        # Integral term\n    D = Kp * Td        # Derivative term\n    Td_f = Td / Fd     # Derivative term filter\n    \n    W_PID = c.parallel(c.tf([P], [1]),\n                       c.tf([I * Ti0], [1 * Ti0, 1 * (not Ti0)]),\n                       c.tf([D * Td0, 0], [Td_f * Td0, 1]))  # PID controller in time constant format\n    \n    W_open = c.series(W_PID, W_sys)         # Open loop \n    W_closed = c.feedback(W_open, 1, -1)    # Closed loop with negative feedback\n    \n    if type_select:   # Disturbance transfer\n        W_load = c.feedback (c.tf([1], [J/r/r+m, 0, 0]), c.series(c.tf([m*g*d], [L]), W_PID), -1)  \n    else:\n        W_load = c.feedback (c.tf([1], [J/r/r+m, 0, 0]), c.series(c.tf([m*g], [1]), W_PID), -1)\n                        \n    # Display\n    \n    global f2_line1, f2_line2, f2_line3, f2_line4, f2_line5, f2_line6\n    \n    f2_ax1.lines.remove(f2_line1)\n    f2_ax2.lines.remove(f2_line2)\n    f2_ax3.lines.remove(f2_line3)\n    f2_ax4.lines.remove(f2_line4)\n    f2_ax5.lines.remove(f2_line5)\n    f2_ax6.lines.remove(f2_line6)\n    \n    tout, yout = c.step_response(W_closed)\n    f2_line1, = f2_ax1.plot(tout, yout, lw=1, color='blue')\n    \n    _, _, ob = c.nyquist_plot(W_open, Plot=False)   # Small resolution plot to determine bounds        \n    real, imag, freq = c.nyquist_plot(W_open, omega=np.logspace(np.log10(ob[0]), np.log10(ob[-1]), 1000), Plot=False)     \n    f2_line2, = f2_ax2.plot(real, imag, lw=1, color='blue')\n    \n    mag, phase, omega = c.bode_plot(W_open, Plot=False)\n    f2_line3, = f2_ax3.plot(omega/2/np.pi, 20*np.log10(mag), lw=1, color='blue')\n    f2_line6, = f2_ax6.plot(omega/2/np.pi, phase*180/np.pi, lw=1, color='blue')\n    \n    tout, yout = c.impulse_response(W_closed)\n    f2_line4, = f2_ax4.plot(tout, yout, lw=1, color='blue')\n    \n    tout, yout = c.step_response(W_load)\n    f2_line5, = f2_ax5.plot(tout, yout, lw=1, color='blue')\n    \n    f2_ax1.relim()\n    f2_ax2.relim()\n    f2_ax3.relim()\n    f2_ax4.relim()\n    f2_ax5.relim()\n    f2_ax6.relim()\n    f2_ax1.autoscale_view()\n    f2_ax2.autoscale_view()\n    f2_ax3.autoscale_view()\n    f2_ax4.autoscale_view()\n    f2_ax5.autoscale_view()\n    f2_ax6.autoscale_view()\n    \ndef update_controller(index):\n    global Kp_slider, Ti_slider, Td_slider, Fd_slider, Ti_button, Td_button\n    \n    if index == -1:\n        Kp_slider.value = 100\n        Td_slider.value = 0.05\n        Fd_slider.value = 5\n        Ti_button.value = False\n        Td_button.value = True\n        \n        Kp_slider.disabled = True\n        Ti_slider.disabled = True\n        Td_slider.disabled = True\n        Fd_slider.disabled = True\n        Ti_button.disabled = True\n        Td_button.disabled = True\n    else:\n        Kp_slider.disabled = False\n        Ti_slider.disabled = False\n        Td_slider.disabled = False\n        Fd_slider.disabled = False\n        Ti_button.disabled = False\n        Td_button.disabled = False\n\n# GUI widgets\n\nKp_slider = w.FloatLogSlider(value=2, base=10, min=-3, max=5, description='Kp:', continuous_update=False,\n                             layout=w.Layout(width='auto', flex='5 5 auto'))\nTi_slider = w.FloatLogSlider(value=0.0035, base=10, min=-4, max=1, description='', continuous_update=False,\n                             layout=w.Layout(width='auto', flex='5 5 auto'))\nTd_slider = w.FloatLogSlider(value=0.25, base=10, min=-4, max=1, description='', continuous_update=False,\n                             layout=w.Layout(width='auto', flex='5 5 auto'))\nFd_slider = w.FloatLogSlider(value=1, base=10, min=0, max=3, description='', continuous_update=False,\n                             layout=w.Layout(width='auto', flex='5 5 auto'))\n\nTi_button = w.ToggleButton(value=False, description='Ti',\n                           layout=w.Layout(width='auto', flex='1 1 0%'))\nTd_button = w.ToggleButton(value=True, description='Td',\n                           layout=w.Layout(width='auto', flex='1 1 0%'))\n\ninput_data = w.interactive_output(position_control, {'Kp': Kp_slider, 'Ti': Ti_slider, 'Td': Td_slider,\n                                                     'Fd': Fd_slider, 'Ti0' : Ti_button, 'Td0': Td_button,\n                                                     'm':m_slider, 'r':r_slider,\n                                                     'd':d_slider, 'L':L_slider, 'type_select':typeSelect})\n\nw.interactive_output(update_controller, {'index': typeSelect2})\n\ndisplay(w.HBox([Kp_slider, Ti_button, Ti_slider, Td_button, Td_slider, Fd_slider]), input_data)\n\n\n\n\n\n\n\n\n\n\n\n\n\nIn the following simulation, you can observe the movement of your system based on your controller setup. You can create reference signals and even apply some disturbance and see how the system reacts.\nIs your configuration suitable for signal-following? Readjust your controller so that it can follow a sine wave acceptably!  (The animations are scaled to fit the frame through the whole simulation. Because of this, unstable solutions might not seem to move until the very last second.)\n\n# Simulation\n\nanim_fig = plt.figure()\nanim_fig.set_size_inches((9.8, 6))\nanim_fig.set_tight_layout(True)\n\nanim_ax1 = anim_fig.add_subplot(211)\nanim_ax2 = anim_ax1.twinx()\n\nframe_count=1000\n\nl1 = anim_ax1.plot([], [], lw=1, color='blue')\nl2 = anim_ax1.plot([], [], lw=2, color='red')\nl3 = anim_ax2.plot([], [], lw=1, color='grey')\n\nline1 = l1[0]\nline2 = l2[0]\nline3 = l3[0]\n\nanim_ax1.legend(l1+l2+l3, ['Reference [m]', 'Output [m]', 'Load [N]'], loc=1)\n\nanim_ax1.set_title('Time response simulation', fontsize=12)\nanim_ax1.set_xlabel(r'$t\\/$[s]', labelpad=0, fontsize=10)\nanim_ax1.set_ylabel(r'$x\\/$[m]', labelpad=0, fontsize=10)\nanim_ax1.tick_params(axis='both', which='both', pad=0, labelsize=8)\nanim_ax2.set_ylabel(r'$F\\/$[N]', labelpad=0, fontsize=10)\nanim_ax2.tick_params(axis='both', which='both', pad=0, labelsize=8)\n\nanim_ax1.grid(which='both', axis='both', color='lightgray')\n\nT_plot = []\nX_plot = []\nD_plot = []\nR_plot = []\nP_plot = []\n\n# Scene data\n\nscene_ax = anim_fig.add_subplot(212)\nscene_ax.set_xlim((-4.75, 4.75))\nscene_ax.set_ylim((-1.5, 1.5))\nscene_ax.axis('off')\n\nrotation_transform = transforms.Affine2D()\n\nscene_ax.add_patch(patches.Polygon(np.stack(([-3.5, -3.5, -0.5, 0.5, 3.5, 3.5, -3.5],\n                                   [0.25, 0.1, -0.25, -0.25, 0.1, 0.25, 0.25])).T,\n                                   fill = True, lw=1, ec='black', fc='lightgray', zorder=5,\n                                   transform=rotation_transform + scene_ax.transData))\nscene_ax.add_patch(patches.Polygon(np.stack(([-0.7, -0.7, 0.7, 0.7, 0.25, -0.25, -0.7],\n                                   [-1.1, -1.4, -1.4, -1.1, 0, 0, -1.1])).T,\n                                   fill = True, lw=1, ec='black', fc='darkgoldenrod', zorder=0))\nscene_ax.add_patch(patches.Circle((0, 0), fill=True, radius=0.03, ec='black', fc='gray', lw=1, zorder=20))\n\nball = patches.Circle((0, 0.5), fill=True, radius=0.25, ec='black', fc='orange', lw=1,\n                      zorder=5, transform=rotation_transform + scene_ax.transData)\ngleam = patches.Wedge((0, 0.5), 0.2, fill=True, width=0.075, theta1=215, theta2=235, lw=0,\n                      ec='white', fc='white', zorder=10, transform=rotation_transform + scene_ax.transData)\n\nscene_ax.add_patch(ball)\nscene_ax.add_patch(gleam)\n\ncenter_drive_belt, = scene_ax.plot([-0.42, -0.15, 0.15, 0.42], [-0.8, 0.05, 0.05, -0.8], color='black', lw=3, zorder=10)\n\ncenter_drive_1 = patches.Circle((0, 0), fill=True, radius=0.18, ec='black', fc='lawngreen', lw=1, zorder=15)\ncenter_drive_2 = patches.Circle((0, -0.85), fill=True, radius=0.45, ec='black', fc='lawngreen', lw=1, zorder=15)\ncenter_drive_shaft = patches.Circle((0, -0.85), fill=True, radius=0.03, ec='black', fc='gray', lw=1, zorder=25)\ncenter_drive_mark_1 = patches.Wedge((0, -0.85), 0.40, theta1=260, theta2=280, width=0.32,\n                                    fill=True, ec='black', fc='white', lw=1, zorder=20)\ncenter_drive_mark_2 = patches.Wedge((0, -0.85), 0.40, theta1=80, theta2=100, width=0.32,\n                                    fill=True, ec='black', fc='white', lw=1, zorder=20)\n\nscene_ax.add_patch(center_drive_1)\nscene_ax.add_patch(center_drive_2)\nscene_ax.add_patch(center_drive_shaft)\nscene_ax.add_patch(center_drive_mark_1)\nscene_ax.add_patch(center_drive_mark_2)\n\nwheel_transform = transforms.Affine2D()\n\ndrive_rod_outline, = scene_ax.plot([3.5, 3.4], [-0.85, 0.175], color='black', solid_capstyle='round', lw=8, zorder=15,\n                                   visible=False)\ndrive_rod, = scene_ax.plot([3.5, 3.4], [-0.85, 0.175], color='deepskyblue', solid_capstyle='round', lw=6, zorder=20,\n                           visible=False)\ndrive_wheel_rod_outline, = scene_ax.plot([3.05, 3.5], [-0.85, -0.85], color='black', solid_capstyle='round', lw=12, zorder=0,\n                                         visible=False)\ndrive_wheel_rod, = scene_ax.plot([3.05, 3.5], [-0.85, -0.85], color='cyan', solid_capstyle='round', lw=10, zorder=10,\n                                 visible=False)\ndrive_motor_grate, = scene_ax.plot([2.5, 2.5, 2.5833, 2.5833, 2.6666, 2.6666, 2.75],\n                                   [-1, -1.25, -1, -1.25, -1, -1.25, -1],\n                                   color='black', solid_capstyle='round', lw=1, zorder=5, visible=False)\n\ndrive_rod_p1 = patches.Circle((3.4, 0.175), fill=True, radius=0.03, ec='black', fc='gray', lw=1, zorder=25,\n                              transform=rotation_transform + scene_ax.transData, visible=False)\ndrive_rod_p2 = patches.Circle((3.5, -0.85), fill=True, radius=0.03, ec='black', fc='gray', lw=1, zorder=25,\n                              transform=wheel_transform + scene_ax.transData, visible=False)\ndrive_wheel = patches.Circle((3.05, -0.85), fill=True, radius=0.25, ec='black', fc='cyan', lw=1, zorder=5, visible=False)\ndrive_wheel_p = patches.Circle((3.05, -0.85), fill=True, radius=0.03, ec='black', fc='gray', lw=1, zorder=25, visible=False)\ndrive_motor = patches.Polygon(np.stack(([2.3, 3.2, 3.2, 2.6, 2.3, 2.3],\n                              [-1.4, -1.4, -0.7, -0.7, -0.85, -1.4])).T,\n                               fill = True, lw=1, ec='black', fc='firebrick', zorder=0, visible=False)\n\nscene_ax.add_patch(drive_rod_p1)\nscene_ax.add_patch(drive_rod_p2)\nscene_ax.add_patch(drive_wheel)\nscene_ax.add_patch(drive_wheel_p)\nscene_ax.add_patch(drive_motor)\n\nx_arrow = scene_ax.arrow(0, 0.05, 0, 0.15, ec='black', fc='blue', head_width=0.1,\n                         length_includes_head=True, lw=1, fill=True, zorder=10,\n                         transform=rotation_transform + scene_ax.transData)\nr_arrow = scene_ax.arrow(0, 0.05, 0, 0.15, ec='black', fc='red', head_width=0.1,\n                         length_includes_head=True, lw=1, fill=True, zorder=10,\n                         transform=rotation_transform + scene_ax.transData)\nbase_arrow = x_arrow.xy\n\n\nrot_pos = []\nball_pos = []\nref_pos = []\nball_rot = []\nsys_type = 0\n\n#Simulation function\n\ndef simulation(Kp, Ti, Td, Fd, Ti0, Td0, m, r, d, L, type_select, T, dt, X, Xf, Xa, Xo, F, Ff, Fa, Fo):\n    \n    # Controller\n    P = Kp            # Proportional term\n    I = Kp / Ti       # Integral term\n    D = Kp * Td       # Derivative term\n    Td_f = Td / Fd    # Derivative term filter\n    \n    W_PID = c.parallel(c.tf([P], [1]),\n                       c.tf([I * Ti0], [1 * Ti0, 1 * (not Ti0)]),\n                       c.tf([D * Td0, 0], [Td_f * Td0, 1]))  # PID controller\n    \n    # System\n    \n    J=2/5*m*r*r\n    if type_select:\n        W_sys = c.tf([m*g*d], [L*(J/(r*r)+m), 0, 0])\n    else:\n        W_sys = c.tf([m*g], [J/(r*r)+m, 0, 0])\n    \n    # Model\n    W_open = c.series(W_PID, W_sys)         # Open loop \n    W_closed = c.feedback(W_open, 1, -1)    # Closed loop with negative feedback\n    \n    if type_select:   # Disturbance transfer\n        W_s1 = c.tf([m*g*d], [L])\n    else:\n        W_s1 = c.tf([m*g], [1])\n        \n    W_s2 = c.tf([1], [J/r/r+m, 0, 0])\n    W_load = c.feedback(W_s2, c.series(W_PID, W_s1), -1)\n    \n    W_cont_sys = c.feedback(W_PID, W_sys, -1)    # Control signal (angle) system component\n    W_cont_load = c.feedback(c.series(W_s2, c.negate(W_PID)), W_s1, 1)     # Control signal (angle) load component         \n    \n    # Reference and disturbance signals\n\n    T_sim = np.arange(0, T, dt, dtype=np.float64)\n    \n    if X == 0:     # Constant reference\n        X_sim = np.full_like(T_sim, Xa * Xo)\n    elif X == 1:   # Sine wave reference\n        X_sim = (np.sin(2 * np.pi * Xf * T_sim) + Xo) * Xa\n    elif X == 2:   # Square wave reference\n        X_sim = (np.sign(np.sin(2 * np.pi * Xf * T_sim)) + Xo) * Xa\n        \n    if F == 0:     # Constant load\n        F_sim = np.full_like(T_sim, Fa * Fo)\n    elif F == 1:   # Sine wave load\n        F_sim = (np.sin(2 * np.pi * Ff * T_sim) + Fo) * Fa\n    elif F == 2:   # Square wave load\n        F_sim = (np.sign(np.sin(2 * np.pi * Ff * T_sim)) + Fo) * Fa\n    elif F == 3:   # Noise form load\n        F_sim = np.interp(T_sim, np.linspace(0, T, int(T * Ff) + 2),\n                          np.random.normal(loc=(Fo * Fa), scale=Fa, size=int(T * Ff) + 2))\n    \n    # System response\n        \n    Tx, youtx, xoutx = c.forced_response(W_closed, T_sim, X_sim)\n    Tf, youtf, xoutf = c.forced_response(W_load, T_sim, F_sim)\n    R_sim = np.nan_to_num(youtx + youtf)\n                    \n    Tcx, youtcx, xoutcx = c.forced_response(W_cont_sys, T_sim, X_sim)\n    Tcf, youtcf, xoutcf = c.forced_response(W_cont_load, T_sim, F_sim)\n    P_sim = np.nan_to_num(youtcx + youtcf)\n    \n    # Display\n            \n    XR_max = max(np.amax(np.absolute(np.concatenate((X_sim, R_sim)))), Xa)\n    F_max = max(np.amax(np.absolute(F_sim)), Fa)\n    P_max = np.amax(np.absolute(P_sim))\n    \n    anim_ax1.set_xlim((0, T))\n    anim_ax1.set_ylim((-1.2 * XR_max, 1.2 * XR_max))\n    anim_ax2.set_ylim((-1.5 * F_max, 1.5 * F_max))\n    \n    global T_plot, X_plot, F_plot, R_plot, P_plot, rot_pos, ball_pos, ref_pos, ball_rot, sys_type\n    \n    T_plot = np.linspace(0, T, frame_count, dtype=np.float32)\n    X_plot = np.interp(T_plot, T_sim, X_sim)\n    F_plot = np.interp(T_plot, T_sim, F_sim)\n    R_plot = np.interp(T_plot, T_sim, R_sim)\n    P_plot = np.interp(T_plot, T_sim, P_sim)\n                    \n    rot_pos = P_plot / P_max * -10   # The constant sets the apparent maximal tilt of the animation in degrees\n    ball_pos = R_plot / XR_max * 3.4\n    ref_pos = X_plot / XR_max * 3.4\n    ball_rot = ball_pos / np.pi * -360\n    sys_type = type_select\n    \n\ndef anim_init():\n    line1.set_data([], [])\n    line2.set_data([], [])\n    line3.set_data([], [])\n    \n    ball.set_center((0, 0.5))\n    gleam.set_center((0, 0.5))\n    gleam.set_theta1(215)\n    gleam.set_theta2(235)\n    \n    center_drive_mark_1.set_theta1(260)\n    center_drive_mark_1.set_theta2(280)\n    center_drive_mark_2.set_theta1(80)\n    center_drive_mark_2.set_theta2(100)\n    \n    drive_rod_outline.set_data([3.5, 3.4], [-0.85, 0.175])\n    drive_rod.set_data([3.5, 3.4], [-0.85, 0.175])\n    drive_wheel_rod_outline.set_data([3.05, 3.5], [-0.85, -0.85])\n    drive_wheel_rod.set_data([3.05, 3.5], [-0.85, -0.85])\n    \n    x_arrow.set_xy(base_arrow)\n    r_arrow.set_xy(base_arrow)\n    \n    rotation_transform.clear()\n    wheel_transform.clear()\n    \n    if sys_type:\n        center_drive_1.set_visible(False)\n        center_drive_2.set_visible(False)\n        center_drive_shaft.set_visible(False)\n        center_drive_belt.set_visible(False)\n        center_drive_mark_1.set_visible(False)\n        center_drive_mark_2.set_visible(False)\n        \n        drive_rod.set_visible(True)\n        drive_rod_outline.set_visible(True)\n        drive_wheel_rod.set_visible(True)\n        drive_wheel_rod_outline.set_visible(True)\n        drive_wheel.set_visible(True)\n        drive_motor.set_visible(True)\n        drive_rod_p1.set_visible(True)\n        drive_rod_p2.set_visible(True)\n        drive_wheel_p.set_visible(True)\n        drive_motor_grate.set_visible(True)\n        \n    else:\n        center_drive_1.set_visible(True)\n        center_drive_2.set_visible(True)\n        center_drive_shaft.set_visible(True)\n        center_drive_belt.set_visible(True)\n        center_drive_mark_1.set_visible(True)\n        center_drive_mark_2.set_visible(True)\n        \n        drive_rod.set_visible(False)\n        drive_rod_outline.set_visible(False)\n        drive_wheel_rod.set_visible(False)\n        drive_wheel_rod_outline.set_visible(False)\n        drive_wheel.set_visible(False)\n        drive_motor.set_visible(False)\n        drive_rod_p1.set_visible(False)\n        drive_rod_p2.set_visible(False)\n        drive_wheel_p.set_visible(False)\n        drive_motor_grate.set_visible(False)\n    \n    return (line1, line2, line3, ball, gleam, x_arrow, r_arrow, center_drive_1, center_drive_2,\n            center_drive_shaft, center_drive_belt, center_drive_mark_1, center_drive_mark_2,\n            drive_rod_outline, drive_rod, drive_wheel_rod_outline, drive_wheel_rod, drive_wheel, drive_motor,\n            drive_rod_p1, drive_rod_p2, drive_wheel_p, drive_motor_grate,)\n\ndef animate(i):\n    line1.set_data(T_plot[0:i], X_plot[0:i])\n    line2.set_data(T_plot[0:i], R_plot[0:i])\n    line3.set_data(T_plot[0:i], F_plot[0:i])\n    \n    ball.set_center((ball_pos[i], 0.5))\n    gleam.set_center((ball_pos[i], 0.5))\n    gleam.set_theta1(215 + ball_rot[i])\n    gleam.set_theta2(235 + ball_rot[i])\n    \n    if sys_type:\n        center_drive_1.set_visible(False)\n        center_drive_2.set_visible(False)\n        center_drive_shaft.set_visible(False)\n        center_drive_belt.set_visible(False)\n        center_drive_mark_1.set_visible(False)\n        center_drive_mark_2.set_visible(False)\n        \n        drive_rod.set_visible(True)\n        drive_rod_outline.set_visible(True)\n        drive_wheel_rod.set_visible(True)\n        drive_wheel_rod_outline.set_visible(True)\n        drive_wheel.set_visible(True)\n        drive_motor.set_visible(True)\n        drive_rod_p1.set_visible(True)\n        drive_rod_p2.set_visible(True)\n        drive_wheel_p.set_visible(True)\n        drive_motor_grate.set_visible(True)\n        \n    else:\n        center_drive_1.set_visible(True)\n        center_drive_2.set_visible(True)\n        center_drive_shaft.set_visible(True)\n        center_drive_belt.set_visible(True)\n        center_drive_mark_1.set_visible(True)\n        center_drive_mark_2.set_visible(True)\n        \n        drive_rod.set_visible(False)\n        drive_rod_outline.set_visible(False)\n        drive_wheel_rod.set_visible(False)\n        drive_wheel_rod_outline.set_visible(False)\n        drive_wheel.set_visible(False)\n        drive_motor.set_visible(False)\n        drive_rod_p1.set_visible(False)\n        drive_rod_p2.set_visible(False)\n        drive_wheel_p.set_visible(False)\n        drive_motor_grate.set_visible(False)\n        \n    \n    center_drive_mark_1.set_theta1(260 + rot_pos[i] / 2.5)\n    center_drive_mark_1.set_theta2(280 + rot_pos[i] / 2.5)\n    center_drive_mark_2.set_theta1(80 + rot_pos[i] / 2.5)\n    center_drive_mark_2.set_theta2(100 + rot_pos[i] / 2.5)\n    \n    x_arrow.set_xy(base_arrow + [ref_pos[i], 0])\n    r_arrow.set_xy(base_arrow + [ball_pos[i], 0])\n    \n    rotation_transform.clear().rotate_deg_around(0, 0, rot_pos[i])\n    wheel_transform.clear().rotate_deg_around(3.05, -0.85, rot_pos[i] * 9)\n    \n    drive_rod_outline.set_data(np.stack((wheel_transform.transform_point([3.5, -0.85]),\n                               rotation_transform.transform_point([3.4, 0.175]))).T)\n    drive_rod.set_data(np.stack((wheel_transform.transform_point([3.5, -0.85]),\n                                 rotation_transform.transform_point([3.4, 0.175]))).T)\n    drive_wheel_rod_outline.set_data(np.stack(([3.05, -0.85], wheel_transform.transform_point([3.5, -0.85]))).T)\n    drive_wheel_rod.set_data(np.stack(([3.05, -0.85], wheel_transform.transform_point([3.5, -0.85]))).T)\n    \n    return (line1, line2, line3, ball, gleam, x_arrow, r_arrow, center_drive_1, center_drive_2,\n            center_drive_shaft, center_drive_belt, center_drive_mark_1, center_drive_mark_2,\n            drive_rod_outline, drive_rod, drive_wheel_rod_outline, drive_wheel_rod, drive_wheel, drive_motor,\n            drive_rod_p1, drive_rod_p2, drive_wheel_p, drive_motor_grate,)\n\nanim = animation.FuncAnimation(anim_fig, animate, init_func=anim_init,\n                               frames=frame_count, interval=10, blit=True,\n                               repeat=True)\n\n# Controllers\n\nT_slider = w.FloatLogSlider(value=10, base=10, min=-0.7, max=1, step=0.01,\n                            description='Duration [s]:', continuous_update=False,\n                            orientation='vertical', layout=w.Layout(width='auto', height='auto', flex='1 1 auto'))\n\ndt_slider = w.FloatLogSlider(value=0.1, base=10, min=-3, max=-1, step=0.01,\n                             description='Timestep [s]:', continuous_update=False,\n                             orientation='vertical', layout=w.Layout(width='auto', height='auto', flex='1 1 auto'))\n       \nX_type = w.Dropdown(options=[('Constant', 0), ('Sine', 1), ('Square', 2)], value=1,\n                     description='Reference: ', continuous_update=False, layout=w.Layout(width='auto', flex='3 3 auto'))    \nXf_slider = w.FloatLogSlider(value=0.5, base=10, min=-2, max=2, step=0.01,\n                             description='Frequency [Hz]:', continuous_update=False,\n                             orientation='vertical', layout=w.Layout(width='auto', height='auto', flex='1 1 auto'))\nXa_slider = w.FloatLogSlider(value=1, base=10, min=-2, max=2, step=0.01,\n                             description='Amplitude [m]:', continuous_update=False,\n                             orientation='vertical', layout=w.Layout(width='auto', height='auto', flex='1 1 auto'))\nXo_slider = w.FloatSlider(value=0, min=-10, max=10, description='Offset/Ampl:', continuous_update=False,\n                              orientation='vertical', layout=w.Layout(width='auto', height='auto', flex='1 1 auto'))    \n    \nF_type = w.Dropdown(options=[('Constant', 0), ('Sine', 1), ('Square', 2), ('Noise', 3)], value=2,\n                     description='Disturbance: ', continuous_update=False, layout=w.Layout(width='auto', flex='3 3 auto'))    \nFf_slider = w.FloatLogSlider(value=1, base=10, min=-2, max=2, step=0.01,\n                             description='Frequency [Hz]:', continuous_update=False,\n                             orientation='vertical', layout=w.Layout(width='auto', height='auto', flex='1 1 auto'))\nFa_slider = w.FloatLogSlider(value=0.1, base=10, min=-2, max=2, step=0.01,\n                             description='Amplitude [N]:', continuous_update=False,\n                             orientation='vertical', layout=w.Layout(width='auto', height='auto', flex='1 1 auto'))\nFo_slider = w.FloatSlider(value=0, min=-10, max=10, description='Offset/Ampl:', continuous_update=False,\n                              orientation='vertical', layout=w.Layout(width='auto', height='auto', flex='1 1 auto'))\n\ninput_data = w.interactive_output(simulation, {'Kp': Kp_slider, 'Ti': Ti_slider, 'Td': Td_slider,\n                                               'Fd': Fd_slider, 'Ti0' : Ti_button, 'Td0': Td_button,\n                                               'm':m_slider, 'r':r_slider, 'd':d_slider, 'L':L_slider,\n                                               'type_select':typeSelect,\n                                               'T': T_slider, 'dt': dt_slider,\n                                               'X': X_type, 'Xf': Xf_slider, 'Xa': Xa_slider, 'Xo': Xo_slider,\n                                               'F': F_type, 'Ff': Ff_slider, 'Fa': Fa_slider, 'Fo': Fo_slider})\n\ndisplay(w.HBox([w.HBox([T_slider, dt_slider], layout=w.Layout(width='25%')),\n                w.Box([], layout=w.Layout(width='5%')),\n                w.VBox([X_type, w.HBox([Xf_slider, Xa_slider, Xo_slider])], layout=w.Layout(width='30%')),\n                w.Box([], layout=w.Layout(width='5%')),\n                w.VBox([F_type, w.HBox([Ff_slider, Fa_slider, Fo_slider])], layout=w.Layout(width='30%'))],\n                layout=w.Layout(width='100%', justify_content='center')), input_data)\n\n\n\n\n\n\n\n\n\n\n\n\n\nThe duration parameter controls the simulated timeframe and does not affect the runtime of the animation. In contrast, the timestep controls the model sampling and can refine the results in exchange for higher computational resources."
  },
  {
    "objectID": "ICCT_en/examples/03/FD-23_DC_Ballscrew_Positioner.html",
    "href": "ICCT_en/examples/03/FD-23_DC_Ballscrew_Positioner.html",
    "title": "Control design for a DC-motor driven Ball Screw Positioner system",
    "section": "",
    "text": "%matplotlib notebook\nimport control as c\nimport ipywidgets as w\nimport numpy as np\n\nfrom IPython.display import display, HTML\nimport matplotlib.pyplot as plt\nimport matplotlib.patches as patches\nimport matplotlib.animation as animation\n\ndisplay(HTML('&lt;script&gt; $(document).ready(function() { $(\"div.input\").hide(); }); &lt;/script&gt;'))\n\nThe following example is a control design task for a motor-driven ball screw positioner system. The structure consists of a DC motor connected to a ball screw, which drives a cart. The model contains a large set of components. After a set of simplifications, it can be reduced to a linear model with ten parameters.  The motor can be modeled in two separate parts, electrical and mechanical:  \\[G_{elec}(s)=\\frac{1}{sL+R}\\qquad\\qquad G_{mech}=\\frac{1}{sJ+B}\\]    While the ball screw with the cart can be described with the following transfer function:  \\[G_{ballscrew}(s)=\\frac{\\frac{h}{2\\pi}}{s^2 m\\left(\\frac{1}{K}+\\frac{1}{k}\\right)+sb\\left(\\frac{1}{K}+\\frac{1}{k}\\right)+1}\\] \n\n\\(h:\\) thread pitch \\(K:\\) shaft torsional spring contant \\(k:\\) combined linear spring constants \\(b:\\) combined damping \\(m:\\) cart mass\n\n Your task is to choose a controller type, and tune it to acceptable levels of performance!\nFirst, choose a system model! Toggle between different realistic models with randomly preselected values (buttons Model 1 - Model 6). By clicking the Preset button default, valid predetermined controller parameters are set and cannot be tuned further.\n\n# System parameters\n\n# Motor parameters\nR = 0.5      # Ohm - armature resistance\nL = 1.5e-3   # H - armature inductance\nJ = 2.5e-4   # kgm^2 - rotor inertia\nB = 1.0e-3   # Nms - friction as damping\nkPhi = 0.05  # Nm/A or Vs/rad - Torque/back EMF constant\n\n# Ballscrew parameters\nh = [0.8, 1.0, 1.25, 0.8, 1.0, 1.25, 0.8]     # mm - thread pitch\nK = [2e5, 0.5e5, 1e6, 1e6, 2e5, 0.5e5, 5e5]   # Nm/rad - shaft torsional spring constant\nk = [1e4, 4e4, 3e4, 1e4, 3e4, 4e4, 2e4]       # N/m - combined spring constants\nb = [2, 8, 5, 3, 2, 10, 8]                    # Ns/m - combined damping\nm = [0.5, 0.3, 1.5, 0.1, 0.75, 1, 1]          # kg - cart mass\n\n# Figure definition\n\nfig1, ((f1_ax1), (f1_ax2)) = plt.subplots(2, 1)\nfig1.set_size_inches((9.8, 5))\nfig1.set_tight_layout(True)\n\nf1_line1, = f1_ax1.plot([], [])\nf1_line2, = f1_ax2.plot([], [])  \n\nf1_ax1.grid(which='both', axis='both', color='lightgray')\nf1_ax2.grid(which='both', axis='both', color='lightgray')\n\nf1_ax1.autoscale(enable=True, axis='both', tight=True)\nf1_ax2.autoscale(enable=True, axis='both', tight=True)\n\nf1_ax1.set_title('Bode magnitude plot', fontsize=11)\nf1_ax1.set_xscale('log')\nf1_ax1.set_xlabel(r'$f\\/[Hz]$', labelpad=0, fontsize=10)\nf1_ax1.set_ylabel(r'$A\\/[dB]$', labelpad=0, fontsize=10)\nf1_ax1.tick_params(axis='both', which='both', pad=0, labelsize=8)\n\nf1_ax2.set_title('Bode phase plot', fontsize=11)\nf1_ax2.set_xscale('log')\nf1_ax2.set_xlabel(r'$f\\/[Hz]$', labelpad=0, fontsize=10)\nf1_ax2.set_ylabel(r'$\\phi\\/[°]$', labelpad=0, fontsize=10)\nf1_ax2.tick_params(axis='both', which='both', pad=0, labelsize=8)\n\ndef build_base_model(sel):\n    \n    # DC motor model\n    \n    W_v = c.tf([1], [L, R])   # Electrical part\n    W_m = c.tf([1], [J, B])   # Mechanical part\n    W_e = c.tf([kPhi], [1])   # Back EMF component\n    \n    W_motor = c.feedback(c.series(W_v, W_e, W_m), W_e, -1)   # Motor transfer function\n    \n    # Ballscrew model\n    \n    p_num = [h[sel]*1e-3/(2*np.pi)]\n    p_den = [(1/K[sel]+1/k[sel])*m[sel], (1/K[sel]+1/k[sel])*b[sel], 1]\n    \n    W_ballscrew = c.tf(p_num, p_den)\n    \n    # Complete system model\n    \n    W_sys = c.series(W_motor, W_ballscrew)\n    \n    print('System transfer function:')\n    print(W_sys)\n    \n    # System analysis\n    \n    poles = c.pole(W_sys)     # Poles\n    \n    print('System poles:\\n')\n    print(poles)\n    \n    global f1_line1, f1_line2\n    \n    f1_ax1.lines.remove(f1_line1)\n    f1_ax2.lines.remove(f1_line2)\n    \n    mag, phase, omega = c.bode_plot(W_sys, Plot=False)   # Bode-plot\n    \n    f1_line1, = f1_ax1.plot(omega/2/np.pi, 20*np.log10(mag), lw=1, color='blue')\n    f1_line2, = f1_ax2.plot(omega/2/np.pi, phase*180/np.pi, lw=1, color='blue')   \n    \n    f1_ax1.relim()\n    f1_ax2.relim()\n    f1_ax1.autoscale_view()\n    f1_ax2.autoscale_view()\n    \n# GUI widgets\ntypeSelect = w.ToggleButtons(\n    options=[('Model 1', 0), ('Model 2', 1), ('Model 3', 2), ('Model 4', 3), ('Model 5', 4), ('Model 6', 5), ('Preset', -1)],\n    value=-1, description='System: ', layout=w.Layout(width='60%'))\n\ninput_data = w.interactive_output(build_base_model, {'sel':typeSelect})\n\ndisplay(typeSelect, input_data)    \n\n\n\n\n\n\n\n\n\n\n\n\n\nThe system has more poles than you can eliminate using a PID controller; you have to select which ones to modify, while the rest will remain unchanged. Select an appropriate controller configuration! Which one is the best for your system? Why? Set up your controller for the fastest settling time with no overshoot!\nYou can turn on/off each of the I and D components, and if D is active, you can apply the first-order filter as well, based on the derivating time constant.\n\n# PID position control\n\nfig2, ((f2_ax1, f2_ax2, f2_ax3), (f2_ax4, f2_ax5, f2_ax6)) = plt.subplots(2, 3)\nfig2.set_size_inches((9.8, 5))\nfig2.set_tight_layout(True)\n\nf2_line1, = f2_ax1.plot([], [])\nf2_line2, = f2_ax2.plot([], []) \nf2_line3, = f2_ax3.plot([], [])\nf2_line4, = f2_ax4.plot([], [])  \nf2_line5, = f2_ax5.plot([], [])\nf2_line6, = f2_ax6.plot([], [])\n\nf2_ax1.grid(which='both', axis='both', color='lightgray')\nf2_ax2.grid(which='both', axis='both', color='lightgray')\nf2_ax3.grid(which='both', axis='both', color='lightgray')\nf2_ax4.grid(which='both', axis='both', color='lightgray')\nf2_ax5.grid(which='both', axis='both', color='lightgray')\nf2_ax6.grid(which='both', axis='both', color='lightgray')\n\nf2_ax1.autoscale(enable=True, axis='both', tight=True)\nf2_ax2.autoscale(enable=True, axis='both', tight=True)\nf2_ax3.autoscale(enable=True, axis='both', tight=True)\nf2_ax4.autoscale(enable=True, axis='both', tight=True)\nf2_ax5.autoscale(enable=True, axis='both', tight=True)\nf2_ax6.autoscale(enable=True, axis='both', tight=True)\n\n\nf2_ax1.set_title('Closed loop step response', fontsize=9)\nf2_ax1.set_xlabel(r'$t\\/$[s]', labelpad=0, fontsize=8)\nf2_ax1.set_ylabel(r'$x\\/$[m]', labelpad=0, fontsize=8)\nf2_ax1.tick_params(axis='both', which='both', pad=0, labelsize=6)\n\nf2_ax2.set_title('Nyquist diagram', fontsize=9)\nf2_ax2.set_xlabel(r'Re', labelpad=0, fontsize=8)\nf2_ax2.set_ylabel(r'Im', labelpad=0, fontsize=8)\nf2_ax2.tick_params(axis='both', which='both', pad=0, labelsize=6)\n\nf2_ax3.set_title('Bode magniture plot', fontsize=9)\nf2_ax3.set_xscale('log')\nf2_ax3.set_xlabel(r'$f\\/$[Hz]', labelpad=0, fontsize=8)\nf2_ax3.set_ylabel(r'$A\\/$[dB]', labelpad=0, fontsize=8)\nf2_ax3.tick_params(axis='both', which='both', pad=0, labelsize=6)\n\nf2_ax4.set_title('Closed loop impulse response', fontsize=9)\nf2_ax4.set_xlabel(r'$t\\/$[s]', labelpad=0, fontsize=8)\nf2_ax4.set_ylabel(r'$x\\/$[m]', labelpad=0, fontsize=8)\nf2_ax4.tick_params(axis='both', which='both', pad=0, labelsize=6)\n\nf2_ax5.set_title('Load transfer step response', fontsize=9)\nf2_ax5.set_xlabel(r'$t\\/$[s]', labelpad=0, fontsize=8)\nf2_ax5.set_ylabel(r'$x\\/$[m]', labelpad=0, fontsize=8)\nf2_ax5.tick_params(axis='both', which='both', pad=0, labelsize=6)\n\nf2_ax6.set_title('Bode phase plot', fontsize=9)\nf2_ax6.set_xscale('log')\nf2_ax6.set_xlabel(r'$f\\/$[Hz]', labelpad=0, fontsize=8)\nf2_ax6.set_ylabel(r'$\\phi\\/$[°]', labelpad=0, fontsize=8)\nf2_ax6.tick_params(axis='both', which='both', pad=0, labelsize=6)\n\ndef position_control(Kp, Ti, Td, Fd, Ti0, Td0, Fd0, sel):\n    \n    W_motor = c.series(c.tf([1], [L, R]), c.tf([1], [J, B]), c.tf([kPhi], [1]))\n    W_ballscrew = c.tf([h[sel]*1e-3/(2*np.pi)], [(1/K[sel]+1/k[sel])*m[sel], (1/K[sel]+1/k[sel])*b[sel], 1])\n    W_sys = c.series(W_motor, W_ballscrew)\n    \n    # PID Controller\n    \n    P = Kp             # Proportional term\n    I = Kp / Ti        # Integral term\n    D = Kp * Td        # Derivative term\n    Td_f = Td / Fd     # Derivative term filter\n    \n    W_PID = c.parallel(c.tf([P], [1]),\n                       c.tf([I * Ti0], [1 * Ti0, 1 * (not Ti0)]),\n                       c.tf([D * Td0, 0], [Td_f * Td0 * Fd0, 1]))  # PID controller in time constant format\n    \n    W_open = c.series(W_PID, W_sys, c.tf([1], [1, 0]))   # Open loop with integrator added for position output\n    W_closed = c.feedback(W_open, 1, -1)                 # Closed loop with negative feedback\n    \n    W_cart = c.tf([1],[m[sel], b[sel]])                                        # Ballscrew ring transfer function component\n    W_rest = c.series(W_open, c.tf([m[sel], b[sel]], [1]), c.tf([1, 0], [1]))  # The system without the cart and the integrator\n    W_load = c.feedback(c.series(W_cart, c.tf([1], [1, 0])), W_rest, -1)       # Transfer function of the load based errors  \n                        \n    # Display\n\n    global f2_line1, f2_line2, f2_line3, f2_line4, f2_line5, f2_line6\n    \n    f2_ax1.lines.remove(f2_line1)\n    f2_ax2.lines.remove(f2_line2)\n    f2_ax3.lines.remove(f2_line3)\n    f2_ax4.lines.remove(f2_line4)\n    f2_ax5.lines.remove(f2_line5)\n    f2_ax6.lines.remove(f2_line6)\n    \n    tout, yout = c.step_response(W_closed)\n    f2_line1, = f2_ax1.plot(tout, yout, lw=1, color='blue') \n    \n    _, _, ob = c.nyquist_plot(W_open, Plot=False)   # Small resolution plot to determine bounds        \n    real, imag, freq = c.nyquist_plot(W_open, omega=np.logspace(np.log10(ob[0]), np.log10(ob[-1]), 1000), Plot=False)\n    f2_line2, = f2_ax2.plot(real, imag, lw=1, color='blue')\n    \n    mag, phase, omega = c.bode_plot(W_open, Plot=False)\n    f2_line3, = f2_ax3.plot(omega/2/np.pi, 20*np.log10(mag), lw=1, color='blue')\n    f2_line6, = f2_ax6.plot(omega/2/np.pi, phase*180/np.pi, lw=1, color='blue')\n    \n    tout, yout = c.impulse_response(W_closed)\n    f2_line4, = f2_ax4.plot(tout, yout, lw=1, color='blue')   \n    \n    tout, yout = c.step_response(W_load)\n    f2_line5, = f2_ax5.plot(tout, yout, lw=1, color='blue')  \n    \n    f2_ax1.relim()\n    f2_ax2.relim()\n    f2_ax3.relim()\n    f2_ax4.relim()\n    f2_ax5.relim()\n    f2_ax6.relim()\n    f2_ax1.autoscale_view()\n    f2_ax2.autoscale_view()\n    f2_ax3.autoscale_view()\n    f2_ax4.autoscale_view()\n    f2_ax5.autoscale_view()\n    f2_ax6.autoscale_view()\n    \ndef update_controller(index):\n    global Kp_slider, Ti_slider, Td_slider, Fd_slider, Ti_button, Td_button, Fd_button\n    \n    if index == -1:\n        Kp_slider.value = 200\n        Td_slider.value = 0.01\n        Fd_slider.value = 10\n        Ti_button.value = False\n        Td_button.value = True\n        Fd_button.value = True\n        \n        Kp_slider.disabled = True\n        Ti_slider.disabled = True\n        Td_slider.disabled = True\n        Fd_slider.disabled = True\n        Ti_button.disabled = True\n        Td_button.disabled = True\n        Fd_button.disabled = True\n    else:\n        Kp_slider.disabled = False\n        Ti_slider.disabled = False\n        Td_slider.disabled = False\n        Fd_slider.disabled = False\n        Ti_button.disabled = False\n        Td_button.disabled = False\n        Fd_button.disabled = False\n    \n    \n# Controllers\n\nKp_slider = w.FloatLogSlider(value=0.5, base=10, min=-3, max=3, description='Kp:', continuous_update=False,\n                             layout=w.Layout(width='auto', flex='5 5 auto'))\nTi_slider = w.FloatLogSlider(value=0.0035, base=10, min=-4, max=1, description='', continuous_update=False,\n                             layout=w.Layout(width='auto', flex='5 5 auto'))\nTd_slider = w.FloatLogSlider(value=1, base=10, min=-4, max=1, description='', continuous_update=False,\n                             layout=w.Layout(width='auto', flex='5 5 auto'))\nFd_slider = w.FloatLogSlider(value=1, base=10, min=0, max=3, description='', continuous_update=False,\n                             layout=w.Layout(width='auto', flex='5 5 auto'))\n\nTi_button = w.ToggleButton(value=True, description='Ti',\n                           layout=w.Layout(width='auto', flex='1 1 0%'))\nTd_button = w.ToggleButton(value=False, description='Td',\n                           layout=w.Layout(width='auto', flex='1 1 0%'))\nFd_button = w.ToggleButton(value=False, description='Fd',\n                           layout=w.Layout(width='auto', flex='1 1 0%'))\n\ninput_data = w.interactive_output(position_control, {'Kp': Kp_slider, 'Ti': Ti_slider, 'Td': Td_slider,\n                                                 'Fd': Fd_slider, 'Ti0' : Ti_button, 'Td0': Td_button,\n                                                 'Fd0': Fd_button, 'sel':typeSelect})\n\nw.interactive_output(update_controller, {'index':typeSelect})\n\ndisplay(w.HBox([Kp_slider, Ti_button, Ti_slider, Td_button, Td_slider, Fd_button, Fd_slider]), input_data)\n\n\n\n\n\n\n\n\n\n\n\n\n\nIn the following simulation, you can observe the movement of your system based on your controller setup. You can create reference signals and even apply some disturbance and see how the system reacts.\nIs your configuration suitable for signal-following? Readjust your controller so that it can follow a sine wave acceptably!  (The animations are scaled to fit the frame through the whole simulation. Because of this, unstable solutions might not seem to move until the very last second.)\n\n# Simulation data\n\nanim_fig = plt.figure()\nanim_fig.set_size_inches((9.8, 6))\nanim_fig.set_tight_layout(True)\n\nanim_ax1 = anim_fig.add_subplot(211)\nanim_ax2 = anim_ax1.twinx()\n\nframe_count=1000\n\nl1 = anim_ax1.plot([], [], lw=1, color='blue')\nl2 = anim_ax1.plot([], [], lw=2, color='red')\nl3 = anim_ax2.plot([], [], lw=1, color='grey')\n\nline1 = l1[0]\nline2 = l2[0]\nline3 = l3[0]\n\nanim_ax1.legend(l1+l2+l3, ['Reference [m]', 'Output [m]', 'Load [N]'], loc=1)\n\nanim_ax1.set_title('Time response simulation', fontsize=12)\nanim_ax1.set_xlabel(r'$t\\/$[s]', labelpad=0, fontsize=10)\nanim_ax1.set_ylabel(r'$x\\/$[m]', labelpad=0, fontsize=10)\nanim_ax1.tick_params(axis='both', which='both', pad=0, labelsize=8)\nanim_ax2.set_ylabel(r'$F\\/$[N]', labelpad=0, fontsize=10)\nanim_ax2.tick_params(axis='both', which='both', pad=0, labelsize=8)\n\nanim_ax1.grid(which='both', axis='both', color='lightgray')\n\nT_plot = []\nU_plot = []\nF_plot = []\nR_plot = []\n\n# Scene data\n\nscene_ax = anim_fig.add_subplot(212)\nscene_ax.set_xlim((-3, 3))\nscene_ax.set_ylim((-1, 1))\nscene_ax.axis('off')\n\n\nscene_ax.add_patch(patches.Ellipse((-2.5, 0), 0.2, 1, fill=True, fc='indianred', lw=0, zorder=0))\nscene_ax.add_patch(patches.Ellipse((-2, 0), 0.2, 1, fill=True, fc='firebrick', lw=0, zorder=5))\nscene_ax.add_patch(patches.Rectangle((-2.5, -0.5), 0.5, 1, fill=True, fc='indianred', lw=0, zorder=0))\nscene_ax.add_patch(patches.Arc((-2.5, 0), 0.2, 1, theta1=90, theta2=270, color='maroon', lw=1.5, zorder=10))\nscene_ax.add_patch(patches.Arc((-2, 0), 0.2, 1, theta1=90, theta2=270, color='maroon', lw=1.5, zorder=30))\nscene_ax.add_patch(patches.Arc((-2, 0), 0.2, 1, theta1=270, theta2=90, color='maroon', lw=1.5, zorder=0))\nscene_ax.add_patch(patches.Rectangle((-2.48, -0.55), 0.12, 0.1, fill=True, ec='maroon', fc='firebrick', lw=1.5, zorder=15))\nscene_ax.add_patch(patches.Rectangle((-2.22, -0.55), 0.12, 0.1, fill=True, ec='maroon', fc='firebrick', lw=1.5, zorder=15))\nscene_ax.plot([-2.5, -2], [-0.5, -0.5], color='maroon', lw=1.5, zorder=5)\nscene_ax.plot([-2.5, -2], [0.5, 0.5], color='maroon', lw=1.5, zorder=5)\nscene_ax.plot([-2.55, -2.15], [-0.1, -0.1], color='maroon', lw=1.5, zorder=5)\nscene_ax.plot([-2.55, -2.15], [0.1, 0.1], color='maroon', lw=1.5, zorder=5)\n\nscene_ax.add_patch(patches.Rectangle((2.4, -0.55), 0.25, 0.75, fill=True, ec='darkgreen', fc='forestgreen', lw=1.5, zorder=25))\nscene_ax.add_patch(patches.Rectangle((-2.1, -0.075), 0.1, 0.15, fill=True, fc='firebrick', lw=0, zorder=25))\nscene_ax.add_patch(patches.Rectangle((-2.2, -0.075), 0.1, 0.15, fill=True, fc='indianred', lw=0, zorder=25))\nscene_ax.add_patch(patches.Rectangle((-2.15, -0.05), 4.9, 0.1, fill=True, ec='silver',\n                                     fc='dimgrey', lw=1.5, zorder=10))\nscene_ax.add_patch(patches.Arc((-1.99, 0), 0.02, 0.1, theta1=90, theta2=270, color='silver', lw=1.5, zorder=30))\nscene_ax.add_patch(patches.Arc((-2, 0), 0.04, 0.15, theta1=80, theta2=270, color='maroon', lw=1.5, zorder=30))\n\nscrew_base_x = np.tile([0, 0.15, 0.2, 0.05], 30) + np.repeat(np.linspace(0, 4.5, 30), 4)\nscrew_base_y = np.tile([-0.05, 0.05, 0.05, -0.05], 30)\nscrew, = scene_ax.plot(screw_base_x - 2.2, screw_base_y, color='silver', lw=1, zorder=15)\n\ncart_1 = patches.Rectangle((-0.35, -0.1), 0.2, 0.2, fill=True, ec='darkslategray', fc='cornflowerblue', lw=1.5, zorder=35)\ncart_2 = patches.Rectangle((-0.15, -0.3), 0.3, 0.4, fill=True, ec='darkslategray', fc='royalblue', lw=1.5, zorder=35)\ncart_3 = patches.Rectangle((0.15, -0.1), 0.2, 0.2, fill=True, ec='darkslategray', fc='cornflowerblue', lw=1.5, zorder=35)\nscene_ax.add_patch(cart_1)\nscene_ax.add_patch(cart_2)\nscene_ax.add_patch(cart_3)\n\nu_arrow = scene_ax.arrow(0, -0.75, 0, 0.25, color='blue', head_width=0.1,\n                         length_includes_head=True, lw=1, fill=False, zorder=10)\nr_arrow = scene_ax.arrow(0, -0.75, 0, 0.25, color='red', head_width=0.1,\n                         length_includes_head=True, lw=1, fill=False, zorder=10)\nbase_arrow = u_arrow.xy\n\npos_var = []\nref_var = []\n    \n#Simulation function\n\ndef simulation(Kp, Ti, Td, Fd, Ti0, Td0, Fd0, sel, T, dt, U, Uf, Ua, Uo, F, Ff, Fa, Fo):\n    \n    # Controller\n    P = Kp            # Proportional term\n    I = Kp / Ti       # Integral term\n    D = Kp * Td       # Derivative term\n    Td_f = Td / Fd    # Derivative term filter\n    \n    W_PID = c.parallel(c.tf([P], [1]),\n                       c.tf([I * Ti0], [1 * Ti0, 1 * (not Ti0)]),\n                       c.tf([D * Td0, 0], [Td_f * Td0 * Fd0, 1]))  # PID controller\n    \n    \n    # System\n    W_motor = c.series(c.tf([1], [L, R]), c.tf([1], [J, B]), c.tf([kPhi], [1]))\n    W_ballscrew = c.tf([h[sel]*1e-3/(2*np.pi)], [(1/K[sel]+1/k[sel])*m[sel], (1/K[sel]+1/k[sel])*b[sel], 1])\n    W_sys = c.series(W_motor, W_ballscrew)\n    \n    # Model\n    W_open = c.series(W_PID, W_sys, c.tf([1], [1, 0]))   # Open loop with integrator added for position output\n    W_closed = c.feedback(W_open, 1, -1)                 # Closed loop with negative feedback\n    \n    W_cart = c.tf([1],[m[sel], b[sel]])                                        # Ballscrew ring transfer function component\n    W_rest = c.series(W_open, c.tf([m[sel], b[sel]], [1]), c.tf([1, 0], [1]))  # The system without the cart and the integrator\n    W_load = c.feedback(c.series(W_cart, c.tf([1], [1, 0])), W_rest, -1)       # Transfer function of the load based errors \n    \n    # Reference and disturbance signals\n\n    T_sim = np.arange(0, T, dt, dtype=np.float64)\n    \n    if U == 0:     # Constant reference\n        U_sim = np.full_like(T_sim, Ua * Uo)\n    elif U == 1:   # Sine wave reference\n        U_sim = (np.sin(2 * np.pi * Uf * T_sim) + Uo) * Ua\n    elif U == 2:   # Square wave reference\n        U_sim = (np.sign(np.sin(2 * np.pi * Uf * T_sim)) + Uo) * Ua\n        \n    if F == 0:     # Constant load\n        F_sim = np.full_like(T_sim, Fa * Fo)\n    elif F == 1:   # Sine wave load\n        F_sim = (np.sin(2 * np.pi * Ff * T_sim) + Fo) * Fa\n    elif F == 2:   # Square wave load\n        F_sim = (np.sign(np.sin(2 * np.pi * Ff * T_sim)) + Fo) * Fa\n    elif F == 3:   # Noise form load\n        F_sim = np.interp(T_sim, np.linspace(0, T, int(T * Ff) + 2),\n                          np.random.normal(loc=(Fo * Fa), scale=Fa, size=int(T * Ff) + 2))\n    \n    # System response\n        \n    Tu, youtu, xoutu = c.forced_response(W_closed, T_sim, U_sim)\n    Tf, youtf, xoutf = c.forced_response(W_load, T_sim, F_sim)\n    R_sim = np.nan_to_num(youtu + youtf)\n    \n    # Display\n            \n    UR_max = max(np.amax(np.absolute(np.concatenate((U_sim, R_sim)))), Ua)\n    F_max = max(np.amax(np.absolute(F_sim)), Fa)\n    \n    anim_ax1.set_xlim((0, T))\n    anim_ax1.set_ylim((-1.2 * UR_max, 1.2 * UR_max))\n    anim_ax2.set_ylim((-1.5 * F_max, 1.5 * F_max))\n    \n    global T_plot, U_plot, F_plot, R_plot, pos_var, ref_var\n    \n    T_plot = np.linspace(0, T, frame_count, dtype=np.float32)\n    U_plot = np.interp(T_plot, T_sim, U_sim)\n    F_plot = np.interp(T_plot, T_sim, F_sim)\n    R_plot = np.interp(T_plot, T_sim, R_sim)\n    \n    pos_var = R_plot/UR_max\n    ref_var = U_plot/UR_max\n    \n\ndef anim_init():\n    line1.set_data([], [])\n    line2.set_data([], [])\n    line3.set_data([], [])\n    \n    screw.set_data(screw_base_x - 2.2, screw_base_y)\n    \n    cart_1.set_xy((-0.35, -0.1))\n    cart_2.set_xy((-0.15, -0.2))\n    cart_3.set_xy((0.15, -0.1))\n    \n    u_arrow.set_xy(base_arrow)\n    r_arrow.set_xy(base_arrow)\n\n    return (line1, line2, line3, screw, cart_1, cart_2, cart_3, u_arrow, r_arrow,)\n\ndef animate(i):\n    line1.set_data(T_plot[0:i], U_plot[0:i])\n    line2.set_data(T_plot[0:i], R_plot[0:i])\n    line3.set_data(T_plot[0:i], F_plot[0:i])\n    \n    screw_shift = 1 - np.remainder(pos_var[i] * 10, 1)\n    screw.set_data(screw_base_x - 2.2 + 0.15 * screw_shift, screw_base_y)\n    \n    cart_1.set_x(pos_var[i] * 1.5 - 0.35)\n    cart_2.set_x(pos_var[i] * 1.5 - 0.15)\n    cart_3.set_x(pos_var[i] * 1.5 + 0.15)\n    \n    u_arrow.set_xy(base_arrow+[ref_var[i] * 1.5, 0])\n    r_arrow.set_xy(base_arrow+[pos_var[i] * 1.5, 0])\n    \n    return (line1, line2, line3, screw, cart_1, cart_2, cart_3, u_arrow, r_arrow,)\n\nanim = animation.FuncAnimation(anim_fig, animate, init_func=anim_init,\n                               frames=frame_count, interval=10, blit=True,\n                               repeat=True)\n\n# Controllers\n\nT_slider = w.FloatLogSlider(value=10, base=10, min=-0.7, max=1, step=0.01,\n                            description='Duration [s]:', continuous_update=False,\n                            orientation='vertical', layout=w.Layout(width='auto', height='auto', flex='1 1 auto'))\n\ndt_slider = w.FloatLogSlider(value=0.1, base=10, min=-3, max=-1, step=0.01,\n                             description='Timestep [s]:', continuous_update=False,\n                             orientation='vertical', layout=w.Layout(width='auto', height='auto', flex='1 1 auto'))\n       \nU_type = w.Dropdown(options=[('Constant', 0), ('Sine', 1), ('Square', 2)], value=1,\n                     description='Reference: ', continuous_update=False, layout=w.Layout(width='auto', flex='3 3 auto'))    \nUf_slider = w.FloatLogSlider(value=0.5, base=10, min=-2, max=2, step=0.01,\n                             description='Frequency [Hz]:', continuous_update=False,\n                             orientation='vertical', layout=w.Layout(width='auto', height='auto', flex='1 1 auto'))\nUa_slider = w.FloatLogSlider(value=1, base=10, min=-2, max=2, step=0.01,\n                             description='Amplitude [m]:', continuous_update=False,\n                             orientation='vertical', layout=w.Layout(width='auto', height='auto', flex='1 1 auto'))\nUo_slider = w.FloatSlider(value=0, min=-10, max=10, description='Offset/Ampl:', continuous_update=False,\n                              orientation='vertical', layout=w.Layout(width='auto', height='auto', flex='1 1 auto'))    \n    \nF_type = w.Dropdown(options=[('Constant', 0), ('Sine', 1), ('Square', 2), ('Noise', 3)], value=2,\n                     description='Load: ', continuous_update=False, layout=w.Layout(width='auto', flex='3 3 auto'))    \nFf_slider = w.FloatLogSlider(value=1, base=10, min=-2, max=2, step=0.01,\n                             description='Frequency [Hz]:', continuous_update=False,\n                             orientation='vertical', layout=w.Layout(width='auto', height='auto', flex='1 1 auto'))\nFa_slider = w.FloatLogSlider(value=0.1, base=10, min=-2, max=2, step=0.01,\n                             description='Amplitude [N]:', continuous_update=False,\n                             orientation='vertical', layout=w.Layout(width='auto', height='auto', flex='1 1 auto'))\nFo_slider = w.FloatSlider(value=0, min=-10, max=10, description='Offset/Ampl:', continuous_update=False,\n                              orientation='vertical', layout=w.Layout(width='auto', height='auto', flex='1 1 auto'))\n\ninput_data = w.interactive_output(simulation, {'Kp': Kp_slider, 'Ti': Ti_slider, 'Td': Td_slider,\n                                               'Fd': Fd_slider, 'Ti0' : Ti_button, 'Td0': Td_button,\n                                               'Fd0': Fd_button, 'sel':typeSelect,\n                                               'T': T_slider, 'dt': dt_slider,\n                                               'U': U_type, 'Uf': Uf_slider, 'Ua': Ua_slider, 'Uo': Uo_slider,\n                                               'F': F_type, 'Ff': Ff_slider, 'Fa': Fa_slider, 'Fo': Fo_slider})\n\ndisplay(w.HBox([w.HBox([T_slider, dt_slider], layout=w.Layout(width='25%')),\n                w.Box([], layout=w.Layout(width='5%')),\n                w.VBox([U_type, w.HBox([Uf_slider, Ua_slider, Uo_slider])], layout=w.Layout(width='30%')),\n                w.Box([], layout=w.Layout(width='5%')),\n                w.VBox([F_type, w.HBox([Ff_slider, Fa_slider, Fo_slider])], layout=w.Layout(width='30%'))],\n                layout=w.Layout(width='100%', justify_content='center')), input_data)\n\n\n\n\n\n\n\n\n\n\n\n\n\nThe duration parameter controls the simulated timeframe and does not affect the runtime of the animation. In contrast, the timestep controls the model sampling and can refine the results in exchange for higher computational resources."
  },
  {
    "objectID": "ICCT_en/examples/04/SS-01-Solution_of_differential_equations_in_matrix_form.html",
    "href": "ICCT_en/examples/04/SS-01-Solution_of_differential_equations_in_matrix_form.html",
    "title": "Solution of differential equations in matrix form",
    "section": "",
    "text": "# Erasmus+ ICCT project (2018-1-SI01-KA203-047081)\n\n# Toggle cell visibility\n\nfrom IPython.display import HTML\ntag = HTML('''&lt;script&gt;\ncode_show=true; \nfunction code_toggle() {\n    if (code_show){\n        $('div.input').hide()\n    } else {\n        $('div.input').show()\n    }\n    code_show = !code_show\n} \n$( document ).ready(code_toggle);\n&lt;/script&gt;\nToggle cell visibility &lt;a href=\"javascript:code_toggle()\"&gt;here&lt;/a&gt;.''')\ndisplay(tag)\n\n# Hide the code completely\n\n# from IPython.display import HTML\n# tag = HTML('''&lt;style&gt;\n# div.input {\n#     display:none;\n# }\n# &lt;/style&gt;''')\n# display(tag)\n\n\nToggle cell visibility here.\n\n\nRecall that the response of a Single Input Single Output (SISO) Linear Time Invariant (LTI) system:\n\\[\n\\dot{x}(t)=Ax(t)+Bu(t)\n\\] \\[\ny(t) = C x(t) + D u(t),\n\\]\ncan be computed in closed form using the Lagrange Equation:\n\\[\nx(t) = e^{A(t-t_0)}x(t_0) + \\int_{t_0}^{t}{e^{A(t-\\tau)}Bu(\\tau) d \\tau},\n\\]\nThe aim of this example is to show how different combinations of matrices, initial conditions and input functions produce different outputs and state space evolutions.\n\nHow to use this notebook?\n\nDefine the elements of the \\(A\\), \\(B\\), \\(C\\), \\(D\\) matrices for a \\(3\\times3\\) system SISO system.\nSelect the initial condition vector \\(X0\\).\nSelect the type of response.\nPress Test button to see the result of the simulation.\n\nExplore different combinations of initial conditions and input signals.\nExplore the effect of changing values of the \\(B\\) and \\(C\\) matrices with respect to their relation to controllability and observability.\n\n#Preparatory Cell \n\nimport control\nimport numpy\nfrom IPython.display import display, Markdown\nimport ipywidgets as widgets\nimport matplotlib.pyplot as plt\n\n#print a matrix latex-like\ndef bmatrix(a):\n     \"\"\"Returns a LaTeX bmatrix - by Damir Arbula (ICCT project)\n\n     :a: numpy array\n     :returns: LaTeX bmatrix as a string\n     \"\"\"\n     if len(a.shape) &gt; 2:\n         raise ValueError('bmatrix can at most display two dimensions')\n     lines = str(a).replace('[', '').replace(']', '').splitlines()\n     rv = [r'\\begin{bmatrix}']\n     rv += ['  ' + ' & '.join(l.split()) + r'\\\\' for l in lines]\n     rv +=  [r'\\end{bmatrix}']\n     return '\\n'.join(rv)\n\n#create a NxM matrix widget \ndef createMatrixWidget(n,m):\n    M = widgets.GridBox(children=[widgets.FloatText(layout=widgets.Layout(width='100px', height='40px'),\n    value=0.0, disabled=False, label=i) for i in range(n*m)],\n    layout=widgets.Layout(\n        #width='50%',\n        grid_template_columns= ''.join(['100px ' for i in range(m)]),\n        #grid_template_rows='80px 80px 80px',\n        grid_row_gap='0px',\n        track_size='0px')\n    )\n    return M\n\n\n#extract matrix from widgets and convert to numpy matrix\ndef getNumpyMatFromWidget(M,n,m):\n    #get W gridbox dims\n    M_ = numpy.matrix(numpy.zeros((n,m)))\n    for irow in range(0,n):\n        for icol in range(0,m):\n            M_[irow,icol] = M.children[irow*3+icol].value\n\n            \n#this is a simple derived class from FloatText used to experience with interact             \nclass floatWidget(widgets.FloatText):\n    def __init__(self,**kwargs):\n        #self.n = n\n        self.value = 30.0\n        #self.M = \n        widgets.FloatText.__init__(self, **kwargs)\n\n#    def value(self):\n#        return 0 #self.FloatText.value\n\nfrom traitlets import Unicode\nfrom ipywidgets import register \n\n\n#matrixWidget is a matrix looking widget built with a VBox of HBox(es) that returns a numPy array as value !\nclass matrixWidget(widgets.VBox):\n    def updateM(self,change):\n        for irow in range(0,self.n):\n            for icol in range(0,self.m):\n                self.M_[irow,icol] = self.children[irow].children[icol].value\n                #print(self.M_[irow,icol])\n        self.value = self.M_\n\n    def __init__(self,n,m):\n        self.n = n\n        self.m = m\n        self.M_ = numpy.matrix(numpy.zeros((self.n,self.m)))\n        self.value = self.M_\n        widgets.VBox.__init__(self,\n                             children = [\n                                 widgets.HBox(children = \n                                              [widgets.FloatText(value=0.0, layout=widgets.Layout(width='90px')) for i in range(m)]\n                                             ) \n                                 for j in range(n)\n                             ])\n        \n        #fill in widgets and tell interact to call updateM each time a children changes value\n        for irow in range(0,self.n):\n            for icol in range(0,self.m):\n                self.children[irow].children[icol].value = self.M_[irow,icol]\n                self.children[irow].children[icol].observe(self.updateM, names='value')\n        #value = Unicode('example@example.com', help=\"The email value.\").tag(sync=True)\n        self.observe(self.updateM, names='value', type= 'All')\n        \n    def setM(self, newM):\n        self.M_ = newM\n\n        \n#overlaod class for state space systems that DO NOT remove \"useless\" states (what professor of automatic control would do this?)\nclass sss(control.StateSpace):\n    def __init__(self,*args):\n        #call base class init constructor\n        control.StateSpace.__init__(self,*args)\n    #disable function below in base class\n    def _remove_useless_states(self):\n        pass\n\n\n\n## matrix input cell TEST:\n# OK  : added to the alltogether container a button object\n#       added a dummy widget DW of zero dimension so that is not visible   \n#       when the value in the matrix is changed, the callback is NOT called\n#       when the value in the dummy widget is changed the callback is called and the rest works \n#       when the button is pushed, its on_click callback changes the vale of the dummy widet DW \n#       and the callback is called and the output updated \n\n\n#define matrices\nA = matrixWidget(3,3)\nB = matrixWidget(3,1)\nC = matrixWidget(1,3)\nD = matrixWidget(1,1)\nX0 = matrixWidget(3,1)\n\n#this is the main callback and does all the computations and plots \ndef main_callback(matA,matB,matC,matD,X0,DW,sel):\n    #get system eigenvalues\n    lambdas, eigvectors = numpy.linalg.eig(matA)\n    #find if eigenvalues are real or complex:\n    #  thre possible cases:\n    #  - all real \n    #  - first real, second and third complex conjugate\n    #  - first and second complex conjugate, third real \n    \n    #round false complex eigenvalues\n    lambdas = numpy.real_if_close(lambdas)\n    #get imaginary part \n    imagparts = numpy.imag(lambdas)\n    isreal = (imagparts == 0)     \n    #find if must plot two or three modes\n    # TBD\n    \n    #find dominant poles \n    realparts = numpy.real(lambdas)\n    #form alist of time cosntants but remove all poles in 0\n    tclist = [];\n    for p in realparts:\n        if p==0:\n            pass\n        else: \n            tclist.append(1/p)\n    #if empty set time time cosntant to 1 seconds\n    if len(tclist)==0:\n        tclist.append(1.)\n    if max(tclist)&gt;0:\n        # if unstable set tmax = 10\n        tmax = 10\n    else:\n        tmax = abs(10*(max(tclist)))\n    \n    T = numpy.arange(0.0, tmax, 0.05)\n    sys = sss(matA,matB,matC,matD)\n    #X0 = numpy.matrix(numpy.zeros((3,1)))\n    if sel=='initial conditions only':\n        T, yout = control.initial_response(sys, T,X0)\n    elif sel=='step':\n        T, yout = control.step_response(sys, T,X0)\n    else:\n        T, yout = control.impulse_response(sys, T,X0)    \n      \n        \n            \n    \n    fig = plt.figure(figsize=(5.4, 4))\n    # add axes\n    ax = fig.add_subplot(111)\n    # plot step function and responses (initalisation)\n    response_plot, = ax.plot(T,yout, 'b', lw=1)\n\n    \n#create dummy widet \nDW = widgets.FloatText(layout=widgets.Layout(width='0px', height='0px'))\n\n#create button widget\nSTART = widgets.Button(\n    description='Test',\n    disabled=False,\n    button_style='', # 'success', 'info', 'warning', 'danger' or ''\n    tooltip='Test',\n    icon='check'\n)\n                       \ndef on_start_button_clicked(b):\n    #This is a workaround to have intreactive_output call the callback:\n    #   force the value of the dummy widget to change\n    if DW.value&gt; 0 :\n        DW.value = -1\n    else: \n        DW.value = 1\n    pass\nSTART.on_click(on_start_button_clicked)\n\n#define type of ipout \nSELECT = widgets.Dropdown(\n    options=['step', 'impulse', 'initial conditions only'],\n    value='step',\n    description='Type of response:',\n    disabled=False,\n    style = {'description_width': 'initial'}\n)\n\n\n#create a graphic structure to hold all widgets \nalltogether =  widgets.VBox([widgets.HBox([widgets.Label('$\\dot{x}(t) = $',border=3), A,widgets.Label('$x(t)+$',border=3), B,widgets.Label('$u(t)$',border=3), widgets.Label('    $x(t_0)=$',border=3),X0, DW,  START]),\n                             widgets.HBox([widgets.Label('$y(t) = $',border=3), C,widgets.Label('$x(t)+$',border=3), D,widgets.Label('$u(t)$',border=3)]), SELECT ] )\n    \n\nout = widgets.interactive_output(main_callback,{'matA': A, 'matB': B, 'matC': C, 'matD': D, 'X0': X0, 'DW': DW, 'sel': SELECT})\ndisplay(alltogether,out)"
  },
  {
    "objectID": "ICCT_en/examples/04/SS-03-Diagonal_matrices_only_convergent_modes.html",
    "href": "ICCT_en/examples/04/SS-03-Diagonal_matrices_only_convergent_modes.html",
    "title": "Diagonal matrices: Only convergent modes",
    "section": "",
    "text": "# Erasmus+ ICCT project (2018-1-SI01-KA203-047081)\n\n# Toggle cell visibility\n\nfrom IPython.display import HTML\ntag = HTML('''&lt;script&gt;\ncode_show=true; \nfunction code_toggle() {\n    if (code_show){\n        $('div.input').hide()\n    } else {\n        $('div.input').show()\n    }\n    code_show = !code_show\n} \n$( document ).ready(code_toggle);\n&lt;/script&gt;\nToggle cell visibility &lt;a href=\"javascript:code_toggle()\"&gt;here&lt;/a&gt;.''')\ndisplay(tag)\n\n# Hide the code completely\n\n# from IPython.display import HTML\n# tag = HTML('''&lt;style&gt;\n# div.input {\n#     display:none;\n# }\n# &lt;/style&gt;''')\n# display(tag)\n\n\nToggle cell visibility here.\n\n\nA diagonal matrix is a particular matrix that has null elements outside of the principal diagonal. Two examples of such matrices are:\n\\[D_{1}=\\begin{bmatrix}\n1 & 0 & 0 & 0 \\\\\n0 & 3 & 0 & 0 \\\\\n0 & 0 & 2 & 0 \\\\\n0 & 0 & 0 & 1 \\\\\n\\end{bmatrix} \\quad \\text{and} \\quad\nD_{2}=\\begin{bmatrix}\n-1 & 0 & 0 & 0 \\\\\n0 & 0 & 0 & 0 \\\\\n0 & 0 & 2 & 0 \\\\\n0 & 0 & 0 & 1 \\\\\n\\end{bmatrix}.\n\\]\nThis type of matrix, from the systems theory point of view, is the representation of a system where the dynamics of each single state variable is not influenced by other state variables. Dynamics of state variables is said to be decoupled. An example of diagonal matrix with all convergent modes is given below, it is possible to change any value and test if the matrix is diagonal with all convergent modes.\n\n%matplotlib notebook\nimport control\nimport numpy\nfrom IPython.display import display, Markdown\nimport ipywidgets as widgets\nimport matplotlib.pyplot as plt\nfrom matplotlib import animation\n\n#print a matrix latex-like\ndef bmatrix(a):\n     \"\"\"Returns a LaTeX bmatrix - by Damir Arbula (ICCT project)\n\n     :a: numpy array\n     :returns: LaTeX bmatrix as a string\n     \"\"\"\n     if len(a.shape) &gt; 2:\n         raise ValueError('bmatrix can at most display two dimensions')\n     lines = str(a).replace('[', '').replace(']', '').splitlines()\n     rv = [r'\\begin{bmatrix}']\n     rv += ['  ' + ' & '.join(l.split()) + r'\\\\' for l in lines]\n     rv +=  [r'\\end{bmatrix}']\n     return '\\n'.join(rv)\n\n\n# Display formatted matrix: \ndef vmatrix(a):\n    if len(a.shape) &gt; 2:\n         raise ValueError('bmatrix can at most display two dimensions')\n    lines = str(a).replace('[', '').replace(']', '').splitlines()\n    rv = [r'\\begin{vmatrix}']\n    rv += ['  ' + ' & '.join(l.split()) + r'\\\\' for l in lines]\n    rv +=  [r'\\end{vmatrix}']\n    return '\\n'.join(rv)\n\n\n#matrixWidget is a matrix looking widget built with a VBox of HBox(es) that returns a numPy array as value !\nclass matrixWidget(widgets.VBox):\n    def updateM(self,change):\n        for irow in range(0,self.n):\n            for icol in range(0,self.m):\n                self.M_[irow,icol] = self.children[irow].children[icol].value\n                #print(self.M_[irow,icol])\n        self.value = self.M_\n\n    #def dummychangecallback(self,change):\n        #pass\n    \n    \n    def __init__(self,n,m):\n        self.n = n\n        self.m = m\n        self.M_ = numpy.matrix(numpy.zeros((self.n,self.m)))\n        self.value = self.M_\n        widgets.VBox.__init__(self,\n                             children = [\n                                 widgets.HBox(children = \n                                              [widgets.FloatText(value=0.0, layout=widgets.Layout(width='90px')) for i in range(m)]\n                                             ) \n                                 for j in range(n)\n                             ])\n        \n        #fill in widgets and tell interact to call updateM each time a children changes value\n        for irow in range(0,self.n):\n            for icol in range(0,self.m):\n                self.children[irow].children[icol].value = self.M_[irow,icol]\n                self.children[irow].children[icol].observe(self.updateM, names='value')\n        #value = Unicode('example@example.com', help=\"The email value.\").tag(sync=True)\n        self.observe(self.updateM, names='value', type= 'All')\n        \n    def setM(self, newM):\n        #disable callbacks, change values, and reenable\n        self.unobserve(self.updateM, names='value', type= 'All')\n        for irow in range(0,self.n):\n            for icol in range(0,self.m):\n                self.children[irow].children[icol].unobserve(self.updateM, names='value')\n        self.M_ = newM\n        self.value = self.M_\n        for irow in range(0,self.n):\n            for icol in range(0,self.m):\n                self.children[irow].children[icol].value = self.M_[irow,icol]\n        for irow in range(0,self.n):\n            for icol in range(0,self.m):\n                self.children[irow].children[icol].observe(self.updateM, names='value')\n        self.observe(self.updateM, names='value', type= 'All')        \n\n                #self.children[irow].children[icol].observe(self.updateM, names='value')\n\n             \n#overlaod class for state space systems that DO NOT remove \"useless\" states (what \"professor\" of automatic control would do this?)\nclass sss(control.StateSpace):\n    def __init__(self,*args):\n        #call base class init constructor\n        control.StateSpace.__init__(self,*args)\n    #disable function below in base class\n    def _remove_useless_states(self):\n        pass\n\n\nA=matrixWidget(4,4)\nA.setM(numpy.matrix('-1,0,0,0;0,-2,0,0;0,0,-3,0;0,0,0,-4'))\n\ndef main_callback(matA,DW):\n    (r,c) = numpy.shape(matA)\n    print('The eigenvalues are: %s' %str(numpy.linalg.eig(matA)[0]))\n    \n    for i in range(0,r):\n        for j in range(0,c):\n            if i != j:\n                if matA[i,j] != 0:\n                    if all(numpy.real(numpy.linalg.eig(matA)[0]) &lt;= 0):\n                        if all(numpy.real(numpy.linalg.eig(matA)[0]) &lt; 0):\n                            print('The matrix is stable but isn\\'t diagonal')\n                            return\n                        else:\n                            print('The matrix has mode with real part 0 and isn\\'t diagonal')\n                            return\n                    if any(numpy.real(numpy.linalg.eig(matA)[0]) &gt; 0):\n                        print('The matrix is unstable and isn\\'t diagonal')\n                        return\n            else:\n                if matA[i,j] &gt; 0:\n                    print('The matrix is unstable')\n                    return\n                if matA[i,j] == 0:\n                    print('The matrix has a mode with real part 0')\n                    return\n    print('Ok!')\n    \n\n#create dummy widget \nDW = widgets.FloatText(layout=widgets.Layout(width='0px', height='0px'))\n\n#create button widget\nSTART = widgets.Button(\n    description='Test',\n    disabled=False,\n    button_style='', # 'success', 'info', 'warning', 'danger' or ''\n    tooltip='Test',\n    icon='check'\n)\n                       \ndef on_start_button_clicked(b):\n    #This is a workaround to have intreactive_output call the callback:\n    #   force the value of the dummy widget to change\n    if DW.value&gt; 0 :\n        DW.value = -1\n    else: \n        DW.value = 1\n    pass\nSTART.on_click(on_start_button_clicked)\n\nout = widgets.interactive_output(main_callback,{'matA':A,'DW':DW})\ndisplay(A,START,out)"
  },
  {
    "objectID": "ICCT_en/examples/04/SS-05-Jordan_form_with_real_eigenvalues.html",
    "href": "ICCT_en/examples/04/SS-05-Jordan_form_with_real_eigenvalues.html",
    "title": "Jordan Form - Real Eigenvalues",
    "section": "",
    "text": "#remove cell visibility\nfrom IPython.display import HTML\ntag = HTML('''&lt;script&gt;\ncode_show=true; \nfunction code_toggle() {\n    if (code_show){\n        $('div.input').hide()\n    } else {\n        $('div.input').show()\n    }\n    code_show = !code_show\n} \n$( document ).ready(code_toggle);\n&lt;/script&gt;\nToggle cell visibility &lt;a href=\"javascript:code_toggle()\"&gt;here&lt;/a&gt;.''')\ndisplay(tag)\n\n\nToggle cell visibility here.\n\n\nThis example shows the Jordan Form for the dynamic matrix of Linear Time Invariant (LTI) systems. The Jordan form is a particular matrix form that simplifies the modal analysis of a LTI system by highlighting the eigenvalues of the system and the relations between states especially in the case of repeated eigenvalues.\nThe Jordan form can be obtained from the dynamic matrix \\(A\\) of the system \\(\\dot x = A x\\) as:\n\\[\nJ = V^{-1}AV,\n\\]\nwhere \\(V\\) is a matrix composed of the, so called, generalized eigenvectors of the eigenvalues of \\(A\\).\nClearly, since \\(A\\) and \\(J\\) are similar matrices, they share the same eigenvalues and also the same system modes.\nA matrix in Jordan form is a block diagonal matrix like:\n\\[\nJ = \\begin{bmatrix}\nJ_1 & 0 & 0 & ... \\\\\n0 & J_2 & 0 & ... \\\\\n0 & 0 & J_3 & ... \\\\\n... & ... & ... & ...\\\\\n\\end{bmatrix},\n\\]\nwhere the elements \\(J_i\\) are the so called Jordan mini-blocks that look like:\n\\[\nJ_i = \\begin{bmatrix}\n\\lambda_i & 1 & 0 & ... \\\\\n0 & \\lambda_i & 1 & ... \\\\\n0 & 0 & \\lambda_i & ... \\\\\n... & ... & ... & ...\\\\\n\\end{bmatrix},\n\\]\nwhere \\(\\lambda_i\\) is the \\(i\\)-th eigenvalue of \\(J\\) (and of \\(A\\)). The number and dimensions of mini-blocks depends on the multiplicity of the eigenvalues.\n\nHow to use this notebook?\n\nDefine a matrix and watch its Jordan form; experiment with both real and complex eigenvalues.\nNote how the Jordan form of a system matrix with distinct eigenvalues is actually a diagonal matrix (all Jordan mini-blocks of dimension 1).\nNote the relation between the number and dimension of the Jordan mini-blocks of an eigenvalue and the modes associated with it.\nNote that in the case of complex eigenvalues the matrix \\(J\\) has complex elements on the diagonal and so does the generalized eigenvectors matrix \\(V\\).\nExplore the effects of changing matrix \\(A\\) values or load example matrices.\n\n\n#Preparatory Cell \n\nimport control\nimport numpy\nimport sympy\nfrom IPython.display import display, Markdown\nimport ipywidgets as widgets\nimport matplotlib.pyplot as plt\n\nfrom sympy import Matrix \n\n\n\n#print a matrix latex-like\ndef bmatrix(a):\n     \"\"\"Returns a LaTeX bmatrix - by Damir Arbula (ICCT project)\n\n     :a: numpy array\n     :returns: LaTeX bmatrix as a string\n     \"\"\"\n     if len(a.shape) &gt; 2:\n         raise ValueError('bmatrix can at most display two dimensions')\n     lines = str(a).replace('[', '').replace(']', '').splitlines()\n     rv = [r'\\begin{bmatrix}']\n     rv += ['  ' + ' & '.join(l.split()) + r'\\\\' for l in lines]\n     rv +=  [r'\\end{bmatrix}']\n     return '\\n'.join(rv)\n\n\n# Display formatted matrix: \ndef vmatrix(a):\n    if len(a.shape) &gt; 2:\n         raise ValueError('bmatrix can at most display two dimensions')\n    lines = str(a).replace('[', '').replace(']', '').splitlines()\n    rv = [r'\\begin{vmatrix}']\n    rv += ['  ' + ' & '.join(l.split()) + r'\\\\' for l in lines]\n    rv +=  [r'\\end{vmatrix}']\n    return '\\n'.join(rv)\n\n\n#create a NxM matrix widget \ndef createMatrixWidget(n,m):\n    M = widgets.GridBox(children=[widgets.FloatText(layout=widgets.Layout(width='100px', height='40px'),\n    value=0.0, disabled=False, label=i) for i in range(n*m)],\n    layout=widgets.Layout(\n        #width='50%',\n        grid_template_columns= ''.join(['100px ' for i in range(m)]),\n        #grid_template_rows='80px 80px 80px',\n        grid_row_gap='0px',\n        track_size='0px')\n    )\n    return M\n\n\n#extract matrix from widgets and convert to numpy matrix\ndef getNumpyMatFromWidget(M,n,m):\n    #get W gridbox dims\n    M_ = numpy.matrix(numpy.zeros((n,m)))\n    for irow in range(0,n):\n        for icol in range(0,m):\n            M_[irow,icol] = M.children[irow*3+icol].value\n\n            \n#this is a simple derived class from FloatText used to experience with interact             \nclass floatWidget(widgets.FloatText):\n    def __init__(self,**kwargs):\n        #self.n = n\n        self.value = 30.0\n        #self.M = \n        widgets.FloatText.__init__(self, **kwargs)\n\n#    def value(self):\n#        return 0 #self.FloatText.value\n\nfrom traitlets import Unicode\nfrom ipywidgets import register \n\n\n#matrixWidget is a matrix looking widget built with a VBox of HBox(es) that returns a numPy array as value !\nclass matrixWidget(widgets.VBox):\n    def updateM(self,change):\n        for irow in range(0,self.n):\n            for icol in range(0,self.m):\n                self.M_[irow,icol] = self.children[irow].children[icol].value\n                #print(self.M_[irow,icol])\n        self.value = self.M_\n\n    def dummychangecallback(self,change):\n        pass\n    \n    \n    def __init__(self,n,m):\n        self.n = n\n        self.m = m\n        self.M_ = numpy.matrix(numpy.zeros((self.n,self.m)))\n        self.value = self.M_\n        widgets.VBox.__init__(self,\n                             children = [\n                                 widgets.HBox(children = \n                                              [widgets.FloatText(value=0.0, layout=widgets.Layout(width='90px')) for i in range(m)]\n                                             ) \n                                 for j in range(n)\n                             ])\n        \n        #fill in widgets and tell interact to call updateM each time a children changes value\n        for irow in range(0,self.n):\n            for icol in range(0,self.m):\n                self.children[irow].children[icol].value = self.M_[irow,icol]\n                self.children[irow].children[icol].observe(self.updateM, names='value')\n        #value = Unicode('example@example.com', help=\"The email value.\").tag(sync=True)\n        self.observe(self.updateM, names='value', type= 'All')\n        \n    def setM(self, newM):\n        #disable callbacks, change values, and reenable\n        self.unobserve(self.updateM, names='value', type= 'All')\n        for irow in range(0,self.n):\n            for icol in range(0,self.m):\n                self.children[irow].children[icol].unobserve(self.updateM, names='value')\n        self.M_ = newM\n        self.value = self.M_\n        for irow in range(0,self.n):\n            for icol in range(0,self.m):\n                self.children[irow].children[icol].value = self.M_[irow,icol]\n        for irow in range(0,self.n):\n            for icol in range(0,self.m):\n                self.children[irow].children[icol].observe(self.updateM, names='value')\n        self.observe(self.updateM, names='value', type= 'All')        \n\n                #self.children[irow].children[icol].observe(self.updateM, names='value')\n\n        \n\n        \n#overlaod class for state space systems that DO NOT remove \"useless\" states (what \"professor\" of automatic control would do this?)\nclass sss(control.StateSpace):\n    def __init__(self,*args):\n        #call base class init constructor\n        control.StateSpace.__init__(self,*args)\n    #disable function below in base class\n    def _remove_useless_states(self):\n        pass\n\n\n\n#define matrices\nA = matrixWidget(4,4)\n\n#this is the main callback and does all the computations and plots \ndef main_callback(matA,DW,sel):\n    #check if a specific matrix is requested or is manual \n    if sel=='manual definition of the system' :\n        pass\n    elif sel == 'stable system - no complex congjugate poles':\n        matA = numpy.zeros((4,4))\n        matA[0,0] = -1\n        matA[1,1] = -2\n        matA[2,2] = -3\n        matA[3,3] = -4\n        A.setM(matA)\n    elif sel == 'stable system - w/ complex conjugate pair':\n        matA = numpy.zeros((4,4))\n        matA[0,0] = -1\n        matA[0,1] = 3\n        matA[1,0] = -3\n        matA[1,1] = -1\n        matA[2,2] = -3\n        matA[3,3] = -4\n        A.setM(matA)\n    elif sel == 'unstable system - unstable real pole unstable':\n        matA = numpy.zeros((4,4))\n        matA[0,0] = 1\n        matA[1,1] = -2\n        matA[2,2] = -3\n        matA[3,3] = -4\n        A.setM(matA)\n    elif sel ==  'unstable system - unstable complex conjugate pair ':\n        matA = numpy.zeros((4,4))\n        matA[0,0] = 1\n        matA[0,1] = 3\n        matA[1,0] = -3\n        matA[1,1] = 1\n        matA[2,2] = -3\n        matA[3,3] = -4\n        A.setM(matA)\n    else : \n        matA = numpy.zeros((4,4))\n        A.setM(matA)\n    \n    # Work with symbolic matrix\n    matAs = sympy.Matrix(matA)\n    dictEig = matAs.eigenvals()\n    eigs = list(dictEig.keys())\n    algMult = list(dictEig.values())\n    \n    # check dimension of jordan blocks\n    dimJblock = []\n    for i in range(len(eigs)):\n        dimJblock.append(algMult[i]-len((matAs-eigs[i]*sympy.eye(4)).nullspace())+1)\n        \n    # jordan form\n    matAs_P, matAs_J = matAs.jordan_form(chop=True)\n    \n    timeVectors = []\n    modeVectors = []\n    # compute modes simulations and prepare modestring\n    modestring = ''\n    for i in range(len(eigs)):\n        sim = []\n        if sympy.re(eigs[i]) &gt;= 0:\n            # instable or integral like\n            time = numpy.linspace(0,10,1000)\n            for n in range(dimJblock[i]):\n                if n==0:\n                    if sympy.im(eigs[i]) != 0 and (sympy.conjugate(eigs[i]) not in eigs[0:i]):\n                        sim.append(time**n*numpy.exp(float(sympy.re(eigs[i]))*time)*numpy.cos(float(sympy.im(eigs[i]))*time))\n                        modestring = modestring + \"$e^{%s t} cos(%s t + \\phi)$  \" % (str(float(sympy.re(eigs[i]))), str(float(sympy.im(eigs[i]))))\n                    elif sympy.im(eigs[i]) == 0:\n                        sim.append(time**n*numpy.exp(float(sympy.re(eigs[i]))*time))\n                        modestring = modestring + \"$e^{%s t}$  \" % (str(float(sympy.re(eigs[i]))))\n                else:\n                    if sympy.im(eigs[i]) != 0 and (sympy.conjugate(eigs[i]) not in eigs[0:i]):\n                        sim.append(time**n*numpy.exp(float(sympy.re(eigs[i]))*time)*numpy.cos(float(sympy.im(eigs[i]))*time))\n                        modestring = modestring + \"$t^{%s}e^{%s t} cos(%s t + \\phi)$  \" % (str(n), str(float(sympy.re(eigs[i]))), str(float(sympy.im(eigs[i]))))\n                    elif sympy.im(eigs[i]) == 0:\n                        sim.append(time**n*numpy.exp(float(sympy.re(eigs[i]))*time))\n                        modestring = modestring + \"$t^{%s}e^{%s t}$  \" % (str(n), str(float(sympy.re(eigs[i]))))\n        else:\n            # stable mode\n            time = numpy.linspace(0,10*(1/float(sympy.Abs(eigs[i]))),1000)\n            for n in range(dimJblock[i]):\n                if n==0:\n                    if sympy.im(eigs[i]) != 0 and (sympy.conjugate(eigs[i]) not in eigs[0:i]):\n                        sim.append(time**n*numpy.exp(float(sympy.re(eigs[i]))*time)*numpy.cos(float(sympy.im(eigs[i]))*time))\n                        modestring = modestring + \"$e^{%s t} cos(%s t + \\phi)$  \" % (str(float(sympy.re(eigs[i]))), str(float(sympy.im(eigs[i]))))\n                    elif sympy.im(eigs[i]) == 0:\n                        sim.append(time**n*numpy.exp(float(sympy.re(eigs[i]))*time))\n                        modestring = modestring + \"$e^{%s t}$  \" % (str(float(sympy.re(eigs[i]))))\n                else:\n                    if sympy.im(eigs[i]) != 0 and (sympy.conjugate(eigs[i]) not in eigs[0:i]):\n                        sim.append(time**n*numpy.exp(float(sympy.re(eigs[i]))*time)*numpy.cos(float(sympy.im(eigs[i]))*time))\n                        modestring = modestring + \"$t^{%s}e^{%s t} cos(%s t + \\phi)$  \" % (str(n), str(float(sympy.re(eigs[i]))), str(float(sympy.im(eigs[i]))))\n                    elif sympy.im(eigs[i]) == 0:\n                        sim.append(time**n*numpy.exp(float(sympy.re(eigs[i]))*time))\n                        modestring = modestring + \"$t^{%s}e^{%s t}$  \" % (str(n), str(float(sympy.re(eigs[i]))))\n        if len(sim) != 0:\n            timeVectors.append(time)\n            modeVectors.append(sim)\n    \n    #print(dimJblock)\n    #print(len(modeVectors))\n    \n    #create textual output            \n    display(Markdown('Matrix: $%s$ has eigenvalues $%s$' % (vmatrix(matA), vmatrix(numpy.array(numpy.linalg.eig(matA)[0])))))\n    #for better visualization\n    matJlist = []\n    for i in range(4):\n        temp = []\n        for j in range(4):\n            if sympy.im(matAs_J[i,j]) != 0:\n                temp.append(numpy.complex(matAs_J[i,j]))\n            else:\n                temp.append(numpy.real(matAs_J[i,j]))\n        matJlist.append(temp)\n    matJ = numpy.matrix(matJlist)\n    display(Markdown('and the Jordan form equal to: $%s$' %str(vmatrix(matJ))))\n    #for better visualization\n    matPlist = []\n    for i in range(4):\n        temp = []\n        for j in range(4):\n            if sympy.im(matAs_P[i,j]) != 0:\n                temp.append(numpy.complex(matAs_P[i,j]))\n            else:\n                temp.append(numpy.real(matAs_P[i,j]))\n        matPlist.append(temp)\n    matP = numpy.matrix(matPlist)\n    display(Markdown('with generalized eigenvectors $%s$.' %str(vmatrix(matP))))\n    display(Markdown('The modes are: %s' % modestring))\n    \n    #compute total number of figures\n    totfig=0\n    for i in range(len(modeVectors)):\n            totfig = totfig + len(modeVectors[i])\n            \n    #plot each single mode\n    fig = plt.figure(figsize=(20, 4))\n    idx = 1\n    for i in range(len(timeVectors)):\n        for j in range(len(modeVectors[i])):\n            sf = fig.add_subplot(1,totfig,idx)\n            idx = idx + 1\n            sf.plot(timeVectors[i],modeVectors[i][j])\n            sf.grid(True)\n            plt.xlabel(r'$t$ [s]')\n            plt.axvline(x=0,color='black',linewidth=0.8)\n            plt.axhline(y=0,color='black',linewidth=0.8)\n\n    \n    \n#create dummy widget \nDW = widgets.FloatText(layout=widgets.Layout(width='0px', height='0px'))\n\n#create button widget\nSTART = widgets.Button(\n    description='Test',\n    disabled=False,\n    button_style='', # 'success', 'info', 'warning', 'danger' or ''\n    tooltip='Test',\n    icon='check'\n)\n                       \ndef on_start_button_clicked(b):\n    #This is a workaround to have intreactive_output call the callback:\n    #   force the value of the dummy widget to change\n    if DW.value&gt; 0 :\n        DW.value = -1\n    else: \n        DW.value = 1\n    pass\nSTART.on_click(on_start_button_clicked)\n\n#define type of ipout \nSELECT = widgets.Dropdown(\n    options=['manual definition of the system', 'reset', 'stable system - no complex congjugate poles', \n             'stable system - w/ complex conjugate pair', \n             'unstable system - unstable real pole unstable', \n             'unstable system - unstable complex conjugate pair '],\n    value='manual definition of the system',\n    description='Examples:',\n    disabled=False,\n)\n\n\n#create a graphic structure to hold all widgets \nalltogether =  widgets.VBox([SELECT, widgets.Label(''), widgets.HBox([widgets.Label('$\\dot{x}(t) = $',border=3), A,widgets.Label('$x(t)$',border=3), START])] )\n    \n\nout = widgets.interactive_output(main_callback,{'matA': A, 'DW': DW, 'sel': SELECT})\nout.layout.height = '600px'\ndisplay(alltogether,out)"
  },
  {
    "objectID": "ICCT_en/examples/04/SS-07-From_differential_equation_form_to_state_space.html",
    "href": "ICCT_en/examples/04/SS-07-From_differential_equation_form_to_state_space.html",
    "title": "From differential equation form to state space model",
    "section": "",
    "text": "# Erasmus+ ICCT project (2018-1-SI01-KA203-047081)\n\n# Toggle cell visibility\n\nfrom IPython.display import HTML\ntag = HTML('''&lt;script&gt;\ncode_show=true; \nfunction code_toggle() {\n    if (code_show){\n        $('div.input').hide()\n    } else {\n        $('div.input').show()\n    }\n    code_show = !code_show\n} \n$( document ).ready(code_toggle);\n&lt;/script&gt;\nToggle cell visibility &lt;a href=\"javascript:code_toggle()\"&gt;here&lt;/a&gt;.''')\ndisplay(tag)\n\n# Hide the code completely\n\n# from IPython.display import HTML\n# tag = HTML('''&lt;style&gt;\n# div.input {\n#     display:none;\n# }\n# &lt;/style&gt;''')\n# display(tag)\n\n\nToggle cell visibility here.\n\n\n\nModeling a Mass-Spring-Damper system\nThis example lets you experience parametric variations and free and forced response of the Mass-Spring-Damper system presented in the manual.\n\nThe equation that describes the system is:\n\\[m\\ddot{x}=-kx-c\\dot{x}+F(t),\\]\nwhere \\(x\\) is the position of the mass along its degree of freedom of motion, \\(m\\) is its mass, \\(k\\) is the stiffness of the spring (thus \\(kx\\) is the force exerted by the spring on the mass), \\(c\\) the constant that describes the viscous damper (thus \\(c\\dot{x}\\) is the force exerted by the damper on the mass, and \\(F(t)\\) is the external force applied to the mass (it actually represents the input of the system).\nBy defining the state vector \\(\\textbf{x}=[x_1, x_2]^T\\), where \\(x_1=x\\) and \\(x_2=\\dot{x}\\), and the input as \\(u(t)=F(t)\\), it is possible to describe the behaviour of the system by the two equations:\n\\[\\begin{cases}\n\\dot{x_2}=-\\frac{k}{m}x_1-\\frac{c}{m}x_2+u(t) \\\\\n\\dot{x_1}=x_2\n\\end{cases}\\]\n(note that \\(\\dot{x_2}=\\ddot{x}\\)). Thus in matrix form \\[\n\\begin{bmatrix}\n\\dot{x_1} \\\\\n\\dot{x_2}\n\\end{bmatrix}=\\underbrace{\\begin{bmatrix}\n0 && 1 \\\\\n-\\frac{k}{m} && -\\frac{c}{m}\n\\end{bmatrix}}_{A}\\begin{bmatrix}\nx_1 \\\\\nx_2\n\\end{bmatrix}+\\underbrace{\\begin{bmatrix}\n0 \\\\\n\\frac{1}{m}\n\\end{bmatrix}}_{B}u.\n\\]\n\n\nHow to use this notebook?\n\nExplore the different responses of the system to different initial conditions and to different inputs.\nNote how the value of the damper coefficient \\(c\\) affects the presence or not of oscillations of the mass position.\n\nTry to let the mass oscillate forever, or to move quickly from point to point without oscillations.\nTry to find, if you can, a set of parameters (\\(m\\), \\(k\\) and \\(c\\)) and an input function that let the oscillations amplitude increase in time towards infinity. Is it possible?\n\n#Preparatory Cell \n\n%matplotlib notebook\nimport control\nimport numpy\nfrom IPython.display import display, Markdown\nimport ipywidgets as widgets\nimport matplotlib.pyplot as plt\nfrom matplotlib import animation\n\n%matplotlib inline\n#print a matrix latex-like\ndef bmatrix(a):\n     \"\"\"Returns a LaTeX bmatrix - by Damir Arbula (ICCT project)\n\n     :a: numpy array\n     :returns: LaTeX bmatrix as a string\n     \"\"\"\n     if len(a.shape) &gt; 2:\n         raise ValueError('bmatrix can at most display two dimensions')\n     lines = str(a).replace('[', '').replace(']', '').splitlines()\n     rv = [r'\\begin{bmatrix}']\n     rv += ['  ' + ' & '.join(l.split()) + r'\\\\' for l in lines]\n     rv +=  [r'\\end{bmatrix}']\n     return '\\n'.join(rv)\n\n\n# Display formatted matrix: \ndef vmatrix(a):\n    if len(a.shape) &gt; 2:\n         raise ValueError('bmatrix can at most display two dimensions')\n    lines = str(a).replace('[', '').replace(']', '').splitlines()\n    rv = [r'\\begin{vmatrix}']\n    rv += ['  ' + ' & '.join(l.split()) + r'\\\\' for l in lines]\n    rv +=  [r'\\end{vmatrix}']\n    return '\\n'.join(rv)\n\n\n#matrixWidget is a matrix looking widget built with a VBox of HBox(es) that returns a numPy array as value !\nclass matrixWidget(widgets.VBox):\n    def updateM(self,change):\n        for irow in range(0,self.n):\n            for icol in range(0,self.m):\n                self.M_[irow,icol] = self.children[irow].children[icol].value\n                #print(self.M_[irow,icol])\n        self.value = self.M_\n\n    def dummychangecallback(self,change):\n        pass\n    \n    \n    def __init__(self,n,m):\n        self.n = n\n        self.m = m\n        self.M_ = numpy.matrix(numpy.zeros((self.n,self.m)))\n        self.value = self.M_\n        widgets.VBox.__init__(self,\n                             children = [\n                                 widgets.HBox(children = \n                                              [widgets.FloatText(value=0.0, layout=widgets.Layout(width='90px')) for i in range(m)]\n                                             ) \n                                 for j in range(n)\n                             ])\n        \n        #fill in widgets and tell interact to call updateM each time a children changes value\n        for irow in range(0,self.n):\n            for icol in range(0,self.m):\n                self.children[irow].children[icol].value = self.M_[irow,icol]\n                self.children[irow].children[icol].observe(self.updateM, names='value')\n        #value = Unicode('example@example.com', help=\"The email value.\").tag(sync=True)\n        self.observe(self.updateM, names='value', type= 'All')\n        \n    def setM(self, newM):\n        #disable callbacks, change values, and reenable\n        self.unobserve(self.updateM, names='value', type= 'All')\n        for irow in range(0,self.n):\n            for icol in range(0,self.m):\n                self.children[irow].children[icol].unobserve(self.updateM, names='value')\n        self.M_ = newM\n        self.value = self.M_\n        for irow in range(0,self.n):\n            for icol in range(0,self.m):\n                self.children[irow].children[icol].value = self.M_[irow,icol]\n        for irow in range(0,self.n):\n            for icol in range(0,self.m):\n                self.children[irow].children[icol].observe(self.updateM, names='value')\n        self.observe(self.updateM, names='value', type= 'All')        \n\n                #self.children[irow].children[icol].observe(self.updateM, names='value')\n\n             \n#overlaod class for state space systems that DO NOT remove \"useless\" states (what \"professor\" of automatic control would do this?)\nclass sss(control.StateSpace):\n    def __init__(self,*args):\n        #call base class init constructor\n        control.StateSpace.__init__(self,*args)\n    #disable function below in base class\n    def _remove_useless_states(self):\n        pass\n\n\n#define matrixes\n\nC = numpy.matrix([[1,0],[0,1]])\nD = numpy.matrix([[0],[0]])\nX0 = matrixWidget(2,1)\n\n\nm = widgets.FloatSlider(\n    value=5,\n    min=0.1,\n    max=10.0,\n    step=0.1,\n    description='m [kg]:',\n    disabled=False,\n    continuous_update=False,\n    orientation='horizontal',\n    readout=True,\n    readout_format='.1f',\n)\nk = widgets.FloatSlider(\n    value=1,\n    min=0,\n    max=10.0,\n    step=0.1,\n    description='k [N/m]:',\n    disabled=False,\n    continuous_update=False,\n    orientation='horizontal',\n    readout=True,\n    readout_format='.1f',\n)\nc = widgets.FloatSlider(\n    value=0.5,\n    min=0,\n    max=10.0,\n    step=0.1,\n    description='c [Ns/m]:',\n    disabled=False,\n    continuous_update=False,\n    orientation='horizontal',\n    readout=True,\n    readout_format='.1f',\n)\nu = widgets.FloatSlider(\n    value=1,\n    min=0,\n    max=10.0,\n    step=0.1,\n    description='',\n    disabled=False,\n    continuous_update=False,\n    orientation='horizontal',\n    readout=True,\n    readout_format='.1f',\n)\nomega = widgets.FloatSlider(\n    value=5,\n    min=0,\n    max=10.0,\n    step=0.1,\n    description='',\n    disabled=False,\n    continuous_update=False,\n    orientation='horizontal',\n    readout=True,\n    readout_format='.1f',\n)\n\n\ndef main_callback(X0, m, k, c, u, selu, omega):#m, k, c, u, selu, DW\n    \n    a = numpy.matrix([[0,1],[-k/m,-c/m]])\n    b = numpy.matrix([[0],[1/m]])\n\n    eig = numpy.linalg.eig(a)\n    sys = sss(a,b,C,D)\n    \n    if min(numpy.real(abs(eig[0]))) != 0:\n        T = numpy.linspace(0,100/min(numpy.real(abs(eig[0]))),1000)\n    else:\n        if max(numpy.real(abs(eig[0]))) != 0:\n            T = numpy.linspace(0,100/max(numpy.real(abs(eig[0]))),1000)\n        else:\n            T = numpy.linspace(0,1000,1000)\n        \n    if selu == 'impulse': #selu\n        U = [0 for t in range(0,len(T))]\n        U[0] = u\n        y = control.forced_response(sys,T,U,X0)\n    if selu == 'step':\n        U = [u for t in range(0,len(T))]\n        y = control.forced_response(sys,T,U,X0)\n    if selu == 'sinusoid':\n        U = u*numpy.sin(omega*T)\n        y = control.forced_response(sys,T,U,X0)\n    \n    fig=plt.figure(num=1,figsize=[15, 4])\n    fig.add_subplot(121)\n    plt.plot(T,y[1][0])\n    plt.grid()\n    plt.xlabel('time [s]')\n    plt.ylabel('position [m]')\n    \n    fig.add_subplot(122)\n    plt.plot(T,y[1][1])\n    plt.grid()\n    plt.xlabel('time [s]')\n    plt.ylabel('velocity [m]')\n    \n    #display(Markdown('The A matrix is: $%s$ and the eigenvalues are: $%s$' % (bmatrix(a),eig[0])))\n\n#create dummy widget \nDW = widgets.FloatText(layout=widgets.Layout(width='0px', height='0px'))\n\n#create button widget\nSTART = widgets.Button(\n    description='Test',\n    disabled=False,\n    button_style='', # 'success', 'info', 'warning', 'danger' or ''\n    tooltip='Test',\n    icon='check'\n)\n                       \ndef on_start_button_clicked(b):\n    #This is a workaround to have intreactive_output call the callback:\n    #   force the value of the dummy widget to change\n    if DW.value&gt; 0 :\n        DW.value = -1\n    else: \n        DW.value = 1\n    pass\nSTART.on_click(on_start_button_clicked)\n\n#define type of ipout \nSELECT = widgets.Dropdown(\n    options=['impulse', 'step', 'sinusoid'],\n    value='impulse',\n    description='',\n    disabled=False\n)\n\n#create a graphic structure to hold all widgets \nalltogether =  widgets.VBox([widgets.HBox([widgets.VBox([m,\n                                           k,\n                                           c]),\n                            widgets.HBox([widgets.VBox([widgets.Label('select the type of input:',border=3),\n                                                        widgets.Label('u [N]:',border=3),\n                                                        widgets.Label('omega [rad/s]:',border=3)]),\n                                          widgets.VBox([SELECT,u,omega])])]),\n                             widgets.HBox([widgets.Label('Initial state X0:',border=3),X0])])\n\nout = widgets.interactive_output(main_callback,{'X0':X0, 'm': m, 'k': k, 'c': c, 'u': u, 'selu': SELECT, 'omega':omega})\n#out.layout.height = '300px'\ndisplay(out,alltogether)"
  },
  {
    "objectID": "ICCT_en/examples/04/SS-09-Car_speed_dynamics.html",
    "href": "ICCT_en/examples/04/SS-09-Car_speed_dynamics.html",
    "title": "Car speed dynamics",
    "section": "",
    "text": "# Erasmus+ ICCT project (2018-1-SI01-KA203-047081)\n\n# Toggle cell visibility\n\nfrom IPython.display import HTML\ntag = HTML('''&lt;script&gt;\ncode_show=true; \nfunction code_toggle() {\n    if (code_show){\n        $('div.input').hide()\n    } else {\n        $('div.input').show()\n    }\n    code_show = !code_show\n} \n$( document ).ready(code_toggle);\n&lt;/script&gt;\nToggle cell visibility &lt;a href=\"javascript:code_toggle()\"&gt;here&lt;/a&gt;.''')\ndisplay(tag)\n\n# Hide the code completely\n\n# from IPython.display import HTML\n# tag = HTML('''&lt;style&gt;\n# div.input {\n#     display:none;\n# }\n# &lt;/style&gt;''')\n# display(tag)\n\n\nToggle cell visibility here.\n\n\nThis example shows the speed dynamics of a car by writing its dynamics using differential equations and then reformulating them in state space form.\nThe velocity dynamics of a car is governed by two main forces: traction and air resistance. The necessary data for describing the system are: car mass \\(m = 1000\\) kg; maximum motor torque \\(\\tau_{\\text{max}}=150\\) Nm; wheel radius \\(r=25\\) cm (assume for simplicity gear ratio \\(\\eta\\) constant and 4:1 engine:wheel); aerodynamic resistance damping factor \\(b = 60\\) Ns/m (air resistance modelled as a linear function of speed \\(v\\)).\nIt is assumed that engine dynamics, from throttle command \\(t_{r}\\) (limited in \\([0, 1]\\)) to obtained fraction of max torque \\(\\tau_{\\%}\\), can be modelled as:\n\\[\n\\dot{\\tau}_{\\%}=-\\frac{1}{2}\\tau_{\\%}+\\frac{1}{2}t_{r}\n\\]\nlike a first order linear system with \\(T=2\\) s time constant, and unit gain.\n\nDifferential equation\nBy the Newton’s equation (\\(F=ma\\)) it is possible to write the differential equation that describes the car motion:\n\\[\nm\\dot{v}= \\frac{\\tau_{\\text{max}}\\eta}{r}\\tau_{\\%}-bv,\n\\]\nwhere the torque generated by the motor is obtained by multiplying \\(\\tau_{\\%}\\) by maximum torque \\(\\tau_{\\text{max}}\\). The behaviour of the system is then described by the differential equations system:\n\\[\n\\begin{cases}\nm\\dot{v}= \\frac{\\tau_{\\text{max}}\\eta}{r}\\tau_{\\%}-bv \\\\\n\\dot{\\tau}_{\\%}=-\\frac{1}{2}\\tau_{\\%}+\\frac{1}{2}t_{r}\n\\end{cases}\n\\]\n\n\nState space form\nSince the two differential equations are both first order differential equations, the number of necessary states in order to completely describe the behaviour of the system is 2. Defining the state vector as \\(x=\\begin{bmatrix}x_1&x_2\\end{bmatrix}^T=\\begin{bmatrix}v&\\tau_{\\%}\\end{bmatrix}^T\\) and treating \\(t_r\\) as input, in state space form the equations become:\n\\[\n\\dot{x}=\\underbrace{\\begin{bmatrix}-\\frac{b}{m}&\\frac{\\tau_{\\text{max}}\\eta}{mr}\\\\0&-\\frac{1}{2}\\end{bmatrix}}_{A}x+\\underbrace{\\begin{bmatrix}0\\\\\\frac{1}{2}\\end{bmatrix}}_{B}t_r \\\\\n\\]\n\n\nHow to use this notebook?\nPlay with the system’s parameters and try to answer the following questions: - Can the simple car model of this example reach an infinite velocity? Why? - Does the maximum velocity depend on the car’s mass? Why? - Is a negative throttle (\\(t_r\\)) value meaningful for this model? Why?\n\n#Preparatory Cell \n\n%matplotlib notebook\nimport control\nimport numpy\nfrom IPython.display import display, Markdown\nimport ipywidgets as widgets\nimport matplotlib.pyplot as plt\n\n%matplotlib inline\n#print a matrix latex-like\ndef bmatrix(a):\n     \"\"\"Returns a LaTeX bmatrix - by Damir Arbula (ICCT project)\n\n     :a: numpy array\n     :returns: LaTeX bmatrix as a string\n     \"\"\"\n     if len(a.shape) &gt; 2:\n         raise ValueError('bmatrix can at most display two dimensions')\n     lines = str(a).replace('[', '').replace(']', '').splitlines()\n     rv = [r'\\begin{bmatrix}']\n     rv += ['  ' + ' & '.join(l.split()) + r'\\\\' for l in lines]\n     rv +=  [r'\\end{bmatrix}']\n     return '\\n'.join(rv)\n\n\n# Display formatted matrix: \ndef vmatrix(a):\n    if len(a.shape) &gt; 2:\n         raise ValueError('bmatrix can at most display two dimensions')\n    lines = str(a).replace('[', '').replace(']', '').splitlines()\n    rv = [r'\\begin{vmatrix}']\n    rv += ['  ' + ' & '.join(l.split()) + r'\\\\' for l in lines]\n    rv +=  [r'\\end{vmatrix}']\n    return '\\n'.join(rv)\n\n\n#matrixWidget is a matrix looking widget built with a VBox of HBox(es) that returns a numPy array as value !\nclass matrixWidget(widgets.VBox):\n    def updateM(self,change):\n        for irow in range(0,self.n):\n            for icol in range(0,self.m):\n                self.M_[irow,icol] = self.children[irow].children[icol].value\n                #print(self.M_[irow,icol])\n        self.value = self.M_\n\n    def dummychangecallback(self,change):\n        pass\n    \n    \n    def __init__(self,n,m):\n        self.n = n\n        self.m = m\n        self.M_ = numpy.matrix(numpy.zeros((self.n,self.m)))\n        self.value = self.M_\n        widgets.VBox.__init__(self,\n                             children = [\n                                 widgets.HBox(children = \n                                              [widgets.FloatText(value=0.0, layout=widgets.Layout(width='90px')) for i in range(m)]\n                                             ) \n                                 for j in range(n)\n                             ])\n        \n        #fill in widgets and tell interact to call updateM each time a children changes value\n        for irow in range(0,self.n):\n            for icol in range(0,self.m):\n                self.children[irow].children[icol].value = self.M_[irow,icol]\n                self.children[irow].children[icol].observe(self.updateM, names='value')\n        #value = Unicode('example@example.com', help=\"The email value.\").tag(sync=True)\n        self.observe(self.updateM, names='value', type= 'All')\n        \n    def setM(self, newM):\n        #disable callbacks, change values, and reenable\n        self.unobserve(self.updateM, names='value', type= 'All')\n        for irow in range(0,self.n):\n            for icol in range(0,self.m):\n                self.children[irow].children[icol].unobserve(self.updateM, names='value')\n        self.M_ = newM\n        self.value = self.M_\n        for irow in range(0,self.n):\n            for icol in range(0,self.m):\n                self.children[irow].children[icol].value = self.M_[irow,icol]\n        for irow in range(0,self.n):\n            for icol in range(0,self.m):\n                self.children[irow].children[icol].observe(self.updateM, names='value')\n        self.observe(self.updateM, names='value', type= 'All')        \n\n                #self.children[irow].children[icol].observe(self.updateM, names='value')\n\n             \n#overlaod class for state space systems that DO NOT remove \"useless\" states (what \"professor\" of automatic control would do this?)\nclass sss(control.StateSpace):\n    def __init__(self,*args):\n        #call base class init constructor\n        control.StateSpace.__init__(self,*args)\n    #disable function below in base class\n    def _remove_useless_states(self):\n        pass\n\n\n#define matrixes\nC = numpy.matrix([[1,0],[0,1]])\nD = numpy.matrix([[0],[0]])\nX0 = matrixWidget(2,1)\n\n\nm = widgets.FloatSlider(\n    value=1000,\n    min=400,\n    max=2000,\n    step=1,\n    description='m [kg]:',\n    disabled=False,\n    continuous_update=False,\n    orientation='horizontal',\n    readout=True,\n    readout_format='.1f',\n)\neta = widgets.FloatSlider(\n    value=4,\n    min=0.8,\n    max=10.0,\n    step=0.1,\n    description='$\\eta$:',\n    disabled=False,\n    continuous_update=False,\n    orientation='horizontal',\n    readout=True,\n    readout_format='.1f',\n)\ntau_max = widgets.FloatSlider(\n    value=150,\n    min=50,\n    max=900,\n    step=1,\n    description=r'$\\tau_{\\text{max}}$ [Nm]:',\n    disabled=False,\n    continuous_update=False,\n    orientation='horizontal',\n    readout=True,\n    readout_format='.1f',\n)\nb_air = widgets.FloatSlider(\n    value=60,\n    min=0,\n    max=200,\n    step=1,\n    description=r'$b$ [Ns/m]:',\n    disabled=False,\n    continuous_update=False,\n    orientation='horizontal',\n    readout=True,\n    readout_format='.1f',\n)\nu = widgets.FloatSlider(\n    value=0.5,\n    min=0,\n    max=1,\n    step=0.01,\n    description='',\n    disabled=False,\n    continuous_update=False,\n    orientation='horizontal',\n    readout=True,\n    readout_format='.1f',\n)\nomega = widgets.FloatSlider(\n    value=5,\n    min=0,\n    max=10.0,\n    step=0.1,\n    description='',\n    disabled=False,\n    continuous_update=False,\n    orientation='horizontal',\n    readout=True,\n    readout_format='.1f',\n)\n\n\n#create dummy widget \nDW = widgets.FloatText(layout=widgets.Layout(width='0px', height='0px'))\n\n#create button widget\nSTART = widgets.Button(\n    description='Click!',\n    disabled=False,\n    button_style='', # 'success', 'info', 'warning', 'danger' or ''\n    tooltip='Click for changed initial conditions',\n    icon='check'\n)\n                       \ndef on_start_button_clicked(b):\n    #This is a workaround to have intreactive_output call the callback:\n    #   force the value of the dummy widget to change\n    if DW.value&gt; 0 :\n        DW.value = -1\n    else: \n        DW.value = 1\n    pass\nSTART.on_click(on_start_button_clicked)\n\n#define type of ipout \nSELECT = widgets.Dropdown(\n    options=['impulse', 'step', 'sinusoid'],\n    value='step',\n    description='',\n    disabled=False\n)\n\n\ndef main_callback(X0, m, eta, tau_max, b_air, u, selu, omega, DW):\n    r = 0.25 # m\n    a = numpy.matrix([[-b_air/m,tau_max*eta/m/r],[0,-1/2]])\n    b = numpy.matrix([[0],[1/2]])\n\n    eig = numpy.linalg.eig(a)\n    sys = sss(a,b,C,D)\n    \n    if min(numpy.real(abs(eig[0]))) != 0:\n        T = numpy.linspace(0,10/min(numpy.real(abs(eig[0]))),1000)\n    else:\n        if max(numpy.real(abs(eig[0]))) != 0:\n            T = numpy.linspace(0,10/max(numpy.real(abs(eig[0]))),1000)\n        else:\n            T = numpy.linspace(0,180,1000)\n        \n    if selu == 'impulse': #selu\n        U = [0 for t in range(0,len(T))]\n        U[0] = u\n        y = control.forced_response(sys,T,U,X0)\n    if selu == 'step':\n        U = [u for t in range(0,len(T))]\n        y = control.forced_response(sys,T,U,X0)\n    if selu == 'sinusoid':\n        U = u*numpy.sin(omega*T)\n        y = control.forced_response(sys,T,U,X0)\n    \n    fig=plt.figure(num=1,figsize=[15, 4])\n    fig.add_subplot(121)\n    plt.plot(T,y[1][0])\n    plt.grid()\n    plt.xlabel('time [s]')\n    plt.ylabel('velocity [m/s]')\n    \n    fig.add_subplot(122)\n    plt.plot(T,y[1][1])\n    plt.grid()\n    plt.xlabel('time [s]')\n    plt.ylabel(r'$\\tau_\\%$')\n    \n    #display(Markdown('The A matrix is: $%s$ and the eigenvalues are: $%s$' % (bmatrix(a),eig[0])))\n\n#create a graphic structure to hold all widgets \nalltogether =  widgets.VBox([widgets.HBox([widgets.VBox([m,\n                                           eta,\n                                           tau_max,\n                                           b_air]),\n                            widgets.HBox([widgets.VBox([widgets.Label('select the type of input:',border=3),\n                                                        widgets.Label('$t_r$:',border=3),\n                                                        widgets.Label('omega [rad/s]:',border=3)]),\n                                          widgets.VBox([SELECT,u,omega])])]),\n                             widgets.HBox([widgets.Label('Initial state X0:',border=3),X0,\n                                           widgets.Label(' Click for changed initial conditions:',border=3),START])])\n\nout = widgets.interactive_output(main_callback,{'X0':X0, 'm': m, 'eta': eta, 'tau_max': tau_max, 'b_air': b_air, 'u': u, 'selu': SELECT, 'omega':omega, 'DW':DW})\n#out.layout.height = '300px'\ndisplay(out,alltogether)\n\n\n\n\n\n\n\n\n#create dummy widget 2\nDW2 = widgets.FloatText(layout=widgets.Layout(width='0px', height='0px'))\nDW2.value = -1\n\n#create button widget\nSTART2 = widgets.Button(\n    description='Show answers',\n    disabled=False,\n    button_style='', # 'success', 'info', 'warning', 'danger' or ''\n    tooltip='Click for view the answers',\n    icon='check'\n)\n                       \ndef on_start_button_clicked2(b):\n    #This is a workaround to have intreactive_output call the callback:\n    #   force the value of the dummy widget to change\n    if DW2.value&gt; 0 :\n        DW2.value = -1\n    else: \n        DW2.value = 1\n    pass\nSTART2.on_click(on_start_button_clicked2)\n\ndef main_callback2(DW2):\n    if DW2 &gt; 0:\n        display(Markdown(r'''&gt;Answers:\n                            &gt;- Yes, but only if the air friction coefficient $b$ is 0.\n                            &gt;- No, car mass only changes the time it takes to reach a certain velocity, that is it affects acceleration, not maximum speed. \n                            &gt;- Yes, it could be used to model braking. '''))\n    else:\n        display(Markdown(''))\n\n#create a graphic structure to hold all widgets \nalltogether2 =  widgets.VBox([START2])\n\nout2 = widgets.interactive_output(main_callback2,{'DW2':DW2})\n#out.layout.height = '300px'\ndisplay(out2,alltogether2)"
  },
  {
    "objectID": "ICCT_en/examples/04/SS-11-Lunar_lander_lateral_position_dynamics.html",
    "href": "ICCT_en/examples/04/SS-11-Lunar_lander_lateral_position_dynamics.html",
    "title": "Lunar lander lateral position dynamics",
    "section": "",
    "text": "# Erasmus+ ICCT project (2018-1-SI01-KA203-047081)\n\n# Toggle cell visibility\n\nfrom IPython.display import HTML\ntag = HTML('''&lt;script&gt;\ncode_show=true; \nfunction code_toggle() {\n    if (code_show){\n        $('div.input').hide()\n    } else {\n        $('div.input').show()\n    }\n    code_show = !code_show\n} \n$( document ).ready(code_toggle);\n&lt;/script&gt;\nToggle cell visibility &lt;a href=\"javascript:code_toggle()\"&gt;here&lt;/a&gt;.''')\ndisplay(tag)\n\n# Hide the code completely\n\n# from IPython.display import HTML\n# tag = HTML('''&lt;style&gt;\n# div.input {\n#     display:none;\n# }\n# &lt;/style&gt;''')\n# display(tag)\n\n\nToggle cell visibility here.\n\n\nThis example shows the lateral dynamics of a lunar lander using differential equations. These equations are then reformulated in state space form.\n\nThe Lunar Lander system is represented in the figure above, its vertical descent is slowed down using a vertical thruster that produces the constant force \\(F\\). Horizontal motion may be achieved by slightly tilting the Lander by an angle \\(\\theta\\), tilting generates a lateral force that is approximately equal to \\(F\\theta\\). Tilting is achieved by generating the torque \\(T\\) using a set of controllable steer rockets (max torque = 500 Nm). The atmospheric drag is assumed to be negligible and the parameters’ values are listed in the table below.\n\n\n\nParameter\nValue\n\n\n\n\n\\(m\\)\n1000 kg\n\n\n\\(J\\)\n1000 kg\\(\\text{m}^2\\)\n\n\n\\(F\\)\n1500 N\n\n\n\n\nDifferential equation\nUsing the Newton-Euler equations it is possible to write:\n\\[\\begin{cases}\nJ\\ddot{\\theta}=T \\\\\nm\\ddot{z}=F\\theta,\n\\end{cases}\\]\nwhere \\(z\\) is the lateral position.\n\n\nState space form\nSince the two differential equations are second order differential equations, the number of necessary states in order to completely describe the evolution of the system is 4 (2 and 2). Defining the state vector as \\(\\textbf{x}=[x_1,x_2,x_3,x_4]^T=[z,\\dot{z},\\theta,\\dot{\\theta}]^T\\) and \\(u=T\\) as input, in state space form they become:\n\\[\n\\dot{\\textbf{x}}=\\underbrace{\\begin{bmatrix}0&1&0&0 \\\\ 0&0&F/m&0 \\\\ 0&0&0&1 \\\\ 0&0&0&0\\end{bmatrix}}_{A}\\textbf{x}+\\underbrace{\\begin{bmatrix}0\\\\0\\\\0\\\\1/J\\end{bmatrix}}_{B}u\n\\]\n\n\nHow to use this notebook?\nPlay with the system parameters and try to answer: - Is it possible to reach a constant value of \\(\\theta\\) by applying an impulsive or stepwise input? Why? - Are Large values of \\(\\theta\\) physically interesting? Why?\n\n#Preparatory Cell \n\n%matplotlib notebook\nimport control\nimport numpy\nfrom IPython.display import display, Markdown\nimport ipywidgets as widgets\nimport matplotlib.pyplot as plt\n\n%matplotlib inline\n#print a matrix latex-like\ndef bmatrix(a):\n     \"\"\"Returns a LaTeX bmatrix - by Damir Arbula (ICCT project)\n\n     :a: numpy array\n     :returns: LaTeX bmatrix as a string\n     \"\"\"\n     if len(a.shape) &gt; 2:\n         raise ValueError('bmatrix can at most display two dimensions')\n     lines = str(a).replace('[', '').replace(']', '').splitlines()\n     rv = [r'\\begin{bmatrix}']\n     rv += ['  ' + ' & '.join(l.split()) + r'\\\\' for l in lines]\n     rv +=  [r'\\end{bmatrix}']\n     return '\\n'.join(rv)\n\n\n# Display formatted matrix: \ndef vmatrix(a):\n    if len(a.shape) &gt; 2:\n         raise ValueError('bmatrix can at most display two dimensions')\n    lines = str(a).replace('[', '').replace(']', '').splitlines()\n    rv = [r'\\begin{vmatrix}']\n    rv += ['  ' + ' & '.join(l.split()) + r'\\\\' for l in lines]\n    rv +=  [r'\\end{vmatrix}']\n    return '\\n'.join(rv)\n\n\n#matrixWidget is a matrix looking widget built with a VBox of HBox(es) that returns a numPy array as value !\nclass matrixWidget(widgets.VBox):\n    def updateM(self,change):\n        for irow in range(0,self.n):\n            for icol in range(0,self.m):\n                self.M_[irow,icol] = self.children[irow].children[icol].value\n                #print(self.M_[irow,icol])\n        self.value = self.M_\n\n    def dummychangecallback(self,change):\n        pass\n    \n    \n    def __init__(self,n,m):\n        self.n = n\n        self.m = m\n        self.M_ = numpy.matrix(numpy.zeros((self.n,self.m)))\n        self.value = self.M_\n        widgets.VBox.__init__(self,\n                             children = [\n                                 widgets.HBox(children = \n                                              [widgets.FloatText(value=0.0, layout=widgets.Layout(width='90px')) for i in range(m)]\n                                             ) \n                                 for j in range(n)\n                             ])\n        \n        #fill in widgets and tell interact to call updateM each time a children changes value\n        for irow in range(0,self.n):\n            for icol in range(0,self.m):\n                self.children[irow].children[icol].value = self.M_[irow,icol]\n                self.children[irow].children[icol].observe(self.updateM, names='value')\n        #value = Unicode('example@example.com', help=\"The email value.\").tag(sync=True)\n        self.observe(self.updateM, names='value', type= 'All')\n        \n    def setM(self, newM):\n        #disable callbacks, change values, and reenable\n        self.unobserve(self.updateM, names='value', type= 'All')\n        for irow in range(0,self.n):\n            for icol in range(0,self.m):\n                self.children[irow].children[icol].unobserve(self.updateM, names='value')\n        self.M_ = newM\n        self.value = self.M_\n        for irow in range(0,self.n):\n            for icol in range(0,self.m):\n                self.children[irow].children[icol].value = self.M_[irow,icol]\n        for irow in range(0,self.n):\n            for icol in range(0,self.m):\n                self.children[irow].children[icol].observe(self.updateM, names='value')\n        self.observe(self.updateM, names='value', type= 'All')        \n\n                #self.children[irow].children[icol].observe(self.updateM, names='value')\n\n             \n#overlaod class for state space systems that DO NOT remove \"useless\" states (what \"professor\" of automatic control would do this?)\nclass sss(control.StateSpace):\n    def __init__(self,*args):\n        #call base class init constructor\n        control.StateSpace.__init__(self,*args)\n    #disable function below in base class\n    def _remove_useless_states(self):\n        pass\n\n\n#define matrixes\nC = numpy.matrix([[1,0,0,0],[0,1,0,0],[0,0,1,0],[0,0,0,1]])\nD = numpy.matrix([[0],[0],[0],[0]])\nX0 = matrixWidget(4,1)\n\n\nm = widgets.FloatSlider(\n    value=1000,\n    min=400,\n    max=2000,\n    step=1,\n    description='$m$ [kg]:',\n    disabled=False,\n    continuous_update=False,\n    orientation='horizontal',\n    readout=True,\n    readout_format='.1f',\n)\nF = widgets.FloatSlider(\n    value=1500,\n    min=10,\n    max=5000,\n    step=10,\n    description='$F$ [N]:',\n    disabled=False,\n    continuous_update=False,\n    orientation='horizontal',\n    readout=True,\n    readout_format='.1f',\n)\nJ = widgets.FloatSlider(\n    value=1000,\n    min=500,\n    max=2000,\n    step=1,\n    description=r'$J$ [kg$\\text{m}^2$]:',\n    disabled=False,\n    continuous_update=False,\n    orientation='horizontal',\n    readout=True,\n    readout_format='.1f',\n)\nu = widgets.FloatSlider(\n    value=100,\n    min=0,\n    max=500,\n    step=0.01,\n    description='',\n    disabled=False,\n    continuous_update=False,\n    orientation='horizontal',\n    readout=True,\n    readout_format='.1f',\n)\nomega = widgets.FloatSlider(\n    value=5,\n    min=0,\n    max=10.0,\n    step=0.1,\n    description='',\n    disabled=False,\n    continuous_update=False,\n    orientation='horizontal',\n    readout=True,\n    readout_format='.1f',\n)\n\n\n#create dummy widget \nDW = widgets.FloatText(layout=widgets.Layout(width='0px', height='0px'))\n\n#create button widget\nSTART = widgets.Button(\n    description='Click!',\n    disabled=False,\n    button_style='', # 'success', 'info', 'warning', 'danger' or ''\n    tooltip='Click for changed initial conditions',\n    icon='check'\n)\n                       \ndef on_start_button_clicked(b):\n    #This is a workaround to have intreactive_output call the callback:\n    #   force the value of the dummy widget to change\n    if DW.value&gt; 0 :\n        DW.value = -1\n    else: \n        DW.value = 1\n    pass\nSTART.on_click(on_start_button_clicked)\n\n#define type of ipout \nSELECT = widgets.Dropdown(\n    options=['impulse', 'step', 'sinusoid'],\n    value='impulse',\n    description='',\n    disabled=False\n)\n\n\ndef main_callback(X0, m, F, J, u, selu, omega, DW):\n    a = numpy.matrix([[0,1,0,0],[0,0,F/m,0],[0,0,0,1],[0,0,0,0]])\n    b = numpy.matrix([[0],[0],[0],[1/J]])\n\n    eig = numpy.linalg.eig(a)\n    sys = sss(a,b,C,D)\n    \n    if min(numpy.real(abs(eig[0]))) != 0:\n        T = numpy.linspace(0,10/min(numpy.real(abs(eig[0]))),1000)\n    else:\n        if max(numpy.real(abs(eig[0]))) != 0:\n            T = numpy.linspace(0,10/max(numpy.real(abs(eig[0]))),1000)\n        else:\n            T = numpy.linspace(0,30,1000)\n        \n    if selu == 'impulse': #selu\n        U = [0 for t in range(0,len(T))]\n        U[0] = u\n        y = control.forced_response(sys,T,U,X0)\n    if selu == 'step':\n        U = [u for t in range(0,len(T))]\n        y = control.forced_response(sys,T,U,X0)\n    if selu == 'sinusoid':\n        U = u*numpy.sin(omega*T)\n        y = control.forced_response(sys,T,U,X0)\n    \n    fig=plt.figure(num=1,figsize=[15, 8])\n    fig.add_subplot(221)\n    plt.plot(T,y[1][0])\n    plt.grid()\n    plt.xlabel('time [s]')\n    plt.ylabel(r'$z$ [m]')\n    \n    fig.add_subplot(222)\n    plt.plot(T,y[1][1])\n    plt.grid()\n    plt.xlabel('time [s]')\n    plt.ylabel(r'$\\dot{z}$ [m/s]')\n    \n    fig.add_subplot(223)\n    plt.plot(T,y[1][2])\n    plt.grid()\n    plt.xlabel('time [s]')\n    plt.ylabel(r'$\\theta$ [rad]')\n    \n    fig.add_subplot(224)\n    plt.plot(T,y[1][3])\n    plt.grid()\n    plt.xlabel('time [s]')\n    plt.ylabel(r'$\\dot{\\theta}$ [rad/s]')\n    \n    #display(Markdown('The A matrix is: $%s$ and the eigenvalues are: $%s$' % (bmatrix(a),eig[0])))\n\n#create a graphic structure to hold all widgets \nalltogether =  widgets.VBox([widgets.HBox([widgets.VBox([m,\n                                           J,\n                                           F]),\n                            widgets.HBox([widgets.VBox([widgets.Label('select the type of input:',border=3),\n                                                        widgets.Label('$u$:',border=3),\n                                                        widgets.Label('omega [rad/s]:',border=3)]),\n                                          widgets.VBox([SELECT,u,omega])])]),\n                             widgets.HBox([widgets.Label('Initial state X0:',border=3),X0,\n                                           widgets.Label(' Click for changed initial conditions:',border=3),START])])\n\nout = widgets.interactive_output(main_callback,{'X0':X0, 'm': m, 'F': F, 'J': J, 'u': u, 'selu': SELECT, 'omega':omega, 'DW':DW})\n#out.layout.height = '300px'\ndisplay(out,alltogether)\n\n\n\n\n\n\n\n\n#create dummy widget 2\nDW2 = widgets.FloatText(layout=widgets.Layout(width='0px', height='0px'))\nDW2.value = -1\n\n#create button widget\nSTART2 = widgets.Button(\n    description='Show answers',\n    disabled=False,\n    button_style='', # 'success', 'info', 'warning', 'danger' or ''\n    tooltip='Click for view the answers',\n    icon='check'\n)\n                       \ndef on_start_button_clicked2(b):\n    #This is a workaround to have intreactive_output call the callback:\n    #   force the value of the dummy widget to change\n    if DW2.value&gt; 0 :\n        DW2.value = -1\n    else: \n        DW2.value = 1\n    pass\nSTART2.on_click(on_start_button_clicked2)\n\ndef main_callback2(DW2):\n    if DW2 &gt; 0:\n        display(Markdown('''&gt; Answer:\n                            &gt;* No, it is not possible. The dynamics of variable $\\\\theta$ is that of the so called double integrator: the value of $\\\\theta$ can be obtained integrating twice the input (appropriately scaled by the inverse of the inertia $J$). In terms of state space representation, this is highligthed by the fact that the dynamic matrix has two eigenvalues in 0 that form a Jordan block of dimension 2. Thus the system modes are $1$ and $t$ and this latter one is divergent.\n                            &gt;* If values of $\\\\theta$ become large, the approximation that lateral force is approximately equal to $F\\\\theta$ is no more valid, thus this model looses applicability.   '''))\n    else:\n        display(Markdown(''))\n\n#create a graphic structure to hold all widgets \nalltogether2 =  widgets.VBox([START2])\n\nout2 = widgets.interactive_output(main_callback2,{'DW2':DW2})\n#out.layout.height = '300px'\ndisplay(out2,alltogether2)"
  },
  {
    "objectID": "ICCT_en/examples/04/SS-13-Equilibrium_points.html",
    "href": "ICCT_en/examples/04/SS-13-Equilibrium_points.html",
    "title": "Equilibrium Points as a function of system input and system modes",
    "section": "",
    "text": "# Erasmus+ ICCT project (2018-1-SI01-KA203-047081)\n\n# Toggle cell visibility\n\nfrom IPython.display import HTML\ntag = HTML('''&lt;script&gt;\ncode_show=true; \nfunction code_toggle() {\n    if (code_show){\n        $('div.input').hide()\n    } else {\n        $('div.input').show()\n    }\n    code_show = !code_show\n} \n$( document ).ready(code_toggle);\n&lt;/script&gt;\nToggle cell visibility &lt;a href=\"javascript:code_toggle()\"&gt;here&lt;/a&gt;.''')\ndisplay(tag)\n\n# Hide the code completely\n\n# from IPython.display import HTML\n# tag = HTML('''&lt;style&gt;\n# div.input {\n#     display:none;\n# }\n# &lt;/style&gt;''')\n# display(tag)\n\n\nToggle cell visibility here.\n\n\nThis example shows what the equilibrium points of a Linear Time Invariant (LTI) system are. The aim of this example is to show where equilibrium points of the system lie in the state space (a 2D plane in this example) as a function of system matrices and input value.\nRecall, that given the LTI system dynamics:\n\\[\n\\dot{x}(t)=Ax(t)+B\\bar{u},\n\\]\nwith \\(\\bar{u}\\) a constant input. The equilibrium points of the system can be found as solution of the equation:\n\\[\nAx(t)=-B\\bar{u}.\n\\]\n\nHow to use this notebook?\nTry to define matrices and constant input \\(\\bar u\\) so that: * the system has one equilibrium point at the origin, * the system has one equilibrium point bu not at the origin, * the system has \\(\\infty\\) equilibrium points, * the system has \\(\\infty^2\\) equilibrium points.\n\n#Preparatory Cell \n\nimport control\nimport numpy\nfrom IPython.display import display, Markdown\nimport ipywidgets as widgets\nimport matplotlib.pyplot as plt\n\n#print a matrix latex-like\ndef bmatrix(a):\n     \"\"\"Returns a LaTeX bmatrix - by Damir Arbula (ICCT project)\n\n     :a: numpy array\n     :returns: LaTeX bmatrix as a string\n     \"\"\"\n     if len(a.shape) &gt; 2:\n         raise ValueError('bmatrix can at most display two dimensions')\n     lines = str(a).replace('[', '').replace(']', '').splitlines()\n     rv = [r'\\begin{bmatrix}']\n     rv += ['  ' + ' & '.join(l.split()) + r'\\\\' for l in lines]\n     rv +=  [r'\\end{bmatrix}']\n     return '\\n'.join(rv)\n\n\n# Display formatted matrix: \ndef vmatrix(a):\n    if len(a.shape) &gt; 2:\n         raise ValueError('bmatrix can at most display two dimensions')\n    lines = str(a).replace('[', '').replace(']', '').splitlines()\n    rv = [r'\\begin{vmatrix}']\n    rv += ['  ' + ' & '.join(l.split()) + r'\\\\' for l in lines]\n    rv +=  [r'\\end{vmatrix}']\n    return '\\n'.join(rv)\n\n\n#create a NxM matrix widget \ndef createMatrixWidget(n,m):\n    M = widgets.GridBox(children=[widgets.FloatText(layout=widgets.Layout(width='100px', height='40px'),\n    value=0.0, disabled=False, label=i) for i in range(n*m)],\n    layout=widgets.Layout(\n        #width='50%',\n        grid_template_columns= ''.join(['100px ' for i in range(m)]),\n        #grid_template_rows='80px 80px 80px',\n        grid_row_gap='0px',\n        track_size='0px')\n    )\n    return M\n\n\n#extract matrix from widgets and convert to numpy matrix\ndef getNumpyMatFromWidget(M,n,m):\n    #get W gridbox dims\n    M_ = numpy.matrix(numpy.zeros((n,m)))\n    for irow in range(0,n):\n        for icol in range(0,m):\n            M_[irow,icol] = M.children[irow*3+icol].value\n\n            \n#this is a simple derived class from FloatText used to experience with interact             \nclass floatWidget(widgets.FloatText):\n    def __init__(self,**kwargs):\n        #self.n = n\n        self.value = 30.0\n        #self.M = \n        widgets.FloatText.__init__(self, **kwargs)\n\n#    def value(self):\n#        return 0 #self.FloatText.value\n\nfrom traitlets import Unicode\nfrom ipywidgets import register \n\n\n#matrixWidget is a matrix looking widget built with a VBox of HBox(es) that returns a numPy array as value !\nclass matrixWidget(widgets.VBox):\n    def updateM(self,change):\n        for irow in range(0,self.n):\n            for icol in range(0,self.m):\n                self.M_[irow,icol] = self.children[irow].children[icol].value\n                #print(self.M_[irow,icol])\n        self.value = self.M_\n\n    def dummychangecallback(self,change):\n        pass\n    \n    \n    def __init__(self,n,m):\n        self.n = n\n        self.m = m\n        self.M_ = numpy.matrix(numpy.zeros((self.n,self.m)))\n        self.value = self.M_\n        widgets.VBox.__init__(self,\n                             children = [\n                                 widgets.HBox(children = \n                                              [widgets.FloatText(value=0.0, layout=widgets.Layout(width='90px')) for i in range(m)]\n                                             ) \n                                 for j in range(n)\n                             ])\n        \n        #fill in widgets and tell interact to call updateM each time a children changes value\n        for irow in range(0,self.n):\n            for icol in range(0,self.m):\n                self.children[irow].children[icol].value = self.M_[irow,icol]\n                self.children[irow].children[icol].observe(self.updateM, names='value')\n        #value = Unicode('example@example.com', help=\"The email value.\").tag(sync=True)\n        self.observe(self.updateM, names='value', type= 'All')\n        \n    def setM(self, newM):\n        #disable callbacks, change values, and reenable\n        self.unobserve(self.updateM, names='value', type= 'All')\n        for irow in range(0,self.n):\n            for icol in range(0,self.m):\n                self.children[irow].children[icol].unobserve(self.updateM, names='value')\n        self.M_ = newM\n        self.value = self.M_\n        for irow in range(0,self.n):\n            for icol in range(0,self.m):\n                self.children[irow].children[icol].value = self.M_[irow,icol]\n        for irow in range(0,self.n):\n            for icol in range(0,self.m):\n                self.children[irow].children[icol].observe(self.updateM, names='value')\n        self.observe(self.updateM, names='value', type= 'All')        \n\n                #self.children[irow].children[icol].observe(self.updateM, names='value')\n\n        \n\n        \n#overlaod class for state space systems that DO NOT remove \"useless\" states (what \"professor\" of automatic control would do this?)\nclass sss(control.StateSpace):\n    def __init__(self,*args):\n        #call base class init constructor\n        control.StateSpace.__init__(self,*args)\n    #disable function below in base class\n    def _remove_useless_states(self):\n        pass\n\n\n\n#define matrices\nA = matrixWidget(2,2)\nB = matrixWidget(2,1)\nubar = matrixWidget(1,1)\n\nA.setM(-numpy.identity(2))\n\n#this is the main callback and does all the computations and plots \ndef main_callback(matA,matB,ubar_,DW,sel):\n    #check if a specific matrix is requested or is manual \n    if sel=='manual' :\n        pass\n    elif sel == '1 equilibrium point':\n        matA = numpy.zeros((2,2))\n        matA[0,0] = -1\n        matA[1,1] = -2\n        A.setM(matA)\n        matB = numpy.ones((2,1))\n        B.setM(matB)\n        ubar_ = numpy.ones((1,1))\n        ubar.setM(ubar_)\n    elif sel == 'infinite^1 equilibrium points':\n        matA = numpy.zeros((2,2))\n        matA[0,0] = -1\n        matA[0,1] = 2\n        A.setM(matA)\n        matB = numpy.zeros((2,1))\n        B.setM(matB)\n        ubar_ = numpy.zeros((1,1))\n        ubar.setM(ubar_)\n    elif sel == 'infinite^2 equilibrium points':\n        matA = numpy.zeros((2,2))\n        A.setM(matA)\n        matB = numpy.zeros((2,1))\n        B.setM(matB)\n        ubar_ = numpy.zeros((1,1))\n        ubar.setM(ubar_)\n    else : \n        matA = numpy.zeros((2,2))\n        matA[0,0] = -1\n        matA[1,1] = -1\n        A.setM(matA)\n        matB = numpy.zeros((2,1))\n        B.setM(matB)\n        ubar_ = numpy.zeros((1,1))\n        ubar.setM(ubar_)\n        \n        \n        \n    #get system eigenvalues\n    lambdas, eigvectors = numpy.linalg.eig(matA)\n\n    #count eigenvalues in 0\n    #NOTE: when extracting i-th right eignvectors (columns from the matrix eigvectors) \n    # must use the notation : eigvectors[:,i:i+1] that generates a column array \n    # because the notation eigvectors[:,i] generates a row array !!!! WTF MBM\n    eigin0 = 0    \n    if lambdas[0] == 0.0:\n        eig0 = True\n        dir0 = eigvectors[:,0:1]\n        eigin0 = eigin0+1\n    else:\n        eig0 = False\n    if lambdas[1] == 0.0:\n        eig1 = True\n        dir1 = eigvectors[:,1:2]\n        eigin0 = eigin0+1\n    else: \n        eig1 = False\n\n    #create textual output            \n    display(Markdown('Matrix: $%s$ has $%s$ eigenvalues equal to 0.' % (vmatrix(matA), str(eigin0)) ))\n    #create modes string:\n\n    \n    \n    #test if aoslution exist: \n    if eigin0 == 0:\n        #a solution always exists\n        print('There is only one solution, that is, one equilibrium point.')\n        pass\n    else:\n        # in order for a solution of Ax = -Bu, with A singular, it is necessary that\n        # rank([A b])=rank(A)\n        # if this does not happen pinv cannot be used !!!\n        if numpy.linalg.matrix_rank(numpy.concatenate((matA,matB), axis = 1)) == numpy.linalg.matrix_rank(matA):\n            #a solution exists\n            if eigin0 == 1:\n                print('There are infinite equilibrium points lying on a line.')\n            else:\n                print('There are infinite^2 equilibrium points: they occupy the entire state space.')\n        else:\n            #a solution does not exist \n            print('Warning: a solution does not exist. No equilibrium points!')\n            return\n   \n    #print(lambdas)\n    #print('----')\n    #print(eigvectors)\n    #print(eigvectors[:,1:2])\n    #v1 = eigvectors[:,]\n    #print(eigvectors.__type__)\n    #print(v1.__type__)\n    #print(eigvectors[:,0:1])\n    #print('----')\n    \n    #compute equilibrium points \n    if eigin0 == 0 : \n        #only one equilibrium point \n        eq = - numpy.dot(numpy.linalg.inv(matA),matB)*ubar_\n        eqdir = numpy.zeros((2,1))\n    elif eigin0 == 1:\n        #equilibrium along a line \n        eq = - numpy.dot(numpy.linalg.pinv(matA),matB)*ubar_\n        if eig0:\n            eqdir = dir0\n        else:\n            eqdir = dir1\n    else:\n        #equilibrium is the entire plane\n        eq = numpy.zeros((2,1))\n        eqdir = numpy.zeros((2,1))\n        pass\n    \n    #set limits of plot \n    xlim = max(abs(eq[0,0])*1.1, 1.)\n    ylim = max(abs(eq[1,0])*1.1, 1.)\n\n    #print(eq)\n    #print(eqdir)\n    #print(xlim)\n    #print(ylim)\n    \n    #plot equilibrium points (poles only)    \n    pzmap = plt.figure(figsize=(6,6))\n    sf = pzmap.add_subplot(111)\n    sf.grid(True)\n    sf.set_xlabel('$x_1$')\n    sf.set_ylabel('$x_2$')\n    sf.set_xlim([-xlim, xlim])\n    sf.set_ylim([-ylim, ylim])\n    #sf.set_aspect('equal', adjustable='datalim')\n    if eigin0 == 0:\n        #one equilibrium point\n        sf.plot(eq[0,0],eq[1,0],marker='o')\n    elif eigin0 == 1:\n        #infinite equilibrium points along a line\n        sf.plot(eq[0,0],eq[1,0],marker='o')\n        #ph.hold(True)\n        sf.plot([eq[0,0]-eqdir[0,0]*xlim*10, eq[0,0]+eqdir[0,0]*xlim*10],[eq[1,0]-eqdir[1,0]*ylim*10, eq[1,0]+eqdir[1,0]*ylim*10])\n    else:\n        #infinite^2 equilibrium points occupying the entire state plane \n        sf.fill((-xlim, xlim, xlim, -xlim),(-ylim, -ylim, ylim, ylim),alpha = 0.5)\n            \n            \n   \n    \n#create dummy widget \nDW = widgets.FloatText(layout=widgets.Layout(width='0px', height='0px'))\n\n#create button widget\nSTART = widgets.Button(\n    description='Test',\n    disabled=False,\n    button_style='', # 'success', 'info', 'warning', 'danger' or ''\n    tooltip='Test',\n    icon='check'\n)\n                       \ndef on_start_button_clicked(b):\n    #This is a workaround to have intreactive_output call the callback:\n    #   force the value of the dummy widget to change\n    if DW.value&gt; 0 :\n        DW.value = -1\n    else: \n        DW.value = 1\n    pass\nSTART.on_click(on_start_button_clicked)\n\n#define type of ipout \nSELECT = widgets.Dropdown(\n    options=['manual', 'reset', '1 equilibrium point', \n             'infinite^1 equilibrium points', \n             'infinite^2 equilibrium points'],\n    value='manual',\n    description='examples',\n    disabled=False,\n)\n\n\n#create a graphic structure to hold all widgets \nalltogether =  widgets.VBox([widgets.HBox([widgets.Label('$\\dot{x}(t) = $',border=3), A,widgets.Label('$x(t) + $',border=3),B,widgets.Label('$\\\\bar{u}$',border=3),ubar, START]),\n                             SELECT ] )\n    \n\nout = widgets.interactive_output(main_callback,{'matA': A, 'matB': B,'ubar_': ubar,'DW': DW, 'sel': SELECT})\ndisplay(alltogether,out)"
  },
  {
    "objectID": "ICCT_en/examples/04/SS-15-Equilibrium_points_example_2.html",
    "href": "ICCT_en/examples/04/SS-15-Equilibrium_points_example_2.html",
    "title": "Infinite Equilibrium Points 2",
    "section": "",
    "text": "# Erasmus+ ICCT project (2018-1-SI01-KA203-047081)\n\n# Toggle cell visibility\n\nfrom IPython.display import HTML\ntag = HTML('''&lt;script&gt;\ncode_show=true; \nfunction code_toggle() {\n    if (code_show){\n        $('div.input').hide()\n    } else {\n        $('div.input').show()\n    }\n    code_show = !code_show\n} \n$( document ).ready(code_toggle);\n&lt;/script&gt;\nToggle cell visibility &lt;a href=\"javascript:code_toggle()\"&gt;here&lt;/a&gt;.''')\ndisplay(tag)\n\n# Hide the code completely\n\n# from IPython.display import HTML\n# tag = HTML('''&lt;style&gt;\n# div.input {\n#     display:none;\n# }\n# &lt;/style&gt;''')\n# display(tag)\n\n\nToggle cell visibility here.\n\n\nThis interactive example shows a \\(2\\times2\\) system that has the equilibrium points lying on the \\(x_2\\) axis (for the underlying theory refer to example Equilibrium points).\nIn order to have the line \\(x_1=0\\) as equilibrium points’ space, it is necessary that \\[\nA\\bar{x}=0 \\quad \\forall \\, \\bar{x}\\in\\begin{bmatrix} 0 \\\\ \\alpha\\end{bmatrix} \\, \\text{with} \\, \\alpha\\in\\mathbb{R},\n\\] thus, \\(\\begin{bmatrix} 0 \\\\ \\alpha\\end{bmatrix}\\) has to belong to the \\(A\\)’s nullspace.\n\nHow to use this notebook?\n\nModify matrix \\(A\\) directly to see how the equilibrium points change.\nTry to modify \\(A\\) so that the equilibrium points lie on the \\(x_2\\) axis.\n\n\n#Preparatory Cell \n\nimport control\nimport numpy\nfrom IPython.display import display, Markdown\nimport ipywidgets as widgets\nimport matplotlib.pyplot as plt\nimport sympy as sym\n\n#print a matrix latex-like\ndef bmatrix(a):\n     \"\"\"Returns a LaTeX bmatrix - by Damir Arbula (ICCT project)\n\n     :a: numpy array\n     :returns: LaTeX bmatrix as a string\n     \"\"\"\n     if len(a.shape) &gt; 2:\n         raise ValueError('bmatrix can at most display two dimensions')\n     lines = str(a).replace('[', '').replace(']', '').splitlines()\n     rv = [r'\\begin{bmatrix}']\n     rv += ['  ' + ' & '.join(l.split()) + r'\\\\' for l in lines]\n     rv +=  [r'\\end{bmatrix}']\n     return '\\n'.join(rv)\n\n\n# Display formatted matrix: \ndef vmatrix(a):\n    if len(a.shape) &gt; 2:\n         raise ValueError('bmatrix can at most display two dimensions')\n    lines = str(a).replace('[', '').replace(']', '').splitlines()\n    rv = [r'\\begin{vmatrix}']\n    rv += ['  ' + ' & '.join(l.split()) + r'\\\\' for l in lines]\n    rv +=  [r'\\end{vmatrix}']\n    return '\\n'.join(rv)\n\n\n#create a NxM matrix widget \ndef createMatrixWidget(n,m):\n    M = widgets.GridBox(children=[widgets.FloatText(layout=widgets.Layout(width='100px', height='40px'),\n    value=0.0, disabled=False, label=i) for i in range(n*m)],\n    layout=widgets.Layout(\n        #width='50%',\n        grid_template_columns= ''.join(['100px ' for i in range(m)]),\n        #grid_template_rows='80px 80px 80px',\n        grid_row_gap='0px',\n        track_size='0px')\n    )\n    return M\n\n\n#extract matrix from widgets and convert to numpy matrix\ndef getNumpyMatFromWidget(M,n,m):\n    #get W gridbox dims\n    M_ = numpy.matrix(numpy.zeros((n,m)))\n    for irow in range(0,n):\n        for icol in range(0,m):\n            M_[irow,icol] = M.children[irow*3+icol].value\n\n            \n#this is a simple derived class from FloatText used to experience with interact             \nclass floatWidget(widgets.FloatText):\n    def __init__(self,**kwargs):\n        #self.n = n\n        self.value = 30.0\n        #self.M = \n        widgets.FloatText.__init__(self, **kwargs)\n\n#    def value(self):\n#        return 0 #self.FloatText.value\n\nfrom traitlets import Unicode\nfrom ipywidgets import register \n\n\n#matrixWidget is a matrix looking widget built with a VBox of HBox(es) that returns a numPy array as value !\nclass matrixWidget(widgets.VBox):\n    def updateM(self,change):\n        for irow in range(0,self.n):\n            for icol in range(0,self.m):\n                self.M_[irow,icol] = self.children[irow].children[icol].value\n                #print(self.M_[irow,icol])\n        self.value = self.M_\n\n    def dummychangecallback(self,change):\n        pass\n    \n    \n    def __init__(self,n,m):\n        self.n = n\n        self.m = m\n        self.M_ = numpy.matrix(numpy.zeros((self.n,self.m)))\n        self.value = self.M_\n        widgets.VBox.__init__(self,\n                             children = [\n                                 widgets.HBox(children = \n                                              [widgets.FloatText(value=0.0, layout=widgets.Layout(width='90px')) for i in range(m)]\n                                             ) \n                                 for j in range(n)\n                             ])\n        \n        #fill in widgets and tell interact to call updateM each time a children changes value\n        for irow in range(0,self.n):\n            for icol in range(0,self.m):\n                self.children[irow].children[icol].value = self.M_[irow,icol]\n                self.children[irow].children[icol].observe(self.updateM, names='value')\n        #value = Unicode('example@example.com', help=\"The email value.\").tag(sync=True)\n        self.observe(self.updateM, names='value', type= 'All')\n        \n    def setM(self, newM):\n        #disable callbacks, change values, and reenable\n        self.unobserve(self.updateM, names='value', type= 'All')\n        for irow in range(0,self.n):\n            for icol in range(0,self.m):\n                self.children[irow].children[icol].unobserve(self.updateM, names='value')\n        self.M_ = newM\n        self.value = self.M_\n        for irow in range(0,self.n):\n            for icol in range(0,self.m):\n                self.children[irow].children[icol].value = self.M_[irow,icol]\n        for irow in range(0,self.n):\n            for icol in range(0,self.m):\n                self.children[irow].children[icol].observe(self.updateM, names='value')\n        self.observe(self.updateM, names='value', type= 'All')        \n\n                #self.children[irow].children[icol].observe(self.updateM, names='value')\n\n        \n\n        \n#overlaod class for state space systems that DO NOT remove \"useless\" states (what \"professor\" of automatic control would do this?)\nclass sss(control.StateSpace):\n    def __init__(self,*args):\n        #call base class init constructor\n        control.StateSpace.__init__(self,*args)\n    #disable function below in base class\n    def _remove_useless_states(self):\n        pass\n\n\n#define the matrixes\nA=matrixWidget(2,2)\nA.setM(numpy.matrix('1. 0.; 0. 1.'))\n\ndef main_callback(matA,DW):\n    \n    As = sym.Matrix(matA)\n    NAs = As.nullspace()\n    \n    t = numpy.linspace(-10,10,1000)\n    if len(NAs) == 1:\n        eq1 = [t[i]*numpy.matrix(NAs[0]) for i in range(0,len(t))]\n        x1 = [eq1[i][0,0] for i in range(0,len(t))]\n        x2 = [eq1[i][1,0] for i in range(0,len(t))]\n    \n    fig = plt.figure(figsize=(6,6))\n    if len(NAs) == 0:\n        plt.plot(0,0,'bo')\n    if len(NAs) == 1:\n        plt.plot(x1,x2)\n    if len(NAs) == 2:\n        plt.fill((-5,-5,5,5),(-5,5,5,-5),alpha=0.5)\n        plt.xlim(left=-5,right=5)\n        plt.ylim(top=5,bottom=-5)\n    plt.grid()\n    plt.xlabel('$x_1$')\n    plt.ylabel('$x_2$')\n    print('A base for A\\'s nullspace (by row) is %s. \\nThe eigenvalues are %s' %(str(numpy.array(NAs)),\n                                                                          str(numpy.linalg.eig(matA)[0])))\n\n\n#create dummy widget \nDW = widgets.FloatText(layout=widgets.Layout(width='0px', height='0px'))\n\n#create button widget\nSTART = widgets.Button(\n    description='Test',\n    disabled=False,\n    button_style='', # 'success', 'info', 'warning', 'danger' or ''\n    tooltip='Test',\n    icon='check'\n)\n                       \ndef on_start_button_clicked(b):\n    #This is a workaround to have intreactive_output call the callback:\n    #   force the value of the dummy widget to change\n    if DW.value&gt; 0 :\n        DW.value = -1\n    else: \n        DW.value = 1\n    pass\nSTART.on_click(on_start_button_clicked)\n\nout = widgets.interactive_output(main_callback,{'matA':A,'DW':DW})\nout1 = widgets.HBox([out,\n                     widgets.VBox([widgets.Label(''),widgets.Label(''),widgets.Label(''),widgets.Label('$\\qquad \\qquad A=$')]),\n                     widgets.VBox([widgets.Label(''),widgets.Label(''),widgets.Label(''),A,START])])\nout.layout.height = '450px'\ndisplay(out1)\n\n\n\n\n\n#create dummy widget 2\nDW2 = widgets.FloatText(layout=widgets.Layout(width='0px', height='0px'))\nDW2.value = -1\n\n#create button widget\nSTART2 = widgets.Button(\n    description='Show answers',\n    disabled=False,\n    button_style='', # 'success', 'info', 'warning', 'danger' or ''\n    tooltip='Click for view the answers',\n    icon='check'\n)\n                       \ndef on_start_button_clicked2(b):\n    #This is a workaround to have intreactive_output call the callback:\n    #   force the value of the dummy widget to change\n    if DW2.value&gt; 0 :\n        DW2.value = -1\n    else: \n        DW2.value = 1\n    pass\nSTART2.on_click(on_start_button_clicked2)\n\ndef main_callback2(DW2):\n    if DW2 &gt; 0:\n        display(Markdown(r'''Answer:\nTo construct the matrix it is possible to choose row vectors that are orthogonal with respect to the nullspace. A possible matrix is therefore:\n$$\nA=\\begin{bmatrix} 1 & 0 \\\\ 2 & 0 \\end{bmatrix}.\n$$'''))\n    else:\n        display(Markdown(''))\n\n#create a graphic structure to hold all widgets \nalltogether2 =  widgets.VBox([START2])\n\nout2 = widgets.interactive_output(main_callback2,{'DW2':DW2})\n#out.layout.height = '300px'\ndisplay(out2,alltogether2)"
  },
  {
    "objectID": "ICCT_en/examples/04/SS-17-Internal_stability.html",
    "href": "ICCT_en/examples/04/SS-17-Internal_stability.html",
    "title": "Internal stability",
    "section": "",
    "text": "# Erasmus+ ICCT project (2018-1-SI01-KA203-047081)\n\n# Toggle cell visibility\n\nfrom IPython.display import HTML\ntag = HTML('''&lt;script&gt;\ncode_show=true; \nfunction code_toggle() {\n    if (code_show){\n        $('div.input').hide()\n    } else {\n        $('div.input').show()\n    }\n    code_show = !code_show\n} \n$( document ).ready(code_toggle);\n&lt;/script&gt;\nToggle cell visibility &lt;a href=\"javascript:code_toggle()\"&gt;here&lt;/a&gt;.''')\ndisplay(tag)\n\n# Hide the code completely\n\n# from IPython.display import HTML\n# tag = HTML('''&lt;style&gt;\n# div.input {\n#     display:none;\n# }\n# &lt;/style&gt;''')\n# display(tag)\n\n\nToggle cell visibility here.\n\n\nThe concept of stability captures the behaviour of a system state evolution when this is perturbed from an equilibrium condition: stability describes if the state evolution arising after a perturbation from an equilibrium point diverges or not.\n\nDefinition\nGiven a time invariant dynamic system described by the state vector \\(x(t)\\in \\mathbb{R}^n\\), a point of equilibrium \\(x_e\\), an initial state \\(x_0\\) and an initial time \\(t_0\\) if \\[\n\\forall \\, \\epsilon \\in \\mathbb{R}, \\, \\epsilon &gt; 0 \\quad \\exists \\delta \\in \\mathbb{R}, \\, \\delta &gt; 0 : \\quad ||x_0-x_e|| &lt; \\delta \\, \\Rightarrow  \\, ||x(t)-x_e|| &lt; \\epsilon \\quad \\forall t \\ge t_0\n\\] that could be read as: if a small enough initial perturbation \\(\\delta\\) from the equilibrium point exists so that the state evolution \\(x(t)\\) from the perturbed point does not get too far (more than \\(\\epsilon\\)) from the equilibrium itself, then the equilibrium point is stable.\nIf it also happens that \\(\\lim_{t\\to\\infty}||x(t)-x_e|| = 0\\), that can be read as: the state evolution returns back to the equilibrium point, then the equilibrium is said to be asymptotically stable.\nIn the case of linear time invariant systems of the type:\n\\[\\begin{cases}\n\\dot{x} = Ax +Bu \\\\\ny = Cx + Du,\n\\end{cases}\\]\nit is possible to prove that stability of one equilibrium point implies stability of all equilibrium points, thus we can talk about stability of the system even if, in general, the stability property is related to an equilibrium point. This linear system’s peculiar feature is due to the fact that the evolution of this type of systems is strictly related to the eigenvalues of the dynamics matrix \\(A\\), which are rotation-, translation-, initial-condition- and time-invariant.\nRecall what is explained in example Modal Analysis:\n\nThe closed form solution of the differential equation, from initial time \\(t_0\\), with initial condition \\(x(t_0)\\) is: \\[\nx(t) = e^{A(t-t_0)}x(t_0).\n\\] The matrix \\(e^{A(t-t_0)}x(t_0)\\) is composed of linear combinations of functions of time \\(t\\), each one of the type: \\[e^{\\lambda t},\\] where the \\(\\lambda\\)(s) are the eigenvalues of the matrix \\(A\\); these functions are the modes of the system.\n\nthus: - a linear dynamic system is stable if and only if all its modes are not divergent, - a linear dynamic system is asymptotically stable if and only if all its modes are convergent, - a linear dynamic system is unstable if it has at least one divergent mode.\nand, with respect to dynamic matrix eigenvalues, these happen if: - all the eigenvalues of \\(A\\) belong to the closed left half complex plane (that is they have negative or zero real part) and, in case they have zero real part, their algebraic multiplicity is the same of the geometric multiplicity, or, equivalently, they have scalar blocks in the Jordan form;\n- all the eigenvalues belong to the open left half imaginary plane, that is they have strictly negative real part; - at least one eigenvalue has positive real part, or eigenvalues with zero real part and non-scalar Jordan blocks exist.\nThis interactive example presents an editable dynamic matrix \\(A\\) and shows the system free response with the corresponding eigenvalues.\n\n\nHow to use this notebook?\n\nTry to change the eigenvalues and the initial condition \\(x_0\\) and see how the response changes.\n\n\n%matplotlib inline\n#%matplotlib notebook \nimport control as control\nimport numpy\nimport sympy as sym\nfrom IPython.display import display, Markdown\nimport ipywidgets as widgets\nimport matplotlib.pyplot as plt\n\n\n#print a matrix latex-like\ndef bmatrix(a):\n     \"\"\"Returns a LaTeX bmatrix - by Damir Arbula (ICCT project)\n\n     :a: numpy array\n     :returns: LaTeX bmatrix as a string\n     \"\"\"\n     if len(a.shape) &gt; 2:\n         raise ValueError('bmatrix can at most display two dimensions')\n     lines = str(a).replace('[', '').replace(']', '').splitlines()\n     rv = [r'\\begin{bmatrix}']\n     rv += ['  ' + ' & '.join(l.split()) + r'\\\\' for l in lines]\n     rv +=  [r'\\end{bmatrix}']\n     return '\\n'.join(rv)\n\n\n# Display formatted matrix: \ndef vmatrix(a):\n    if len(a.shape) &gt; 2:\n         raise ValueError('bmatrix can at most display two dimensions')\n    lines = str(a).replace('[', '').replace(']', '').splitlines()\n    rv = [r'\\begin{vmatrix}']\n    rv += ['  ' + ' & '.join(l.split()) + r'\\\\' for l in lines]\n    rv +=  [r'\\end{vmatrix}']\n    return '\\n'.join(rv)\n\n\n#matrixWidget is a matrix looking widget built with a VBox of HBox(es) that returns a numPy array as value !\nclass matrixWidget(widgets.VBox):\n    def updateM(self,change):\n        for irow in range(0,self.n):\n            for icol in range(0,self.m):\n                self.M_[irow,icol] = self.children[irow].children[icol].value\n                #print(self.M_[irow,icol])\n        self.value = self.M_\n\n    def dummychangecallback(self,change):\n        pass\n    \n    \n    def __init__(self,n,m):\n        self.n = n\n        self.m = m\n        self.M_ = numpy.matrix(numpy.zeros((self.n,self.m)))\n        self.value = self.M_\n        widgets.VBox.__init__(self,\n                             children = [\n                                 widgets.HBox(children = \n                                              [widgets.FloatText(value=0.0, layout=widgets.Layout(width='90px')) for i in range(m)]\n                                             ) \n                                 for j in range(n)\n                             ])\n        \n        #fill in widgets and tell interact to call updateM each time a children changes value\n        for irow in range(0,self.n):\n            for icol in range(0,self.m):\n                self.children[irow].children[icol].value = self.M_[irow,icol]\n                self.children[irow].children[icol].observe(self.updateM, names='value')\n        #value = Unicode('example@example.com', help=\"The email value.\").tag(sync=True)\n        self.observe(self.updateM, names='value', type= 'All')\n        \n    def setM(self, newM):\n        #disable callbacks, change values, and reenable\n        self.unobserve(self.updateM, names='value', type= 'All')\n        for irow in range(0,self.n):\n            for icol in range(0,self.m):\n                self.children[irow].children[icol].unobserve(self.updateM, names='value')\n        self.M_ = newM\n        self.value = self.M_\n        for irow in range(0,self.n):\n            for icol in range(0,self.m):\n                self.children[irow].children[icol].value = self.M_[irow,icol]\n        for irow in range(0,self.n):\n            for icol in range(0,self.m):\n                self.children[irow].children[icol].observe(self.updateM, names='value')\n        self.observe(self.updateM, names='value', type= 'All')        \n\n                #self.children[irow].children[icol].observe(self.updateM, names='value')\n\n             \n#overlaod class for state space systems that DO NOT remove \"useless\" states (what \"professor\" of automatic control would do this?)\nclass sss(control.StateSpace):\n    def __init__(self,*args):\n        #call base class init constructor\n        control.StateSpace.__init__(self,*args)\n    #disable function below in base class\n    def _remove_useless_states(self):\n        pass\n\n\n# Preparatory cell\n\nA = numpy.matrix([[0,1],[-2/5,-1/5]])\nX0 = numpy.matrix('5; 3')\n\nAw = matrixWidget(2,2)\nAw.setM(A)\nX0w = matrixWidget(2,1)\nX0w.setM(X0)\n\n\n# Misc\n\n#create dummy widget \nDW = widgets.FloatText(layout=widgets.Layout(width='0px', height='0px'))\n\n#create button widget\nSTART = widgets.Button(\n    description='Test',\n    disabled=False,\n    button_style='', # 'success', 'info', 'warning', 'danger' or ''\n    tooltip='Test',\n    icon='check'\n)\n                       \ndef on_start_button_clicked(b):\n    #This is a workaround to have intreactive_output call the callback:\n    #   force the value of the dummy widget to change\n    if DW.value&gt; 0 :\n        DW.value = -1\n    else: \n        DW.value = 1\n    pass\nSTART.on_click(on_start_button_clicked)\n\n\n# Main cell\n\ndef main_callback(A, X0, DW):\n    sols = numpy.linalg.eig(A)\n    sys = sss(A,[[1],[0]],[0,1],0)\n    pole = control.pole(sys)\n    if numpy.real(pole[0]) != 0:\n        p1r = abs(numpy.real(pole[0]))\n    else:\n        p1r = 1\n    if numpy.real(pole[1]) != 0:\n        p2r = abs(numpy.real(pole[1]))\n    else:\n        p2r = 1\n    if numpy.imag(pole[0]) != 0:\n        p1i = abs(numpy.imag(pole[0]))\n    else:\n        p1i = 1\n    if numpy.imag(pole[1]) != 0:\n        p2i = abs(numpy.imag(pole[1]))\n    else:\n        p2i = 1\n    \n    print('A\\'s eigenvalues are:',round(sols[0][0],4),'and',round(sols[0][1],4))\n    \n    #T = numpy.linspace(0, 60, 1000)\n    T, yout, xout = control.initial_response(sys,X0=X0,return_x=True)\n    \n    fig = plt.figure(\"A's eigenvalues\", figsize=(16,16))\n    ax = fig.add_subplot(311,title='Poles (Real vs Imag)')\n    #plt.axis(True)\n    # Move left y-axis and bottim x-axis to centre, passing through (0,0)\n    # Eliminate upper and right axes\n    ax.spines['left'].set_position(('data',0.0))\n    ax.spines['bottom'].set_position(('data',0.0))\n    ax.spines['right'].set_color('none')\n    ax.spines['top'].set_color('none')\n    ax.set_xlim(-max([p1r+p1r/3,p2r+p2r/3]),\n                max([p1r+p1r/3,p2r+p2r/3]))\n    ax.set_ylim(-max([p1i+p1i/3,p2i+p2i/3]),\n                max([p1i+p1i/3,p2i+p2i/3]))\n    \n    plt.plot([numpy.real(pole[0]),numpy.real(pole[1])],[numpy.imag(pole[0]),numpy.imag(pole[1])],'o')\n    plt.grid()\n\n    ax1 = fig.add_subplot(312,title='Free response')\n    plt.plot(T,xout[0])\n    plt.grid()\n    ax1.set_xlabel('time [s]')\n    ax1.set_ylabel('$x_1$')\n    ax1.axvline(x=0,color='black',linewidth='0.8')\n    ax1.axhline(y=0,color='black',linewidth='0.8')\n    ax2 = fig.add_subplot(313)\n    plt.plot(T,xout[1])\n    plt.grid()\n    ax2.set_xlabel('time [s]')\n    ax2.set_ylabel('$x_2$')\n    ax2.axvline(x=0,color='black',linewidth='0.8')\n    ax2.axhline(y=0,color='black',linewidth='0.8')\n    \n    #plt.show()\n    \n\n    \nalltogether = widgets.HBox([widgets.VBox([widgets.Label('$A$:',border=3),\n                                          Aw]),\n                                          widgets.Label('   ',border=3),\n                            widgets.VBox([widgets.Label('$X_0$:',border=3),\n                                          X0w]),\n                                          START])\nout = widgets.interactive_output(main_callback, {'A':Aw, 'X0':X0w, 'DW':DW})\nout.layout.height = '1000px'\ndisplay(out, alltogether)"
  },
  {
    "objectID": "ICCT_en/examples/04/SS-19-Internal_stability_example_2.html",
    "href": "ICCT_en/examples/04/SS-19-Internal_stability_example_2.html",
    "title": "Internal stability example 2",
    "section": "",
    "text": "# Erasmus+ ICCT project (2018-1-SI01-KA203-047081)\n\n# Toggle cell visibility\n\nfrom IPython.display import HTML\ntag = HTML('''&lt;script&gt;\ncode_show=true; \nfunction code_toggle() {\n    if (code_show){\n        $('div.input').hide()\n    } else {\n        $('div.input').show()\n    }\n    code_show = !code_show\n} \n$( document ).ready(code_toggle);\n&lt;/script&gt;\nToggle cell visibility &lt;a href=\"javascript:code_toggle()\"&gt;here&lt;/a&gt;.''')\ndisplay(tag)\n\n# Hide the code completely\n\n# from IPython.display import HTML\n# tag = HTML('''&lt;style&gt;\n# div.input {\n#     display:none;\n# }\n# &lt;/style&gt;''')\n# display(tag)\n\n\nToggle cell visibility here.\n\n\n\nHow to use this notebook?\nTry to change the dynamic matrix \\(A\\) of the stable linear system below in order to obtain an unstable system and change the initial conditions in order to show the divergent mode(s).\n\\[\n\\dot{x} = \\underbrace{\\begin{bmatrix}0&1\\\\-0.1&-2\\end{bmatrix}}_{A}x\n\\]\nTry to answer: - How can a suitable initial state be built?\n\n%matplotlib inline\nimport control as control\nimport numpy\nimport sympy as sym\nfrom IPython.display import display, Markdown\nimport ipywidgets as widgets\nimport matplotlib.pyplot as plt\n\n#matrixWidget is a matrix looking widget built with a VBox of HBox(es) that returns a numPy array as value !\nclass matrixWidget(widgets.VBox):\n    def updateM(self,change):\n        for irow in range(0,self.n):\n            for icol in range(0,self.m):\n                self.M_[irow,icol] = self.children[irow].children[icol].value\n                #print(self.M_[irow,icol])\n        self.value = self.M_\n\n    def dummychangecallback(self,change):\n        pass\n    \n    \n    def __init__(self,n,m):\n        self.n = n\n        self.m = m\n        self.M_ = numpy.matrix(numpy.zeros((self.n,self.m)))\n        self.value = self.M_\n        widgets.VBox.__init__(self,\n                             children = [\n                                 widgets.HBox(children = \n                                              [widgets.FloatText(value=0.0, layout=widgets.Layout(width='90px')) for i in range(m)]\n                                             ) \n                                 for j in range(n)\n                             ])\n        \n        #fill in widgets and tell interact to call updateM each time a children changes value\n        for irow in range(0,self.n):\n            for icol in range(0,self.m):\n                self.children[irow].children[icol].value = self.M_[irow,icol]\n                self.children[irow].children[icol].observe(self.updateM, names='value')\n        #value = Unicode('example@example.com', help=\"The email value.\").tag(sync=True)\n        self.observe(self.updateM, names='value', type= 'All')\n        \n    def setM(self, newM):\n        #disable callbacks, change values, and reenable\n        self.unobserve(self.updateM, names='value', type= 'All')\n        for irow in range(0,self.n):\n            for icol in range(0,self.m):\n                self.children[irow].children[icol].unobserve(self.updateM, names='value')\n        self.M_ = newM\n        self.value = self.M_\n        for irow in range(0,self.n):\n            for icol in range(0,self.m):\n                self.children[irow].children[icol].value = self.M_[irow,icol]\n        for irow in range(0,self.n):\n            for icol in range(0,self.m):\n                self.children[irow].children[icol].observe(self.updateM, names='value')\n        self.observe(self.updateM, names='value', type= 'All')        \n\n                #self.children[irow].children[icol].observe(self.updateM, names='value')\n\n             \n#overlaod class for state space systems that DO NOT remove \"useless\" states (what \"professor\" of automatic control would do this?)\nclass sss(control.StateSpace):\n    def __init__(self,*args):\n        #call base class init constructor\n        control.StateSpace.__init__(self,*args)\n    #disable function below in base class\n    def _remove_useless_states(self):\n        pass\n\n\n# Preparatory cell\n\nA = numpy.matrix([[0.,1.],[-1.0/10.0,-2.0]])\nX0 = numpy.matrix([[0.0],[0.0]])\n\nAw = matrixWidget(2,2)\nAw.setM(A)\nX0w = matrixWidget(2,1)\nX0w.setM(X0)\n\n\n# Misc\n\n#create dummy widget \nDW = widgets.FloatText(layout=widgets.Layout(width='0px', height='0px'))\n\n#create button widget\nSTART = widgets.Button(\n    description='Test',\n    disabled=False,\n    button_style='', # 'success', 'info', 'warning', 'danger' or ''\n    tooltip='Test',\n    icon='check'\n)\n                       \ndef on_start_button_clicked(b):\n    #This is a workaround to have intreactive_output call the callback:\n    #   force the value of the dummy widget to change\n    if DW.value&gt; 0 :\n        DW.value = -1\n    else: \n        DW.value = 1\n    pass\nSTART.on_click(on_start_button_clicked)\n\n\n# Main cell\n\ndef main_callback(A, X0, DW):\n    sols = numpy.linalg.eig(A)\n    sys = sss(A,[[0],[1]],[1,0],0)\n    pole = control.pole(sys)\n    if numpy.real(pole[0]) != 0:\n        p1r = abs(numpy.real(pole[0]))\n    else:\n        p1r = 1\n    if numpy.real(pole[1]) != 0:\n        p2r = abs(numpy.real(pole[1]))\n    else:\n        p2r = 1\n    if numpy.imag(pole[0]) != 0:\n        p1i = abs(numpy.imag(pole[0]))\n    else:\n        p1i = 1\n    if numpy.imag(pole[1]) != 0:\n        p2i = abs(numpy.imag(pole[1]))\n    else:\n        p2i = 1\n    \n    print('A\\'s eigenvalues are:',round(sols[0][0],4),'and',round(sols[0][1],4))\n    \n    #T = numpy.linspace(0, 60, 1000)\n    T, yout, xout = control.initial_response(sys,X0=X0,return_x=True)\n    \n    fig = plt.figure(\"Free response\", figsize=(16,5))\n    ax = fig.add_subplot(121)\n    plt.plot(T,xout[0])\n    plt.grid()\n    ax.set_xlabel('time [s]')\n    ax.set_ylabel(r'$x_1$')\n\n    ax1 = fig.add_subplot(122)\n    plt.plot(T,xout[1])\n    plt.grid()\n    ax1.set_xlabel('time [s]')\n    ax1.set_ylabel(r'$x_2$')\n\n    \n\n    \nalltogether = widgets.HBox([widgets.VBox([widgets.Label('$A$:',border=3),\n                                          Aw]),\n                                          widgets.Label('   ',border=3),\n                            widgets.VBox([widgets.Label('$X_0$:',border=3),\n                                          X0w]),\n                                          START])\nout = widgets.interactive_output(main_callback, {'A':Aw, 'X0':X0w, 'DW':DW})\nout.layout.height = '400px'\ndisplay(out, alltogether)\n\n\n\n\n\n\n\n\n#create dummy widget 2\nDW2 = widgets.FloatText(layout=widgets.Layout(width='0px', height='0px'))\nDW2.value = -1\n\n#create button widget\nSTART2 = widgets.Button(\n    description='Show answers',\n    disabled=False,\n    button_style='', # 'success', 'info', 'warning', 'danger' or ''\n    tooltip='Click for view the answers',\n    icon='check'\n)\n                       \ndef on_start_button_clicked2(b):\n    #This is a workaround to have intreactive_output call the callback:\n    #   force the value of the dummy widget to change\n    if DW2.value&gt; 0 :\n        DW2.value = -1\n    else: \n        DW2.value = 1\n    pass\nSTART2.on_click(on_start_button_clicked2)\n\ndef main_callback2(DW2):\n    if DW2 &gt; 0:\n        display(Markdown(r'''&gt;Answer: The initial state can be built as a linear combination of the eigenvectors associated to the unstable poles.\n        $$ $$\n        Example:\n        $$\n        A = \\begin{bmatrix} -1 & 1 \\\\ 0 & 3 \\end{bmatrix}, \\quad x_0 = \\begin{bmatrix} \\frac{1}{4} \\\\ 1 \\end{bmatrix} \\text{where $x_0$ is the eigenvector associated to the unstable pole $3$ .}\n        $$'''))\n    else:\n        display(Markdown(''))\n\n#create a graphic structure to hold all widgets \nalltogether2 =  widgets.VBox([START2])\n\nout2 = widgets.interactive_output(main_callback2,{'DW2':DW2})\n#out.layout.height = '300px'\ndisplay(out2,alltogether2)"
  },
  {
    "objectID": "ICCT_en/examples/04/SS-21-Internal_stability_example_4.html",
    "href": "ICCT_en/examples/04/SS-21-Internal_stability_example_4.html",
    "title": "Internal stability example 4",
    "section": "",
    "text": "# Erasmus+ ICCT project (2018-1-SI01-KA203-047081)\n\n# Toggle cell visibility\n\nfrom IPython.display import HTML\ntag = HTML('''&lt;script&gt;\ncode_show=true; \nfunction code_toggle() {\n    if (code_show){\n        $('div.input').hide()\n    } else {\n        $('div.input').show()\n    }\n    code_show = !code_show\n} \n$( document ).ready(code_toggle);\n&lt;/script&gt;\nToggle cell visibility &lt;a href=\"javascript:code_toggle()\"&gt;here&lt;/a&gt;.''')\ndisplay(tag)\n\n# Hide the code completely\n\n# from IPython.display import HTML\n# tag = HTML('''&lt;style&gt;\n# div.input {\n#     display:none;\n# }\n# &lt;/style&gt;''')\n# display(tag)\n\n\nToggle cell visibility here.\n\n\n\nHow to use this notebook?\nTry to change the dynamic matrix \\(A\\) of the stable linear system below in order to obtain a system with two divergent modes and then change the initial conditions in order to hide the divergent behaviour.\n\\[\n\\dot{x} = \\underbrace{\\begin{bmatrix}0&1\\\\-2&-2\\end{bmatrix}}_{A}x\n\\]\nTry to answer: - Is it possible to achieve this? If yes, in which particular case?\n\n%matplotlib inline\nimport control as control\nimport numpy\nimport sympy as sym\nfrom IPython.display import display, Markdown\nimport ipywidgets as widgets\nimport matplotlib.pyplot as plt\n\n#matrixWidget is a matrix looking widget built with a VBox of HBox(es) that returns a numPy array as value !\nclass matrixWidget(widgets.VBox):\n    def updateM(self,change):\n        for irow in range(0,self.n):\n            for icol in range(0,self.m):\n                self.M_[irow,icol] = self.children[irow].children[icol].value\n                #print(self.M_[irow,icol])\n        self.value = self.M_\n\n    def dummychangecallback(self,change):\n        pass\n    \n    \n    def __init__(self,n,m):\n        self.n = n\n        self.m = m\n        self.M_ = numpy.matrix(numpy.zeros((self.n,self.m)))\n        self.value = self.M_\n        widgets.VBox.__init__(self,\n                             children = [\n                                 widgets.HBox(children = \n                                              [widgets.FloatText(value=0.0, layout=widgets.Layout(width='90px')) for i in range(m)]\n                                             ) \n                                 for j in range(n)\n                             ])\n        \n        #fill in widgets and tell interact to call updateM each time a children changes value\n        for irow in range(0,self.n):\n            for icol in range(0,self.m):\n                self.children[irow].children[icol].value = self.M_[irow,icol]\n                self.children[irow].children[icol].observe(self.updateM, names='value')\n        #value = Unicode('example@example.com', help=\"The email value.\").tag(sync=True)\n        self.observe(self.updateM, names='value', type= 'All')\n        \n    def setM(self, newM):\n        #disable callbacks, change values, and reenable\n        self.unobserve(self.updateM, names='value', type= 'All')\n        for irow in range(0,self.n):\n            for icol in range(0,self.m):\n                self.children[irow].children[icol].unobserve(self.updateM, names='value')\n        self.M_ = newM\n        self.value = self.M_\n        for irow in range(0,self.n):\n            for icol in range(0,self.m):\n                self.children[irow].children[icol].value = self.M_[irow,icol]\n        for irow in range(0,self.n):\n            for icol in range(0,self.m):\n                self.children[irow].children[icol].observe(self.updateM, names='value')\n        self.observe(self.updateM, names='value', type= 'All')        \n\n                #self.children[irow].children[icol].observe(self.updateM, names='value')\n\n             \n#overlaod class for state space systems that DO NOT remove \"useless\" states (what \"professor\" of automatic control would do this?)\nclass sss(control.StateSpace):\n    def __init__(self,*args):\n        #call base class init constructor\n        control.StateSpace.__init__(self,*args)\n    #disable function below in base class\n    def _remove_useless_states(self):\n        pass\n\n\n# Preparatory cell\n\nA = numpy.matrix([[0.,1.],[-2.,-2.]])\nX0 = numpy.matrix([[1.],[0.]])\n\nAw = matrixWidget(2,2)\nAw.setM(A)\nX0w = matrixWidget(2,1)\nX0w.setM(X0)\n\n\n# Misc\n\n#create dummy widget \nDW = widgets.FloatText(layout=widgets.Layout(width='0px', height='0px'))\n\n#create button widget\nSTART = widgets.Button(\n    description='Test',\n    disabled=False,\n    button_style='', # 'success', 'info', 'warning', 'danger' or ''\n    tooltip='Test',\n    icon='check'\n)\n                       \ndef on_start_button_clicked(b):\n    #This is a workaround to have intreactive_output call the callback:\n    #   force the value of the dummy widget to change\n    if DW.value&gt; 0 :\n        DW.value = -1\n    else: \n        DW.value = 1\n    pass\nSTART.on_click(on_start_button_clicked)\n\n\n# Main cell\n\ndef main_callback(A, X0, DW):\n    sols = numpy.linalg.eig(A)\n    sys = sss(A,[[0],[1]],[1,0],0)\n    pole = control.pole(sys)\n    if numpy.real(pole[0]) != 0:\n        p1r = abs(numpy.real(pole[0]))\n    else:\n        p1r = 1\n    if numpy.real(pole[1]) != 0:\n        p2r = abs(numpy.real(pole[1]))\n    else:\n        p2r = 1\n    if numpy.imag(pole[0]) != 0:\n        p1i = abs(numpy.imag(pole[0]))\n    else:\n        p1i = 1\n    if numpy.imag(pole[1]) != 0:\n        p2i = abs(numpy.imag(pole[1]))\n    else:\n        p2i = 1\n    \n    print('A\\'s eigenvalues are:',round(sols[0][0],4),'and',round(sols[0][1],4))\n    \n    #T = numpy.linspace(0, 60, 1000)\n    T, yout, xout = control.initial_response(sys,X0=X0,return_x=True)\n    \n    fig = plt.figure(\"Free response\", figsize=(16,5))\n    ax = fig.add_subplot(121)\n    plt.plot(T,xout[0])\n    plt.grid()\n    ax.set_xlabel('time [s]')\n    ax.set_ylabel(r'$x_1$')\n\n    ax1 = fig.add_subplot(122)\n    plt.plot(T,xout[1])\n    plt.grid()\n    ax1.set_xlabel('time [s]')\n    ax1.set_ylabel(r'$x_2$')\n\n    \n\n    \nalltogether = widgets.HBox([widgets.VBox([widgets.Label('$A$:',border=3),\n                                          Aw]),\n                                          widgets.Label('   ',border=3),\n                            widgets.VBox([widgets.Label('$X_0$:',border=3),\n                                          X0w]),\n                                          START])\nout = widgets.interactive_output(main_callback, {'A':Aw, 'X0':X0w, 'DW':DW})\nout.layout.height = '350px'\ndisplay(out, alltogether)\n\n\n\n\n\n\n\n\n#create dummy widget 2\nDW2 = widgets.FloatText(layout=widgets.Layout(width='0px', height='0px'))\nDW2.value = -1\n\n#create button widget\nSTART2 = widgets.Button(\n    description='Show answers',\n    disabled=False,\n    button_style='', # 'success', 'info', 'warning', 'danger' or ''\n    tooltip='Click for view the answers',\n    icon='check'\n)\n                       \ndef on_start_button_clicked2(b):\n    #This is a workaround to have intreactive_output call the callback:\n    #   force the value of the dummy widget to change\n    if DW2.value&gt; 0 :\n        DW2.value = -1\n    else: \n        DW2.value = 1\n    pass\nSTART2.on_click(on_start_button_clicked2)\n\ndef main_callback2(DW2):\n    if DW2 &gt; 0:\n        display(Markdown(r'''&gt;Answer: The only initial condition that hides completly the divergent modes is the state space origin.\n        $$ $$\n        Example:\n        $$\n        A = \\begin{bmatrix} 1 & 0 \\\\ 0 & 1 \\end{bmatrix}\n        $$'''))\n    else:\n        display(Markdown(''))\n\n#create a graphic structure to hold all widgets \nalltogether2 =  widgets.VBox([START2])\n\nout2 = widgets.interactive_output(main_callback2,{'DW2':DW2})\n#out.layout.height = '300px'\ndisplay(out2,alltogether2)"
  },
  {
    "objectID": "ICCT_en/examples/04/SS-23-Controllability.html",
    "href": "ICCT_en/examples/04/SS-23-Controllability.html",
    "title": "Controllability",
    "section": "",
    "text": "# Erasmus+ ICCT project (2018-1-SI01-KA203-047081)\n\n# Toggle cell visibility\n\nfrom IPython.display import HTML\ntag = HTML('''&lt;script&gt;\ncode_show=true; \nfunction code_toggle() {\n    if (code_show){\n        $('div.input').hide()\n    } else {\n        $('div.input').show()\n    }\n    code_show = !code_show\n} \n$( document ).ready(code_toggle);\n&lt;/script&gt;\nToggle cell visibility &lt;a href=\"javascript:code_toggle()\"&gt;here&lt;/a&gt;.''')\ndisplay(tag)\n\n# Hide the code completely\n\n# from IPython.display import HTML\n# tag = HTML('''&lt;style&gt;\n# div.input {\n#     display:none;\n# }\n# &lt;/style&gt;''')\n# display(tag)\n\n\nToggle cell visibility here.\n\n\nControllability is a fundamental property of a system and describes if the system state \\(x(t)\\) can be brought with an appropriate input \\(u(t)\\) to some point of the state space or not. More specifically, controllability tells if by starting in a specific state, and by varying the inputs, it is possible or not to bring the system at the origin of the state space. If it is possible, then that state is said to be controllable (to zero). The analogous property of Reachability tells if starting from the origin it is possible to reach a specific state. If it is possible, then that state is said to be reachable (from zero). For continuous-time linear time invariant systems, the set of reachable states and that of controllable states coincide, these are vectorial spaces and, we can talk about controllability and reachability of a system.\nGiven a linear system of the type:\n\\[\\begin{cases}\n\\dot{\\textbf{x}}=A\\textbf{x}+B\\textbf{u} \\\\\n\\textbf{y}=C\\textbf{x}\n\\end{cases}\\]\nand by defining the reachable set as \\(R=\\{x\\, |\\, \\exists\\, u\\in\\, U: x=\\int_{t_0}^{t_f}e^{A(t_f-\\tau)}Bu(\\tau)d\\tau\\}\\), a system is reachable if and only if \\(\\text{dim}(R)=n\\) where \\(n:x\\in \\mathbb{R}^n\\). It can be demonstrated that \\(R\\) is a vector space and that it is described by the reachability Gramian \\(G_r(0,t_f)=\\int_{0}^{t_f}e^{A(t_f-\\tau)}BB^Te^{A^T(t_f-\\tau)}d\\tau\\); therefore, a system is Controllable if and only if \\(\\text{det}(G_r)\\neq 0\\) and introducing the controllability matrix as \\[\n\\mathcal{C} = \\begin{bmatrix}B&AB&A^2B&\\dots&A^{n-1}B\\end{bmatrix}\n\\] if and only if \\(\\mathcal{C}\\) has full column rank since the Image of \\(G_r\\) is the same as of \\(\\mathcal{C}\\).\nThe Controllability property is fundamental because if a point of the state space is not controllable/reachable then it does not exist an input function \\(u(t)\\) that brings the system state to this point. This in turn implies that it will neither be possible to create a closed-loop controller that regulates the system state to that point.\nThe example below allows to edit the matrices \\(A\\) and \\(B\\), compute the corresponding Controllability matrix \\(\\mathcal{C}\\), and to plot response to various inputs and initial conditions.\n\nHow to use this notebook?\n\nTry to make the default system uncontrollable by changing only \\(B\\).\nTry to define a couple \\((A,B)\\) that has one positive eigenvalue that is associated to an uncontrollable state. How does the output behave in a step response?\n\n\n#Preparatory Cell \n\n%matplotlib inline\nimport control\nimport numpy\nfrom IPython.display import display, Markdown, Javascript\nimport ipywidgets as widgets\nimport matplotlib.pyplot as plt\n\n#print a matrix latex-like\ndef bmatrix(a):\n     \"\"\"Returns a LaTeX bmatrix - by Damir Arbula (ICCT project)\n\n     :a: numpy array\n     :returns: LaTeX bmatrix as a string\n     \"\"\"\n     if len(a.shape) &gt; 2:\n         raise ValueError('bmatrix can at most display two dimensions')\n     lines = str(a).replace('[', '').replace(']', '').splitlines()\n     rv = [r'\\begin{bmatrix}']\n     rv += ['  ' + ' & '.join(l.split()) + r'\\\\' for l in lines]\n     rv +=  [r'\\end{bmatrix}']\n     return ''.join(rv) #'\\n'.join(rv)\n\n#matrixWidget is a matrix looking widget built with a VBox of HBox(es) that returns a numPy array as value !\nclass matrixWidget(widgets.VBox):\n    def updateM(self,change):\n        for irow in range(0,self.n):\n            for icol in range(0,self.m):\n                self.M_[irow,icol] = self.children[irow].children[icol].value\n                #print(self.M_[irow,icol])\n        self.value = self.M_\n\n    def dummychangecallback(self,change):\n        pass\n    \n    \n    def __init__(self,n,m):\n        self.n = n\n        self.m = m\n        self.M_ = numpy.matrix(numpy.zeros((self.n,self.m)))\n        self.value = self.M_\n        widgets.VBox.__init__(self,\n                             children = [\n                                 widgets.HBox(children = \n                                              [widgets.FloatText(value=0.0, layout=widgets.Layout(width='90px')) for i in range(m)]\n                                             ) \n                                 for j in range(n)\n                             ])\n        \n        #fill in widgets and tell interact to call updateM each time a children changes value\n        for irow in range(0,self.n):\n            for icol in range(0,self.m):\n                self.children[irow].children[icol].value = self.M_[irow,icol]\n                self.children[irow].children[icol].observe(self.updateM, names='value')\n        #value = Unicode('example@example.com', help=\"The email value.\").tag(sync=True)\n        self.observe(self.updateM, names='value', type= 'All')\n        \n    def setM(self, newM):\n        #disable callbacks, change values, and reenable\n        self.unobserve(self.updateM, names='value', type= 'All')\n        for irow in range(0,self.n):\n            for icol in range(0,self.m):\n                self.children[irow].children[icol].unobserve(self.updateM, names='value')\n        self.M_ = newM\n        self.value = self.M_\n        for irow in range(0,self.n):\n            for icol in range(0,self.m):\n                self.children[irow].children[icol].value = self.M_[irow,icol]\n        for irow in range(0,self.n):\n            for icol in range(0,self.m):\n                self.children[irow].children[icol].observe(self.updateM, names='value')\n        self.observe(self.updateM, names='value', type= 'All')        \n\n                #self.children[irow].children[icol].observe(self.updateM, names='value')\n\n             \n#overlaod class for state space systems that DO NOT remove \"useless\" states (what \"professor\" of automatic control would do this?)\nclass sss(control.StateSpace):\n    def __init__(self,*args):\n        #call base class init constructor\n        control.StateSpace.__init__(self,*args)\n    #disable function below in base class\n    def _remove_useless_states(self):\n        pass\n\n\n# Preparatory cell\nA = numpy.matrix('-1 1 0; 0 -1 1; 0 0 -1')\nB = numpy.matrix('0; 0; 1')\nC = numpy.matrix('1 0 0')\nX0 = numpy.matrix('0; 0; 0')\n\nAw = matrixWidget(3,3)\nAw.setM(A)\nBw = matrixWidget(3,1)\nBw.setM(B)\nCw = matrixWidget(1,3)\nCw.setM(C)\nX0w = matrixWidget(3,1)\nX0w.setM(X0)\n\n\n# Misc\n#define type of ipout \nselu = widgets.Dropdown(\n    options=['impulse', 'step', 'sinusoid', 'square wave'],\n    value='step',\n    description='Type of input:',\n    disabled=False\n)\n# Define the values of the input\nu = widgets.FloatSlider(\n    value=1,\n    min=0,\n    max=20.0,\n    step=0.1,\n    description=r'$u$:',\n    disabled=False,\n    continuous_update=False,\n    orientation='horizontal',\n    readout=True,\n    readout_format='.1f',\n)\nperiod = widgets.FloatSlider(\n    value=1,\n    min=0.01,\n    max=4,\n    step=0.01,\n    description='Period: ',\n    disabled=False,\n    continuous_update=False,\n    orientation='horizontal',\n    readout=True,\n    readout_format='.2f',\n)\n\n#create dummy widget \nDW = widgets.FloatText(layout=widgets.Layout(width='0px', height='0px'))\n\n#create button widget\nSTART = widgets.Button(\n    description='Test',\n    disabled=False,\n    button_style='', # 'success', 'info', 'warning', 'danger' or ''\n    tooltip='Test',\n    icon='check'\n)\n                       \ndef on_start_button_clicked(b):\n    #This is a workaround to have intreactive_output call the callback:\n    #   force the value of the dummy widget to change\n    if DW.value&gt; 0 :\n        DW.value = -1\n    else: \n        DW.value = 1\n    pass\nSTART.on_click(on_start_button_clicked)\n\n\ndef main_callback(A, B, C, X0, u, period, selu, DW):\n    eig = numpy.linalg.eig(A)[0]\n    R = control.ctrb(A,B)\n    rankR = numpy.linalg.matrix_rank(R)\n    \n    text = r'The eigenvalues of the system are ' + str(eig[0]) + r', ' + str(eig[1])+ r' and ' + str(eig[2]) + r'. '\n    if rankR == 3:\n        text = text + r'Since $\\text{rank}(\\mathcal{C})=3$ the system is controllable. ' + '\\n\\n' + 'The reachability matrix is: ' + r'$\\mathcal{C}=' + bmatrix(R) + r'$'\n    else:\n        text = text + r'Since $\\text{rank}(\\mathcal{C})=' + str(rankR) + r'$ the system is uncontrollable. ' + '\\n\\n' + 'The reachability matrix is: ' + r'$\\mathcal{C}=' + bmatrix(R) + r'$'\n    display(Markdown(text))\n    \n    \n    sys = sss(A,B,C,0)\n    if numpy.real([eig[0],eig[1],eig[2]])[0] == 0 and numpy.real([eig[0],eig[1],eig[2]])[1] == 0 and numpy.real([eig[0],eig[1],eig[2]])[2] == 0:\n        T = numpy.linspace(0,20,1000)\n    else:\n        if min(numpy.abs(numpy.real([eig[0],eig[1],eig[2]]))) != 0:\n            T = numpy.linspace(0,7*1/min(numpy.abs(numpy.real([eig[0],eig[1],eig[2]]))),1000)\n        else:\n            T = numpy.linspace(0,7*1/max(numpy.abs(numpy.real([eig[0],eig[1],eig[2]]))),1000)\n    \n    if selu == 'impulse': #selu\n        U = [0 for t in range(0,len(T))]\n        U[0] = u\n        T, Y, X = control.forced_response(sys,T=T,U=U,X0=X0)\n    if selu == 'step':\n        U = [u for t in range(0,len(T))]\n        T, Y, X = control.forced_response(sys,T=T,U=U,X0=X0)\n    if selu == 'sinusoid':\n        U = u*numpy.sin(2*numpy.pi/period*T)\n        T, Y, X = control.forced_response(sys,T=T,U=U,X0=X0)\n    if selu == 'square wave':\n        U = u*numpy.sign(numpy.sin(2*numpy.pi/period*T))\n        T, Y, X = control.forced_response(sys,T=T,U=U,X0=X0)\n    \n    fig = plt.figure(figsize=(16,5))\n    \n    fig.add_subplot(121)\n    plt.title('Step response: states')\n    plt.plot(T,X[0])\n    plt.plot(T,X[1])\n    plt.plot(T,X[2])\n    plt.ylabel('States')\n    plt.xlabel('time [s]')\n    plt.legend([r'$x_1$',r'$x_2$',r'$x_3$'])\n    plt.grid()\n    \n    fig.add_subplot(122)\n    plt.ylabel(r'$y$')\n    plt.plot(T,Y)\n    plt.xlabel('time [s]')\n    plt.title('Step response: output')\n    plt.grid()\n    \n\nalltogether = widgets.VBox([widgets.HBox([widgets.Label('A:',border=3),  Aw, widgets.Label('   ',border=3),\n                                          widgets.Label('B:',border=3),  Bw, widgets.Label('   ',border=3),\n                                          widgets.Label('x0:',border=3),X0w,widgets.Label('   ',border=3),\n                                          START]),\n                            widgets.Label('   ',border=3),\n                            widgets.HBox([widgets.Label('C:',border=3),Cw,widgets.Label('   ',border=3)]),\n                            widgets.Label('   ',border=3),\n                            widgets.HBox([selu, u, period])])\nout = widgets.interactive_output(main_callback, {'A':Aw, 'B':Bw, 'C':Cw, 'X0':X0w, 'u':u, 'period':period, 'selu':selu, 'DW':DW})\nout.layout.height = '460px'\ndisplay(out, alltogether)\n\n\n\n\n\n\n\n\n%%js\nJupyter.notebook.execute_cells([5])"
  },
  {
    "objectID": "ICCT_en/examples/04/SS-25-Internal_and_external_stability.html",
    "href": "ICCT_en/examples/04/SS-25-Internal_and_external_stability.html",
    "title": "Internal and External stability",
    "section": "",
    "text": "# Erasmus+ ICCT project (2018-1-SI01-KA203-047081)\n\n# Toggle cell visibility\n\nfrom IPython.display import HTML\ntag = HTML('''&lt;script&gt;\ncode_show=true; \nfunction code_toggle() {\n    if (code_show){\n        $('div.input').hide()\n    } else {\n        $('div.input').show()\n    }\n    code_show = !code_show\n} \n$( document ).ready(code_toggle);\n&lt;/script&gt;\nToggle cell visibility &lt;a href=\"javascript:code_toggle()\"&gt;here&lt;/a&gt;.''')\ndisplay(tag)\n\n# Hide the code completely\n\n# from IPython.display import HTML\n# tag = HTML('''&lt;style&gt;\n# div.input {\n#     display:none;\n# }\n# &lt;/style&gt;''')\n# display(tag)\n\n\nToggle cell visibility here.\n\n\nRecalling that the Input-output representation of a dynamic system represents only the observable and controllable part of the entire system, and that a system with divergent modes, thus unstable (internally), may not show these modes on the output because of zero-pole cancellations in the transfer function(thus BIBO stable).\nUse this interactive example to: * Define a system that is both internally and BIBO stable. * Define a system that is unstable but is BIBO stable. Is it possible to achieve this? Why? * Define a system that is stable but BIBO unstable. Is it possible to achieve this? Why?\n\n#Preparatory Cell \n\n%matplotlib inline\nimport control\nimport control.matlab as cm\nimport numpy\nfrom IPython.display import display, Markdown\nimport ipywidgets as widgets\nimport matplotlib.pyplot as plt\n\n#print a matrix latex-like\ndef bmatrix(a):\n     \"\"\"Returns a LaTeX bmatrix - by Damir Arbula (ICCT project)\n\n     :a: numpy array\n     :returns: LaTeX bmatrix as a string\n     \"\"\"\n     if len(a.shape) &gt; 2:\n         raise ValueError('bmatrix can at most display two dimensions')\n     lines = str(a).replace('[', '').replace(']', '').splitlines()\n     rv = [r'\\begin{bmatrix}']\n     rv += ['  ' + ' & '.join(l.split()) + r'\\\\' for l in lines]\n     rv +=  [r'\\end{bmatrix}']\n     return ''.join(rv) #'\\n'.join(rv)\n\n#matrixWidget is a matrix looking widget built with a VBox of HBox(es) that returns a numPy array as value !\nclass matrixWidget(widgets.VBox):\n    def updateM(self,change):\n        for irow in range(0,self.n):\n            for icol in range(0,self.m):\n                self.M_[irow,icol] = self.children[irow].children[icol].value\n                #print(self.M_[irow,icol])\n        self.value = self.M_\n\n    def dummychangecallback(self,change):\n        pass\n    \n    \n    def __init__(self,n,m):\n        self.n = n\n        self.m = m\n        self.M_ = numpy.matrix(numpy.zeros((self.n,self.m)))\n        self.value = self.M_\n        widgets.VBox.__init__(self,\n                             children = [\n                                 widgets.HBox(children = \n                                              [widgets.FloatText(value=0.0, layout=widgets.Layout(width='90px')) for i in range(m)]\n                                             ) \n                                 for j in range(n)\n                             ])\n        \n        #fill in widgets and tell interact to call updateM each time a children changes value\n        for irow in range(0,self.n):\n            for icol in range(0,self.m):\n                self.children[irow].children[icol].value = self.M_[irow,icol]\n                self.children[irow].children[icol].observe(self.updateM, names='value')\n        #value = Unicode('example@example.com', help=\"The email value.\").tag(sync=True)\n        self.observe(self.updateM, names='value', type= 'All')\n        \n    def setM(self, newM):\n        #disable callbacks, change values, and reenable\n        self.unobserve(self.updateM, names='value', type= 'All')\n        for irow in range(0,self.n):\n            for icol in range(0,self.m):\n                self.children[irow].children[icol].unobserve(self.updateM, names='value')\n        self.M_ = newM\n        self.value = self.M_\n        for irow in range(0,self.n):\n            for icol in range(0,self.m):\n                self.children[irow].children[icol].value = self.M_[irow,icol]\n        for irow in range(0,self.n):\n            for icol in range(0,self.m):\n                self.children[irow].children[icol].observe(self.updateM, names='value')\n        self.observe(self.updateM, names='value', type= 'All')        \n\n                #self.children[irow].children[icol].observe(self.updateM, names='value')\n\n             \n#overlaod class for state space systems that DO NOT remove \"useless\" states (what \"professor\" of automatic control would do this?)\nclass sss(control.StateSpace):\n    def __init__(self,*args):\n        #call base class init constructor\n        control.StateSpace.__init__(self,*args)\n    #disable function below in base class\n    def _remove_useless_states(self):\n        pass\n\n\n# Preparatory cell\nimport warnings\n# In order to suppress the warning BadCoefficient\nwarnings.filterwarnings(\"ignore\")\n\ndef MINREAL(A,B,C,D):\n    ''' Trick in order to have a right cancellations without very small numbers '''\n    sys = control.ss2tf(sss(A,B,C,D))\n    sys = control.minreal(sys, verbose=False)\n    z, p, k = cm.tf2zpk(sys.num[0][0],sys.den[0][0])\n    num, den = cm.zpk2tf(z, p, k)\n    sys = control.tf(num, den)\n    return sys\n\ndef allRealNeg(a):\n    for i in a:\n        if numpy.real(i) &gt;= 0:\n            return False\n    return True\n\ndef anyRealPos(a):\n    for i in a:\n        if numpy.real(i) &gt; 0:\n            return True\n    return False\n\nA = numpy.matrix('-1 1 0 0; 0 -1 1 0; 0 0 -1 0; 0 1 -1 0')\nB = numpy.matrix('0; 0; 1; -1')\nC = numpy.matrix('1 0 0 1')\nD = numpy.matrix('0')\nX0 = numpy.matrix('0; 0; 0; 0')\n\nAdef = [numpy.matrix('-1 1 4 0; 0 -0.5 3 0; 0 0 -2 0; 0 0 0 -3'),\n        numpy.matrix('-1 1 4 0; 0 -0.5 3 0; 0 0 0 0; 0 0 0 -2'),\n        numpy.matrix('-3 2 0 0; 0 -1 0 0; 0 1 1 0; 0 0 0 -1')] \nBdef = [numpy.matrix('0; 0; 1; 0'),\n        numpy.matrix('0; 0; 1; 0'),\n        numpy.matrix('0; 1; 0; 0')] \nCdef = [numpy.matrix('1 0 0 1'),\n        numpy.matrix('1 0 0 0'),\n        numpy.matrix('1 0 0 1')]\n\nAw = matrixWidget(4,4)\nAw.setM(A)\nBw = matrixWidget(4,1)\nBw.setM(B)\nCw = matrixWidget(1,4)\nCw.setM(C)\nDw = matrixWidget(1,1)\nDw.setM(D)\nX0w = matrixWidget(4,1)\nX0w.setM(X0)\n\n\n# Misc\n# default systems\nsel_system = widgets.Dropdown(\n                              options=['Manual', 'Internally stable and BIBO stable system', 'Internally stable and BIBO unstable system', 'Internally unstable and BIBO stable system'],\n                              value='Internally stable and BIBO stable system',\n                              description='',\n                              disabled=False\n)\n#define type of ipout \nselu = widgets.Dropdown(\n    options=['impulse', 'step', 'sinusoid', 'square wave'],\n    value='step',\n    description='Type of input:',\n    disabled=False\n)\n# Define the values of the input\nu = widgets.FloatSlider(\n    value=1,\n    min=0,\n    max=20.0,\n    step=0.1,\n    description=r'$u$:',\n    disabled=False,\n    continuous_update=False,\n    orientation='horizontal',\n    readout=True,\n    readout_format='.1f',\n)\nperiod = widgets.FloatSlider(\n    value=1,\n    min=0.001,\n    max=4,\n    step=0.001,\n    description='Period: ',\n    disabled=False,\n    continuous_update=False,\n    orientation='horizontal',\n    readout=True,\n    readout_format='.2f',\n)\n\n#create dummy widget \nDW = widgets.FloatText(layout=widgets.Layout(width='0px', height='0px'))\n\n#create button widget\nSTART = widgets.Button(\n    description='Test',\n    disabled=False,\n    button_style='', # 'success', 'info', 'warning', 'danger' or ''\n    tooltip='Test',\n    icon='check'\n)\n                       \ndef on_start_button_clicked(b):\n    #This is a workaround to have intreactive_output call the callback:\n    #   force the value of the dummy widget to change\n    if DW.value&gt; 0 :\n        DW.value = -1\n    else: \n        DW.value = 1\n    pass\nSTART.on_click(on_start_button_clicked)\n\n\ndef main_callback(A, B, C, D, X0, u, period, selu, sel_system, DW):\n    global Aw, Bw, Cw, Dw, X0w, Adef, Bdef, Cdef\n\n    if sel_system == 'Internally stable and BIBO stable system':\n        A = Adef[0]\n        Aw.setM(A)\n        B = Bdef[0]\n        Bw.setM(B)\n        C = Cdef[0]\n        Cw.setM(C)\n        D = 0\n        Dw.setM(numpy.matrix('0'))\n        X0w.setM(numpy.matrix([0, 0, 0, 0]).T)\n        X0 = numpy.matrix([0, 0, 0, 0]).T\n    elif sel_system == 'Internally stable and BIBO unstable system':\n        A = Adef[1]\n        Aw.setM(A)\n        B = Bdef[1]\n        Bw.setM(B)\n        C = Cdef[1]\n        Cw.setM(C)\n        D = 0\n        Dw.setM(numpy.matrix('0'))\n        X0w.setM(numpy.matrix([0, 0, 0, 0]).T)\n        X0 = numpy.matrix([0, 0, 0, 0]).T\n    elif sel_system == 'Internally unstable and BIBO stable system':\n        A = Adef[2]\n        Aw.setM(A)\n        B = Bdef[2]\n        Bw.setM(B)\n        C = Cdef[2]\n        Cw.setM(C)\n        D = 0\n        Dw.setM(numpy.matrix('0'))\n        X0w.setM(numpy.matrix([0, 0, 0, 0]).T)\n        X0 = numpy.matrix([0, 0, 0, 0]).T\n        \n        \n    eig = numpy.linalg.eig(A)[0]\n    R = control.ctrb(A,B)\n    O = control.obsv(A,C)\n    rankR = numpy.linalg.matrix_rank(R)\n    rankO = numpy.linalg.matrix_rank(O)\n    \n    text = r'The eigenvalues of the system are ' + str(eig[0]) + r', ' + str(eig[1])+ r', ' + str(eig[2]) + r' and ' + str(eig[3]) + '. '\n    if rankO == 4:\n        text = text + r'The system is observable and '\n    else:\n        text = text + r'The system is unobservable and '\n    if rankR == 4:\n        text = text + r' reachable.'\n    else:\n        text = text + r' unreachable. '\n    \n    \n    sys = MINREAL(A,B,C,D)\n    text = text + 'The transfer function is: \\n '\n    display(Markdown(text))\n    print(sys)\n    \n    # Check internal stability\n    if allRealNeg(eig) and allRealNeg(sys.pole()):\n        display(Markdown(\"**Internally stable and BIBO stable system**\"))\n    elif allRealNeg(eig) and not allRealNeg(sys.pole()):\n        display(Markdown(\"**Internally stable and BIBO unstable system**\"))\n    elif anyRealPos(eig):\n        if not allRealNeg(sys.pole()):\n            display(Markdown(\"**Internally unstable and BIBO unstable system**\"))\n        else:\n            display(Markdown(\"**Internally unstable and BIBO stable system**\"))\n    else:\n        setted = False\n        for i in eig:\n            if numpy.real(i) == 0:\n                count = 0\n                for j in eig:\n                    if j==i:\n                        count += 1\n                if count == 1:\n                    continue\n                else:\n                    alg_mul = count-1\n                geom_mul = 4-numpy.linalg.matrix_rank((A-i*numpy.matrix(numpy.eye(4))))\n                if alg_mul &gt; geom_mul:\n                    setted = True\n                    break\n        if setted == True:\n            if not allRealNeg(sys.pole()):\n                display(Markdown(\"**Internally unstable and BIBO unstable system**\"))\n            else:\n                display(Markdown(\"**Internally unstable and BIBO stable system**\"))\n        else:\n            if not allRealNeg(sys.pole()):\n                display(Markdown(\"**Internally stable and BIBO unstable system**\"))\n            else:\n                display(Markdown(\"**Internally stable and BIBO stable system**\"))\n\n    \n    sys = sss(A,B,C,D)\n    \n    if (numpy.real([eig[0],eig[1],eig[2],eig[3]]) == [0, 0, 0, 0]).all():\n        T = numpy.linspace(0,20,1000)\n    else:\n        if min(numpy.abs(numpy.real([eig[0],eig[1],eig[2],eig[3]]))) != 0:\n            T = numpy.linspace(0,7*1/min(numpy.abs(numpy.real([eig[0],eig[1],eig[2],eig[3]]))),1000)\n        else:\n            T = numpy.linspace(0,7*1/max(numpy.abs(numpy.real([eig[0],eig[1],eig[2],eig[3]]))),1000)\n    \n    if selu == 'impulse': #selu\n        U = [0 for t in range(0,len(T))]\n        U[0] = u\n        T, Y, X = control.forced_response(sys,T=T,U=U,X0=X0)\n    if selu == 'step':\n        U = [u for t in range(0,len(T))]\n        T, Y, X = control.forced_response(sys,T=T,U=U,X0=X0)\n    if selu == 'sinusoid':\n        U = u*numpy.sin(2*numpy.pi/period*T)\n        T, Y, X = control.forced_response(sys,T=T,U=U,X0=X0)\n    if selu == 'square wave':\n        U = u*numpy.sign(numpy.sin(2*numpy.pi/period*T))\n        T, Y, X = control.forced_response(sys,T=T,U=U,X0=X0)\n    \n    fig = plt.figure(figsize=(16,5))\n    \n    fig.add_subplot(121)\n    plt.title('Initial response: states')\n    plt.plot(T,X[0])\n    plt.plot(T,X[1])\n    plt.plot(T,X[2])\n    plt.plot(T,X[3])\n    plt.ylabel('States')\n    plt.xlabel('time [s]')\n    plt.legend([r'$x_1$',r'$x_2$',r'$x_3$',r'$x_4$'])\n    plt.grid()\n    \n    fig.add_subplot(122)\n    plt.ylabel(r'$y$')\n    plt.plot(T,Y)\n    plt.xlabel('time [s]')\n    plt.title('Initial response: output')\n    plt.grid()\n    \n    \nalltogether = widgets.VBox([sel_system,\n                            widgets.Label('   ',border=3),\n                            widgets.HBox([widgets.Label('A:',border=3),  Aw, widgets.Label('   ',border=3),\n                                          widgets.Label('B:',border=3),  Bw, widgets.Label('   ',border=3),\n                                          widgets.Label('x0:',border=3),X0w,widgets.Label('   ',border=3)]),\n                            widgets.Label('   ',border=3),\n                            widgets.HBox([widgets.Label('C:',border=3),\n                                          Cw,widgets.Label('   ',border=3),\n                                          widgets.Label('D:',border=3),\n                                          Dw,widgets.Label('   ',border=3),\n                                          START]),\n                            widgets.Label('   ',border=3),\n                            widgets.HBox([selu, u, period])])\nout = widgets.interactive_output(main_callback, {'A':Aw, 'B':Bw, 'C':Cw, 'D':Dw, 'X0':X0w, 'u':u, 'period':period, 'selu':selu, 'sel_system':sel_system, 'DW':DW})\nout.layout.height = '520px'\ndisplay(out, alltogether)"
  },
  {
    "objectID": "ICCT_en/examples/04/SS-27-Luenberger_observer_with_dynamic_requirements.html",
    "href": "ICCT_en/examples/04/SS-27-Luenberger_observer_with_dynamic_requirements.html",
    "title": "Dynamic requirements for a Luenberger observer",
    "section": "",
    "text": "# Erasmus+ ICCT project (2018-1-SI01-KA203-047081)\n\n# Toggle cell visibility\n\nfrom IPython.display import HTML\ntag = HTML('''&lt;script&gt;\ncode_show=true; \nfunction code_toggle() {\n    if (code_show){\n        $('div.input').hide()\n    } else {\n        $('div.input').show()\n    }\n    code_show = !code_show\n} \n$( document ).ready(code_toggle);\n&lt;/script&gt;\nToggle cell visibility &lt;a href=\"javascript:code_toggle()\"&gt;here&lt;/a&gt;.''')\ndisplay(tag)\n\n# Hide the code completely\n\n# from IPython.display import HTML\n# tag = HTML('''&lt;style&gt;\n# div.input {\n#     display:none;\n# }\n# &lt;/style&gt;''')\n# display(tag)\n\n\nToggle cell visibility here.\n\n\nThis example shows how to develop of a Luenberger observer in the case of closed-loop dynamics requirements for a plant and thus, for the observer.\nGiven the system:\n\\[\\begin{cases}\n\\dot{\\textbf{x}}=\\begin{bmatrix}-0.5&1&2\\\\0&-1&-2\\\\0&1&0.5\\end{bmatrix}\\textbf{x}+\\begin{bmatrix}0\\\\0\\\\1\\end{bmatrix}\\textbf{u} \\\\ \\\\\n\\textbf{y}=\\begin{bmatrix}1&0&0\\end{bmatrix}\\textbf{x}\n\\end{cases}\\]\nthe control system designer is required to design a controller with a settling time to a step reference of 5 seconds or less. In order to implement such a controller with state feedback, an observer is necessary.\nIn order to have the estimation error converge to zero much faster then the desired closed-loop settling time, the observer convergence must be faster than 1 second.\nRecalling the expression for the estimation error dynamics:\n\\[\n\\dot{\\textbf{e}}=(A-LC)\\textbf{e} \\,.\n\\]\nin order to achieve this performance, the eigenvalues of observer’s dynamic matrix \\((A-LC)\\) must be greater (in modulus) than -3 rad/s, considering a settling time within a range of 5% of the final value.\n\nHow to use this notebook?\nTry to change \\(L\\) or directly the eigenvalues to meet the above requirement.\n\n#Preparatory Cell \n\n%matplotlib inline\nimport control as control\nimport numpy\nimport sympy as sym\nfrom IPython.display import display, Markdown\nimport ipywidgets as widgets\nimport matplotlib.pyplot as plt\n\n\n#print a matrix latex-like\ndef bmatrix(a):\n     \"\"\"Returns a LaTeX bmatrix - by Damir Arbula (ICCT project)\n\n     :a: numpy array\n     :returns: LaTeX bmatrix as a string\n     \"\"\"\n     if len(a.shape) &gt; 2:\n         raise ValueError('bmatrix can at most display two dimensions')\n     lines = str(a).replace('[', '').replace(']', '').splitlines()\n     rv = [r'\\begin{bmatrix}']\n     rv += ['  ' + ' & '.join(l.split()) + r'\\\\' for l in lines]\n     rv +=  [r'\\end{bmatrix}']\n     return '\\n'.join(rv)\n\n\n# Display formatted matrix: \ndef vmatrix(a):\n    if len(a.shape) &gt; 2:\n         raise ValueError('bmatrix can at most display two dimensions')\n    lines = str(a).replace('[', '').replace(']', '').splitlines()\n    rv = [r'\\begin{vmatrix}']\n    rv += ['  ' + ' & '.join(l.split()) + r'\\\\' for l in lines]\n    rv +=  [r'\\end{vmatrix}']\n    return '\\n'.join(rv)\n\n\n#matrixWidget is a matrix looking widget built with a VBox of HBox(es) that returns a numPy array as value !\nclass matrixWidget(widgets.VBox):\n    def updateM(self,change):\n        for irow in range(0,self.n):\n            for icol in range(0,self.m):\n                self.M_[irow,icol] = self.children[irow].children[icol].value\n                #print(self.M_[irow,icol])\n        self.value = self.M_\n\n    def dummychangecallback(self,change):\n        pass\n    \n    \n    def __init__(self,n,m):\n        self.n = n\n        self.m = m\n        self.M_ = numpy.matrix(numpy.zeros((self.n,self.m)))\n        self.value = self.M_\n        widgets.VBox.__init__(self,\n                             children = [\n                                 widgets.HBox(children = \n                                              [widgets.FloatText(value=0.0, layout=widgets.Layout(width='90px')) for i in range(m)]\n                                             ) \n                                 for j in range(n)\n                             ])\n        \n        #fill in widgets and tell interact to call updateM each time a children changes value\n        for irow in range(0,self.n):\n            for icol in range(0,self.m):\n                self.children[irow].children[icol].value = self.M_[irow,icol]\n                self.children[irow].children[icol].observe(self.updateM, names='value')\n        #value = Unicode('example@example.com', help=\"The email value.\").tag(sync=True)\n        self.observe(self.updateM, names='value', type= 'All')\n        \n    def setM(self, newM):\n        #disable callbacks, change values, and reenable\n        self.unobserve(self.updateM, names='value', type= 'All')\n        for irow in range(0,self.n):\n            for icol in range(0,self.m):\n                self.children[irow].children[icol].unobserve(self.updateM, names='value')\n        self.M_ = newM\n        self.value = self.M_\n        for irow in range(0,self.n):\n            for icol in range(0,self.m):\n                self.children[irow].children[icol].value = self.M_[irow,icol]\n        for irow in range(0,self.n):\n            for icol in range(0,self.m):\n                self.children[irow].children[icol].observe(self.updateM, names='value')\n        self.observe(self.updateM, names='value', type= 'All')        \n\n                #self.children[irow].children[icol].observe(self.updateM, names='value')\n\n             \n#overlaod class for state space systems that DO NOT remove \"useless\" states (what \"professor\" of automatic control would do this?)\nclass sss(control.StateSpace):\n    def __init__(self,*args):\n        #call base class init constructor\n        control.StateSpace.__init__(self,*args)\n    #disable function below in base class\n    def _remove_useless_states(self):\n        pass\n\n\n# Preparatory cell\n\nA = numpy.matrix('-0.5 1 2; 0 -1 -2; 0 1 0.5')\nB = numpy.matrix('0; 0; 1')\nC = numpy.matrix('1 0 0')\nX0 = numpy.matrix('2; 2; 2')\nL = numpy.matrix([[11],[561/18],[8625/1800]])\nL = numpy.matrix([[5],[10],[10]])\n\nsol1 = numpy.linalg.eig(A)\n\nAw = matrixWidget(3,3)\nAw.setM(A)\nBw = matrixWidget(3,1)\nBw.setM(B)\nCw = matrixWidget(1,3)\nCw.setM(C)\nX0w = matrixWidget(3,1)\nX0w.setM(X0)\nLw = matrixWidget(3,1)\nLw.setM(L)\n\n\neig1o = matrixWidget(1,1)\neig2o = matrixWidget(2,1)\neig3o = matrixWidget(1,1)\neig1o.setM(numpy.matrix([-3])) \neig2o.setM(numpy.matrix([[-3],[0]]))\neig3o.setM(numpy.matrix([-3]))\n\n\n# Misc\n\n#create dummy widget \nDW = widgets.FloatText(layout=widgets.Layout(width='0px', height='0px'))\n\n#create button widget\nSTART = widgets.Button(\n    description='Test',\n    disabled=False,\n    button_style='', # 'success', 'info', 'warning', 'danger' or ''\n    tooltip='Test',\n    icon='check'\n)\n                       \ndef on_start_button_clicked(b):\n    #This is a workaround to have intreactive_output call the callback:\n    #   force the value of the dummy widget to change\n    if DW.value&gt; 0 :\n        DW.value = -1\n    else: \n        DW.value = 1\n    pass\nSTART.on_click(on_start_button_clicked)\n\n# Define type of method \nselm = widgets.Dropdown(\n    options= ['Set L', 'Set the eigenvalues'],\n    value= 'Set L',\n    description='',\n    disabled=False\n)\n\n# Define the number of complex eigenvalues for the observer\nselo = widgets.Dropdown(\n    options= ['0 complex eigenvalues', '2 complex eigenvalues'],\n    value= '0 complex eigenvalues',\n    description='Eigenvalues:',\n    disabled=False\n)\n\n#define type of ipout \nselu = widgets.Dropdown(\n    options=['impulse', 'step', 'sinusoid', 'square wave'],\n    value='impulse',\n    description='Type of input:',\n    disabled=False\n)\n# Define the values of the input\nu = widgets.FloatSlider(\n    value=1,\n    min=0,\n    max=20.0,\n    step=0.1,\n    description='input u:',\n    disabled=False,\n    continuous_update=False,\n    orientation='horizontal',\n    readout=True,\n    readout_format='.1f',\n)\nperiod = widgets.FloatSlider(\n    value=0.5,\n    min=0.0,\n    max=10,\n    step=0.05,\n    description='Period: ',\n    disabled=False,\n    continuous_update=False,\n    orientation='horizontal',\n    readout=True,\n    readout_format='.2f',\n)\n\n\n# Support functions\n\ndef eigen_choice(selo):\n    if selo == '0 complex eigenvalues':\n        eig1o.children[0].children[0].disabled = False\n        eig2o.children[1].children[0].disabled = True\n        eigo = 0\n    if selo == '2 complex eigenvalues':\n        eig1o.children[0].children[0].disabled = True\n        eig2o.children[1].children[0].disabled = False\n        eigo = 2\n    return eigo\n\ndef method_choice(selm):\n    if selm == 'Set L':\n        method = 1\n        selo.disabled = True\n    if selm == 'Set the eigenvalues':\n        method = 2\n        selo.disabled = False\n    return method\n\n\ndef main_callback(X0w, L, eig1o, eig2o, eig3o, u, period, selm, selo, selu, DW):\n    eigo = eigen_choice(selo)\n    method = method_choice(selm)\n    \n    if method == 1:\n        sol = numpy.linalg.eig(A-L*C)\n    if method == 2:\n        if eigo == 0:\n            L = control.acker(A.T, C.T, [eig1o[0,0], eig2o[0,0], eig3o[0,0]]).T\n            Lw.setM(L) \n        if eigo == 2:\n            L = control.acker(A.T, C.T, [eig1o[0,0], \n                                      numpy.complex(eig2o[0,0],eig2o[1,0]), \n                                      numpy.complex(eig2o[0,0],-eig2o[1,0])]).T\n            Lw.setM(L)\n        sol = numpy.linalg.eig(A-L*C)\n    print('The system\\'s eigenvalues are:',round(sol1[0][0],4),',',round(sol1[0][1],4),'and',round(sol1[0][2],4)) \n    print('The observer\\'s eigenvalues are:',round(sol[0][0],4),',',round(sol[0][1],4),'and',round(sol[0][2],4))\n    \n    sys = sss(A,B,C,0)\n    syso = sss(A-L*C, numpy.concatenate((B,L),axis=1), numpy.eye(3), numpy.zeros(6).reshape((3,2)))\n    T = numpy.linspace(0, 6, 1000)\n      \n    if selu == 'impulse': #selu\n        U = [0 for t in range(0,len(T))]\n        U[0] = u\n        T, yout, xout = control.forced_response(sys,T,U,X0w)\n        T, youto, xouto = control.forced_response(syso,T,numpy.matrix([U,yout]),[[0],[0],[0]])\n    if selu == 'step':\n        U = [u for t in range(0,len(T))]\n        T, yout, xout = control.forced_response(sys,T,U,X0w)\n        T, youto, xouto = control.forced_response(syso,T,numpy.matrix([U,yout]),[[0],[0],[0]])\n    if selu == 'sinusoid':\n        U = u*numpy.sin(2*numpy.pi/period*T)\n        T, yout, xout = control.forced_response(sys,T,U,X0w)\n        T, youto, xouto = control.forced_response(syso,T,numpy.matrix([U,yout]),[[0],[0],[0]])\n    if selu == 'square wave':\n        U = u*numpy.sign(numpy.sin(2*numpy.pi/period*T))\n        T, yout, xout = control.forced_response(sys,T,U,X0w)\n        T, youto, xouto = control.forced_response(syso,T,numpy.matrix([U,yout]),[[0],[0],[0]])\n    \n    fig = plt.figure(num='Simulation', figsize=(16,10))\n    \n    fig.add_subplot(321)\n    plt.ylabel('$X_1$ vs $X_{1est}$ (output of the system)')\n    plt.plot(T,xout[0])\n    plt.plot(T,xouto[0])\n    plt.xlabel('time [s]')\n    plt.legend(['Real','Estimated'])\n    plt.grid()\n    \n    fig.add_subplot(323)\n    plt.ylabel('$X_2$ vs $X_{2est}$')\n    plt.plot(T,xout[1])\n    plt.plot(T,xouto[1])\n    plt.xlabel('time [s]')\n    plt.legend(['Real','Estimated'])\n    plt.grid()\n    \n    fig.add_subplot(325)\n    plt.ylabel('$X_3$ vs $X_{3est}$')\n    plt.plot(T,xout[2])\n    plt.plot(T,xouto[2])\n    plt.xlabel('time [s]')\n    plt.legend(['Real','Estimated'])\n    plt.grid()\n    \n    fig.add_subplot(322)\n    plt.ylabel('$e_1$')\n    plt.plot(T,xouto[0]-xout[0])\n    plt.xlabel('time [s]')\n    plt.grid()\n    \n    fig.add_subplot(324)\n    plt.ylabel('$e_2$')\n    plt.plot(T,xouto[1]-xout[1])\n    plt.xlabel('time [s]')\n    plt.grid()\n    \n    fig.add_subplot(326)\n    plt.ylabel('$e_3$')\n    plt.plot(T,xouto[2]-xout[2])\n    plt.xlabel('time [s]')\n    plt.grid()\n    \nalltogether = widgets.VBox([widgets.HBox([selm, \n                                          selo, \n                                          selu]),\n                            widgets.Label(' ',border=3),\n                            widgets.HBox([widgets.Label('L:',border=3), Lw, \n                                          widgets.Label(' ',border=3),\n                                          widgets.Label(' ',border=3),\n                                          widgets.Label('Eigenvalues:',border=3), \n                                          eig1o, \n                                          eig2o, \n                                          eig3o,\n                                          widgets.Label(' ',border=3),\n                                          widgets.Label(' ',border=3),\n                                          widgets.Label('X0:',border=3), X0w]),\n                            widgets.Label(' ',border=3),\n                            widgets.HBox([u, \n                                          period, \n                                          START])])\nout = widgets.interactive_output(main_callback, {'X0w':X0w, 'L':Lw, 'eig1o':eig1o, 'eig2o':eig2o, 'eig3o':eig3o, \n                                                 'u':u, 'period':period, 'selm':selm, 'selo':selo, 'selu':selu, 'DW':DW})\nout.layout.height = '680px'\ndisplay(out, alltogether)"
  },
  {
    "objectID": "ICCT_en/examples/04/SS-29-Observer_for_unobservable_plants.html",
    "href": "ICCT_en/examples/04/SS-29-Observer_for_unobservable_plants.html",
    "title": "Observer for unobservable plants",
    "section": "",
    "text": "# Erasmus+ ICCT project (2018-1-SI01-KA203-047081)\n\n# Toggle cell visibility\n\nfrom IPython.display import HTML\ntag = HTML('''&lt;script&gt;\ncode_show=true; \nfunction code_toggle() {\n    if (code_show){\n        $('div.input').hide()\n    } else {\n        $('div.input').show()\n    }\n    code_show = !code_show\n} \n$( document ).ready(code_toggle);\n&lt;/script&gt;\nToggle cell visibility &lt;a href=\"javascript:code_toggle()\"&gt;here&lt;/a&gt;.''')\ndisplay(tag)\n\n# Hide the code completely\n\n# from IPython.display import HTML\n# tag = HTML('''&lt;style&gt;\n# div.input {\n#     display:none;\n# }\n# &lt;/style&gt;''')\n# display(tag)\n\n\nToggle cell visibility here.\n\n\nThis example shows what happens when an observer is designed for an unobservable linear system.\nRecalling the standard observability form:\n\\[\\begin{cases}\n\\underbrace{\\begin{bmatrix} \\dot{x}_o \\\\ \\dot{x}_{\\bar{o}} \\end{bmatrix}}_{\\dot{\\textbf{x}}} = \\begin{bmatrix} A_o & 0 \\\\ A_{o\\bar{o}} & A_{\\bar{o}} \\end{bmatrix} \\underbrace{\\begin{bmatrix} x_o \\\\ x_{\\bar{o}} \\end{bmatrix}}_{\\textbf{x}} + \\begin{bmatrix} B_o \\\\ B_{\\bar{o}} \\end{bmatrix} \\textbf{u} \\\\\n\\textbf{y} = \\begin{bmatrix} C_o & 0 \\end{bmatrix} \\textbf{x},\n\\end{cases}\\]\nbuild: - a system that is not observable and the unobservable dynamics is stable; - a system that is not observable and the unobservable dynamics is unstable; - a system that is not observable and the unobservable dynamics has dimension 1 and eigenvalue 0. What changes in this case?\n\n#Preparatory Cell \n\n%matplotlib inline\nimport control as control\nimport numpy\nimport sympy as sym\nfrom IPython.display import display, Markdown\nimport ipywidgets as widgets\nimport matplotlib.pyplot as plt\n\n\n#print a matrix latex-like\ndef bmatrix(a):\n     \"\"\"Returns a LaTeX bmatrix - by Damir Arbula (ICCT project)\n\n     :a: numpy array\n     :returns: LaTeX bmatrix as a string\n     \"\"\"\n     if len(a.shape) &gt; 2:\n         raise ValueError('bmatrix can at most display two dimensions')\n     lines = str(a).replace('[', '').replace(']', '').splitlines()\n     rv = [r'\\begin{bmatrix}']\n     rv += ['  ' + ' & '.join(l.split()) + r'\\\\' for l in lines]\n     rv +=  [r'\\end{bmatrix}']\n     return '\\n'.join(rv)\n\n\n# Display formatted matrix: \ndef vmatrix(a):\n    if len(a.shape) &gt; 2:\n         raise ValueError('bmatrix can at most display two dimensions')\n    lines = str(a).replace('[', '').replace(']', '').splitlines()\n    rv = [r'\\begin{vmatrix}']\n    rv += ['  ' + ' & '.join(l.split()) + r'\\\\' for l in lines]\n    rv +=  [r'\\end{vmatrix}']\n    return '\\n'.join(rv)\n\n\n#matrixWidget is a matrix looking widget built with a VBox of HBox(es) that returns a numPy array as value !\nclass matrixWidget(widgets.VBox):\n    def updateM(self,change):\n        for irow in range(0,self.n):\n            for icol in range(0,self.m):\n                self.M_[irow,icol] = self.children[irow].children[icol].value\n                #print(self.M_[irow,icol])\n        self.value = self.M_\n\n    def dummychangecallback(self,change):\n        pass\n    \n    \n    def __init__(self,n,m):\n        self.n = n\n        self.m = m\n        self.M_ = numpy.matrix(numpy.zeros((self.n,self.m)))\n        self.value = self.M_\n        widgets.VBox.__init__(self,\n                             children = [\n                                 widgets.HBox(children = \n                                              [widgets.FloatText(value=0.0, layout=widgets.Layout(width='90px')) for i in range(m)]\n                                             ) \n                                 for j in range(n)\n                             ])\n        \n        #fill in widgets and tell interact to call updateM each time a children changes value\n        for irow in range(0,self.n):\n            for icol in range(0,self.m):\n                self.children[irow].children[icol].value = self.M_[irow,icol]\n                self.children[irow].children[icol].observe(self.updateM, names='value')\n        #value = Unicode('example@example.com', help=\"The email value.\").tag(sync=True)\n        self.observe(self.updateM, names='value', type= 'All')\n        \n    def setM(self, newM):\n        #disable callbacks, change values, and reenable\n        self.unobserve(self.updateM, names='value', type= 'All')\n        for irow in range(0,self.n):\n            for icol in range(0,self.m):\n                self.children[irow].children[icol].unobserve(self.updateM, names='value')\n        self.M_ = newM\n        self.value = self.M_\n        for irow in range(0,self.n):\n            for icol in range(0,self.m):\n                self.children[irow].children[icol].value = self.M_[irow,icol]\n        for irow in range(0,self.n):\n            for icol in range(0,self.m):\n                self.children[irow].children[icol].observe(self.updateM, names='value')\n        self.observe(self.updateM, names='value', type= 'All')        \n\n                #self.children[irow].children[icol].observe(self.updateM, names='value')\n\n             \n#overlaod class for state space systems that DO NOT remove \"useless\" states (what \"professor\" of automatic control would do this?)\nclass sss(control.StateSpace):\n    def __init__(self,*args):\n        #call base class init constructor\n        control.StateSpace.__init__(self,*args)\n    #disable function below in base class\n    def _remove_useless_states(self):\n        pass\n\n\n# Preparatory cell\n\nA = numpy.matrix('-1 1 0; 0 -2 0; 0 1 2')\nB = numpy.matrix('0.7; 0.5; 1')\nC = numpy.matrix('1 0 0')\nX0 = numpy.matrix('2; 2; 2')\nF = numpy.matrix('-1 0 3; 0 -2 -1; 0 1 -2')\nG = numpy.matrix('0; 0; 1')\nL = numpy.matrix([[4],[-2/3],[2/3]])\nsol1 = numpy.linalg.eig(A)\n\nAdefault = [A,\n            numpy.matrix('-1 1 0; 0 -2 0; 0 1 -2')]\nBdefault = B\nCdefault = C\n\nAw = matrixWidget(3,3)\nAw.setM(A)\nBw = matrixWidget(3,1)\nBw.setM(B)\nCw = matrixWidget(1,3)\nCw.setM(C)\nX0w = matrixWidget(3,1)\nX0w.setM(X0)\nFw = matrixWidget(3,3)\nFw.setM(F)\nGw = matrixWidget(3,1)\nGw.setM(G)\nLw = matrixWidget(3,1)\nLw.setM(L)\n\n\neig1o = matrixWidget(1,1)\neig2o = matrixWidget(2,1)\neig3o = matrixWidget(1,1)\neig1o.setM(numpy.matrix([-3])) \neig2o.setM(numpy.matrix([[-3],[0]]))\neig3o.setM(numpy.matrix([-3]))\n\n\n# Misc\n\n#create dummy widget \nDW = widgets.FloatText(layout=widgets.Layout(width='0px', height='0px'))\n\n#create button widget\nSTART = widgets.Button(\n    description='Test',\n    disabled=False,\n    button_style='', # 'success', 'info', 'warning', 'danger' or ''\n    tooltip='Test',\n    icon='check'\n)\n                       \ndef on_start_button_clicked(b):\n    #This is a workaround to have intreactive_output call the callback:\n    #   force the value of the dummy widget to change\n    if DW.value&gt; 0 :\n        DW.value = -1\n    else: \n        DW.value = 1\n    pass\nSTART.on_click(on_start_button_clicked)\n\n# default systems\nsel_system = widgets.Dropdown(\n                              options=['Manual', 'Unstable unobservable state', 'Stable unobservable state'],\n                              value='Unstable unobservable state',\n                              description='',\n                              disabled=False\n)\n\n#define type of ipout \nselu = widgets.Dropdown(\n    options=['impulse', 'step', 'sinusoid', 'square wave'],\n    value='impulse',\n    description='Type of input:',\n    disabled=False\n)\n# Define the values of the input\nu = widgets.FloatSlider(\n    value=1,\n    min=0,\n    max=20.0,\n    step=0.1,\n    description='input u:',\n    disabled=False,\n    continuous_update=False,\n    orientation='horizontal',\n    readout=True,\n    readout_format='.1f',\n)\nperiod = widgets.FloatSlider(\n    value=0.5,\n    min=0.0,\n    max=10,\n    step=0.01,\n    description='Period: ',\n    disabled=False,\n    continuous_update=False,\n    orientation='horizontal',\n    readout=True,\n    readout_format='.2f',\n)\n\n\ndef main_callback(A, B, C, X0w, L, u, period, sel_system, selu, DW):\n    global Adefault, Bdefault, Cdefault, Aw, Bw, Cw, Lw\n    \n    if sel_system == 'Manual':\n        sol = numpy.linalg.eig(A-L*C)\n    elif sel_system == 'Unstable unobservable state':\n        A = Adefault[0]\n        B = Bdefault\n        C = Cdefault\n        Aw.setM(A) \n        Bw.setM(B)\n        Cw.setM(C)\n        L = numpy.matrix([[4],[2],[2]])\n        Lw.setM(L)\n        sol = numpy.linalg.eig(A-L*C)\n    elif sel_system == 'Stable unobservable state':\n        A = Adefault[1]\n        B = Bdefault\n        C = Cdefault\n        Aw.setM(A) \n        Bw.setM(B)\n        Cw.setM(C)\n        L = numpy.matrix([[4],[2],[10]])\n        Lw.setM(L)\n        sol = numpy.linalg.eig(A-L*C)\n        \n    sol1 = numpy.linalg.eig(A)\n    \n    print('The system\\'s eigenvalues are:',round(sol1[0][0],4),',',round(sol1[0][1],4),'and',round(sol1[0][2],4)) \n    print('The observer\\'s eigenvalues are:',round(sol[0][0],4),',',round(sol[0][1],4),'and',round(sol[0][2],4))\n\n    \n    sys = sss(A,B,C,0)\n    syso = sss(A-L*C, numpy.concatenate((B,L),axis=1), numpy.eye(3), numpy.zeros(6).reshape((3,2)))\n    if (numpy.real([sol[0][0],sol[0][1],sol[0][2]]) == [0, 0, 0]).all():\n        T = numpy.linspace(0,20,1000)\n    else:\n        if min(numpy.abs(numpy.real([sol[0][0],sol[0][1],sol[0][2]]))) != 0:\n            T = numpy.linspace(0,10*1/min(numpy.abs(numpy.real([sol[0][0],sol[0][1],sol[0][2]]))),1000)\n        else:\n            T = numpy.linspace(0,10*1/max(numpy.abs(numpy.real([sol[0][0],sol[0][1],sol[0][2]]))),1000)\n      \n    if selu == 'impulse': #selu\n        U = [0 for t in range(0,len(T))]\n        U[0] = u\n        T, yout, xout = control.forced_response(sys,T,U,X0w)\n        T, youto, xouto = control.forced_response(syso,T,numpy.matrix([U,yout]),[[0],[0],[0]])\n    if selu == 'step':\n        U = [u for t in range(0,len(T))]\n        T, yout, xout = control.forced_response(sys,T,U,X0w)\n        T, youto, xouto = control.forced_response(syso,T,numpy.matrix([U,yout]),[[0],[0],[0]])\n    if selu == 'sinusoid':\n        U = u*numpy.sin(2*numpy.pi/period*T)\n        T, yout, xout = control.forced_response(sys,T,U,X0w)\n        T, youto, xouto = control.forced_response(syso,T,numpy.matrix([U,yout]),[[0],[0],[0]])\n    if selu == 'square wave':\n        U = u*numpy.sign(numpy.sin(2*numpy.pi/period*T))\n        T, yout, xout = control.forced_response(sys,T,U,X0w)\n        T, youto, xouto = control.forced_response(syso,T,numpy.matrix([U,yout]),[[0],[0],[0]])\n    \n    fig = plt.figure(num='Simulation', figsize=(16,10))\n    \n    fig.add_subplot(321)\n    plt.ylabel('$X_1$ vs $X_{1est}$ (output of the system)')\n    plt.plot(T,xout[0])\n    plt.plot(T,xouto[0])\n    plt.xlabel('time [s]')\n    plt.legend(['Real','Estimated'])\n    plt.axvline(x=0,color='black',linewidth=0.8)\n    plt.axhline(y=0,color='black',linewidth=0.8)\n    plt.grid()\n    \n    fig.add_subplot(323)\n    plt.ylabel('$X_2$ vs $X_{2est}$')\n    plt.plot(T,xout[1])\n    plt.plot(T,xouto[1])\n    plt.xlabel('time [s]')\n    plt.legend(['Real','Estimated'])\n    plt.axvline(x=0,color='black',linewidth=0.8)\n    plt.axhline(y=0,color='black',linewidth=0.8)\n    plt.grid()\n    \n    fig.add_subplot(325)\n    plt.ylabel('$X_3$ vs $X_{3est}$')\n    plt.plot(T,xout[2])\n    plt.plot(T,xouto[2])\n    plt.xlabel('time [s]')\n    plt.legend(['Real','Estimated'])\n    plt.axvline(x=0,color='black',linewidth=0.8)\n    plt.axhline(y=0,color='black',linewidth=0.8)\n    plt.grid()\n    \n    fig.add_subplot(322)\n    plt.ylabel('$e_1$')\n    plt.plot(T,xouto[0]-xout[0])\n    plt.xlabel('time [s]')\n    plt.grid()\n    \n    fig.add_subplot(324)\n    plt.ylabel('$e_1$')\n    plt.plot(T,xouto[1]-xout[1])\n    plt.xlabel('time [s]')\n    plt.grid()\n    \n    fig.add_subplot(326)\n    plt.ylabel('$e_1$')\n    plt.plot(T,xouto[2]-xout[2])\n    plt.xlabel('time [s]')\n    plt.grid()\n    \n    fig1 = plt.figure(num='Output simulation', figsize=(16,5))\n    fig1.add_subplot(111)\n    plt.ylabel('$y$')\n    plt.plot(T,yout)\n    plt.xlabel('time [s]')\n    plt.grid()\n    \nalltogether = widgets.VBox([widgets.HBox([sel_system, widgets.Label(' ',border=3), selu]),\n                            widgets.Label(' ',border=3),\n                            widgets.HBox([widgets.Label('A:',border=3), Aw,\n                                          widgets.Label(' ',border=3),\n                                          widgets.Label(' ',border=3),\n                                          widgets.Label('B:',border=3), Bw,\n                                          widgets.Label(' ',border=3),\n                                          widgets.Label(' ',border=3),\n                                          widgets.Label('X0:',border=3), X0w,\n                                          widgets.Label(' ',border=3),\n                                          widgets.Label(' ',border=3),\n                                          widgets.Label('L:',border=3), Lw]),\n                            widgets.Label(' ',border=3),\n                            widgets.HBox([widgets.Label('C:',border=3), Cw]),\n                            widgets.Label(' ',border=3),\n                            widgets.HBox([u, \n                                          period, \n                                          START])])\nout = widgets.interactive_output(main_callback, {'A':Aw, 'B':Bw, 'C':Cw, 'X0w':X0w, 'L':Lw,\n                                                 'u':u, 'period':period, 'sel_system':sel_system, \n                                                 'selu':selu, 'DW':DW})\nout.layout.height = '980px'\ndisplay(out, alltogether)"
  },
  {
    "objectID": "ICCT_en/examples/04/SS-31-State_feedback_control_performance.html",
    "href": "ICCT_en/examples/04/SS-31-State_feedback_control_performance.html",
    "title": "State feedback control - Steady state specification",
    "section": "",
    "text": "# Erasmus+ ICCT project (2018-1-SI01-KA203-047081)\n\n# Toggle cell visibility\n\nfrom IPython.display import HTML\ntag = HTML('''&lt;script&gt;\ncode_show=true; \nfunction code_toggle() {\n    if (code_show){\n        $('div.input').hide()\n    } else {\n        $('div.input').show()\n    }\n    code_show = !code_show\n} \n$( document ).ready(code_toggle);\n&lt;/script&gt;\nToggle cell visibility &lt;a href=\"javascript:code_toggle()\"&gt;here&lt;/a&gt;.''')\ndisplay(tag)\n\n# Hide the code completely\n\n# from IPython.display import HTML\n# tag = HTML('''&lt;style&gt;\n# div.input {\n#     display:none;\n# }\n# &lt;/style&gt;''')\n# display(tag)\n\n\nToggle cell visibility here.\n\n\nGiven the system described by the equation:\n\\[\n\\dot{x}=\\underbrace{\\begin{bmatrix}-0.5&1\\\\0&-0.1\\end{bmatrix}}_{A}x+\\underbrace{\\begin{bmatrix}0\\\\1\\end{bmatrix}}_{B}u,\n\\]\ndesign a controller so that the first state of the system follows step references with zero error and settling time to 5% of the steady-state value of less than 1 second.\nIn order to satisfy the above requirements, the fictitious state \\(x_3\\) is added with dynamics \\(\\dot{x_3}=x_1-x_{1r}\\), where \\(x_{1r}\\) is the reference signal, so that if the augmented system is made asymptotically stable then the new state \\(x_3\\) goes to 0 guaranteeing that \\(x_1\\) goes to \\(x_{1r}\\).\nThe equations of the augmented system are:\n\\[\n\\dot{x}_a=\\underbrace{\\begin{bmatrix}-0.5&1&0\\\\0&-0.1&0\\\\1&0&0\\end{bmatrix}}_{A_a}x_a+\\underbrace{\\begin{bmatrix}0\\\\1\\\\0\\end{bmatrix}}_{B_a}u+\\underbrace{\\begin{bmatrix}0\\\\0\\\\-1\\end{bmatrix}}_{B_{\\text{ref}}}x_{1r}\n\\]\nand the augmented controllability matrix is:\n\\[\n\\begin{bmatrix}B_a&A_aB_a&A_a^2B_a\\end{bmatrix} = \\begin{bmatrix}0&1&-0.6\\\\1&-0.1&0.01\\\\0&0&1\\end{bmatrix}\n\\]\nsince \\(\\text{rank}=3\\) the augmented system is controllable.\nTo satisfy the second requirement, one possible solution is to make a pole placement so that the system result with a dominant pole in \\(-3\\) rad/s (note that \\(e^{\\lambda t}=e^{-3t}\\) in \\(t=1\\) s is \\(0.4978..&lt;0.05\\)). The chosen poles are \\(\\lambda_1=-3\\,\\text{and}\\,\\lambda_2=\\lambda_3=-30\\), with the related gain matrix \\(K_a=\\begin{bmatrix}1048.75&62.4&2700\\end{bmatrix}\\).\nThe closed-loop system becomes:\n\\[\n\\dot{x}_a=(A_a-B_aK_a)x_a+B_av+B_{\\text{ref}}x_{1r}=\\begin{bmatrix}-0.5&1&0\\\\-1048.75&-62.5&-2700\\\\1&0&0\\end{bmatrix}x_a+\\begin{bmatrix}0\\\\1\\\\0\\end{bmatrix}v+\\begin{bmatrix}0\\\\0\\\\-1\\end{bmatrix}x_{1r}\n\\]\n\nHow to use this notebook?\nTry different solutions by changing the gains in \\(K\\) or directly the closed-loop eigenvalues.\n\n%matplotlib inline\nimport control as control\nimport numpy\nimport sympy as sym\nfrom IPython.display import display, Markdown\nimport ipywidgets as widgets\nimport matplotlib.pyplot as plt\n\n\n#print a matrix latex-like\ndef bmatrix(a):\n     \"\"\"Returns a LaTeX bmatrix - by Damir Arbula (ICCT project)\n\n     :a: numpy array\n     :returns: LaTeX bmatrix as a string\n     \"\"\"\n     if len(a.shape) &gt; 2:\n         raise ValueError('bmatrix can at most display two dimensions')\n     lines = str(a).replace('[', '').replace(']', '').splitlines()\n     rv = [r'\\begin{bmatrix}']\n     rv += ['  ' + ' & '.join(l.split()) + r'\\\\' for l in lines]\n     rv +=  [r'\\end{bmatrix}']\n     return '\\n'.join(rv)\n\n\n# Display formatted matrix: \ndef vmatrix(a):\n    if len(a.shape) &gt; 2:\n         raise ValueError('bmatrix can at most display two dimensions')\n    lines = str(a).replace('[', '').replace(']', '').splitlines()\n    rv = [r'\\begin{vmatrix}']\n    rv += ['  ' + ' & '.join(l.split()) + r'\\\\' for l in lines]\n    rv +=  [r'\\end{vmatrix}']\n    return '\\n'.join(rv)\n\n\n#matrixWidget is a matrix looking widget built with a VBox of HBox(es) that returns a numPy array as value !\nclass matrixWidget(widgets.VBox):\n    def updateM(self,change):\n        for irow in range(0,self.n):\n            for icol in range(0,self.m):\n                self.M_[irow,icol] = self.children[irow].children[icol].value\n                #print(self.M_[irow,icol])\n        self.value = self.M_\n\n    def dummychangecallback(self,change):\n        pass\n    \n    \n    def __init__(self,n,m):\n        self.n = n\n        self.m = m\n        self.M_ = numpy.matrix(numpy.zeros((self.n,self.m)))\n        self.value = self.M_\n        widgets.VBox.__init__(self,\n                             children = [\n                                 widgets.HBox(children = \n                                              [widgets.FloatText(value=0.0, layout=widgets.Layout(width='90px')) for i in range(m)]\n                                             ) \n                                 for j in range(n)\n                             ])\n        \n        #fill in widgets and tell interact to call updateM each time a children changes value\n        for irow in range(0,self.n):\n            for icol in range(0,self.m):\n                self.children[irow].children[icol].value = self.M_[irow,icol]\n                self.children[irow].children[icol].observe(self.updateM, names='value')\n        #value = Unicode('example@example.com', help=\"The email value.\").tag(sync=True)\n        self.observe(self.updateM, names='value', type= 'All')\n        \n    def setM(self, newM):\n        #disable callbacks, change values, and reenable\n        self.unobserve(self.updateM, names='value', type= 'All')\n        for irow in range(0,self.n):\n            for icol in range(0,self.m):\n                self.children[irow].children[icol].unobserve(self.updateM, names='value')\n        self.M_ = newM\n        self.value = self.M_\n        for irow in range(0,self.n):\n            for icol in range(0,self.m):\n                self.children[irow].children[icol].value = self.M_[irow,icol]\n        for irow in range(0,self.n):\n            for icol in range(0,self.m):\n                self.children[irow].children[icol].observe(self.updateM, names='value')\n        self.observe(self.updateM, names='value', type= 'All')        \n\n                #self.children[irow].children[icol].observe(self.updateM, names='value')\n\n             \n#overlaod class for state space systems that DO NOT remove \"useless\" states (what \"professor\" of automatic control would do this?)\nclass sss(control.StateSpace):\n    def __init__(self,*args):\n        #call base class init constructor\n        control.StateSpace.__init__(self,*args)\n    #disable function below in base class\n    def _remove_useless_states(self):\n        pass\n\n\n# Preparatory cell\n\nA = numpy.matrix('-0.5 1 0; 0 -0.1 0; 1 0 0')\nB = numpy.matrix('0; 1; 0')\nBr = numpy.matrix('0; 0; -1')\nC = numpy.matrix('1 0 0')\nX0 = numpy.matrix('0; 0; 0')\nK = numpy.matrix([1048.75,62.4,2700])\n\nAw = matrixWidget(3,3)\nAw.setM(A)\nBw = matrixWidget(3,1)\nBw.setM(B)\nBrw = matrixWidget(3,1)\nBrw.setM(Br)\nCw = matrixWidget(1,3)\nCw.setM(C)\nX0w = matrixWidget(3,1)\nX0w.setM(X0)\nKw = matrixWidget(1,3)\nKw.setM(K)\n\n\neig1c = matrixWidget(1,1)\neig2c = matrixWidget(2,1)\neig3c = matrixWidget(1,1)\neig1c.setM(numpy.matrix([-3])) \neig2c.setM(numpy.matrix([[-30],[0]]))\neig3c.setM(numpy.matrix([-30]))\n\n\n# Misc\n\n#create dummy widget \nDW = widgets.FloatText(layout=widgets.Layout(width='0px', height='0px'))\n\n#create button widget\nSTART = widgets.Button(\n    description='Test',\n    disabled=False,\n    button_style='', # 'success', 'info', 'warning', 'danger' or ''\n    tooltip='Test',\n    icon='check'\n)\n                       \ndef on_start_button_clicked(b):\n    #This is a workaround to have intreactive_output call the callback:\n    #   force the value of the dummy widget to change\n    if DW.value&gt; 0 :\n        DW.value = -1\n    else: \n        DW.value = 1\n    pass\nSTART.on_click(on_start_button_clicked)\n\n# Define type of method \nselm = widgets.Dropdown(\n    options= ['Set K', 'Set the eigenvalues'],\n    value= 'Set K',\n    description='',\n    disabled=False\n)\n\n# Define the number of complex eigenvalues for the observer\nselc = widgets.Dropdown(\n    options= ['0 complex eigenvalues', '2 complex eigenvalues'],\n    value= '0 complex eigenvalues',\n    description='Eigenvalues:',\n    disabled=False\n)\n\n#define type of ipout \nselu = widgets.Dropdown(\n    options=['impulse', 'step', 'sinusoid', 'square wave'],\n    value='step',\n    description='Type of reference:',\n    disabled=False,\n    style = {'description_width': 'initial','button_width':'180px'}\n)\n# Define the values of the input\nu = widgets.FloatSlider(\n    value=1,\n    min=0,\n    max=20.0,\n    step=0.1,\n    description='Reference:',\n    disabled=False,\n    continuous_update=False,\n    orientation='horizontal',\n    readout=True,\n    readout_format='.1f',\n)\nperiod = widgets.FloatSlider(\n    value=0.5,\n    min=0.01,\n    max=4,\n    step=0.01,\n    description='Period: ',\n    disabled=False,\n    continuous_update=False,\n    orientation='horizontal',\n    readout=True,\n    readout_format='.2f',\n)\n\n\n# Support functions\n\ndef eigen_choice(selc):\n    if selc == '0 complex eigenvalues':\n        eig1c.children[0].children[0].disabled = False\n        eig2c.children[1].children[0].disabled = True\n        eigc = 0\n    if selc == '2 complex eigenvalues':\n        eig1c.children[0].children[0].disabled = True\n        eig2c.children[1].children[0].disabled = False\n        eigc = 2\n    return eigc\n\ndef method_choice(selm):\n    if selm == 'Set K':\n        method = 1\n        selc.disabled = True\n    if selm == 'Set the eigenvalues':\n        method = 2\n        selc.disabled = False\n    return method\n\n\ndef main_callback(Aw, Bw, Brw, X0w, K, eig1c, eig2c, eig3c, u, period, selm, selc, selu, DW):\n    A, B, Br = Aw, Bw, Brw \n    sols = numpy.linalg.eig(A)\n    eigc = eigen_choice(selc)\n    method = method_choice(selm)\n    \n    if method == 1:\n        sol = numpy.linalg.eig(A-B*K)\n    if method == 2:\n        if eigc == 0:\n            K = control.acker(A, B, [eig1c[0,0], eig2c[0,0], eig3c[0,0]])\n            Kw.setM(K) \n        if eigc == 2:\n            K = control.acker(A, B, [eig1c[0,0], \n                                      numpy.complex(eig2c[0,0],eig2c[1,0]), \n                                      numpy.complex(eig2c[0,0],-eig2c[1,0])])\n            Kw.setM(K)\n        sol = numpy.linalg.eig(A-B*K)\n    print('The system\\'s eigenvalues are:',round(sols[0][0],4),',',round(sols[0][1],4),'and',round(sols[0][2],4))\n    print('The controlled system\\'s eigenvalues are:',round(sol[0][0],4),',',round(sol[0][1],4),'and',round(sol[0][2],4))\n    \n    sys = sss(A-B*K,Br,C,0)\n    T = numpy.linspace(0, 6, 1000)\n      \n    if selu == 'impulse': #selu\n        U = [0 for t in range(0,len(T))]\n        U[0] = u\n        T, yout, xout = control.forced_response(sys,T,U,X0w)\n    if selu == 'step':\n        U = [u for t in range(0,len(T))]\n        T, yout, xout = control.forced_response(sys,T,U,X0w)\n    if selu == 'sinusoid':\n        U = u*numpy.sin(2*numpy.pi/period*T)\n        T, yout, xout = control.forced_response(sys,T,U,X0w)\n    if selu == 'square wave':\n        U = u*numpy.sign(numpy.sin(2*numpy.pi/period*T))\n        T, yout, xout = control.forced_response(sys,T,U,X0w)\n    \n    fig = plt.figure(num='Simulation', figsize=(16,10))\n    \n    fig.add_subplot(211)\n    plt.title('First state step response')\n    plt.ylabel('$X_1$ vs ref')\n    plt.plot(T,xout[0],T,U,'r--')\n    plt.xlabel('$t$ [s]')\n    plt.legend(['$x_1$','Reference'])\n    plt.axvline(x=0,color='black',linewidth=0.8)\n    plt.axhline(y=0,color='black',linewidth=0.8)\n    plt.grid()\n    \n    fig.add_subplot(212)\n    poles, zeros = control.pzmap(sys,Plot=False)\n    plt.title('Poles and zeros')\n    plt.ylabel('Im')\n    plt.plot(numpy.real(poles),numpy.imag(poles),'rx',numpy.real(zeros),numpy.imag(zeros),'bo')\n    plt.xlabel('Re')\n    plt.axvline(x=0,color='black',linewidth=0.8)\n    plt.axhline(y=0,color='black',linewidth=0.8)\n    plt.grid()\n    \nalltogether = widgets.VBox([widgets.HBox([selm, \n                                          selc, \n                                          selu]),\n                            widgets.Label(' ',border=3),\n                            widgets.HBox([widgets.Label('K:',border=3), Kw, \n                                          widgets.Label(' ',border=3),\n                                          widgets.Label(' ',border=3),\n                                          widgets.Label('Eigenvalues:',border=3), \n                                          eig1c, \n                                          eig2c, \n                                          eig3c,\n                                          widgets.Label(' ',border=3),\n                                          widgets.Label(' ',border=3),\n                                          widgets.Label('X0:',border=3), X0w]),\n                            widgets.Label(' ',border=3),\n                            widgets.HBox([u, \n                                          period, \n                                          START]),\n                            widgets.Label(' ',border=3),\n                            widgets.HBox([widgets.Label('Dynamics matrix Aa:',border=3),\n                                          Aw,\n                                          widgets.Label('Input matrix Ba:',border=3),\n                                          Bw,\n                                          widgets.Label('Reference matrix Br:',border=3),\n                                          Brw])])\nout = widgets.interactive_output(main_callback, {'Aw':Aw, 'Bw':Bw, 'Brw':Brw, 'X0w':X0w, 'K':Kw, 'eig1c':eig1c, 'eig2c':eig2c, 'eig3c':eig3c, \n                                                 'u':u, 'period':period, 'selm':selm, 'selc':selc, 'selu':selu, 'DW':DW})\nout.layout.height = '640px'\ndisplay(out, alltogether)"
  },
  {
    "objectID": "ICCT_en/examples/04/SS-33_State_feedback_control_for_the_mass-spring-damper_system.html",
    "href": "ICCT_en/examples/04/SS-33_State_feedback_control_for_the_mass-spring-damper_system.html",
    "title": "State feedback control for the mass-spring-damper system",
    "section": "",
    "text": "# Erasmus+ ICCT project (2018-1-SI01-KA203-047081)\n\n# Toggle cell visibility\n\nfrom IPython.display import HTML\ntag = HTML('''&lt;script&gt;\ncode_show=true; \nfunction code_toggle() {\n    if (code_show){\n        $('div.input').hide()\n    } else {\n        $('div.input').show()\n    }\n    code_show = !code_show\n} \n$( document ).ready(code_toggle);\n&lt;/script&gt;\nToggle cell visibility &lt;a href=\"javascript:code_toggle()\"&gt;here&lt;/a&gt;.''')\ndisplay(tag)\n\n# Hide the code completely\n\n# from IPython.display import HTML\n# tag = HTML('''&lt;style&gt;\n# div.input {\n#     display:none;\n# }\n# &lt;/style&gt;''')\n# display(tag)\n\n\nToggle cell visibility here.\n\n\nGiven the mass-spring-damper system, we want to control it in order to have a step response with zero error at steady state and a settling time for 5% tolerance band of less than 6 s.\nThe system’s equations written in state space form are:\n\\[\n\\begin{bmatrix}\n\\dot{x_1} \\\\\n\\dot{x_2}\n\\end{bmatrix}=\\underbrace{\\begin{bmatrix}\n0 && 1 \\\\\n-\\frac{k}{m} && -\\frac{c}{m}\n\\end{bmatrix}}_{A}\\begin{bmatrix}\nx_1 \\\\\nx_2\n\\end{bmatrix}+\\underbrace{\\begin{bmatrix}\n0 \\\\\n\\frac{1}{m}\n\\end{bmatrix}}_{B}u,\n\\]\nwith \\(m=5\\) kg, \\(k=2\\) N/m, \\(c=1\\) Ns/m, \\(x_1\\) representing the position and \\(x_2\\) the velocity. By defining the gain matrix of the state feedback as \\(K=\\begin{bmatrix}k_1&k_2\\end{bmatrix}^T\\) and substituting it in \\(A-BK\\) we obtain:\n\\[\nA-BK = \\begin{bmatrix}0&1\\\\-\\frac{2}{5}-\\frac{k_1}{5}&-\\frac{1}{5}-\\frac{k_2}{5}\\end{bmatrix}\\,.\n\\]\nNote that the system is in canonical controllability form, the characteristic polynomial is\n\\[\n\\lambda^2+(\\frac{k_2}{5}+\\frac{1}{5})\\lambda+(\\frac{k_1}{5}+\\frac{2}{5})\n\\]\nand imposing the roots to be equal to \\(\\lambda_{1,2}=-1\\) rad/s \\(\\left((\\lambda+1)^2=\\lambda^2+2\\lambda+1\\right)\\) we find the values \\(k_1 = 3\\) and \\(k_2=9\\).\nIn order to reach zero steady-state error, it is possible to simply adjust the closed-loop gain: we multiply the reference input \\(u_{ref}\\) by the inverse of the closed-loop gain to have the closed-loop transfer function staying at \\(0\\) dB at low frequencies.\nThe static gain is calculated as \\(G(0)=C(-A+BK)^{-1}B\\) with \\(C=\\begin{bmatrix}1&0\\end{bmatrix}\\).\nThe final controlled system, that is still SISO from the input \\(u_{ref}\\) to the position \\(x_1\\), is:\n\\[\n\\begin{cases}\n\\begin{bmatrix}\n\\dot{x_1} \\\\\n\\dot{x_2}\n\\end{bmatrix}=\\underbrace{\\begin{bmatrix}\n0 && 1 \\\\\n-1 && -2\n\\end{bmatrix}}_{A-BK}\\begin{bmatrix}\nx_1 \\\\\nx_2\n\\end{bmatrix}+\\underbrace{\\begin{bmatrix}\n0 \\\\\n\\frac{1}{5}\n\\end{bmatrix}}_{B}\\frac{1}{0.2}u_{\\text{ref}} \\\\\ny = \\begin{bmatrix}1&0\\end{bmatrix}\\begin{bmatrix}\nx_1 \\\\\nx_2\n\\end{bmatrix}\n\\end{cases}\n\\]\n\nHow to use this notebook?\nTry to change the eigenvalues and adjust the reference signal gain to achieve zero steady-state error.\n\n%matplotlib inline\nimport control as control\nimport numpy\nimport sympy as sym\nfrom IPython.display import display, Markdown\nimport ipywidgets as widgets\nimport matplotlib.pyplot as plt\n\n\n#print a matrix latex-like\ndef bmatrix(a):\n     \"\"\"Returns a LaTeX bmatrix - by Damir Arbula (ICCT project)\n\n     :a: numpy array\n     :returns: LaTeX bmatrix as a string\n     \"\"\"\n     if len(a.shape) &gt; 2:\n         raise ValueError('bmatrix can at most display two dimensions')\n     lines = str(a).replace('[', '').replace(']', '').splitlines()\n     rv = [r'\\begin{bmatrix}']\n     rv += ['  ' + ' & '.join(l.split()) + r'\\\\' for l in lines]\n     rv +=  [r'\\end{bmatrix}']\n     return '\\n'.join(rv)\n\n\n# Display formatted matrix: \ndef vmatrix(a):\n    if len(a.shape) &gt; 2:\n         raise ValueError('bmatrix can at most display two dimensions')\n    lines = str(a).replace('[', '').replace(']', '').splitlines()\n    rv = [r'\\begin{vmatrix}']\n    rv += ['  ' + ' & '.join(l.split()) + r'\\\\' for l in lines]\n    rv +=  [r'\\end{vmatrix}']\n    return '\\n'.join(rv)\n\n\n#matrixWidget is a matrix looking widget built with a VBox of HBox(es) that returns a numPy array as value !\nclass matrixWidget(widgets.VBox):\n    def updateM(self,change):\n        for irow in range(0,self.n):\n            for icol in range(0,self.m):\n                self.M_[irow,icol] = self.children[irow].children[icol].value\n                #print(self.M_[irow,icol])\n        self.value = self.M_\n\n    def dummychangecallback(self,change):\n        pass\n    \n    \n    def __init__(self,n,m):\n        self.n = n\n        self.m = m\n        self.M_ = numpy.matrix(numpy.zeros((self.n,self.m)))\n        self.value = self.M_\n        widgets.VBox.__init__(self,\n                             children = [\n                                 widgets.HBox(children = \n                                              [widgets.FloatText(value=0.0, layout=widgets.Layout(width='90px')) for i in range(m)]\n                                             ) \n                                 for j in range(n)\n                             ])\n        \n        #fill in widgets and tell interact to call updateM each time a children changes value\n        for irow in range(0,self.n):\n            for icol in range(0,self.m):\n                self.children[irow].children[icol].value = self.M_[irow,icol]\n                self.children[irow].children[icol].observe(self.updateM, names='value')\n        #value = Unicode('example@example.com', help=\"The email value.\").tag(sync=True)\n        self.observe(self.updateM, names='value', type= 'All')\n        \n    def setM(self, newM):\n        #disable callbacks, change values, and reenable\n        self.unobserve(self.updateM, names='value', type= 'All')\n        for irow in range(0,self.n):\n            for icol in range(0,self.m):\n                self.children[irow].children[icol].unobserve(self.updateM, names='value')\n        self.M_ = newM\n        self.value = self.M_\n        for irow in range(0,self.n):\n            for icol in range(0,self.m):\n                self.children[irow].children[icol].value = self.M_[irow,icol]\n        for irow in range(0,self.n):\n            for icol in range(0,self.m):\n                self.children[irow].children[icol].observe(self.updateM, names='value')\n        self.observe(self.updateM, names='value', type= 'All')        \n\n                #self.children[irow].children[icol].observe(self.updateM, names='value')\n\n             \n#overlaod class for state space systems that DO NOT remove \"useless\" states (what \"professor\" of automatic control would do this?)\nclass sss(control.StateSpace):\n    def __init__(self,*args):\n        #call base class init constructor\n        control.StateSpace.__init__(self,*args)\n    #disable function below in base class\n    def _remove_useless_states(self):\n        pass\n\n\n# Preparatory cell\n\nA = numpy.matrix([[0,1],[-2/5,-1/5]])\nB = numpy.matrix('0; 1')\nC = numpy.matrix('1 0')\nX0 = numpy.matrix('0; 0')\nK = numpy.matrix([3,9])\n\nAw = matrixWidget(2,2)\nAw.setM(A)\nBw = matrixWidget(2,1)\nBw.setM(B)\nCw = matrixWidget(1,2)\nCw.setM(C)\nX0w = matrixWidget(2,1)\nX0w.setM(X0)\nKw = matrixWidget(1,2)\nKw.setM(K)\n\n\neig1c = matrixWidget(1,1)\neig2c = matrixWidget(2,1)\neig1c.setM(numpy.matrix([-1])) \neig2c.setM(numpy.matrix([[-1],[0]]))\n\n\n# Misc\n\n#create dummy widget \nDW = widgets.FloatText(layout=widgets.Layout(width='0px', height='0px'))\n\n#create button widget\nSTART = widgets.Button(\n    description='Test',\n    disabled=False,\n    button_style='', # 'success', 'info', 'warning', 'danger' or ''\n    tooltip='Test',\n    icon='check'\n)\n                       \ndef on_start_button_clicked(b):\n    #This is a workaround to have intreactive_output call the callback:\n    #   force the value of the dummy widget to change\n    if DW.value&gt; 0 :\n        DW.value = -1\n    else: \n        DW.value = 1\n    pass\nSTART.on_click(on_start_button_clicked)\n\n# Define type of method \nselm = widgets.Dropdown(\n    options= ['Set K', 'Set the eigenvalues'],\n    value= 'Set the eigenvalues',\n    description='',\n    disabled=False\n)\n\n# Define the number of complex eigenvalues for the observer\nselc = widgets.Dropdown(\n    options= ['0 complex eigenvalues', '2 complex eigenvalues'],\n    value= '0 complex eigenvalues',\n    description='Eigenvalues:',\n    disabled=False\n)\n\n#define type of ipout \nselu = widgets.Dropdown(\n    options=['impulse', 'step', 'sinusoid', 'square wave'],\n    value='step',\n    description='Type of reference:',\n    style = {'description_width': 'initial'},\n    disabled=False\n)\n# Define the values of the input\nu = widgets.FloatSlider(\n    value=1,\n    min=0,\n    max=20.0,\n    step=0.1,\n    description='Input reference:',\n    style = {'description_width': 'initial'},\n    disabled=False,\n    continuous_update=False,\n    orientation='horizontal',\n    readout=True,\n    readout_format='.1f',\n)\nperiod = widgets.FloatSlider(\n    value=1,\n    min=0.01,\n    max=4,\n    step=0.01,\n    description='Period: ',\n    disabled=False,\n    continuous_update=False,\n    orientation='horizontal',\n    readout=True,\n    readout_format='.2f',\n)\ngain = widgets.FloatText(\n    value=0.2,\n    description='Inverse reference gain:',\n    style = {'description_width': 'initial'},\n    disabled=False\n)\nm = widgets.FloatSlider(\n    value=5,\n    min=0.1,\n    max=10.0,\n    step=0.1,\n    description='m [kg]:',\n    disabled=False,\n    continuous_update=False,\n    orientation='horizontal',\n    readout=True,\n    readout_format='.1f',\n)\nk = widgets.FloatSlider(\n    value=2,\n    min=0,\n    max=10.0,\n    step=0.1,\n    description='k [N/m]:',\n    disabled=False,\n    continuous_update=False,\n    orientation='horizontal',\n    readout=True,\n    readout_format='.1f',\n)\nc = widgets.FloatSlider(\n    value=1,\n    min=0,\n    max=10.0,\n    step=0.1,\n    description='c [Ns/m]:',\n    disabled=False,\n    continuous_update=False,\n    orientation='horizontal',\n    readout=True,\n    readout_format='.1f',\n)\n\n\n# Support functions\n\ndef eigen_choice(selc):\n    if selc == '0 complex eigenvalues':\n        eig1c.children[0].children[0].disabled = False\n        eig2c.children[1].children[0].disabled = True\n        eigc = 0\n    if selc == '2 complex eigenvalues':\n        eig1c.children[0].children[0].disabled = True\n        eig2c.children[1].children[0].disabled = False\n        eigc = 2\n    return eigc\n\ndef method_choice(selm):\n    if selm == 'Set K':\n        method = 1\n        selc.disabled = True\n    if selm == 'Set the eigenvalues':\n        method = 2\n        selc.disabled = False\n    return method\n\n\ndef main_callback(m, k, c, gain, X0w, K, eig1c, eig2c, u, period, selm, selc, selu, DW):\n    A, B = numpy.matrix([[0,1],[-k/m,-c/m]]), numpy.matrix([[0],[1/m]])\n    sols = numpy.linalg.eig(A)\n    eigc = eigen_choice(selc)\n    method = method_choice(selm)\n    \n    if method == 1:\n        sol = numpy.linalg.eig(A-B*K)\n    if method == 2:\n        if eigc == 0:\n            K = control.acker(A, B, [eig1c[0,0], eig2c[0,0]])\n            Kw.setM(K) \n        if eigc == 2:\n            K = control.acker(A, B, [numpy.complex(eig2c[0,0],eig2c[1,0]), \n                                     numpy.complex(eig2c[0,0],-eig2c[1,0])])\n            Kw.setM(K)\n        sol = numpy.linalg.eig(A-B*K)\n    print('The system\\'s eigenvalues are:',round(sols[0][0],4),'and',round(sols[0][1],4))\n    print('The controlled system\\'s eigenvalues are:',round(sol[0][0],4),'and',round(sol[0][1],4))\n    \n    sys1 = sss(A-B*K,B,C,0)\n    sg = control.evalfr(sys1,0)\n    print('The static gain of the controlled system is: %f' %sg)\n    if gain != 0:\n        sys = sss(A-B*K,B*1/gain,C,0)\n    else:\n        print('The inverse gain setted is 0 and it is changed to 1')\n        sys = sss(A-B*K,B,C,0)\n    T = numpy.linspace(0, 10, 1000)\n      \n    if selu == 'impulse': #selu\n        U = [0 for t in range(0,len(T))]\n        U[0] = u\n        T, yout, xout = control.forced_response(sys,T,U,X0w)\n    if selu == 'step':\n        U = [u for t in range(0,len(T))]\n        T, yout, xout = control.forced_response(sys,T,U,X0w)\n    if selu == 'sinusoid':\n        U = u*numpy.sin(2*numpy.pi/period*T)\n        T, yout, xout = control.forced_response(sys,T,U,X0w)\n    if selu == 'square wave':\n        U = u*numpy.sign(numpy.sin(2*numpy.pi/period*T))\n        T, yout, xout = control.forced_response(sys,T,U,X0w)\n    \n    fig = plt.figure(num='Bode plot', figsize=(16,10))\n    control.bode_plot(sys)\n    fig.suptitle('Bode plot', fontsize=16)\n    \n    plt.figure(num='Simulation', figsize=(16,4))\n    plt.title('Position input response')\n    plt.ylabel('position vs ref')\n    plt.plot(T,xout[0],T,U,'r--')\n    plt.xlabel('$t$ [s]')\n    plt.axvline(x=0,color='black',linewidth=0.8)\n    plt.axhline(y=0,color='black',linewidth=0.8)\n    plt.legend(['position','Reference'])\n    plt.grid()\n\n    \nalltogether = widgets.VBox([widgets.HBox([selm, \n                                          selc, \n                                          selu]),\n                            widgets.Label(' ',border=3),\n                            widgets.HBox([widgets.Label('K:',border=3), Kw, \n                                          widgets.Label(' ',border=3),\n                                          widgets.Label(' ',border=3),\n                                          widgets.Label('Eigenvalues:',border=3), \n                                          eig1c, \n                                          eig2c, \n                                          widgets.Label(' ',border=3),\n                                          widgets.Label(' ',border=3),\n                                          widgets.Label('X0:',border=3), X0w]),\n                            widgets.Label(' ',border=3),\n                            widgets.HBox([u, \n                                          period, \n                                          START]),\n                            widgets.Label(' ',border=3),\n                            widgets.HBox([m,\n                                          k,\n                                          c,\n                                          gain])])\nout = widgets.interactive_output(main_callback, {'m':m, 'k':k, 'c':c, 'gain':gain, 'X0w':X0w, 'K':Kw, 'eig1c':eig1c, 'eig2c':eig2c, \n                                                 'u':u, 'period':period, 'selm':selm, 'selc':selc, 'selu':selu, 'DW':DW})\nout.layout.height = '1050px'\ndisplay(out, alltogether)"
  },
  {
    "objectID": "ICCT_en/examples/04/SS-35-Regulator_for_the_mass-spring-damper_system.html",
    "href": "ICCT_en/examples/04/SS-35-Regulator_for_the_mass-spring-damper_system.html",
    "title": "Regulator design for the mass-spring-damper system",
    "section": "",
    "text": "# Erasmus+ ICCT project (2018-1-SI01-KA203-047081)\n\n# Toggle cell visibility\n\nfrom IPython.display import HTML\ntag = HTML('''&lt;script&gt;\ncode_show=true; \nfunction code_toggle() {\n    if (code_show){\n        $('div.input').hide()\n    } else {\n        $('div.input').show()\n    }\n    code_show = !code_show\n} \n$( document ).ready(code_toggle);\n&lt;/script&gt;\nToggle cell visibility &lt;a href=\"javascript:code_toggle()\"&gt;here&lt;/a&gt;.''')\ndisplay(tag)\n\n# Hide the code completely\n\n# from IPython.display import HTML\n# tag = HTML('''&lt;style&gt;\n# div.input {\n#     display:none;\n# }\n# &lt;/style&gt;''')\n# display(tag)\n\n\nToggle cell visibility here.\n\n\nThis example shows the design of a regulator for the mass-spring-damper system described by the following state space equations (\\(m=2,\\,k=4\\,\\text{and}\\,c=1\\)):\n\\[\\begin{cases}\n\\dot{\\textbf{x}}=\\underbrace{\\begin{bmatrix}0&1\\\\-\\frac{4}{2}&-\\frac{1}{2}\\end{bmatrix}}_{A}\\textbf{x}+\\underbrace{\\begin{bmatrix}0\\\\\\frac{1}{2}\\end{bmatrix}}_{B}\\textbf{u} \\\\ \\\\\n\\textbf{y}=\\underbrace{\\begin{bmatrix}1&0\\end{bmatrix}}_{C}\\textbf{x}\\,.\n\\end{cases}\\]\nThe aim of the control is to have a maximum overshoot of 10% and to guarantee zero error in response to a step signal reference.\nThe chosen poles are \\(\\lambda_{c\\,1,2}=-1\\pm1.5i\\) for the controlled system and \\(\\lambda_{o\\,1,2}=-15\\) rad/s for the observer, both obtained with respect to the gain matrices \\(K=\\begin{bmatrix}\\frac{5}{2}&3\\end{bmatrix}\\) and \\(L=\\begin{bmatrix}\\frac{59}{2}&\\frac{833}{4}\\end{bmatrix}^T\\). The resulting structure of the controller is:\n\nand, in order to achieve the zero error response, the reference is divided by the static gain of the closed-loop transfer function from ref to \\(y\\).\nThe system is simulated below.\n\nHow to use this notebook?\n\nModify the initial values of the observer’s states and the observer eigenvalues and observe the response.\nTry to achieve perfect tracking of a sinusoidal reference with a period of 3 s.\n\n\n%matplotlib inline\nimport control as control\nimport numpy\nimport sympy as sym\nfrom IPython.display import display, Markdown\nimport ipywidgets as widgets\nimport matplotlib.pyplot as plt\n\n\n#print a matrix latex-like\ndef bmatrix(a):\n     \"\"\"Returns a LaTeX bmatrix - by Damir Arbula (ICCT project)\n\n     :a: numpy array\n     :returns: LaTeX bmatrix as a string\n     \"\"\"\n     if len(a.shape) &gt; 2:\n         raise ValueError('bmatrix can at most display two dimensions')\n     lines = str(a).replace('[', '').replace(']', '').splitlines()\n     rv = [r'\\begin{bmatrix}']\n     rv += ['  ' + ' & '.join(l.split()) + r'\\\\' for l in lines]\n     rv +=  [r'\\end{bmatrix}']\n     return '\\n'.join(rv)\n\n\n# Display formatted matrix: \ndef vmatrix(a):\n    if len(a.shape) &gt; 2:\n         raise ValueError('bmatrix can at most display two dimensions')\n    lines = str(a).replace('[', '').replace(']', '').splitlines()\n    rv = [r'\\begin{vmatrix}']\n    rv += ['  ' + ' & '.join(l.split()) + r'\\\\' for l in lines]\n    rv +=  [r'\\end{vmatrix}']\n    return '\\n'.join(rv)\n\n\n#matrixWidget is a matrix looking widget built with a VBox of HBox(es) that returns a numPy array as value !\nclass matrixWidget(widgets.VBox):\n    def updateM(self,change):\n        for irow in range(0,self.n):\n            for icol in range(0,self.m):\n                self.M_[irow,icol] = self.children[irow].children[icol].value\n                #print(self.M_[irow,icol])\n        self.value = self.M_\n\n    def dummychangecallback(self,change):\n        pass\n    \n    \n    def __init__(self,n,m):\n        self.n = n\n        self.m = m\n        self.M_ = numpy.matrix(numpy.zeros((self.n,self.m)))\n        self.value = self.M_\n        widgets.VBox.__init__(self,\n                             children = [\n                                 widgets.HBox(children = \n                                              [widgets.FloatText(value=0.0, layout=widgets.Layout(width='90px')) for i in range(m)]\n                                             ) \n                                 for j in range(n)\n                             ])\n        \n        #fill in widgets and tell interact to call updateM each time a children changes value\n        for irow in range(0,self.n):\n            for icol in range(0,self.m):\n                self.children[irow].children[icol].value = self.M_[irow,icol]\n                self.children[irow].children[icol].observe(self.updateM, names='value')\n        #value = Unicode('example@example.com', help=\"The email value.\").tag(sync=True)\n        self.observe(self.updateM, names='value', type= 'All')\n        \n    def setM(self, newM):\n        #disable callbacks, change values, and reenable\n        self.unobserve(self.updateM, names='value', type= 'All')\n        for irow in range(0,self.n):\n            for icol in range(0,self.m):\n                self.children[irow].children[icol].unobserve(self.updateM, names='value')\n        self.M_ = newM\n        self.value = self.M_\n        for irow in range(0,self.n):\n            for icol in range(0,self.m):\n                self.children[irow].children[icol].value = self.M_[irow,icol]\n        for irow in range(0,self.n):\n            for icol in range(0,self.m):\n                self.children[irow].children[icol].observe(self.updateM, names='value')\n        self.observe(self.updateM, names='value', type= 'All')        \n\n                #self.children[irow].children[icol].observe(self.updateM, names='value')\n\n             \n#overlaod class for state space systems that DO NOT remove \"useless\" states (what \"professor\" of automatic control would do this?)\nclass sss(control.StateSpace):\n    def __init__(self,*args):\n        #call base class init constructor\n        control.StateSpace.__init__(self,*args)\n    #disable function below in base class\n    def _remove_useless_states(self):\n        pass\n\n\n# Preparatory cell\n\nA = numpy.matrix('0 1;-2 -0.5')\nB = numpy.matrix('0; 0.5')\nC = numpy.matrix('1 0')\nX0 = numpy.matrix('0.5; 0.5')\nK = numpy.matrix([5/2,3.])\nL = numpy.matrix([[59/2],[833/4]])\n\nAw = matrixWidget(2,2)\nAw.setM(A)\nBw = matrixWidget(2,1)\nBw.setM(B)\nCw = matrixWidget(1,2)\nCw.setM(C)\nX0w = matrixWidget(2,1)\nX0w.setM(X0)\nKw = matrixWidget(1,2)\nKw.setM(K)\nLw = matrixWidget(2,1)\nLw.setM(L)\n\n\neig1c = matrixWidget(1,1)\neig2c = matrixWidget(2,1)\neig1c.setM(numpy.matrix([-1.])) \neig2c.setM(numpy.matrix([[-1.],[-1.5]]))\n\neig1o = matrixWidget(1,1)\neig2o = matrixWidget(2,1)\neig1o.setM(numpy.matrix([-15.])) \neig2o.setM(numpy.matrix([[-15.],[0.]]))\n\n\n# Misc\n\n#create dummy widget \nDW = widgets.FloatText(layout=widgets.Layout(width='0px', height='0px'))\n\n#create button widget\nSTART = widgets.Button(\n    description='Test',\n    disabled=False,\n    button_style='', # 'success', 'info', 'warning', 'danger' or ''\n    tooltip='Test',\n    icon='check'\n)\n                       \ndef on_start_button_clicked(b):\n    #This is a workaround to have intreactive_output call the callback:\n    #   force the value of the dummy widget to change\n    if DW.value&gt; 0 :\n        DW.value = -1\n    else: \n        DW.value = 1\n    pass\nSTART.on_click(on_start_button_clicked)\n\n# Define type of method \nselm = widgets.Dropdown(\n    options= ['Set K and L', 'Set the eigenvalues'],\n    value= 'Set the eigenvalues',\n    description='',\n    disabled=False\n)\n\n# Define the number of complex eigenvalues\nsele = widgets.Dropdown(\n    options= ['0 complex eigenvalues', '2 complex eigenvalues'],\n    value= '2 complex eigenvalues',\n    description='Complex eigenvalues:',\n    style = {'description_width': 'initial'},\n    disabled=False\n)\n\n#define type of ipout \nselu = widgets.Dropdown(\n    options=['impulse', 'step', 'sinusoid', 'square wave'],\n    value='step',\n    description='Type of reference:',\n    style = {'description_width': 'initial'},\n    disabled=False\n)\n# Define the values of the input\nu = widgets.FloatSlider(\n    value=1,\n    min=0,\n    max=20.0,\n    step=0.1,\n    description='Reference:',\n    disabled=False,\n    continuous_update=False,\n    orientation='horizontal',\n    readout=True,\n    readout_format='.1f',\n)\nperiod = widgets.FloatSlider(\n    value=0.5,\n    min=0.01,\n    max=4,\n    step=0.01,\n    description='Period: ',\n    disabled=False,\n    continuous_update=False,\n    orientation='horizontal',\n    readout=True,\n    readout_format='.2f',\n)\n\ngain_w = widgets.FloatText(\n    value=1.,\n    description='',\n    disabled=True\n)\n\ngain_id_w = widgets.FloatText(\n    value=1.,\n    description='',\n    disabled=True\n)\n\nm = widgets.FloatSlider(\n    value=2,\n    min=0.1,\n    max=10.0,\n    step=0.1,\n    description='m [kg]:',\n    disabled=False,\n    continuous_update=False,\n    orientation='horizontal',\n    readout=True,\n    readout_format='.1f',\n)\nk = widgets.FloatSlider(\n    value=4,\n    min=0,\n    max=10.0,\n    step=0.1,\n    description='k [N/m]:',\n    disabled=False,\n    continuous_update=False,\n    orientation='horizontal',\n    readout=True,\n    readout_format='.1f',\n)\nc = widgets.FloatSlider(\n    value=1,\n    min=0,\n    max=10.0,\n    step=0.1,\n    description='c [Ns/m]:',\n    disabled=False,\n    continuous_update=False,\n    orientation='horizontal',\n    readout=True,\n    readout_format='.1f',\n)\n\ntime = widgets.FloatText(\n    value=5.,\n    description='Time',\n    disabled=False\n)\n\n\n# Support functions\n\ndef eigen_choice(sele):\n    if sele == '0 complex eigenvalues':\n        eig1c.children[0].children[0].disabled = False\n        eig2c.children[1].children[0].disabled = True\n        eig1o.children[0].children[0].disabled = False\n        eig2o.children[1].children[0].disabled = True\n        eig = 0\n    if sele == '2 complex eigenvalues':\n        eig1c.children[0].children[0].disabled = True\n        eig2c.children[1].children[0].disabled = False\n        eig1o.children[0].children[0].disabled = True\n        eig2o.children[1].children[0].disabled = False\n        eig = 2\n    return eig\n\ndef method_choice(selm):\n    if selm == 'Set K and L':\n        method = 1\n        sele.disabled = True\n    if selm == 'Set the eigenvalues':\n        method = 2\n        sele.disabled = False\n    return method\n\n\nsols = numpy.linalg.eig(A)\n\ndef main_callback(m, k, c, X0w, K, L, eig1c, eig2c, eig1o, eig2o, u, period, selm, sele, selu, time, DW):\n    A = numpy.matrix([[0,1],[-k/m,-c/m]])\n    B = numpy.matrix([[0],[1/m]])\n    eige = eigen_choice(sele)\n    method = method_choice(selm)\n    \n    if method == 1:\n        solc = numpy.linalg.eig(A-B*K)\n        solo = numpy.linalg.eig(A-L*C)\n    if method == 2:\n        if eige == 0:\n            K = control.acker(A, B, [eig1c[0,0], eig2c[0,0]])\n            Kw.setM(K)\n            L = control.acker(A.T, C.T, [eig1o[0,0], eig2o[0,0]]).T\n            Lw.setM(L)\n        if eige == 2:\n            K = control.acker(A, B, [numpy.complex(eig2c[0,0],eig2c[1,0]), \n                                     numpy.complex(eig2c[0,0],-eig2c[1,0])])\n            Kw.setM(K)\n            L = control.acker(A.T, C.T, [numpy.complex(eig2o[0,0],eig2o[1,0]), \n                                         numpy.complex(eig2o[0,0],-eig2o[1,0])]).T\n            Lw.setM(L)\n            \n    \n    Gs = sss(A,B,numpy.vstack((C,[0,0])),[[0],[1]])\n    Os = sss(A-L*C,numpy.hstack((L,B)),-K,[0,0])\n    Gas = control.append(Gs,Os)\n    sys = control.connect(Gas,[[2,1],[3,2],[1,3]],[1],[1])\n    \n    Gs_id = sss(A,B,sym.eye(2),sym.zeros(2,1))\n    Fs_id = control.series(K,Gs_id)\n    A1 = numpy.matrix(Fs_id.A-Fs_id.B*Fs_id.C)\n    B1 = numpy.matrix(Fs_id.B*sym.Matrix([[1],[0]]))\n    C1 = numpy.matrix(sym.Matrix([1,0]).T*Fs_id.C)\n    sys_id = sss(A1,B1,C1,0)\n\n    \n    dcgain = control.dcgain(sys)\n    t = numpy.linspace(0, 1000, 2)\n    t, y = control.step_response(sys_id,t)\n    dcgain_id = y[-1]\n    gain_w.value = dcgain\n    gain_id_w.value = dcgain_id\n    if dcgain != 0 and dcgain_id != 0:\n        u1 = u/gain_w.value\n        u2 = u/gain_id_w.value\n    else:\n        print('The inverse gain setted is 0 and it is changed to 1')\n        u1 = u/1\n        u2 = u/1\n    \n    solc = numpy.linalg.eig(sys.A)\n    solo = numpy.linalg.eig(A-L*C-B*K)\n    print('The system\\'s eigenvalues are:', round(sols[0][0],2),'and', round(sols[0][1],2))\n    print('The controlled closed-loop system\\'s eigenvalues are:', \n          round(solc[0][0],2),',', \n          round(solc[0][1],2),',', \n          round(solc[0][2],2),'and',\n          round(solc[0][3],2))\n    print('')\n    print('The static gain of the closed-loop system (from the reference to the output) is: %.5f' %dcgain)\n    print('The static gain of the closed-loop ideal system (from the reference to the output) is: %.5f' %dcgain_id)\n    \n    X0w1 = numpy.matrix([[0],[0],[X0w[0,0]],[X0w[1,0]]])\n    if time != 0:\n        T = numpy.linspace(0, time, 10000)\n    else:\n        T = numpy.linspace(0, 1, 10000)\n\n    if selu == 'impulse': #selu\n        U = [0 for t in range(0,len(T))]\n        U[0] = u\n        U1 = [0 for t in range(0,len(T))]\n        U1[0] = u1\n        U2 = [0 for t in range(0,len(T))]\n        U2[0] = u2\n        T, yout, xout = control.forced_response(sys,T,U1,X0w1)\n        T, yout_id, xout_id = control.forced_response(sys_id,T,U2,[0, 0])\n    if selu == 'step':\n        U = [u for t in range(0,len(T))]\n        U1 = [u1 for t in range(0,len(T))]\n        U2 = [u2 for t in range(0,len(T))]\n        T, yout, xout = control.forced_response(sys,T,U1,X0w1)\n        T, yout_id, xout_id = control.forced_response(sys_id,T,U2,[0, 0])\n    if selu == 'sinusoid':\n        U = u*numpy.sin(2*numpy.pi/period*T)\n        U1 = u1*numpy.sin(2*numpy.pi/period*T)\n        U2 = u2*numpy.sin(2*numpy.pi/period*T)\n        T, yout, xout = control.forced_response(sys,T,U1,X0w1)\n        T, yout_id, xout_id = control.forced_response(sys_id,T,U2,[0, 0])\n    if selu == 'square wave':\n        U = u*numpy.sign(numpy.sin(2*numpy.pi/period*T))\n        U1 = u1*numpy.sign(numpy.sin(2*numpy.pi/period*T))\n        U2 = u2*numpy.sign(numpy.sin(2*numpy.pi/period*T))\n        T, yout, xout = control.forced_response(sys,T,U1,X0w1)\n        T, yout_id, xout_id = control.forced_response(sys_id,T,U2,[0, 0])\n    \n    fig = plt.figure(num='Simulation', figsize=(14,12))\n    mag, phase, omega = control.bode_plot(sys,Plot = False)\n    mag = control.mag2db(mag)\n    phase = phase*180/numpy.pi\n    fig.add_subplot(221)\n    plt.title('Bode plot: magnitude')\n    plt.semilogx(omega,mag)\n    plt.xlabel('$\\omega$ [rad/s]')\n    plt.ylabel('Mag. [dB]')\n    plt.grid(True,which=\"both\")\n    \n    fig.add_subplot(223)\n    plt.title('Bode plot: phase')\n    plt.semilogx(omega,phase)\n    plt.xlabel('$\\omega$ [rad/s]')\n    plt.ylabel('Phase [deg]')\n    plt.grid(True,which=\"both\")\n    \n    fig.add_subplot(222)\n    plt.title('Output response')\n    plt.ylabel('Output ($x_1$)')\n    plt.plot(T,xout[2],T,xout[0],T,xout_id[0],'g',T,U,'r--')\n    plt.xlabel('$t$ [s]')\n    plt.legend(['$x_{1est}$','$y = x_{1real}$','$x_{1ideal}$','reference'])\n    plt.axvline(x=0,color='black',linewidth=0.8)\n    plt.axhline(y=0,color='black',linewidth=0.8)\n    plt.grid()\n    \n    fig.add_subplot(224)\n    plt.title('Second state response')\n    plt.ylabel('$x_2$')\n    plt.plot(T,xout[3],T,xout[1],T,xout_id[1],'g')\n    plt.xlabel('$t$ [s]')\n    plt.legend(['$x_{2est}$','$x_{2real}$','$x_{2ideal}$'])\n    plt.axvline(x=0,color='black',linewidth=0.8)\n    plt.axhline(y=0,color='black',linewidth=0.8)\n    plt.grid()\n\n   \nalltogether = widgets.VBox([widgets.HBox([selm, \n                                          sele,\n                                          selu]),\n                            widgets.Label(' ',border=3),\n                            widgets.HBox([widgets.Label('K:',border=3), Kw, \n                                          widgets.Label(' ',border=3),\n                                          widgets.Label(' ',border=3),\n                                          widgets.Label('Eigenvalues:',border=3), \n                                          eig1c, \n                                          eig2c,\n                                          widgets.Label(' ',border=3),\n                                          widgets.Label(' ',border=3),\n                                          widgets.Label('X0 est.:',border=3), X0w]),\n                            widgets.Label(' ',border=3),\n                            widgets.HBox([widgets.Label('L:',border=3), Lw, \n                                          widgets.Label(' ',border=3),\n                                          widgets.Label(' ',border=3),\n                                          widgets.Label('Eigenvalues:',border=3), \n                                          eig1o, \n                                          eig2o, \n                                          widgets.Label(' ',border=3),\n                                          widgets.VBox([widgets.Label('Inverse reference gain:',border=3),\n                                                        widgets.Label('Inverse ideal reference gain:',border=3)]),\n                                          widgets.VBox([gain_w,gain_id_w])]),\n                            widgets.Label(' ',border=3),\n                            widgets.HBox([m, \n                                          k, \n                                          c]),\n                            widgets.HBox([u, \n                                          period, \n                                          time]),\n                            START])\nout = widgets.interactive_output(main_callback, {'m':m, 'k':k, 'c':c, 'X0w':X0w, 'K':Kw, 'L':Lw,\n                                                 'eig1c':eig1c, 'eig2c':eig2c, 'eig1o':eig1o, 'eig2o':eig2o, \n                                                 'u':u, 'period':period, 'selm':selm, 'sele':sele, 'selu':selu, \n                                                 'time':time, 'DW':DW})\nout.layout.height = '900px'\ndisplay(out, alltogether)"
  },
  {
    "objectID": "ICCT_en/examples/04/SS-37-Quadrotor_longitudinal_velocity_control.html",
    "href": "ICCT_en/examples/04/SS-37-Quadrotor_longitudinal_velocity_control.html",
    "title": "Quadrotor longitudinal velocity control",
    "section": "",
    "text": "#remove cell visibility\nfrom IPython.display import HTML\ntag = HTML('''&lt;script&gt;\ncode_show=true; \nfunction code_toggle() {\n    if (code_show){\n        $('div.input').hide()\n    } else {\n        $('div.input').show()\n    }\n    code_show = !code_show\n} \n$( document ).ready(code_toggle);\n&lt;/script&gt;\nToggle cell visibility &lt;a href=\"javascript:code_toggle()\"&gt;here&lt;/a&gt;.''')\ndisplay(tag)\n\n\nToggle cell visibility here.\n\n\n\n%matplotlib inline\nimport control\nimport numpy\nimport sympy as sym\nfrom IPython.display import display, Markdown\nimport ipywidgets as widgets\nimport matplotlib.pyplot as plt\n\n\n#print a matrix latex-like\ndef bmatrix(a):\n     \"\"\"Returns a LaTeX bmatrix - by Damir Arbula (ICCT project)\n\n     :a: numpy array\n     :returns: LaTeX bmatrix as a string\n     \"\"\"\n     if len(a.shape) &gt; 2:\n         raise ValueError('bmatrix can at most display two dimensions')\n     lines = str(a).replace('[', '').replace(']', '').splitlines()\n     rv = [r'\\begin{bmatrix}']\n     rv += ['  ' + ' & '.join(l.split()) + r'\\\\' for l in lines]\n     rv +=  [r'\\end{bmatrix}']\n     return '\\n'.join(rv)\n\n\n# Display formatted matrix: \ndef vmatrix(a):\n    if len(a.shape) &gt; 2:\n         raise ValueError('bmatrix can at most display two dimensions')\n    lines = str(a).replace('[', '').replace(']', '').splitlines()\n    rv = [r'\\begin{vmatrix}']\n    rv += ['  ' + ' & '.join(l.split()) + r'\\\\' for l in lines]\n    rv +=  [r'\\end{vmatrix}']\n    return '\\n'.join(rv)\n\n\n#matrixWidget is a matrix looking widget built with a VBox of HBox(es) that returns a numPy array as value !\nclass matrixWidget(widgets.VBox):\n    def updateM(self,change):\n        for irow in range(0,self.n):\n            for icol in range(0,self.m):\n                self.M_[irow,icol] = self.children[irow].children[icol].value\n                #print(self.M_[irow,icol])\n        self.value = self.M_\n\n    def dummychangecallback(self,change):\n        pass\n    \n    \n    def __init__(self,n,m):\n        self.n = n\n        self.m = m\n        self.M_ = numpy.matrix(numpy.zeros((self.n,self.m)))\n        self.value = self.M_\n        widgets.VBox.__init__(self,\n                             children = [\n                                 widgets.HBox(children = \n                                              [widgets.FloatText(value=0.0, layout=widgets.Layout(width='90px')) for i in range(m)]\n                                             ) \n                                 for j in range(n)\n                             ])\n        \n        #fill in widgets and tell interact to call updateM each time a children changes value\n        for irow in range(0,self.n):\n            for icol in range(0,self.m):\n                self.children[irow].children[icol].value = self.M_[irow,icol]\n                self.children[irow].children[icol].observe(self.updateM, names='value')\n        #value = Unicode('example@example.com', help=\"The email value.\").tag(sync=True)\n        self.observe(self.updateM, names='value', type= 'All')\n        \n    def setM(self, newM):\n        #disable callbacks, change values, and reenable\n        self.unobserve(self.updateM, names='value', type= 'All')\n        for irow in range(0,self.n):\n            for icol in range(0,self.m):\n                self.children[irow].children[icol].unobserve(self.updateM, names='value')\n        self.M_ = newM\n        self.value = self.M_\n        for irow in range(0,self.n):\n            for icol in range(0,self.m):\n                self.children[irow].children[icol].value = self.M_[irow,icol]\n        for irow in range(0,self.n):\n            for icol in range(0,self.m):\n                self.children[irow].children[icol].observe(self.updateM, names='value')\n        self.observe(self.updateM, names='value', type= 'All')        \n\n                #self.children[irow].children[icol].observe(self.updateM, names='value')\n\n             \n#overlaod class for state space systems that DO NOT remove \"useless\" states (what \"professor\" of automatic control would do this?)\nclass sss(control.StateSpace):\n    def __init__(self,*args):\n        #call base class init constructor\n        control.StateSpace.__init__(self,*args)\n    #disable function below in base class\n    def _remove_useless_states(self):\n        pass\n\n\nThe quadrotor (or quadcopter) longitudinal velocity \\(v\\) may be controlled by tilting the vehicle by the pitch angle. The angle \\(\\theta\\) is controlled by applying the torque \\(T\\) using the propellers. The vehicle moment of inertia is \\(J= 1.3e-2\\). When the vehicle is tilted by the angle \\(\\theta\\), the propellers produce a forward force approximately equal to \\(F_v = F\\theta = mg\\theta\\) and the aerodynamic drag is \\(F_c=-cv=-0.9v\\), where \\(m=2000\\) g is vehicle mass, and \\(g = 9.81\\) m/s^2 gravity acceleration. Maximum torque equals \\(5000\\) mNm. Pitch angle \\(\\theta\\) must be limited to \\(\\pm30\\) degrees during all operations and maximum velocity to 2 m/s. The pitch angle is estimated by an appropriate sensor and velocity is measured with GPS.\nThe design procedure follows the following two-step procedure: 1. Write the system equations in state space form for the rotational dynamics (torque \\(T\\) to pitch angle \\(\\theta\\)) and the longitudinal dynamics (pitch angle to forward velocity \\(v\\)). 2. Design a regulator for \\(v\\) in order to satisfy the following specifications: - Settling time for 5% tolerance band of less than 2.5 seconds. - No Overshoot. - No steady-state error in response to a step velocity request.\n\nSystem equations\nThe system equations are equal to:\n\\[\\begin{cases}\n    m\\dot{v} = F_v + F_c = mg\\theta -cv \\\\\n    J\\ddot{\\theta} = T.\n\\end{cases}\\]\nBy defining the state vector as \\(x = \\begin{bmatrix} x_1 & x_2 & x_3 \\end{bmatrix}^T = \\begin{bmatrix} v & \\theta & \\dot{\\theta} \\end{bmatrix}^T\\) and the input \\(u=T\\), system equations in state space form become:\n\\[\\begin{cases}\n\\dot{x} = \\begin{bmatrix} -c/m & g & 0 \\\\ 0 & 0 & 1 \\\\ 0 & 0 & 0 \\end{bmatrix}x + \\begin{bmatrix} 0 \\\\ 0 \\\\ 1/J \\end{bmatrix}u \\\\\ny = \\begin{bmatrix} y_1 \\\\ y_2 \\end{bmatrix} = \\begin{bmatrix} 1 & 0 & 0 \\\\ 0 & 1 & 0 \\end{bmatrix}x\n\\end{cases}\\]\nThe dynamics from \\(u\\) to \\(\\theta\\) is a double integrator while that from \\(\\theta\\) to \\(v\\) is a first order dynamics with a pole in \\(-c/m\\). The system has two outputs: velocity and tilt angle.\nThe controllability matrix \\(\\mathcal{C}\\) is\n\nA = numpy.matrix('-0.45 9.81 0; 0 0 1; 0 0 0')\nB = numpy.matrix([[0],[0],[1/1.3E-02]])\nC = numpy.matrix('1 0 0; 0 1 0')\nD = numpy.matrix('0; 0')\n\nCM = control.ctrb(A,B)\ndisplay(Markdown(bmatrix(CM)))\n# print(numpy.linalg.matrix_rank(CM))\n\n\\[\\begin{bmatrix}\n  0. & 0. & 754.61538462\\\\\n  0. & 76.92307692 & 0.\\\\\n  76.92307692 & 0. & 0.\\\\\n\\end{bmatrix}\\]\n\n\nand has rank equal to 3 so the system is controllable. The observability matrix \\(\\mathcal{O}\\) is\n\nOM = control.obsv(A,C)\ndisplay(Markdown(bmatrix(OM)))\n# print(numpy.linalg.matrix_rank(OM))\n\n\\[\\begin{bmatrix}\n  1. & 0. & 0.\\\\\n  0. & 1. & 0.\\\\\n  -0.45 & 9.81 & 0.\\\\\n  0. & 0. & 1.\\\\\n  0.2025 & -4.4145 & 9.81\\\\\n  0. & 0. & 0.\\\\\n\\end{bmatrix}\\]\n\n\nand has rank equal to 3 so the system is observable.\n\n\nRegulator design\n\nObserver design\nSince we have the direct measurements of \\(x_1\\) and \\(x_2\\) we are only interested in estimating \\(x_3\\). If we look at the subsystem \\((x_2, \\, x_3)\\) we note that it is observable, so it is possible to design an observer by considering only this subsystem. The structure of our estimator is therefore:\n\\[\n\\begin{bmatrix} \\dot{\\hat{x}_2} \\\\ \\dot{\\hat{x}_3} \\end{bmatrix} = \\begin{bmatrix} 0 & 1 \\\\ 0 & 0 \\end{bmatrix}\\begin{bmatrix} \\hat{x}_2 \\\\ \\hat{x}_3 \\end{bmatrix} + \\begin{bmatrix} 0 \\\\ 1/J \\end{bmatrix}u + \\begin{bmatrix} l_1 \\\\ l_2 \\end{bmatrix}\\left( y - C\\begin{bmatrix} \\hat{x}_2 \\\\ \\hat{x}_3 \\end{bmatrix} \\right) = \\begin{bmatrix} -l_1 & 1 \\\\ -l_2 & 0 \\end{bmatrix}\\begin{bmatrix} \\hat{x}_2 \\\\ \\hat{x}_3 \\end{bmatrix} + \\begin{bmatrix} 0 \\\\ 1/J \\end{bmatrix}u + \\begin{bmatrix} l_1 \\\\ l_2 \\end{bmatrix}y\n\\]\napplying the Laplace transform and solving for \\(\\hat{x}_3(s)\\) we arrive at\n\\[\n\\hat{x}_3(s) = \\frac{l_2s}{s^2+l_1s+l_2}y_2(s) + \\frac{s+l_1}{s^2+l_1s+l_2}\\frac{u(s)}{J}.\n\\]\nWe now have a simple linear estimator for \\(x_3\\) that is asymptotically stable for any \\(l_1&gt;0\\) and \\(l_2&gt;0\\). It is interesting to note that if \\(l_2\\rightarrow \\infty\\), the estimator transfer function simplifies to \\(\\hat{x}_3(s) = s y_2(s)\\) and the result equals \\(\\hat{x}_3 = \\dot{\\theta}\\); it is obtained by differentiating the measured \\(y_2 = \\theta\\).\nSelecting \\(l_1 = 20\\) and \\(l_2 = 100\\) places both observer eigenvalues in \\(-10\\).\n\n\nController design\nFor the requirement on settling time, the frequency of the poles must be greater than \\(3/T_S\\) for real poles and greater than \\(3/\\zeta Ts\\) for complex poles, where \\(T_s\\) is the settling time (5%) and \\(\\zeta\\) the damping. Good poles locations, in terms of response and input energy, for a double integrator system, should lay within a range of \\(\\pm 45°\\) w.r.t. the real negative axis. By first considering these facts and then proceeding iteratively, dominant poles were chosen in \\(-2.8\\pm1.0i\\), whereas the third pole was chosen at much higher frequency: \\(-15\\). For the requirement of zero steady-state error the reference input is scaled by a gain equal to the inverse of the steady-state gain of the closed-loop system, yielding total closed-loop gain of \\(1.0\\).\n\n\n\nHow to use this notebook?\n\nVerify the requested specifications in case of initial error in the estimate of \\(x_3\\) for both positive and negative error.\nWatch the changed response and, by having a physical system in your mind, try to understand why it changed the way it did.\n\n\n# Preparatory cell\n\nX0 = 0.0\nK = numpy.matrix([8/15,-4.4,-4])\nL = numpy.matrix([[66],[107/3]])\n\nAw = matrixWidget(3,3)\nAw.setM(A)\nBw = matrixWidget(3,1)\nBw.setM(B)\nCw = matrixWidget(1,3)\nCw.setM(C)\nX0w = widgets.FloatText(\n    value=X0,\n    description='',\n    disabled=False\n)\nKw = matrixWidget(1,3)\nKw.setM(K)\nLw = matrixWidget(2,1)\nLw.setM(L)\n\n\neig1c = matrixWidget(1,1)\neig2c = matrixWidget(2,1)\neig3c = matrixWidget(1,1)\neig1c.setM(numpy.matrix([-15.])) \neig2c.setM(numpy.matrix([[-2.8],[-1.0]]))\neig3c.setM(numpy.matrix([-15.]))\n\neig2o = matrixWidget(2,1)\neig3o = matrixWidget(1,1)\neig2o.setM(numpy.matrix([[-10.],[0.]]))\neig3o.setM(numpy.matrix([-10.]))\n\n\n# Misc\n\n#create dummy widget \nDW = widgets.FloatText(layout=widgets.Layout(width='0px', height='0px'))\n\n#create button widget\nSTART = widgets.Button(\n    description='Test',\n    disabled=False,\n    button_style='', # 'success', 'info', 'warning', 'danger' or ''\n    tooltip='Test',\n    icon='check'\n)\n                       \ndef on_start_button_clicked(b):\n    #This is a workaround to have intreactive_output call the callback:\n    #   force the value of the dummy widget to change\n    if DW.value&gt; 0 :\n        DW.value = -1\n    else: \n        DW.value = 1\n    pass\nSTART.on_click(on_start_button_clicked)\n\n# Define type of method \nselm = widgets.Dropdown(\n    options= ['Set K and L', 'Set the eigenvalues'],\n    value= 'Set the eigenvalues',\n    description='',\n    disabled=False\n)\n\n# Define the number of complex eigenvalues\nsele = widgets.Dropdown(\n    options= ['0 complex eigenvalues', '2 complex eigenvalues'],\n    value= '2 complex eigenvalues',\n    description='Complex eigenvalues:',\n    style = {'description_width': 'initial'},\n    disabled=False\n)\n\n#define type of ipout \nselu = widgets.Dropdown(\n    options=['impulse', 'step', 'sinusoid', 'square wave'],\n    value='step',\n    description='Type of reference:',\n    style = {'description_width': 'initial'},\n    disabled=False\n)\n# Define the values of the input\nu = widgets.FloatSlider(\n    value=2,\n    min=0,\n    max=4,\n    step=0.1,\n    description='Reference:',\n    disabled=False,\n    continuous_update=False,\n    orientation='horizontal',\n    readout=True,\n    readout_format='.1f',\n)\nperiod = widgets.FloatSlider(\n    value=0.5,\n    min=0.001,\n    max=10,\n    step=0.001,\n    description='Period: ',\n    disabled=False,\n    continuous_update=False,\n    orientation='horizontal',\n    readout=True,\n    readout_format='.2f',\n)\n\ngain_w2 = widgets.FloatText(\n    value=1.,\n    description='',\n    disabled=True\n)\n\nsimTime = widgets.FloatText(\n    value=3,\n    description='',\n    disabled=False\n)\n\n\n# Support functions\n\ndef eigen_choice(sele):\n    if sele == '0 complex eigenvalues':\n        eig1c.children[0].children[0].disabled = False\n        eig2c.children[1].children[0].disabled = True\n        eig2o.children[1].children[0].disabled = True\n        eig = 0\n    if sele == '2 complex eigenvalues':\n        eig1c.children[0].children[0].disabled = True\n        eig2c.children[1].children[0].disabled = False\n        eig2o.children[1].children[0].disabled = False\n        eig = 2\n    return eig\n\ndef method_choice(selm):\n    if selm == 'Set K and L':\n        method = 1\n        sele.disabled = True\n    if selm == 'Set the eigenvalues':\n        method = 2\n        sele.disabled = False\n    return method\n\n\n# Reduced system\nAr = numpy.matrix('0 1; 0 0')\nBr = numpy.matrix([[0],[1/1.3E-02]])\nCr = numpy.matrix('1 0')\nDr = numpy.matrix('0')\n\ndef main_callback2(Aw, Bw, X0w, K, L, eig1c, eig2c, eig3c, eig2o, eig3o, u, period, selm, sele, selu, simTime, DW):\n    eige = eigen_choice(sele)\n    method = method_choice(selm)\n    \n    if method == 1:\n        solc = numpy.linalg.eig(A-B*K)\n        solo = numpy.linalg.eig(Ar-L*Cr)\n    if method == 2:\n        if eige == 0:\n            K = control.acker(A, B, [eig1c[0,0], eig2c[0,0], eig3c[0,0]])\n            Kw.setM(K)\n            \n            L = control.acker(Ar.T, Cr.T, [eig2o[0,0], eig3o[0,0]]).T\n            Lw.setM(L)\n        if eige == 2:\n            K = control.acker(A, B, [eig3c[0,0], \n                                     numpy.complex(eig2c[0,0],eig2c[1,0]), \n                                     numpy.complex(eig2c[0,0],-eig2c[1,0])])\n            Kw.setM(K)\n            \n            L = control.acker(Ar.T, Cr.T, [numpy.complex(eig2o[0,0],eig2o[1,0]), \n                                           numpy.complex(eig2o[0,0],-eig2o[1,0])]).T\n            Lw.setM(L)\n            \n    \n    sys = control.ss(A,B,numpy.vstack((C,numpy.zeros((B.shape[1],C.shape[1])))),numpy.vstack((D,numpy.eye(B.shape[1]))))\n    sysC = control.ss(numpy.zeros((1,1)),\n                      numpy.zeros((1,numpy.shape(A)[0])),\n                      numpy.zeros((numpy.shape(B)[1],1)),\n                      -K)\n    \n    sysE = control.ss(Ar-L*Cr,\n                      numpy.hstack((L,Br-L*Dr)),\n                      numpy.matrix('0 1'),\n                      numpy.zeros((1,2)))\n    \n    sys_append = control.append(sys, sysE, sysC, control.ss(A,B,numpy.eye(A.shape[0]),numpy.zeros((A.shape[0],B.shape[1]))))\n    Q = []\n    # y in ingresso a sysE\n    for i in range(1):\n        Q.append([B.shape[1]+i+1, i+2])\n    # u in ingresso a sysE\n    for i in range(B.shape[1]):\n        Q.append([B.shape[1]+1+i+1, C.shape[0]+i+1])\n    # u in ingresso a sys\n    for i in range(B.shape[1]):\n        Q.append([i+1, C.shape[0]+B.shape[1]+1+i+1])\n    # u in ingresso al sistema che ha come uscite gli stati reali\n    for i in range(B.shape[1]):\n        Q.append([2*B.shape[1]+1+A.shape[0]+i+1, C.shape[0]+i+1])\n    # xe in ingresso a sysC\n    Q.append([2*B.shape[1]+1+1, 1])\n    Q.append([2*B.shape[1]+1+1+1, 1+1])\n    Q.append([2*B.shape[1]+1+2+1, C.shape[0]+B.shape[1]+1])\n        \n    inputv = [i+1 for i in range(B.shape[1])]\n    outputv = [i+1 for i in range(numpy.shape(sys_append.C)[0])]\n    sys_CL = control.connect(sys_append,\n                             Q,\n                             inputv,\n                             outputv)\n    \n    t = numpy.linspace(0, 100000, 2)\n    t, yout = control.step_response(sys_CL[0,0],T=t)\n    dcgain = yout[-1]\n    gain_w2.value = dcgain\n    if dcgain != 0:\n        u1 = u/gain_w2.value\n    else:\n        print('The feedforward gain is set to 0 and it changed to 1.')\n        u1 = u/1\n    print('The static gain of the closed-loop system (from the reference to the output) is: %.5f' %dcgain)\n    \n    X0w1 = numpy.zeros((2*A.shape[0]+2,1))\n    X0w1[A.shape[0]+1,0] = X0w\n    if simTime != 0:\n        T = numpy.linspace(0, simTime, 10000)\n    else:\n        T = numpy.linspace(0, 1, 10000)\n      \n    if selu == 'impulse': #selu\n        U = [0 for t in range(0,len(T))]\n        U[0] = u\n        U1 = [0 for t in range(0,len(T))]\n        U1[0] = u1\n        T, yout, xout = control.forced_response(sys_CL,T,U1,X0w1)\n    if selu == 'step':\n        U = [u for t in range(0,len(T))]\n        U1 = [u1 for t in range(0,len(T))]\n        T, yout, xout = control.forced_response(sys_CL,T,U1,X0w1)\n    if selu == 'sinusoid':\n        U = u*numpy.sin(2*numpy.pi/period*T)\n        U1 = u1*numpy.sin(2*numpy.pi/period*T)\n        T, yout, xout = control.forced_response(sys_CL,T,U1,X0w1)\n    if selu == 'square wave':\n        U = u*numpy.sign(numpy.sin(2*numpy.pi/period*T))\n        U1 = u1*numpy.sign(numpy.sin(2*numpy.pi/period*T))\n        T, yout, xout = control.forced_response(sys_CL,T,U1,X0w1)\n    # N.B. i primi 3 stati di xout sono quelli del sistema, mentre gli ultimi 3 sono quelli dell'osservatore\n    \n    step_info_dict = control.step_info(sys_CL[0,0],SettlingTimeThreshold=0.05,T=T)\n    print('Step info: \\n\\tRise time =',step_info_dict['RiseTime'],'\\n\\tSettling time (5%) =',step_info_dict['SettlingTime'],'\\n\\tOvershoot (%)=',step_info_dict['Overshoot'])\n    print('Max x2 value (%)=', max(abs(yout[C.shape[0]+2*B.shape[1]+1+1]))/(numpy.pi/180*30)*100)\n    \n    fig = plt.figure(num='Simulation1', figsize=(14,12))\n    \n    fig.add_subplot(221)\n    plt.title('Output response')\n    plt.ylabel('Output')\n    plt.plot(T,yout[0],T,U,'r--')\n    plt.xlabel('$t$ [s]')\n    plt.axvline(x=0,color='black',linewidth=0.8)\n    plt.axhline(y=0,color='black',linewidth=0.8)\n    plt.legend(['$y$','Reference'])\n    plt.grid()\n    \n    fig.add_subplot(222)\n    plt.title('Input')\n    plt.ylabel('$u$')\n    plt.plot(T,yout[C.shape[0]])\n    plt.xlabel('$t$ [s]')\n    plt.axvline(x=0,color='black',linewidth=0.8)\n    plt.axhline(y=0,color='black',linewidth=0.8)\n    plt.grid()\n    \n    fig.add_subplot(223)\n    plt.title('States response')\n    plt.ylabel('States')\n    plt.plot(T,yout[C.shape[0]+2*B.shape[1]+1],\n             T,yout[C.shape[0]+2*B.shape[1]+1+1],\n             T,yout[C.shape[0]+2*B.shape[1]+1+2],\n             T,[numpy.pi/180*30 for i in range(len(T))],'r--',\n             T,[-numpy.pi/180*30 for i in range(len(T))],'r--')\n    plt.xlabel('$t$ [s]')\n    plt.legend(['$x_{1}$','$x_{2}$','$x_{3}$','limit +$x_{2}$','limit -$x_{2}$'])\n    plt.axvline(x=0,color='black',linewidth=0.8)\n    plt.axhline(y=0,color='black',linewidth=0.8)\n    plt.grid()\n    \n    fig.add_subplot(224)\n    plt.title('Estimation error')\n    plt.ylabel('Error')\n    plt.plot(T,yout[C.shape[0]+2*B.shape[1]+1+2]-yout[C.shape[0]+B.shape[1]])\n    plt.xlabel('$t$ [s]')\n    plt.legend(['$e_{3}$'])\n    plt.axvline(x=0,color='black',linewidth=0.8)\n    plt.axhline(y=0,color='black',linewidth=0.8)\n    plt.grid()\n    #plt.tight_layout()\n   \nalltogether2 = widgets.VBox([widgets.HBox([selm, \n                                          sele,\n                                          selu]),\n                            widgets.Label(' ',border=3),\n                            widgets.HBox([widgets.Label('K:',border=3), Kw, \n                                          widgets.Label(' ',border=3),\n                                          widgets.Label(' ',border=3),\n                                          widgets.Label('Eigenvalues:',border=3),\n                                          eig1c, \n                                          eig2c, \n                                          eig3c,\n                                          widgets.Label(' ',border=3),\n                                          widgets.Label(' ',border=3)]),\n                            widgets.Label('X0 est.:',border=3), X0w,\n                            widgets.Label(' ',border=3), \n                            widgets.HBox([widgets.Label('L:',border=3), Lw, \n                                          widgets.Label(' ',border=3),\n                                          widgets.Label(' ',border=3),\n                                          widgets.Label('Eigenvalues:',border=3), \n                                          eig2o, \n                                          eig3o,\n                                          widgets.Label(' ',border=3),\n                                          widgets.VBox([widgets.Label('Inverse reference gain:',border=3),\n                                                        widgets.Label('Simulation time (s):',border=3)]),\n                                          widgets.VBox([gain_w2,simTime])]),\n                            widgets.Label(' ',border=3),\n                            widgets.HBox([u, \n                                          period, \n                                          START])])\nout2 = widgets.interactive_output(main_callback2, {'Aw':Aw, 'Bw':Bw, 'X0w':X0w, 'K':Kw, 'L':Lw,\n                                                 'eig1c':eig1c, 'eig2c':eig2c, 'eig3c':eig3c, 'eig2o':eig2o, 'eig3o':eig3o, \n                                                 'u':u, 'period':period, 'selm':selm, 'sele':sele, 'selu':selu, 'simTime':simTime, 'DW':DW})\nout2.layout.height = '870px'\ndisplay(out2, alltogether2)"
  },
  {
    "objectID": "ICCT_en/examples/04/SS-39-Crane_load_position_control.html",
    "href": "ICCT_en/examples/04/SS-39-Crane_load_position_control.html",
    "title": "Crane load position control",
    "section": "",
    "text": "# Erasmus+ ICCT project (2018-1-SI01-KA203-047081)\n\n# Toggle cell visibility\n\nfrom IPython.display import HTML\ntag = HTML('''&lt;script&gt;\ncode_show=true; \nfunction code_toggle() {\n    if (code_show){\n        $('div.input').hide()\n    } else {\n        $('div.input').show()\n    }\n    code_show = !code_show\n} \n$( document ).ready(code_toggle);\n&lt;/script&gt;\nToggle cell visibility &lt;a href=\"javascript:code_toggle()\"&gt;here&lt;/a&gt;.''')\ndisplay(tag)\n\n# Hide the code completely\n\n# from IPython.display import HTML\n# tag = HTML('''&lt;style&gt;\n# div.input {\n#     display:none;\n# }\n# &lt;/style&gt;''')\n# display(tag)\n\n\nToggle cell visibility here.\n\n\n\n%matplotlib inline\nimport control\nimport numpy\nimport sympy as sym\nfrom IPython.display import display, Markdown\nimport ipywidgets as widgets\nimport matplotlib.pyplot as plt\n\n\n#print a matrix latex-like\ndef bmatrix(a):\n     \"\"\"Returns a LaTeX bmatrix - by Damir Arbula (ICCT project)\n\n     :a: numpy array\n     :returns: LaTeX bmatrix as a string\n     \"\"\"\n     if len(a.shape) &gt; 2:\n         raise ValueError('bmatrix can at most display two dimensions')\n     lines = str(a).replace('[', '').replace(']', '').splitlines()\n     rv = [r'\\begin{bmatrix}']\n     rv += ['  ' + ' & '.join(l.split()) + r'\\\\' for l in lines]\n     rv +=  [r'\\end{bmatrix}']\n     return '\\n'.join(rv)\n\n\n# Display formatted matrix: \ndef vmatrix(a):\n    if len(a.shape) &gt; 2:\n         raise ValueError('bmatrix can at most display two dimensions')\n    lines = str(a).replace('[', '').replace(']', '').splitlines()\n    rv = [r'\\begin{vmatrix}']\n    rv += ['  ' + ' & '.join(l.split()) + r'\\\\' for l in lines]\n    rv +=  [r'\\end{vmatrix}']\n    return '\\n'.join(rv)\n\n\n#matrixWidget is a matrix looking widget built with a VBox of HBox(es) that returns a numPy array as value !\nclass matrixWidget(widgets.VBox):\n    def updateM(self,change):\n        for irow in range(0,self.n):\n            for icol in range(0,self.m):\n                self.M_[irow,icol] = self.children[irow].children[icol].value\n                #print(self.M_[irow,icol])\n        self.value = self.M_\n\n    def dummychangecallback(self,change):\n        pass\n    \n    \n    def __init__(self,n,m):\n        self.n = n\n        self.m = m\n        self.M_ = numpy.matrix(numpy.zeros((self.n,self.m)))\n        self.value = self.M_\n        widgets.VBox.__init__(self,\n                             children = [\n                                 widgets.HBox(children = \n                                              [widgets.FloatText(value=0.0, layout=widgets.Layout(width='90px')) for i in range(m)]\n                                             ) \n                                 for j in range(n)\n                             ])\n        \n        #fill in widgets and tell interact to call updateM each time a children changes value\n        for irow in range(0,self.n):\n            for icol in range(0,self.m):\n                self.children[irow].children[icol].value = self.M_[irow,icol]\n                self.children[irow].children[icol].observe(self.updateM, names='value')\n        #value = Unicode('example@example.com', help=\"The email value.\").tag(sync=True)\n        self.observe(self.updateM, names='value', type= 'All')\n        \n    def setM(self, newM):\n        #disable callbacks, change values, and reenable\n        self.unobserve(self.updateM, names='value', type= 'All')\n        for irow in range(0,self.n):\n            for icol in range(0,self.m):\n                self.children[irow].children[icol].unobserve(self.updateM, names='value')\n        self.M_ = newM\n        self.value = self.M_\n        for irow in range(0,self.n):\n            for icol in range(0,self.m):\n                self.children[irow].children[icol].value = self.M_[irow,icol]\n        for irow in range(0,self.n):\n            for icol in range(0,self.m):\n                self.children[irow].children[icol].observe(self.updateM, names='value')\n        self.observe(self.updateM, names='value', type= 'All')        \n\n                #self.children[irow].children[icol].observe(self.updateM, names='value')\n\n             \n#overlaod class for state space systems that DO NOT remove \"useless\" states (what \"professor\" of automatic control would do this?)\nclass sss(control.StateSpace):\n    def __init__(self,*args):\n        #call base class init constructor\n        control.StateSpace.__init__(self,*args)\n    #disable function below in base class\n    def _remove_useless_states(self):\n        pass\n\n\nA gantry crane consists of a cart of mass \\(m_c = 1000\\) kg, and a load of mass \\(m_l\\), connected by a rope of length \\(L\\) that can be considered massless. Friction acts on the cart linearly, proportional to cart velocity with coefficient \\(B_f = 100\\) Ns/m; the cart is moved by the force \\(F\\). The angle between the vertical axis and the rope is \\(\\theta\\). The dynamic equations of the system, linearized around the steady condition (\\(\\theta=\\dot{\\theta}=\\dot{x}=0\\)), are (where \\(g = 9.81\\) m/\\(\\text{s}^2\\) is gravitational acceleration):\n\\[\\begin{cases}\n    (m_l+m_c)\\ddot{x}+m_lL\\ddot{\\theta}+B_f\\dot{x}=F \\\\\n    m_lL^2\\ddot{\\theta}+m_lL\\ddot{x}+m_lLg\\theta=0\n\\end{cases}\\]\nWe assume \\(m_l=100\\) kg and \\(L=10\\) m as nominal values and we want to design a regulator for the measured load position \\(y=x+L\\sin{\\theta} \\cong x+L\\theta\\) according to the following specifications: - settling time for 5% tolerance band of less than 20 seconds,\n- minimal or no overshoot, - zero or practically zero steady-state error in response to a step-wise change of the desired load position, - force \\(F\\) must not exceed \\(\\pm1000\\) N when the requested position change is 10 meters.\nFirst, we have to write the linearized system’s equations in state space form; dividing the second equation by \\(m_lL\\) became \\[\n    L\\ddot{\\theta}+\\ddot{x}+g\\theta=0 \\, .\n\\]\nNow, defining \\(x=\\begin{bmatrix} x_1 & x_2 & x_3 & x_4 \\end{bmatrix}^T = =\\begin{bmatrix} \\dot{x} & \\dot{\\theta} & \\theta & x \\end{bmatrix}^T\\) we can write:\n\\[\nM\\dot{x}=Gx+HF,\n\\]\nwhere:\n\\[\n    M = \\begin{bmatrix} (m_l+m_c) & m_lL & 0 & 0 \\\\ 1 & L & 0 & 0 \\\\ 0 & 0 & 1 & 0 \\\\ 0 & 0 & 0 & 1 \\end{bmatrix}, \\quad\n    G = \\begin{bmatrix} -B_f & 0 & 0 & 0 \\\\ 0 & 0 & -g & 0 \\\\ 0 & 1 & 0 & 0 \\\\ 1 & 0 & 0 & 0 \\end{bmatrix} \\quad \\text{and} \\quad\n    H = \\begin{bmatrix} 1 \\\\ 0 \\\\ 0 \\\\ 0 \\end{bmatrix} \\, .\n\\]\nThus, pre-multiplying all with \\(M^{-1}\\) we obtain (\\(A=M^{-1}G\\), \\(B=M^{-1}H\\)):\n\\[\\begin{cases}\n    \\dot{x} = \\begin{bmatrix} -B_f/m_c & 0 & gm_l/m_c & 0 \\\\ B_f/(Lm_c) & 0 & -g(1/L + m_l/(Lm_c)) & 0 \\\\ 0 & 1 & 0 & 0 \\\\ 1 & 0 & 0 & 0 \\end{bmatrix}x +\\begin{bmatrix}1/m_c \\\\ -1/(Lm_c) \\\\ 0 \\\\ 0 \\end{bmatrix}F \\\\\n    y = \\begin{bmatrix} 0 & 0 & L & 1 \\end{bmatrix}x\n\\end{cases}\\]\n\nRegulator development\n\nController design\nThe poles of the system are \\(0\\), \\(-0.091\\) and \\(-0.0045\\pm1.038i\\). In order to meet the requirement for settling time, we move the real poles to \\(-0.28\\) and decrease the real part of the imaginary poles by \\(-0.25\\). As a result, the chosen closed-loop poles are: \\(-0.28\\), \\(-0.28\\) and \\(-0.2545\\pm1.038i\\). For the zero steady-state error we scale the reference signal with a gain equal to the inverse of the closed-loop system’s gain.\n\n\nDesign of the observer\nTo support the state feedback controller we design a full state observer with poles in \\(-8\\).\n\n\n\nHow to use this notebook?\nTry to change the poles location in order to satisfy the requirements for a reference step input of 15 m.\n\n# Preparatory cell\n\nX0 = numpy.matrix('0.0; 0.0; 0.0; 0.0')\nK = numpy.matrix([0,0,0,0])\nL = numpy.matrix([[0],[0],[0],[0]])\n\nX0w = matrixWidget(4,1)\nX0w.setM(X0)\nKw = matrixWidget(1,4)\nKw.setM(K)\nLw = matrixWidget(4,1)\nLw.setM(L)\n\n\neig1c = matrixWidget(1,1)\neig2c = matrixWidget(2,1)\neig3c = matrixWidget(1,1)\neig4c = matrixWidget(2,1)\neig1c.setM(numpy.matrix([-0.28])) \neig2c.setM(numpy.matrix([[-0.2545],[-1.038]]))\neig3c.setM(numpy.matrix([-0.28]))\neig4c.setM(numpy.matrix([[-1.],[-1.]]))\n\neig1o = matrixWidget(1,1)\neig2o = matrixWidget(2,1)\neig3o = matrixWidget(1,1)\neig4o = matrixWidget(2,1)\neig1o.setM(numpy.matrix([-8.])) \neig2o.setM(numpy.matrix([[-8.1],[0.]]))\neig3o.setM(numpy.matrix([-8.2]))\neig4o.setM(numpy.matrix([[-8.3],[0.]]))\n\n\n# Misc\n\n#create dummy widget \nDW = widgets.FloatText(layout=widgets.Layout(width='0px', height='0px'))\n\n#create button widget\nSTART = widgets.Button(\n    description='Test',\n    disabled=False,\n    button_style='', # 'success', 'info', 'warning', 'danger' or ''\n    tooltip='Test',\n    icon='check'\n)\n                       \ndef on_start_button_clicked(b):\n    #This is a workaround to have intreactive_output call the callback:\n    #   force the value of the dummy widget to change\n    if DW.value&gt; 0 :\n        DW.value = -1\n    else: \n        DW.value = 1\n    pass\nSTART.on_click(on_start_button_clicked)\n\n# Define type of method \nselm = widgets.Dropdown(\n    options= ['Set K and L', 'Set the eigenvalues'],\n    value= 'Set the eigenvalues',\n    description='',\n    disabled=False\n)\n\n# Define the number of complex eigenvalues\nselec = widgets.Dropdown(\n    options= ['0 complex eigenvalues', '2 complex eigenvalues', '4 complex eigenvalues'],\n    value= '2 complex eigenvalues',\n    description='Eig controller:',\n    disabled=False\n)\nseleo = widgets.Dropdown(\n    options= ['0 complex eigenvalues', '2 complex eigenvalues'],\n    value= '0 complex eigenvalues',\n    description='Eig observer:',\n    disabled=False\n)\n\n#define type of ipout \nselu = widgets.Dropdown(\n    options=['impulse', 'step', 'sinusoid', 'square wave'],\n    value='step',\n    description='Type of reference:',\n    style = {'description_width': 'initial'},\n    disabled=False\n)\n# Define the values of the input\nu = widgets.FloatSlider(\n    value=10,\n    min=0,\n    max=20,\n    step=1,\n    description='Reference:',\n    disabled=False,\n    continuous_update=False,\n    orientation='horizontal',\n    readout=True,\n    readout_format='.1f',\n)\nperiod = widgets.FloatSlider(\n    value=0.5,\n    min=0.001,\n    max=10,\n    step=0.001,\n    description='Period: ',\n    disabled=False,\n    continuous_update=False,\n    orientation='horizontal',\n    readout=True,\n    readout_format='.3f',\n)\n\nsimTime = widgets.FloatText(\n    value=30,\n    description='',\n    disabled=False\n)\n\n\n# Support functions\n\ndef eigen_choice(selec,seleo):\n    if selec == '0 complex eigenvalues':\n        eig1c.children[0].children[0].disabled = False\n        eig2c.children[1].children[0].disabled = True\n        eig3c.children[0].children[0].disabled = False\n        eig4c.children[0].children[0].disabled = False\n        eig4c.children[1].children[0].disabled = True\n        eigc = 0\n    if seleo == '0 complex eigenvalues':\n        eig1o.children[0].children[0].disabled = False\n        eig2o.children[1].children[0].disabled = True\n        eig3o.children[0].children[0].disabled = False\n        eig4o.children[0].children[0].disabled = False\n        eig4o.children[1].children[0].disabled = True\n        eigo = 0\n    if selec == '2 complex eigenvalues':\n        eig1c.children[0].children[0].disabled = False\n        eig2c.children[1].children[0].disabled = False\n        eig3c.children[0].children[0].disabled = False\n        eig4c.children[0].children[0].disabled = True\n        eig4c.children[1].children[0].disabled = True\n        eigc = 2\n    if seleo == '2 complex eigenvalues':\n        eig1o.children[0].children[0].disabled = False\n        eig2o.children[1].children[0].disabled = False\n        eig3o.children[0].children[0].disabled = False\n        eig4o.children[0].children[0].disabled = True\n        eig4o.children[1].children[0].disabled = True\n        eigo = 2\n    if selec == '4 complex eigenvalues':\n        eig1c.children[0].children[0].disabled = True\n        eig2c.children[1].children[0].disabled = False\n        eig3c.children[0].children[0].disabled = True\n        eig4c.children[0].children[0].disabled = False\n        eig4c.children[1].children[0].disabled = False\n        eigc = 4\n    if seleo == '4 complex eigenvalues':\n        eig1o.children[0].children[0].disabled = True\n        eig2o.children[1].children[0].disabled = False\n        eig3o.children[0].children[0].disabled = True\n        eig4o.children[0].children[0].disabled = False\n        eig4o.children[1].children[0].disabled = False\n        eigo = 4\n    return eigc, eigo\n\ndef method_choice(selm):\n    if selm == 'Set K and L':\n        method = 1\n        selec.disabled = True\n        seleo.disabled = True\n    if selm == 'Set the eigenvalues':\n        method = 2\n        selec.disabled = False\n        seleo.disabled = False\n    return method\n\n\nml = 100 \nmc = 1000 \nL  = 10\ng  = 9.81\nBf = 100\n\nA = numpy.matrix([[-Bf/mc,0,g*ml/mc,0],\n                  [Bf/(L*mc), 0, -g*(1/L + ml/(L*mc)), 0],\n                  [0, 1, 0, 0],\n                  [1, 0, 0, 0]])\nB = numpy.matrix([[1/mc],[-1/(L*mc)],[0],[0]])\nC = numpy.matrix([[0,0,L,1]])\n\ndef main_callback2(X0w, K, L, eig1c, eig2c, eig3c, eig4c, eig1o, eig2o, eig3o, eig4o, u, period, selm, selec, seleo, selu, simTime, DW):\n    eigc, eigo = eigen_choice(selec,seleo)\n    method = method_choice(selm)\n    \n    if method == 1:\n        solc = numpy.linalg.eig(A-B*K)\n        solo = numpy.linalg.eig(A-L*C)\n    if method == 2:\n        try:\n            if eigc == 0:\n                K = control.acker(A, B, [eig1c[0,0], eig2c[0,0], eig3c[0,0], eig4c[0,0]])\n                Kw.setM(K)\n            if eigc == 2:\n                K = control.acker(A, B, [eig3c[0,0],\n                                          eig1c[0,0],\n                                          numpy.complex(eig2c[0,0], eig2c[1,0]), \n                                          numpy.complex(eig2c[0,0],-eig2c[1,0])])\n                Kw.setM(K)\n            if eigc == 4:\n                K = control.acker(A, B, [numpy.complex(eig4c[0,0], eig4c[1,0]), \n                                          numpy.complex(eig4c[0,0],-eig4c[1,0]),\n                                          numpy.complex(eig2c[0,0], eig2c[1,0]), \n                                          numpy.complex(eig2c[0,0],-eig2c[1,0])])\n                Kw.setM(K)\n            if eigo == 0:\n                L = control.place(A.T, C.T, [eig1o[0,0], eig2o[0,0], eig3o[0,0], eig4o[0,0]]).T\n                Lw.setM(L)\n            if eigo == 2:\n                L = control.place(A.T, C.T, [eig3o[0,0],\n                                             eig1o[0,0],\n                                             numpy.complex(eig2o[0,0], eig2o[1,0]), \n                                             numpy.complex(eig2o[0,0],-eig2o[1,0])]).T\n                Lw.setM(L)\n            if eigo == 4:\n                L = control.place(A.T, C.T, [numpy.complex(eig4o[0,0], eig4o[1,0]), \n                                          numpy.complex(eig4o[0,0],-eig4o[1,0]),\n                                          numpy.complex(eig2o[0,0], eig2o[1,0]), \n                                          numpy.complex(eig2o[0,0],-eig2o[1,0])]).T\n                Lw.setM(L)\n        except:\n            print(\"ERROR: at least one of the requested pole is repeated more than rank(B) times, try to change the poles\")\n            return\n            \n    sys = sss(A,B,numpy.vstack((C,[0,0,0,0])),[[0],[1]])\n    syse = sss(A-L*C,numpy.hstack((B,L)),numpy.eye(4),numpy.zeros((4,2)))\n    sysc = sss(0,[0,0,0,0],0,-K)\n    sys_append = control.append(sys,syse,sysc)\n    # To avoid strange behaviours\n    try:\n        sys_CL = control.connect(sys_append,\n                                 [[1,7],[2,2],[3,1],[4,3],[5,4],[6,5],[7,6]],\n                                 [1],\n                                 [1,2])\n    except:\n        sys_CL = control.connect(sys_append,\n                                 [[1,7],[2,2],[3,1],[4,3],[5,4],[6,5],[7,6]],\n                                 [1],\n                                 [1,2])\n\n    X0w1 = numpy.zeros((8,1))\n    X0w1[4,0] = X0w[0,0]\n    X0w1[5,0] = X0w[1,0]\n    X0w1[6,0] = X0w[2,0]\n    X0w1[7,0] = X0w[3,0]\n    if simTime != 0:\n        T = numpy.linspace(0, simTime, 10000)\n    else:\n        T = numpy.linspace(0, 1, 10000)\n    #t1, y1 = step(sys_CL[0,0],[0,10000])\n    u1 = u\n    try:\n        DCgain = control.dcgain(sys_CL[0,0])\n        u = u/DCgain\n    except:\n        print(\"Error in the calculation of the dcgain of the closed loop controlled system. The feedforward gain is setted to 1.\")\n        DCgain = 1\n    \n    if selu == 'impulse': #selu\n        U = [0 for t in range(0,len(T))]\n        U[0] = u\n        U1 = [0 for t in range(0,len(T))]\n        U1[0] = u1\n        T, yout, xout = control.forced_response(sys_CL,T,U,X0w1)\n    if selu == 'step':\n        U = [u for t in range(0,len(T))]\n        U1 = [u1 for t in range(0,len(T))]\n        T, yout, xout = control.forced_response(sys_CL,T,U,X0w1)\n    if selu == 'sinusoid':\n        U = u*numpy.sin(2*numpy.pi/period*T)\n        U1 = u1*numpy.sin(2*numpy.pi/period*T)\n        T, yout, xout = control.forced_response(sys_CL,T,U,X0w1)\n    if selu == 'square wave':\n        U = u*numpy.sign(numpy.sin(2*numpy.pi/period*T))\n        U1 = u1*numpy.sign(numpy.sin(2*numpy.pi/period*T))\n        T, yout, xout = control.forced_response(sys_CL,T,U,X0w1)\n    \n    try:\n        step_info_dict = control.step_info(sys_CL[0,0],SettlingTimeThreshold=0.05,T=T)\n        print('Step info: \\n\\tRise time =',step_info_dict['RiseTime'],'\\n\\tSettling time (5%) =',step_info_dict['SettlingTime'],'\\n\\tOvershoot (%)=',step_info_dict['Overshoot'])\n        print('Max u value (% of 1000N)=', max(abs(yout[1]))/(1000)*100)\n    except:\n        print(\"Error in the calculation of step info.\")\n    print(\"Closed loop system's gain =\",DCgain)\n    \n    fig = plt.figure(num='Simulation1', figsize=(14,12))\n    \n    fig.add_subplot(221)\n    plt.title('Output response')\n    plt.ylabel('Output')\n    plt.plot(T,yout[0],T,U1,'r--')\n    plt.xlabel('$t$ [s]')\n    plt.axvline(x=0,color='black',linewidth=0.8)\n    plt.axhline(y=0,color='black',linewidth=0.8)\n    plt.legend(['$y$','Reference'])\n    plt.grid()\n    \n    fig.add_subplot(222)\n    plt.title('Input')\n    plt.ylabel('$u$')\n    plt.plot(T,yout[1])\n    plt.plot(T,[1000 for i in range(len(T))],'r--')\n    plt.plot(T,[-1000 for i in range(len(T))],'r--')\n    plt.xlabel('$t$ [s]')\n    plt.axvline(x=0,color='black',linewidth=0.8)\n    plt.axhline(y=0,color='black',linewidth=0.8)\n    plt.grid()\n    \n    fig.add_subplot(223)\n    plt.title('States response')\n    plt.ylabel('States')\n    plt.plot(T,xout[0],\n             T,xout[1],\n             T,xout[2],\n             T,xout[3])\n    plt.xlabel('$t$ [s]')\n    plt.axvline(x=0,color='black',linewidth=0.8)\n    plt.axhline(y=0,color='black',linewidth=0.8)\n    plt.legend(['$x_{1}$','$x_{2}$','$x_{3}$','$x_{4}$'])\n    plt.grid()\n    \n    fig.add_subplot(224)\n    plt.title('Estimation errors')\n    plt.ylabel('Errors')\n    plt.plot(T,xout[4]-xout[0])\n    plt.plot(T,xout[5]-xout[1])\n    plt.plot(T,xout[6]-xout[2])\n    plt.plot(T,xout[7]-xout[3])\n    plt.axvline(x=0,color='black',linewidth=0.8)\n    plt.axhline(y=0,color='black',linewidth=0.8)\n    plt.xlabel('$t$ [s]')\n    plt.legend(['$e_{1}$','$e_{2}$','$e_{3}$','$e_{4}$'])\n    plt.grid()\n    #plt.tight_layout()\n   \nalltogether2 = widgets.VBox([widgets.HBox([selm, \n                                          selec,\n                                          seleo,\n                                          selu]),\n                            widgets.Label(' ',border=3),\n                            widgets.HBox([widgets.HBox([widgets.Label('K:',border=3), Kw, \n                                                        widgets.Label('Eigenvalues:',border=3),\n                                                        widgets.HBox([eig1c, \n                                                                      eig2c, \n                                                                      eig3c,\n                                                                      eig4c])])]),\n                            widgets.Label(' ',border=3),\n                            widgets.HBox([widgets.VBox([widgets.HBox([widgets.Label('L:',border=3), Lw, widgets.Label(' ',border=3),\n                                          widgets.Label(' ',border=3),\n                                          widgets.Label('Eigenvalues:',border=3), \n                                          eig1o, \n                                          eig2o,\n                                          eig3o, \n                                          eig4o,\n                                          widgets.Label(' ',border=3),\n                                          widgets.Label(' ',border=3),\n                                          widgets.Label('X0 est.:',border=3), X0w]),\n                                          widgets.Label(' ',border=3),\n                                                       widgets.HBox([\n                                          widgets.VBox([widgets.Label('Simulation time (s):',border=3)]),\n                                          widgets.VBox([simTime])])]),\n                                          widgets.Label(' ',border=3)]),\n                            widgets.Label(' ',border=3),\n                            widgets.HBox([u,\n                                          period, \n                                          START])])\nout2 = widgets.interactive_output(main_callback2, {'X0w':X0w, 'K':Kw, 'L':Lw,\n                                                   'eig1c':eig1c, 'eig2c':eig2c, 'eig3c':eig3c, 'eig4c':eig4c, \n                                                   'eig1o':eig1o, 'eig2o':eig2o, 'eig3o':eig3o, 'eig4o':eig4o,  \n                                                   'u':u, 'period':period, 'selm':selm, 'selec':selec, 'seleo':seleo, 'selu':selu, 'simTime':simTime, 'DW':DW})\nout2.layout.height = '860px'\ndisplay(out2, alltogether2)"
  },
  {
    "objectID": "ICCT_en/examples/04/SS-41-Rotary_actuator_position_control.html",
    "href": "ICCT_en/examples/04/SS-41-Rotary_actuator_position_control.html",
    "title": "Rotary actuator position control",
    "section": "",
    "text": "# Erasmus+ ICCT project (2018-1-SI01-KA203-047081)\n\n# Toggle cell visibility\n\nfrom IPython.display import HTML\ntag = HTML('''&lt;script&gt;\ncode_show=true; \nfunction code_toggle() {\n    if (code_show){\n        $('div.input').hide()\n    } else {\n        $('div.input').show()\n    }\n    code_show = !code_show\n} \n$( document ).ready(code_toggle);\n&lt;/script&gt;\nToggle cell visibility &lt;a href=\"javascript:code_toggle()\"&gt;here&lt;/a&gt;.''')\ndisplay(tag)\n\n# Hide the code completely\n\n# from IPython.display import HTML\n# tag = HTML('''&lt;style&gt;\n# div.input {\n#     display:none;\n# }\n# &lt;/style&gt;''')\n# display(tag)\n\n\nToggle cell visibility here.\n\n\n\n%matplotlib inline\nimport control\nimport numpy\nimport sympy as sym\nfrom IPython.display import display, Markdown\nimport ipywidgets as widgets\nimport matplotlib.pyplot as plt\n\n\n#print a matrix latex-like\ndef bmatrix(a):\n     \"\"\"Returns a LaTeX bmatrix - by Damir Arbula (ICCT project)\n\n     :a: numpy array\n     :returns: LaTeX bmatrix as a string\n     \"\"\"\n     if len(a.shape) &gt; 2:\n         raise ValueError('bmatrix can at most display two dimensions')\n     lines = str(a).replace('[', '').replace(']', '').splitlines()\n     rv = [r'\\begin{bmatrix}']\n     rv += ['  ' + ' & '.join(l.split()) + r'\\\\' for l in lines]\n     rv +=  [r'\\end{bmatrix}']\n     return '\\n'.join(rv)\n\n\n# Display formatted matrix: \ndef vmatrix(a):\n    if len(a.shape) &gt; 2:\n         raise ValueError('bmatrix can at most display two dimensions')\n    lines = str(a).replace('[', '').replace(']', '').splitlines()\n    rv = [r'\\begin{vmatrix}']\n    rv += ['  ' + ' & '.join(l.split()) + r'\\\\' for l in lines]\n    rv +=  [r'\\end{vmatrix}']\n    return '\\n'.join(rv)\n\n\n#matrixWidget is a matrix looking widget built with a VBox of HBox(es) that returns a numPy array as value !\nclass matrixWidget(widgets.VBox):\n    def updateM(self,change):\n        for irow in range(0,self.n):\n            for icol in range(0,self.m):\n                self.M_[irow,icol] = self.children[irow].children[icol].value\n                #print(self.M_[irow,icol])\n        self.value = self.M_\n\n    def dummychangecallback(self,change):\n        pass\n    \n    \n    def __init__(self,n,m):\n        self.n = n\n        self.m = m\n        self.M_ = numpy.matrix(numpy.zeros((self.n,self.m)))\n        self.value = self.M_\n        widgets.VBox.__init__(self,\n                             children = [\n                                 widgets.HBox(children = \n                                              [widgets.FloatText(value=0.0, layout=widgets.Layout(width='90px')) for i in range(m)]\n                                             ) \n                                 for j in range(n)\n                             ])\n        \n        #fill in widgets and tell interact to call updateM each time a children changes value\n        for irow in range(0,self.n):\n            for icol in range(0,self.m):\n                self.children[irow].children[icol].value = self.M_[irow,icol]\n                self.children[irow].children[icol].observe(self.updateM, names='value')\n        #value = Unicode('example@example.com', help=\"The email value.\").tag(sync=True)\n        self.observe(self.updateM, names='value', type= 'All')\n        \n    def setM(self, newM):\n        #disable callbacks, change values, and reenable\n        self.unobserve(self.updateM, names='value', type= 'All')\n        for irow in range(0,self.n):\n            for icol in range(0,self.m):\n                self.children[irow].children[icol].unobserve(self.updateM, names='value')\n        self.M_ = newM\n        self.value = self.M_\n        for irow in range(0,self.n):\n            for icol in range(0,self.m):\n                self.children[irow].children[icol].value = self.M_[irow,icol]\n        for irow in range(0,self.n):\n            for icol in range(0,self.m):\n                self.children[irow].children[icol].observe(self.updateM, names='value')\n        self.observe(self.updateM, names='value', type= 'All')        \n\n                #self.children[irow].children[icol].observe(self.updateM, names='value')\n\n             \n#overlaod class for state space systems that DO NOT remove \"useless\" states (what \"professor\" of automatic control would do this?)\nclass sss(control.StateSpace):\n    def __init__(self,*args):\n        #call base class init constructor\n        control.StateSpace.__init__(self,*args)\n    #disable function below in base class\n    def _remove_useless_states(self):\n        pass\n\n\nThe actuator consists of a DC motor actuating a disc where a disturbance torque may be exerted. System constants are:\n\nmoment of inertia of the rotor \\(J = 4E-6\\) kg/\\(\\text{m}^2\\);\n\nmotor viscous friction constant \\(b = 3.3E-6\\) Nms;\n\nelectromotive force constant \\(K_b = 0.03\\) V/(rad/s);\n\nmotor torque constant \\(K_t = 0.03\\) Nm/A;\nelectric resistance \\(R = 5\\) \\(\\Omega\\);\nelectric inductance \\(L = 3E-3\\) \\(\\text{H}\\).\n\nThe torque generated by the motor, assuming fixed excitation field, is \\(T=K_t i\\), and the Back EMF voltage is \\(e=K_b \\dot{\\theta}\\). Assume there can also be an external disturbance torque \\(T_d\\) that must be rejected.\nThe dynamic equations can be written as:\n\\[\\begin{cases}\n      V = Ri+L\\frac{di}{dt}+e = Ri+L\\frac{di}{dt}+K_b\\dot{\\theta} \\\\\n      J\\ddot{\\theta} = -b\\dot{\\theta}+T+T_d = -b\\dot{\\theta}+K_ti +T_d\n\\end{cases}\\]\nand defining \\(x=\\begin{bmatrix} x_1 & x_2 & x_3 \\end{bmatrix}^T=\\begin{bmatrix} \\dot{\\theta} & \\theta & i \\end{bmatrix}^T\\) yields the state space form:\n\\[\\begin{cases}\n      \\dot{x} = \\begin{bmatrix} -\\frac{b}{J} & 0 & \\frac{K_t}{J} \\\\ 1 & 0 & 0 \\\\ -\\frac{K_b}{L} & 0 & -\\frac{R}{L} \\end{bmatrix}x + \\begin{bmatrix} 0 & \\frac{1}{J} \\\\ 0 & 0 \\\\ \\frac{1}{L} & 0 \\end{bmatrix}\\begin{bmatrix} V \\\\ T_d \\end{bmatrix} \\\\\n      y = \\begin{bmatrix} 0 & 1 & 0 \\end{bmatrix}x \\, .\n\\end{cases}\\]\nThe goal is to design a regulator that regulates the variable \\(\\theta\\) using the input \\(V\\) according to: - settling time for 5% tolerance band of less than 0.06 seconds; - no steady-state error in response to a step position request; - full rejection of step-like disturbances \\(T_d\\) (e.g. zero steady-state error in motor position when a step disturbance is applied); - \\(|V|\\leq 2.4\\) \\(V\\).\n\nRegulator design\n\nController design\nTo meet the requirement of zero steady-state error and full rejection of step-like disturbances we add an integrator in the state feedback control by defining a new state \\(\\dot{x_4} = \\theta-y_d\\), where \\(y_d\\) is the reference input. The new state equations became:\n\\[\\begin{cases}\n      \\dot{x_a} = \\begin{bmatrix} -\\frac{b}{J} & 0 & \\frac{K_t}{J} & 0 \\\\ 1 & 0 & 0 & 0 \\\\ -\\frac{K_b}{L} & 0 & -\\frac{R}{L} & 0 \\\\ 0 & 1 & 0 & 0 \\end{bmatrix}x_a + \\begin{bmatrix} 0 & \\frac{1}{J} & 0 \\\\ 0 & 0 & 0 \\\\ \\frac{1}{L} & 0 & 0 \\\\ 0 & 0 & -1 \\end{bmatrix}\\begin{bmatrix} V \\\\ T_d \\\\ y_d \\end{bmatrix} \\\\\n      y_a = \\begin{bmatrix} 0 & 1 & 0 & 0 \\\\ 0 & 0 & 0 & 1 \\end{bmatrix}x_a \\, .\n\\end{cases}\\]\nSince the augmented system still remains controllable with the input \\(V\\) we design a state feedback control with only this input.\nThe poles of the system are:\n\nb = 3.3E-6\nJ = 4E-6\nKb = 0.03\nKt = 0.03\nR = 5\nL = 3E-3\n\nA = [[-b/J, 0, Kt/J, 0],\n     [1, 0, 0, 0],\n     [-Kb/L, 0, -R/L, 0],\n     [0, 1, 0, 0]]\nA = numpy.matrix(A)\n\nB = [[0, 1/J, 0],\n     [0, 0, 0],\n     [1/L, 0, 0],\n     [0, 0, -1]]\nB = numpy.matrix(B)\nBu = B[:,0]\nBd = B[:,1]\nBr = B[:,2]\n\nC = [[0,1,0,0],\n     [0,0,0,1]]\nC = numpy.matrix(C)\n\nD = numpy.zeros((2,3))\n\ndisplay(Markdown(bmatrix(numpy.linalg.eigvals(A).round(3))))\n# print(numpy.linalg.matrix_rank(control.ctrb(A,Bu)))\n\n\\[\\begin{bmatrix}\n  0. & 0. & -1620.357 & -47.135\\\\\n\\end{bmatrix}\\]\n\n\nand since the mode associated with the pole in \\(-1620.4\\) would have a settling time shorter that \\(0.06\\) s we leave the pole as it is. We increase the frequency of the pole from \\(-45.8\\) to \\(-100\\), and place the two integrators in \\(-110\\).\n\n\nDesign of the observer\nFor the observer we consider the augmented system and \\(y_a\\) and we place the poles in \\(-5000\\) in order to have an estimation dynamics faster than that of the closed-loop plant poles.\n\n\n\nHow to use this notebook?\n\nVerify the performance with \\(0\\leq T_d\\leq +5\\) mNm.\nVerify the performance with \\(0\\geq T_d\\geq -5\\) mNm and if the requirements are not met, attempt a control system redesign.\nVerify the performance in presence of a sinusoidal \\(T_d\\) with a period equal to \\(0.01\\) s.\nWhen the system is subject to a disturbance the estimated states does not converge to \\(0\\). Why?\n\n\n# Preparatory cell\n\nX0 = numpy.matrix('0.0; 0.0; 0.0; 0.0')\nK = numpy.matrix([0,0,0,0])\nL = numpy.matrix([[0,0],[0,0],[0,0],[0,0]])\n\nX0w = matrixWidget(4,1)\nX0w.setM(X0)\nKw = matrixWidget(1,4)\nKw.setM(K)\nLw = matrixWidget(4,2)\nLw.setM(L)\n\n\neig1c = matrixWidget(1,1)\neig2c = matrixWidget(2,1)\neig3c = matrixWidget(1,1)\neig4c = matrixWidget(2,1)\neig1c.setM(numpy.matrix([-1620.357])) \neig2c.setM(numpy.matrix([[-110.],[-0.0]]))\neig3c.setM(numpy.matrix([-100.0]))\neig4c.setM(numpy.matrix([[-110],[-0.0]]))\n\neig1o = matrixWidget(1,1)\neig2o = matrixWidget(2,1)\neig3o = matrixWidget(1,1)\neig4o = matrixWidget(2,1)\neig1o.setM(numpy.matrix([-5000.])) \neig2o.setM(numpy.matrix([[-5010.],[0.]]))\neig3o.setM(numpy.matrix([-5020.]))\neig4o.setM(numpy.matrix([[-5030.],[0.]]))\n\n\n# Misc\n\n#create dummy widget \nDW = widgets.FloatText(layout=widgets.Layout(width='0px', height='0px'))\n\n#create button widget\nSTART = widgets.Button(\n    description='Test',\n    disabled=False,\n    button_style='', # 'success', 'info', 'warning', 'danger' or ''\n    tooltip='Test',\n    icon='check'\n)\n                       \ndef on_start_button_clicked(b):\n    #This is a workaround to have intreactive_output call the callback:\n    #   force the value of the dummy widget to change\n    if DW.value&gt; 0 :\n        DW.value = -1\n    else: \n        DW.value = 1\n    pass\nSTART.on_click(on_start_button_clicked)\n\n# Define type of method \nselm = widgets.Dropdown(\n    options= ['Set K and L', 'Set the eigenvalues'],\n    value= 'Set the eigenvalues',\n    description='',\n    disabled=False\n)\n\n# Define the number of complex eigenvalues\nselec = widgets.Dropdown(\n    options= ['0 complex eigenvalues', '2 complex eigenvalues', '4 complex eigenvalues'],\n    value= '0 complex eigenvalues',\n    description='Eig controller:',\n    disabled=False\n)\nseleo = widgets.Dropdown(\n    options= ['0 complex eigenvalues', '2 complex eigenvalues'],\n    value= '0 complex eigenvalues',\n    description='Eig observer:',\n    disabled=False\n)\n\n#define type of ipout \nselu = widgets.Dropdown(\n    options=['impulse', 'step', 'sinusoid', 'square wave'],\n    value='step',\n    description='Type of disturbance:',\n    style = {'description_width': 'initial'},\n    disabled=False\n)\n# Define the values of the input\nu = widgets.FloatSlider(\n    value=45,\n    min=0,\n    max=90,\n    step=1,\n    description='Reference [deg]:',\n    disabled=False,\n    continuous_update=False,\n    orientation='horizontal',\n    readout=True,\n    readout_format='.3f',\n)\nud = widgets.FloatSlider(\n    value=0,\n    min=-10.,\n    max=10.,\n    step=0.1,\n    description=r'$T_d$ [mNm]:',\n    disabled=False,\n    continuous_update=False,\n    orientation='horizontal',\n    readout=True,\n    readout_format='.1f',\n)\nperiod = widgets.FloatSlider(\n    value=0.01,\n    min=0.001,\n    max=0.1,\n    step=0.001,\n    description='Period [s]: ',\n    disabled=False,\n    continuous_update=False,\n    orientation='horizontal',\n    readout=True,\n    readout_format='.3f',\n)\n\nsimTime = widgets.FloatText(\n    value=0.1,\n    description='',\n    disabled=False\n)\n\n\n# Support functions\n\ndef eigen_choice(selec,seleo):\n    if selec == '0 complex eigenvalues':\n        eig1c.children[0].children[0].disabled = False\n        eig2c.children[1].children[0].disabled = True\n        eig3c.children[0].children[0].disabled = False\n        eig4c.children[0].children[0].disabled = False\n        eig4c.children[1].children[0].disabled = True\n        eigc = 0\n    if seleo == '0 complex eigenvalues':\n        eig1o.children[0].children[0].disabled = False\n        eig2o.children[1].children[0].disabled = True\n        eig3o.children[0].children[0].disabled = False\n        eig4o.children[0].children[0].disabled = False\n        eig4o.children[1].children[0].disabled = True\n        eigo = 0\n    if selec == '2 complex eigenvalues':\n        eig1c.children[0].children[0].disabled = False\n        eig2c.children[1].children[0].disabled = False\n        eig3c.children[0].children[0].disabled = False\n        eig4c.children[0].children[0].disabled = True\n        eig4c.children[1].children[0].disabled = True\n        eigc = 2\n    if seleo == '2 complex eigenvalues':\n        eig1o.children[0].children[0].disabled = False\n        eig2o.children[1].children[0].disabled = False\n        eig3o.children[0].children[0].disabled = False\n        eig4o.children[0].children[0].disabled = True\n        eig4o.children[1].children[0].disabled = True\n        eigo = 2\n    if selec == '4 complex eigenvalues':\n        eig1c.children[0].children[0].disabled = True\n        eig2c.children[1].children[0].disabled = False\n        eig3c.children[0].children[0].disabled = True\n        eig4c.children[0].children[0].disabled = False\n        eig4c.children[1].children[0].disabled = False\n        eigc = 4\n    if seleo == '4 complex eigenvalues':\n        eig1o.children[0].children[0].disabled = True\n        eig2o.children[1].children[0].disabled = False\n        eig3o.children[0].children[0].disabled = True\n        eig4o.children[0].children[0].disabled = False\n        eig4o.children[1].children[0].disabled = False\n        eigo = 4\n    return eigc, eigo\n\ndef method_choice(selm):\n    if selm == 'Set K and L':\n        method = 1\n        selec.disabled = True\n        seleo.disabled = True\n    if selm == 'Set the eigenvalues':\n        method = 2\n        selec.disabled = False\n        seleo.disabled = False\n    return method\n\n\nimport warnings\n# In order to suppress the warnings for tolerance\nwarnings.filterwarnings(\"ignore\")\n\ndef main_callback2(ud, X0w, K, L, eig1c, eig2c, eig3c, eig4c, eig1o, eig2o, eig3o, eig4o, u, period, selm, selec, seleo, selu, simTime, DW):\n    eigc, eigo = eigen_choice(selec,seleo)\n    method = method_choice(selm)\n    \n    if method == 1:\n        solc = numpy.linalg.eig(A-Bu*K)\n        solo = numpy.linalg.eig(A-L*C)\n    if method == 2:\n        #for bettere numerical stability of place\n        if eig1c[0,0]==eig2c[0,0] or eig1c[0,0]==eig3c[0,0] or eig1c[0,0]==eig4c[0,0]:\n            eig1c[0,0] *= 1.01\n        if eig2c[0,0]==eig3c[0,0] or eig2c[0,0]==eig4c[0,0]:\n            eig3c[0,0] *= 1.015\n        if eig1o[0,0]==eig2o[0,0] or eig1o[0,0]==eig3o[0,0] or eig1o[0,0]==eig4o[0,0]:\n            eig1o[0,0] *= 1.01\n        if eig2o[0,0]==eig3o[0,0] or eig2o[0,0]==eig4o[0,0]:\n            eig3o[0,0] *= 1.015\n            \n        if eigc == 0:\n            K = control.acker(A, Bu, [eig1c[0,0], eig2c[0,0], eig3c[0,0], eig4c[0,0]])\n            Kw.setM(K)\n        if eigc == 2:\n            K = control.acker(A, Bu, [eig3c[0,0],\n                                      eig1c[0,0],\n                                      numpy.complex(eig2c[0,0], eig2c[1,0]), \n                                      numpy.complex(eig2c[0,0],-eig2c[1,0])])\n            Kw.setM(K)\n        if eigc == 4:\n            K = control.acker(A, Bu, [numpy.complex(eig4c[0,0], eig4c[1,0]), \n                                      numpy.complex(eig4c[0,0],-eig4c[1,0]),\n                                      numpy.complex(eig2c[0,0], eig2c[1,0]), \n                                      numpy.complex(eig2c[0,0],-eig2c[1,0])])\n            Kw.setM(K)\n        if eigo == 0:\n            L = control.place(A.T, C.T, [eig1o[0,0], eig2o[0,0], eig3o[0,0], eig4o[0,0]]).T\n            Lw.setM(L)\n        if eigo == 2:\n            L = control.place(A.T, C.T, [eig3o[0,0],\n                                         eig1o[0,0],\n                                         numpy.complex(eig2o[0,0], eig2o[1,0]), \n                                         numpy.complex(eig2o[0,0],-eig2o[1,0])]).T\n            Lw.setM(L)\n        if eigo == 4:\n            L = control.place(A.T, C.T, [numpy.complex(eig4o[0,0], eig4o[1,0]), \n                                      numpy.complex(eig4o[0,0],-eig4o[1,0]),\n                                      numpy.complex(eig2o[0,0], eig2o[1,0]), \n                                      numpy.complex(eig2o[0,0],-eig2o[1,0])]).T\n            Lw.setM(L)\n            \n    sys = sss(A,numpy.hstack((Bu,Bd,Br)),[[0,1,0,0],[0,0,0,1],[0,0,0,0],[0,0,0,0]],[[0,0,0],[0,0,0],[1,0,0],[0,0,1]])\n    syse = sss(A-L*C,numpy.hstack((Bu,Br,L)),numpy.eye(4),numpy.zeros((4,4)))\n    sysc = sss(0,[0,0,0,0],0,-K)\n    sys_append = control.append(sys,syse,sysc)\n    try:\n        sys_CL = control.connect(sys_append,\n                                 [[1,9],[4,3],[5,4],[6,1],[7,2],[8,5],[9,6],[10,7],[11,8]],\n                                 [3,2],\n                                 [1,3])\n    except:\n        sys_CL = control.connect(sys_append,\n                                 [[1,9],[4,3],[5,4],[6,1],[7,2],[8,5],[9,6],[10,7],[11,8]],\n                                 [3,2],\n                                 [1,3])\n\n    X0w1 = numpy.zeros((8,1))\n    X0w1[4,0] = X0w[0,0]\n    X0w1[5,0] = X0w[1,0]\n    X0w1[6,0] = X0w[2,0]\n    X0w1[7,0] = X0w[3,0]\n    if simTime != 0:\n        T = numpy.linspace(0, simTime, 10000)\n    else:\n        T = numpy.linspace(0, 1, 10000)\n      \n    ud = ud/1000\n    u = u*numpy.pi/180\n    if selu == 'impulse': #selu\n        Ud = [0 for t in range(0,len(T))]\n        Ud[0] = ud\n        U = [u for t in range(0,len(T))]\n        T, yout, xout = control.forced_response(sys_CL,T,[U,Ud],X0w1)\n    if selu == 'step':\n        U = [u for t in range(0,len(T))]\n        Ud = [ud for t in range(0,len(T))]\n        T, yout, xout = control.forced_response(sys_CL,T,[U,Ud],X0w1)\n    if selu == 'sinusoid':\n        Ud = ud*numpy.sin(2*numpy.pi/period*T)\n        U = [u for t in range(0,len(T))]\n        T, yout, xout = control.forced_response(sys_CL,T,[U,Ud],X0w1)\n    if selu == 'square wave':\n        Ud = ud*numpy.sign(numpy.sin(2*numpy.pi/period*T))\n        U = [u for t in range(0,len(T))]\n        T, yout, xout = control.forced_response(sys_CL,T,[U,Ud],X0w1)\n    \n    try:\n        step_info_dict = control.step_info(sys_CL[0,0],SettlingTimeThreshold=0.05,T=T)\n        print('Step info: \\n\\tRise time =',step_info_dict['RiseTime'],'\\n\\tSettling time (5%) =',step_info_dict['SettlingTime'],'\\n\\tOvershoot (%)=',step_info_dict['Overshoot'])\n        print('Max u value (% of 2.4V)=', max(abs(yout[1]))/(2.4)*100)\n    except:\n        print(\"Error in the calculation of step info.\")\n    \n    fig = plt.figure(num='Simulation1', figsize=(14,12))\n    \n    fig.add_subplot(221)\n    plt.title('Output response')\n    plt.ylabel('Output [rad]')\n    plt.plot(T,yout[0],T,U,'r--')\n    plt.xlabel('$t$ [s]')\n    plt.legend(['$y$','Reference'])\n    plt.axvline(x=0,color='black',linewidth=0.8)\n    plt.axhline(y=0,color='black',linewidth=0.8)\n    plt.grid()\n    \n    fig.add_subplot(222)\n    plt.title('Input')\n    plt.ylabel('$u$ [V]')\n    plt.plot(T,yout[1])\n    plt.plot(T,[2.4 for i in range(len(T))],'r--')\n    plt.plot(T,[-2.4 for i in range(len(T))],'r--')\n    plt.xlabel('$t$ [s]')\n    plt.axvline(x=0,color='black',linewidth=0.8)\n    plt.axhline(y=0,color='black',linewidth=0.8)\n    plt.grid()\n    \n    fig.add_subplot(223)\n    plt.title('Disturbance')\n    plt.ylabel('$T_d$ [Nm]')\n    plt.plot(T,Ud,'r')\n    plt.xlabel('$t$ [s]')\n    plt.axvline(x=0,color='black',linewidth=0.8)\n    plt.axhline(y=0,color='black',linewidth=0.8)\n    plt.grid()\n    \n    fig.add_subplot(224)\n    plt.title('Estimation errors')\n    plt.ylabel('Errors')\n    plt.plot(T,xout[4]-xout[0])\n    plt.plot(T,xout[5]-xout[1])\n    plt.plot(T,xout[6]-xout[2])\n    plt.plot(T,xout[7]-xout[3])\n    plt.xlabel('$t$ [s]')\n    plt.legend(['$e_{1}$','$e_{2}$','$e_{3}$','$e_{4}$'])\n    plt.axvline(x=0,color='black',linewidth=0.8)\n    plt.axhline(y=0,color='black',linewidth=0.8)\n    plt.grid()\n    #plt.tight_layout()\n   \nalltogether2 = widgets.VBox([widgets.HBox([selm, \n                                          selec,\n                                          seleo,\n                                          selu]),\n                            widgets.Label(' ',border=3),\n                            widgets.HBox([widgets.HBox([widgets.Label('K:',border=3), Kw, \n                                                        widgets.Label('Eigenvalues:',border=3),\n                                                        widgets.HBox([eig1c, \n                                                                      eig2c, \n                                                                      eig3c,\n                                                                      eig4c])])]),\n                            widgets.Label(' ',border=3),\n                            widgets.HBox([widgets.VBox([widgets.HBox([widgets.Label('L:',border=3), Lw, widgets.Label(' ',border=3),\n                                          widgets.Label(' ',border=3),\n                                          widgets.Label('Eigenvalues:',border=3), \n                                          eig1o, \n                                          eig2o,\n                                          eig3o, \n                                          eig4o,\n                                          widgets.Label(' ',border=3),\n                                          widgets.Label(' ',border=3),\n                                          widgets.Label('X0 est.:',border=3), X0w]),\n                                          widgets.Label(' ',border=3),\n                                                       widgets.HBox([\n                                          widgets.VBox([widgets.Label('Simulation time (s):',border=3)]),\n                                          widgets.VBox([simTime])])]),\n                                          widgets.Label(' ',border=3)]),\n                            widgets.Label(' ',border=3),\n                            widgets.HBox([u,\n                                          ud,\n                                          period, \n                                          START])])\nout2 = widgets.interactive_output(main_callback2, {'ud':ud, 'X0w':X0w, 'K':Kw, 'L':Lw,\n                                                   'eig1c':eig1c, 'eig2c':eig2c, 'eig3c':eig3c, 'eig4c':eig4c, \n                                                   'eig1o':eig1o, 'eig2o':eig2o, 'eig3o':eig3o, 'eig4o':eig4o,  \n                                                   'u':u, 'period':period, 'selm':selm, 'selec':selec, 'seleo':seleo, 'selu':selu, 'simTime':simTime, 'DW':DW})\nout2.layout.height = '860px'\ndisplay(out2, alltogether2)"
  },
  {
    "objectID": "ICCT_en/examples/04/SS-43-Hard_Disk_head_control.html",
    "href": "ICCT_en/examples/04/SS-43-Hard_Disk_head_control.html",
    "title": "Hard disk head control",
    "section": "",
    "text": "#remove cell visibility\nfrom IPython.display import HTML\ntag = HTML('''&lt;script&gt;\ncode_show=true; \nfunction code_toggle() {\n    if (code_show){\n        $('div.input').hide()\n    } else {\n        $('div.input').show()\n    }\n    code_show = !code_show\n} \n$( document ).ready(code_toggle);\n&lt;/script&gt;\nToggle cell visibility &lt;a href=\"javascript:code_toggle()\"&gt;here&lt;/a&gt;.''')\ndisplay(tag)\n\n\nToggle cell visibility here.\n\n\n\n%matplotlib inline\nimport control\nimport numpy\nimport sympy as sym\nfrom IPython.display import display, Markdown\nimport ipywidgets as widgets\nimport matplotlib.pyplot as plt\n\n\n#print a matrix latex-like\ndef bmatrix(a):\n     \"\"\"Returns a LaTeX bmatrix - by Damir Arbula (ICCT project)\n\n     :a: numpy array\n     :returns: LaTeX bmatrix as a string\n     \"\"\"\n     if len(a.shape) &gt; 2:\n         raise ValueError('bmatrix can at most display two dimensions')\n     lines = str(a).replace('[', '').replace(']', '').splitlines()\n     rv = [r'\\begin{bmatrix}']\n     rv += ['  ' + ' & '.join(l.split()) + r'\\\\' for l in lines]\n     rv +=  [r'\\end{bmatrix}']\n     return '\\n'.join(rv)\n\n\n# Display formatted matrix: \ndef vmatrix(a):\n    if len(a.shape) &gt; 2:\n         raise ValueError('bmatrix can at most display two dimensions')\n    lines = str(a).replace('[', '').replace(']', '').splitlines()\n    rv = [r'\\begin{vmatrix}']\n    rv += ['  ' + ' & '.join(l.split()) + r'\\\\' for l in lines]\n    rv +=  [r'\\end{vmatrix}']\n    return '\\n'.join(rv)\n\n\n#matrixWidget is a matrix looking widget built with a VBox of HBox(es) that returns a numPy array as value !\nclass matrixWidget(widgets.VBox):\n    def updateM(self,change):\n        for irow in range(0,self.n):\n            for icol in range(0,self.m):\n                self.M_[irow,icol] = self.children[irow].children[icol].value\n                #print(self.M_[irow,icol])\n        self.value = self.M_\n\n    def dummychangecallback(self,change):\n        pass\n    \n    \n    def __init__(self,n,m):\n        self.n = n\n        self.m = m\n        self.M_ = numpy.matrix(numpy.zeros((self.n,self.m)))\n        self.value = self.M_\n        widgets.VBox.__init__(self,\n                             children = [\n                                 widgets.HBox(children = \n                                              [widgets.FloatText(value=0.0, layout=widgets.Layout(width='90px')) for i in range(m)]\n                                             ) \n                                 for j in range(n)\n                             ])\n        \n        #fill in widgets and tell interact to call updateM each time a children changes value\n        for irow in range(0,self.n):\n            for icol in range(0,self.m):\n                self.children[irow].children[icol].value = self.M_[irow,icol]\n                self.children[irow].children[icol].observe(self.updateM, names='value')\n        #value = Unicode('example@example.com', help=\"The email value.\").tag(sync=True)\n        self.observe(self.updateM, names='value', type= 'All')\n        \n    def setM(self, newM):\n        #disable callbacks, change values, and reenable\n        self.unobserve(self.updateM, names='value', type= 'All')\n        for irow in range(0,self.n):\n            for icol in range(0,self.m):\n                self.children[irow].children[icol].unobserve(self.updateM, names='value')\n        self.M_ = newM\n        self.value = self.M_\n        for irow in range(0,self.n):\n            for icol in range(0,self.m):\n                self.children[irow].children[icol].value = self.M_[irow,icol]\n        for irow in range(0,self.n):\n            for icol in range(0,self.m):\n                self.children[irow].children[icol].observe(self.updateM, names='value')\n        self.observe(self.updateM, names='value', type= 'All')        \n\n                #self.children[irow].children[icol].observe(self.updateM, names='value')\n\n             \n#overlaod class for state space systems that DO NOT remove \"useless\" states (what \"professor\" of automatic control would do this?)\nclass sss(control.StateSpace):\n    def __init__(self,*args):\n        #call base class init constructor\n        control.StateSpace.__init__(self,*args)\n    #disable function below in base class\n    def _remove_useless_states(self):\n        pass\n\n\nThe hard disk arm that supports the reading head rotates on a viscous bearing and is powered by an electric motor; a return spring of torsional stiffness \\(k\\) opposes to its motion. The bearing possesses a light viscous friction, proportional to head arm rotation velocity, with constant \\(b\\). The arm actuator is capable of generating a torque \\(T\\) linearly proportional to the current \\(I\\) flowing inside the actuation coil: \\(T = k_iI\\). The arm inertia is \\(J\\). A sensor measures the arm angular position \\(\\theta\\).\nThe system constants are: - \\(J = 0.001\\) kg\\(\\text{m}^2\\), - \\(k_i = 500\\) Nm/A, - \\(k = 1\\) Nm/rad, - \\(b = 0.04\\) Nm/(rad/s).\nThe goal is to design a regulator for the arm position according to the following specifications: - no overshoot, - settling time for 2% tolerance band of less than 50 milliseconds, - zero steady-state error in response to a step-wise change of the desired arm position, - the input current does not exceed 5 A in response to an input step of 30 degrees.\nThe system’s equation is: \\[\nJ\\ddot{\\theta} = k_iI - b\\dot{\\theta} - k\\theta\n\\]\nDefining the state vector as \\(x=\\begin{bmatrix}x_1 & x_2\\end{bmatrix}^T=\\begin{bmatrix}\\theta & \\dot{\\theta}\\end{bmatrix}^T\\) and \\(u=I\\), the system equation in matrix form becomes:\n\\[\\begin{cases}\n\\dot{x} = \\begin{bmatrix} 0 & 1 \\\\ -k & -b \\end{bmatrix}x + \\begin{bmatrix} 0 \\\\ k_i \\end{bmatrix}u \\\\\ny = \\begin{bmatrix} 1 & 0 \\end{bmatrix}x\n\\end{cases}\\]\nIn order to achieve zero steady-state error we augment the plant with a new state defined as \\(\\dot{x_3}=y-y_d=x_1-y_d\\). The equations therefore become:\n\\[\\begin{cases}\n\\dot{x_a} = \\begin{bmatrix} 0 & 1 & 0 \\\\ -k & -b & 0 \\\\ 1 & 0 & 0 \\end{bmatrix}x_a + \\begin{bmatrix} 0 & 0 \\\\ k_i & 0 \\\\ 0 & -1 \\end{bmatrix}\\begin{bmatrix} u \\\\ y_d \\end{bmatrix} \\\\\ny = \\begin{bmatrix} 1 & 0 & 0 \\\\ 0 & 0 & 1 \\end{bmatrix}x\n\\end{cases}\\]\nThe controllability matrix \\(\\mathcal{C}\\), considering only the input \\(u\\), is\n\nA = numpy.matrix('0 1 0; -1 -0.04 0; 1 0 0')\nB = numpy.matrix('0 0; 500 0; 0 -1')\nC = numpy.matrix('1 0 0; 0 0 1')\nD = numpy.matrix('0 0; 0 0')\n\nCM = control.ctrb(A,B[:,0])\ndisplay(Markdown(bmatrix(CM)))\n# print(numpy.linalg.matrix_rank(CM))\n\n\\[\\begin{bmatrix}\n  0. & 500. & -20.\\\\\n  500. & -20. & -499.2\\\\\n  0. & 0. & 500.\\\\\n\\end{bmatrix}\\]\n\n\nand has rank equal to 3 so the system is controllable. The observability matrix \\(\\mathcal{O}\\) is\n\nOM = control.obsv(A,C)\ndisplay(Markdown(bmatrix(OM)))\n# print(numpy.linalg.matrix_rank(OM))\n\n\\[\\begin{bmatrix}\n  1. & 0. & 0.\\\\\n  0. & 0. & 1.\\\\\n  0. & 1. & 0.\\\\\n  1. & 0. & 0.\\\\\n  -1. & -0.04 & 0.\\\\\n  0. & 1. & 0.\\\\\n\\end{bmatrix}\\]\n\n\nand has rank equal to 3 so the system is observable.\n\nRegulator design\n\nController design\nWe design the state feedback gain considering only the input \\(u\\) while for the reference we utilize \\(y_d\\). The transient specifications can be obtained if the closed-loop dominant poles are placed in \\(-100.02\\pm101i\\), and setting the third pole at least not slower, like for instance in \\(-100\\). This is achieved with the gain matrix: \\[\nK = \\begin{bmatrix} 80.416 & 0.6 & 4041.0 \\end{bmatrix}.\n\\]\n\n\nObserver design\nIn order to have a good estimate of the state and, therefore, a quick convergence to zero of the estimation error, we place the poles of the observer in \\(-151\\), \\(-152\\) and \\(-153\\) (faster than the poles of the controlled system). The observer gain matrix that results is: \\[\nL = \\begin{bmatrix} 300.96 & 3.028e-12 \\\\\n2.264e+04 & 4.55e-10 \\\\\n1.0 & 150.0 \\end{bmatrix}.\n\\]\nSimulations are shown below. Note that by augmenting the state vector we assure that the closed-loop gain is always 1.\n\n\n\nHow to use this notebook?\n\nTry to improve the response in the case of an initial small error (about 0.05) in the first two elements of the observer initial condition (parameter X0 est. below).\nN.B. Introducing an initial error in the third component of the estimated state makes little sense since the third state has dynamics defined by us. We could have also developed an observer only for \\(x_2\\) since we measure \\(x_1\\) and we know \\(x_3\\).\n\n\n# Preparatory cell\n\nX0 = numpy.matrix('0.0; 0.0; 0.0')\nK = numpy.matrix([8/15,-4.4,-4])\nL = numpy.matrix([[300, 3.028E-12],[2.264E+04, 4.55E-10],[1, 150]])\n\nAw = matrixWidget(3,3)\nAw.setM(A)\nBw = matrixWidget(3,1)\nBw.setM(B)\nCw = matrixWidget(1,3)\nCw.setM(C)\nX0w = matrixWidget(3,1)\nX0w.setM(X0)\nKw = matrixWidget(1,3)\nKw.setM(K)\nLw = matrixWidget(3,2)\nLw.setM(L)\n\n\neig1c = matrixWidget(1,1)\neig2c = matrixWidget(2,1)\neig3c = matrixWidget(1,1)\neig1c.setM(numpy.matrix([-100.])) \neig2c.setM(numpy.matrix([[-100.02],[-101.]]))\neig3c.setM(numpy.matrix([-100.]))\n\neig1o = matrixWidget(1,1)\neig2o = matrixWidget(2,1)\neig3o = matrixWidget(1,1)\neig1o.setM(numpy.matrix([-150.])) \neig2o.setM(numpy.matrix([[-151.],[0.]]))\neig3o.setM(numpy.matrix([-152.]))\n\n\n# Misc\n\n#create dummy widget \nDW = widgets.FloatText(layout=widgets.Layout(width='0px', height='0px'))\n\n#create button widget\nSTART = widgets.Button(\n    description='Test',\n    disabled=False,\n    button_style='', # 'success', 'info', 'warning', 'danger' or ''\n    tooltip='Test',\n    icon='check'\n)\n                       \ndef on_start_button_clicked(b):\n    #This is a workaround to have intreactive_output call the callback:\n    #   force the value of the dummy widget to change\n    if DW.value&gt; 0 :\n        DW.value = -1\n    else: \n        DW.value = 1\n    pass\nSTART.on_click(on_start_button_clicked)\n\n# Define type of method \nselm = widgets.Dropdown(\n    options= ['Set K and L', 'Set the eigenvalues'],\n    value= 'Set the eigenvalues',\n    description='',\n    disabled=False\n)\n\n# Define the number of complex eigenvalues\nsele = widgets.Dropdown(\n    options= ['0 complex eigenvalues', '2 complex eigenvalues'],\n    value= '2 complex eigenvalues',\n    description='Complex eigenvalues:',\n    style = {'description_width': 'initial'},\n    disabled=False\n)\n\n#define type of ipout \nselu = widgets.Dropdown(\n    options=['impulse', 'step', 'sinusoid', 'square wave'],\n    value='step',\n    description='Type of reference:',\n    style = {'description_width': 'initial'},\n    disabled=False\n)\n# Define the values of the input\nu = widgets.FloatSlider(\n    value=30*numpy.pi/180,\n    min=0,\n    max=45*numpy.pi/180,\n    step=0.05,\n    description='Reference:',\n    disabled=False,\n    continuous_update=False,\n    orientation='horizontal',\n    readout=True,\n    readout_format='.1f',\n)\nperiod = widgets.FloatSlider(\n    value=0.5,\n    min=0.001,\n    max=10,\n    step=0.001,\n    description='Period: ',\n    disabled=False,\n    continuous_update=False,\n    orientation='horizontal',\n    readout=True,\n    readout_format='.2f',\n)\n\ngain_w2 = widgets.FloatText(\n    value=1.,\n    description='',\n    disabled=True\n)\n\nsimTime = widgets.FloatText(\n    value=0.5,\n    description='',\n    disabled=False\n)\n\n\n# Support functions\n\ndef eigen_choice(sele):\n    if sele == '0 complex eigenvalues':\n        eig1c.children[0].children[0].disabled = False\n        eig2c.children[1].children[0].disabled = True\n        eig1o.children[0].children[0].disabled = False\n        eig2o.children[1].children[0].disabled = True\n        eig = 0\n    if sele == '2 complex eigenvalues':\n        eig1c.children[0].children[0].disabled = True\n        eig2c.children[1].children[0].disabled = False\n        eig1o.children[0].children[0].disabled = True\n        eig2o.children[1].children[0].disabled = False\n        eig = 2\n    return eig\n\ndef method_choice(selm):\n    if selm == 'Set K and L':\n        method = 1\n        sele.disabled = True\n    if selm == 'Set the eigenvalues':\n        method = 2\n        sele.disabled = False\n    return method\n\n\nnumU = 1\n\ndef main_callback2(Aw, Bw, X0w, K, L, eig1c, eig2c, eig3c, eig1o, eig2o, eig3o, u, period, selm, sele, selu, simTime, DW):\n    eige = eigen_choice(sele)\n    method = method_choice(selm)\n    \n    if method == 1:\n        solc = numpy.linalg.eig(A-B[:,0:numU]*K)\n        solo = numpy.linalg.eig(A-L*C)\n    if method == 2:\n        if eige == 0:\n            K = control.acker(A, B[:,0:numU], [eig1c[0,0], eig2c[0,0], eig3c[0,0]])\n            Kw.setM(K)\n            L = control.place(A.T, C.T, [eig1o[0,0], eig2o[0,0], eig3o[0,0]]).T\n            Lw.setM(L)\n        if eige == 2:\n            K = control.acker(A, B[:,0:numU], [eig3c[0,0], \n                                     numpy.complex(eig2c[0,0],eig2c[1,0]), \n                                     numpy.complex(eig2c[0,0],-eig2c[1,0])])\n            Kw.setM(K)\n            L = control.place(A.T, C.T, [eig3o[0,0], \n                                         numpy.complex(eig2o[0,0],eig2o[1,0]), \n                                         numpy.complex(eig2o[0,0],-eig2o[1,0])]).T\n            Lw.setM(L)\n            \n    \n    sys = control.ss(A,B,numpy.vstack((C,numpy.zeros((B.shape[1],C.shape[1])))),numpy.vstack((D,numpy.eye(B.shape[1]))))\n    sysC = control.ss(numpy.zeros((1,1)),\n                      numpy.zeros((1,numpy.shape(A)[0])),\n                      numpy.zeros((numpy.shape(B[:,0:numU])[1],1)),\n                      -K)\n    \n    sysE = control.ss(A-L*C,\n                      numpy.hstack((L,B-L*D)),\n                      numpy.eye(numpy.shape(A)[0]),\n                      numpy.zeros((A.shape[0],C.shape[0]+B.shape[1])))\n    \n    sys_append = control.append(sys, sysE, sysC, control.ss(A,B,numpy.eye(A.shape[0]),numpy.zeros((A.shape[0],B.shape[1]))))\n    Q = []\n    # y in ingresso a sysE\n    for i in range(C.shape[0]):\n        Q.append([B.shape[1]+i+1, i+1])\n    # u in ingresso a sysE\n    for i in range(B.shape[1]):\n        Q.append([B.shape[1]+C.shape[0]+i+1, C.shape[0]+i+1])\n    # u in ingresso a sys\n    for i in range(B[:,0:numU].shape[1]):\n        Q.append([i+1, C.shape[0]+B.shape[1]+A.shape[0]+i+1])\n    # u in ingresso al sistema che ha come uscite gli stati reali\n    for i in range(B.shape[1]):\n        Q.append([2*B.shape[1]+C.shape[0]+A.shape[0]+i+1, C.shape[0]+i+1])\n    # xe in ingresso a sysC\n    for i in range(A.shape[0]):\n        Q.append([2*B.shape[1]+C.shape[0]+i+1, C.shape[0]+B.shape[1]+i+1])\n        \n    inputv = [i+numU+1 for i in range(B[:,numU:].shape[1])]\n    outputv = [i+1 for i in range(numpy.shape(sys_append.C)[0])]\n    # in order to avoid singular value exception\n    try:\n        sys_CL = control.connect(sys_append, Q, inputv, outputv)\n    except:\n        sys_CL = control.connect(sys_append, Q, inputv, outputv)\n    \n    dcgain = control.dcgain(sys_CL[0,0])\n    gain_w2.value = dcgain\n    if dcgain != 0:\n        u1 = u/gain_w2.value\n    else:\n        print('The feedforward gain setted is 0 and it is changed to 1')\n        u1 = u/1\n    print('The static gain of the closed-loop system (from the reference to the output) is: %.5f' %dcgain)\n    \n    X0w1 = numpy.zeros((A.shape[0],1))\n    for j in range(A.shape[0]):\n        X0w1 = numpy.vstack((X0w1,X0w[j]))\n    X0w1 = numpy.vstack((X0w1,numpy.zeros((A.shape[0],1))))\n    if simTime != 0:\n        T = numpy.linspace(0, simTime, 10000)\n    else:\n        T = numpy.linspace(0, 1, 10000)\n      \n    if selu == 'impulse': #selu\n        U = [0 for t in range(0,len(T))]\n        U[0] = u\n        U1 = [0 for t in range(0,len(T))]\n        U1[0] = u1\n        T, yout, xout = control.forced_response(sys_CL[:,0],T,U1,X0w1)\n    if selu == 'step':\n        U = [u for t in range(0,len(T))]\n        U1 = [u1 for t in range(0,len(T))]\n        T, yout, xout = control.forced_response(sys_CL[:,0],T,U1,X0w1)\n    if selu == 'sinusoid':\n        U = u*numpy.sin(2*numpy.pi/period*T)\n        U1 = u1*numpy.sin(2*numpy.pi/period*T)\n        T, yout, xout = control.forced_response(sys_CL[:,0],T,U1,X0w1)\n    if selu == 'square wave':\n        U = u*numpy.sign(numpy.sin(2*numpy.pi/period*T))\n        U1 = u1*numpy.sign(numpy.sin(2*numpy.pi/period*T))\n        T, yout, xout = control.forced_response(sys_CL[:,0],T,U1,X0w1)\n    # N.B. i primi 3 stati di xout sono quelli del sistema, mentre gli ultimi 3 sono quelli dell'osservatore\n    \n    step_info_dict = control.step_info(sys_CL[0,0],SettlingTimeThreshold=0.02,T=T)\n    print('Step info: \\n\\tRise time =',step_info_dict['RiseTime'],'\\n\\tSettling time (2%) =',step_info_dict['SettlingTime'],'\\n\\tOvershoot (%)=',step_info_dict['Overshoot'])\n    print('Max U value (% of 5A)=', max(abs(yout[C.shape[0]]))/(5)*100)\n    \n    fig = plt.figure(num='Simulation1', figsize=(14,12))\n    \n    fig.add_subplot(221)\n    plt.title('Output response')\n    plt.ylabel('Output')\n    plt.plot(T,yout[0],T,U,'r--')\n    plt.xlabel('$t$ [s]')\n    plt.legend(['$y$','Reference'])\n    plt.axvline(x=0,color='black',linewidth=0.8)\n    plt.axhline(y=0,color='black',linewidth=0.8)\n    plt.grid()\n    \n    fig.add_subplot(222)\n    plt.title('Input')\n    plt.ylabel('$u$')\n    plt.plot(T,yout[C.shape[0]],T,[5 for i in range(len(T))],'r--')\n    plt.xlabel('$t$ [s]')\n    plt.axvline(x=0,color='black',linewidth=0.8)\n    plt.axhline(y=0,color='black',linewidth=0.8)\n    plt.grid()\n    \n    fig.add_subplot(223)\n    plt.title('States response')\n    plt.ylabel('States')\n    plt.plot(T,yout[C.shape[0]+B.shape[1]+B[:,numU:].shape[1]+A.shape[0]],\n             T,yout[C.shape[0]+B.shape[1]+B[:,numU:].shape[1]+A.shape[0]+1],\n             T,yout[C.shape[0]+B.shape[1]+B[:,numU:].shape[1]+A.shape[0]+2])\n    plt.xlabel('$t$ [s]')\n    plt.axvline(x=0,color='black',linewidth=0.8)\n    plt.axhline(y=0,color='black',linewidth=0.8)\n    plt.legend(['$x_{1}$','$x_{2}$','$x_{3}$'])\n    plt.grid()\n    \n    fig.add_subplot(224)\n    plt.title('Estimation errors')\n    plt.ylabel('Errors')\n    plt.plot(T,yout[C.shape[0]+B.shape[1]+B[:,numU:].shape[1]+A.shape[0]]-yout[C.shape[0]+B.shape[1]],\n             T,yout[C.shape[0]+B.shape[1]+B[:,numU:].shape[1]+A.shape[0]+1]-yout[C.shape[0]+B.shape[1]+1],\n             T,yout[C.shape[0]+B.shape[1]+B[:,numU:].shape[1]+A.shape[0]+2]-yout[C.shape[0]+B.shape[1]+2])\n    plt.xlabel('$t$ [s]')\n    plt.axvline(x=0,color='black',linewidth=0.8)\n    plt.axhline(y=0,color='black',linewidth=0.8)\n    plt.legend(['$e_{1}$','$e_{2}$','$e_{3}$'])\n    plt.grid()\n    #plt.tight_layout()\n   \nalltogether2 = widgets.VBox([widgets.HBox([selm, \n                                          sele,\n                                          selu]),\n                            widgets.Label(' ',border=3),\n                            widgets.HBox([widgets.Label('K:',border=3), Kw, \n                                          widgets.Label(' ',border=3),\n                                          widgets.Label(' ',border=3),\n                                          widgets.Label('Eigenvalues:',border=3), \n                                          eig1c, \n                                          eig2c, \n                                          eig3c,\n                                          widgets.Label(' ',border=3),\n                                          widgets.Label(' ',border=3),\n                                          widgets.Label('X0 est.:',border=3), X0w]),\n                            widgets.Label(' ',border=3),\n                            widgets.HBox([widgets.Label('L:',border=3), Lw, \n                                          widgets.Label(' ',border=3),\n                                          widgets.Label(' ',border=3),\n                                          widgets.Label('Eigenvalues:',border=3), \n                                          eig1o, \n                                          eig2o, \n                                          eig3o,\n                                          widgets.Label(' ',border=3)]),\n                            widgets.Label(' ',border=3),\n                            widgets.HBox([widgets.VBox([widgets.Label('Inverse reference gain:',border=3),\n                            widgets.Label('Simulation time [s]:',border=3)]),\n                            widgets.VBox([gain_w2,simTime])]),\n                            widgets.Label(' ',border=3),\n                            widgets.HBox([u, \n                                          period, \n                                          START])])\nout2 = widgets.interactive_output(main_callback2, {'Aw':Aw, 'Bw':Bw, 'X0w':X0w, 'K':Kw, 'L':Lw,\n                                                 'eig1c':eig1c, 'eig2c':eig2c, 'eig3c':eig3c, 'eig1o':eig1o, 'eig2o':eig2o, 'eig3o':eig3o, \n                                                 'u':u, 'period':period, 'selm':selm, 'sele':sele, 'selu':selu, 'simTime':simTime, 'DW':DW})\nout2.layout.height = '870px'\ndisplay(out2, alltogether2)"
  },
  {
    "objectID": "ICCT_en/examples/04/SS-45-Aircraft_taxi_trajectory_control.html",
    "href": "ICCT_en/examples/04/SS-45-Aircraft_taxi_trajectory_control.html",
    "title": "Aircraft taxi trajectory control",
    "section": "",
    "text": "#remove cell visibility\nfrom IPython.display import HTML\ntag = HTML('''&lt;script&gt;\ncode_show=true; \nfunction code_toggle() {\n    if (code_show){\n        $('div.input').hide()\n    } else {\n        $('div.input').show()\n    }\n    code_show = !code_show\n} \n$( document ).ready(code_toggle);\n&lt;/script&gt;\nToggle cell visibility &lt;a href=\"javascript:code_toggle()\"&gt;here&lt;/a&gt;.''')\ndisplay(tag)\n\n\nToggle cell visibility here.\n\n\n\n%matplotlib inline\nimport control\nimport numpy\nimport sympy as sym\nfrom IPython.display import display, Markdown\nimport ipywidgets as widgets\nimport matplotlib.pyplot as plt\n\n\n#print a matrix latex-like\ndef bmatrix(a):\n     \"\"\"Returns a LaTeX bmatrix - by Damir Arbula (ICCT project)\n\n     :a: numpy array\n     :returns: LaTeX bmatrix as a string\n     \"\"\"\n     if len(a.shape) &gt; 2:\n         raise ValueError('bmatrix can at most display two dimensions')\n     lines = str(a).replace('[', '').replace(']', '').splitlines()\n     rv = [r'\\begin{bmatrix}']\n     rv += ['  ' + ' & '.join(l.split()) + r'\\\\' for l in lines]\n     rv +=  [r'\\end{bmatrix}']\n     return '\\n'.join(rv)\n\n\n# Display formatted matrix: \ndef vmatrix(a):\n    if len(a.shape) &gt; 2:\n         raise ValueError('bmatrix can at most display two dimensions')\n    lines = str(a).replace('[', '').replace(']', '').splitlines()\n    rv = [r'\\begin{vmatrix}']\n    rv += ['  ' + ' & '.join(l.split()) + r'\\\\' for l in lines]\n    rv +=  [r'\\end{vmatrix}']\n    return '\\n'.join(rv)\n\n\n#matrixWidget is a matrix looking widget built with a VBox of HBox(es) that returns a numPy array as value !\nclass matrixWidget(widgets.VBox):\n    def updateM(self,change):\n        for irow in range(0,self.n):\n            for icol in range(0,self.m):\n                self.M_[irow,icol] = self.children[irow].children[icol].value\n                #print(self.M_[irow,icol])\n        self.value = self.M_\n\n    def dummychangecallback(self,change):\n        pass\n    \n    \n    def __init__(self,n,m):\n        self.n = n\n        self.m = m\n        self.M_ = numpy.matrix(numpy.zeros((self.n,self.m)))\n        self.value = self.M_\n        widgets.VBox.__init__(self,\n                             children = [\n                                 widgets.HBox(children = \n                                              [widgets.FloatText(value=0.0, layout=widgets.Layout(width='90px')) for i in range(m)]\n                                             ) \n                                 for j in range(n)\n                             ])\n        \n        #fill in widgets and tell interact to call updateM each time a children changes value\n        for irow in range(0,self.n):\n            for icol in range(0,self.m):\n                self.children[irow].children[icol].value = self.M_[irow,icol]\n                self.children[irow].children[icol].observe(self.updateM, names='value')\n        #value = Unicode('example@example.com', help=\"The email value.\").tag(sync=True)\n        self.observe(self.updateM, names='value', type= 'All')\n        \n    def setM(self, newM):\n        #disable callbacks, change values, and reenable\n        self.unobserve(self.updateM, names='value', type= 'All')\n        for irow in range(0,self.n):\n            for icol in range(0,self.m):\n                self.children[irow].children[icol].unobserve(self.updateM, names='value')\n        self.M_ = newM\n        self.value = self.M_\n        for irow in range(0,self.n):\n            for icol in range(0,self.m):\n                self.children[irow].children[icol].value = self.M_[irow,icol]\n        for irow in range(0,self.n):\n            for icol in range(0,self.m):\n                self.children[irow].children[icol].observe(self.updateM, names='value')\n        self.observe(self.updateM, names='value', type= 'All')        \n\n                #self.children[irow].children[icol].observe(self.updateM, names='value')\n\n             \n#overlaod class for state space systems that DO NOT remove \"useless\" states (what \"professor\" of automatic control would do this?)\nclass sss(control.StateSpace):\n    def __init__(self,*args):\n        #call base class init constructor\n        control.StateSpace.__init__(self,*args)\n    #disable function below in base class\n    def _remove_useless_states(self):\n        pass\n\nThe rotational dynamics of an aircraft moving on the ground can be represented as:\n\\[\nJ_z\\ddot{\\psi} = bF_1\\delta + F_2\\dot{\\psi} \\, ,\n\\]\nwhere \\(J_z = 11067000\\) kg\\(\\text{m}^2\\), \\(b = 15\\) , \\(F_1 = 35000000\\) Nm, \\(F_2 = 500000\\) kg\\(\\text{m}^2\\)/\\(\\text{s}\\), \\(\\psi\\) is the rotational angle (in rad), or yaw angle, with respect to the vertical axis, and \\(\\delta\\) is the front wheel steering angle (in rad). When the aircraft is following a straight line with longitudinal linear velocity \\(V\\) (in m/s), the aircraft lateral velocity \\(V_y\\) (in m/s) is approximately linearly proportional to the yaw angle: \\(V_y = \\dot{p_y} = V\\psi\\).\nThe goal is to design a regulator for the aircraft lateral position \\(p_y\\), with longitudinal velocity \\(V\\) set to 35 km/h, using the front wheel steering angle \\(\\delta\\) as plant input, according to the following specifications: - settling time for 5% tolerance band of less than 4 seconds; - zero steady-state error in response to a desired lateral position request; - no or minimal overshoot; - steering angle does not exceed \\(\\pm8\\) degrees when following a lateral position step of 5 meters.\nThe dynamic equations in state space form are:\n\\[\\begin{cases}\n    \\dot{x} = \\begin{bmatrix} \\frac{F_2}{J_z} & 0 & 0 \\\\ 1 & 0 & 0 \\\\ 0 & V & 0 \\end{bmatrix}x + \\begin{bmatrix} \\frac{bF_1}{J_z} \\\\ 0 \\\\ 0 \\end{bmatrix}u \\\\\n    y = \\begin{bmatrix} 0 & 0 & 1 \\end{bmatrix}x \\, ,\n\\end{cases}\\]\nwhere \\(x=\\begin{bmatrix} x_1 & x_2 & x_3 \\end{bmatrix}^T = \\begin{bmatrix} \\dot{\\psi} & \\psi & p_y \\end{bmatrix}^T\\) and \\(u=\\delta\\).\nThe poles of the system are \\(0\\), \\(0\\) and \\(\\frac{F_2}{J_z} \\simeq 0.045\\), therefore the system is unstable.\n\nRegulator design\n\nController design\nTo meet the requirements of zero steady-state error we add a new state: \\[\n\\dot{x_4} = p_y-y_d = x_3 - y_d\n\\] The resulting augmented system is thus:\n\\[\\begin{cases}\n    \\dot{x_a} = \\begin{bmatrix} \\frac{F_2}{J_z} & 0 & 0 & 0 \\\\ 1 & 0 & 0 & 0 \\\\ 0 & V & 0 & 0 \\\\ 0 & 0 & 1 & 0 \\end{bmatrix}x_a + \\begin{bmatrix} \\frac{bF_1}{J_z} & 0 \\\\ 0 & 0 \\\\ 0 & 0 \\\\ 0 & -1 \\end{bmatrix}\\begin{bmatrix} u \\\\ y_d \\end{bmatrix} \\\\\n    y_a = \\begin{bmatrix} 0 & 0 & 1 & 0 \\\\ 0 & 0 & 0 & 1 \\end{bmatrix}x_a,\n\\end{cases}\\]\nwhere \\(x_a = \\begin{bmatrix} x_1 & x_2 & x_3 & x_4 \\end{bmatrix}^T\\) and the second output is added in order to maintain the observability. The system remains controllable with the input \\(u\\) and thus we can design the state feedback with this input. A possible solution is to place all the poles in \\(-2\\).\n\n\nObserver design\nEven if states \\(x_3\\) and \\(x_4\\) can be obtained from measurements, and we need to estimate \\(x_2\\) and \\(x_3\\) only, it is convenient to work with the full 4x4 system and to design a state observer of order 4 with all poles in \\(-10\\).\n\n\n\nHow to use this notebook?\n\nVerify, if the requirements are met in presence of errors in the initial state estimate.\n\n\n# Preparatory cell\n\nX0 = numpy.matrix('0.0; 0.0; 0.0; 0.0')\nK = numpy.matrix([0,0,0,0])\nL = numpy.matrix([[0,0],[0,0],[0,0],[0,0]])\n\nX0w = matrixWidget(4,1)\nX0w.setM(X0)\nKw = matrixWidget(1,4)\nKw.setM(K)\nLw = matrixWidget(4,2)\nLw.setM(L)\n\n\neig1c = matrixWidget(1,1)\neig2c = matrixWidget(2,1)\neig3c = matrixWidget(1,1)\neig4c = matrixWidget(2,1)\neig1c.setM(numpy.matrix([-2.])) \neig2c.setM(numpy.matrix([[-2.],[-0.]]))\neig3c.setM(numpy.matrix([-2.]))\neig4c.setM(numpy.matrix([[-2.],[-0.]]))\n\neig1o = matrixWidget(1,1)\neig2o = matrixWidget(2,1)\neig3o = matrixWidget(1,1)\neig4o = matrixWidget(2,1)\neig1o.setM(numpy.matrix([-10.])) \neig2o.setM(numpy.matrix([[-10.],[0.]]))\neig3o.setM(numpy.matrix([-10.]))\neig4o.setM(numpy.matrix([[-10.],[0.]]))\n\n\n# Misc\n\n#create dummy widget \nDW = widgets.FloatText(layout=widgets.Layout(width='0px', height='0px'))\n\n#create button widget\nSTART = widgets.Button(\n    description='Test',\n    disabled=False,\n    button_style='', # 'success', 'info', 'warning', 'danger' or ''\n    tooltip='Test',\n    icon='check'\n)\n                       \ndef on_start_button_clicked(b):\n    #This is a workaround to have intreactive_output call the callback:\n    #   force the value of the dummy widget to change\n    if DW.value&gt; 0 :\n        DW.value = -1\n    else: \n        DW.value = 1\n    pass\nSTART.on_click(on_start_button_clicked)\n\n# Define type of method \nselm = widgets.Dropdown(\n    options= ['Set K and L', 'Set the eigenvalues'],\n    value= 'Set the eigenvalues',\n    description='',\n    disabled=False\n)\n\n# Define the number of complex eigenvalues\nselec = widgets.Dropdown(\n    options= ['0 complex eigenvalues', '2 complex eigenvalues', '4 complex eigenvalues'],\n    value= '0 complex eigenvalues',\n    description='Eig controller:',\n    disabled=False\n)\nseleo = widgets.Dropdown(\n    options= ['0 complex eigenvalues', '2 complex eigenvalues', '4 complex eigenvalues'],\n    value= '0 complex eigenvalues',\n    description='Eig observer:',\n    disabled=False\n)\n\n#define type of ipout \nselu = widgets.Dropdown(\n    options=['impulse', 'step', 'sinusoid', 'square wave'],\n    value='step',\n    description='Type of reference:',\n    style = {'description_width': 'initial'},\n    disabled=False\n)\n# Define the values of the input\nu = widgets.FloatSlider(\n    value=5,\n    min=0,\n    max=10,\n    step=0.1,\n    description='Reference [m]:',\n    style = {'description_width': 'initial'},\n    disabled=False,\n    continuous_update=False,\n    orientation='horizontal',\n    readout=True,\n    readout_format='.1f',\n)\nv = widgets.FloatSlider(\n    value=9.72,\n    min=1,\n    max=20,\n    step=0.1,\n    description=r'$V$ [m/s]:',\n    disabled=False,\n    continuous_update=False,\n    orientation='horizontal',\n    readout=True,\n    readout_format='.2f',\n)\nperiod = widgets.FloatSlider(\n    value=0.5,\n    min=0.001,\n    max=10,\n    step=0.001,\n    description='Period: ',\n    disabled=False,\n    continuous_update=False,\n    orientation='horizontal',\n    readout=True,\n    readout_format='.3f',\n)\n\nsimTime = widgets.FloatText(\n    value=5,\n    description='',\n    disabled=False\n)\n\n\n# Support functions\n\ndef eigen_choice(selec,seleo):\n    if selec == '0 complex eigenvalues':\n        eig1c.children[0].children[0].disabled = False\n        eig2c.children[1].children[0].disabled = True\n        eig3c.children[0].children[0].disabled = False\n        eig4c.children[0].children[0].disabled = False\n        eig4c.children[1].children[0].disabled = True\n        eigc = 0\n    if seleo == '0 complex eigenvalues':\n        eig1o.children[0].children[0].disabled = False\n        eig2o.children[1].children[0].disabled = True\n        eig3o.children[0].children[0].disabled = False\n        eig4o.children[0].children[0].disabled = False\n        eig4o.children[1].children[0].disabled = True\n        eigo = 0\n    if selec == '2 complex eigenvalues':\n        eig1c.children[0].children[0].disabled = False\n        eig2c.children[1].children[0].disabled = False\n        eig3c.children[0].children[0].disabled = False\n        eig4c.children[0].children[0].disabled = True\n        eig4c.children[1].children[0].disabled = True\n        eigc = 2\n    if seleo == '2 complex eigenvalues':\n        eig1o.children[0].children[0].disabled = False\n        eig2o.children[1].children[0].disabled = False\n        eig3o.children[0].children[0].disabled = False\n        eig4o.children[0].children[0].disabled = True\n        eig4o.children[1].children[0].disabled = True\n        eigo = 2\n    if selec == '4 complex eigenvalues':\n        eig1c.children[0].children[0].disabled = True\n        eig2c.children[1].children[0].disabled = False\n        eig3c.children[0].children[0].disabled = True\n        eig4c.children[0].children[0].disabled = False\n        eig4c.children[1].children[0].disabled = False\n        eigc = 4\n    if seleo == '4 complex eigenvalues':\n        eig1o.children[0].children[0].disabled = True\n        eig2o.children[1].children[0].disabled = False\n        eig3o.children[0].children[0].disabled = True\n        eig4o.children[0].children[0].disabled = False\n        eig4o.children[1].children[0].disabled = False\n        eigo = 4\n    return eigc, eigo\n\ndef method_choice(selm):\n    if selm == 'Set K and L':\n        method = 1\n        selec.disabled = True\n        seleo.disabled = True\n    if selm == 'Set the eigenvalues':\n        method = 2\n        selec.disabled = False\n        seleo.disabled = False\n    return method\n\n\nF1 = 35000000\nF2 = 500000\nb = 15\nV = 35/3.6\nJz = 11067000\n\nA = numpy.matrix([[F2/Jz, 0, 0, 0],\n                  [1, 0, 0, 0],\n                  [0, V, 0, 0],\n                  [0, 0, 1, 0]])\nBu = numpy.matrix([[b*F1/Jz],[0],[0],[0]])\nBref = numpy.matrix([[0],[0],[0],[-1]])\nC = numpy.matrix([[0,0,1,0],[0,0,0,1]])\n\ndef main_callback2(v, X0w, K, L, eig1c, eig2c, eig3c, eig4c, eig1o, eig2o, eig3o, eig4o, u, period, selm, selec, seleo, selu, simTime, DW):\n    eigc, eigo = eigen_choice(selec,seleo)\n    method = method_choice(selm)\n    \n    A = numpy.matrix([[F2/Jz, 0, 0, 0],\n                  [1, 0, 0, 0],\n                  [0, v, 0, 0],\n                  [0, 0, 1, 0]])\n    \n    if method == 1:\n        solc = numpy.linalg.eig(A-Bu*K)\n        solo = numpy.linalg.eig(A-L*C)\n    if method == 2:\n        #for better numerical stability of place\n        if eig1c[0,0]==eig2c[0,0] or eig1c[0,0]==eig3c[0,0] or eig1c[0,0]==eig4c[0,0]:\n            eig1c[0,0] *= 1.01\n        if eig2c[0,0]==eig3c[0,0] or eig2c[0,0]==eig4c[0,0]:\n            eig3c[0,0] *= 1.015\n        if eig1o[0,0]==eig2o[0,0] or eig1o[0,0]==eig3o[0,0] or eig1o[0,0]==eig4o[0,0]:\n            eig1o[0,0] *= 1.01\n        if eig2o[0,0]==eig3o[0,0] or eig2o[0,0]==eig4o[0,0]:\n            eig3o[0,0] *= 1.015\n            \n        if eigc == 0:\n            K = control.acker(A, Bu, [eig1c[0,0], eig2c[0,0], eig3c[0,0], eig4c[0,0]])\n            Kw.setM(K)\n        if eigc == 2:\n            K = control.acker(A, Bu, [eig3c[0,0],\n                                      eig1c[0,0],\n                                      numpy.complex(eig2c[0,0], eig2c[1,0]), \n                                      numpy.complex(eig2c[0,0],-eig2c[1,0])])\n            Kw.setM(K)\n        if eigc == 4:\n            K = control.acker(A, Bu, [numpy.complex(eig4c[0,0], eig4c[1,0]), \n                                      numpy.complex(eig4c[0,0],-eig4c[1,0]),\n                                      numpy.complex(eig2c[0,0], eig2c[1,0]), \n                                      numpy.complex(eig2c[0,0],-eig2c[1,0])])\n            Kw.setM(K)\n        if eigo == 0:\n            L = control.place(A.T, C.T, [eig1o[0,0], eig2o[0,0], eig3o[0,0], eig4o[0,0]]).T\n            Lw.setM(L)\n        if eigo == 2:\n            L = control.place(A.T, C.T, [eig3o[0,0],\n                                         eig1o[0,0],\n                                         numpy.complex(eig2o[0,0], eig2o[1,0]), \n                                         numpy.complex(eig2o[0,0],-eig2o[1,0])]).T\n            Lw.setM(L)\n        if eigo == 4:\n            L = control.place(A.T, C.T, [numpy.complex(eig4o[0,0], eig4o[1,0]), \n                                      numpy.complex(eig4o[0,0],-eig4o[1,0]),\n                                      numpy.complex(eig2o[0,0], eig2o[1,0]), \n                                      numpy.complex(eig2o[0,0],-eig2o[1,0])]).T\n            Lw.setM(L)\n            \n    sys = sss(A,numpy.hstack((Bu,Bref)),[[0,0,1,0],[0,0,0,1],[0,0,0,0]],[[0,0],[0,0],[0,1]])\n    syse = sss(A-L*C,numpy.hstack((Bu,Bref,L)),numpy.eye(4),numpy.zeros((4,4)))\n    sysc = sss(0,[0,0,0,0],0,-K)\n    sys_append = control.append(sys,syse,sysc)\n    try:\n        sys_CL = control.connect(sys_append,\n                                 [[1,8],[3,8],[5,1],[6,2],[7,4],[8,5],[9,6],[10,7],[4,3]],\n                                 [2],\n                                 [1,8])\n    except:\n        sys_CL = control.connect(sys_append,\n                                 [[1,8],[3,8],[5,1],[6,2],[7,4],[8,5],[9,6],[10,7],[4,3]],\n                                 [2],\n                                 [1,8])\n\n    X0w1 = numpy.zeros((8,1))\n    X0w1[4,0] = X0w[0,0]\n    X0w1[5,0] = X0w[1,0]\n    X0w1[6,0] = X0w[2,0]\n    X0w1[7,0] = X0w[3,0]\n    if simTime != 0:\n        T = numpy.linspace(0, simTime, 10000)\n    else:\n        T = numpy.linspace(0, 1, 10000)\n      \n    if selu == 'impulse': #selu\n        U = [0 for t in range(0,len(T))]\n        U[0] = u\n        T, yout, xout = control.forced_response(sys_CL,T,U,X0w1)\n    if selu == 'step':\n        U = [u for t in range(0,len(T))]\n        T, yout, xout = control.forced_response(sys_CL,T,U,X0w1)\n    if selu == 'sinusoid':\n        U = u*numpy.sin(2*numpy.pi/period*T)\n        T, yout, xout = control.forced_response(sys_CL,T,U,X0w1)\n    if selu == 'square wave':\n        U = u*numpy.sign(numpy.sin(2*numpy.pi/period*T))\n        T, yout, xout = control.forced_response(sys_CL,T,U,X0w1)\n    \n    try:\n        step_info_dict = control.step_info(sys_CL[0,0],SettlingTimeThreshold=0.05,T=T)\n        print('Step info: \\n\\tRise time =',step_info_dict['RiseTime'],'\\n\\tSettling time (5%) =',step_info_dict['SettlingTime'],'\\n\\tOvershoot (%)=',step_info_dict['Overshoot'])\n        print('Max u value (% of 8deg)=', max(abs(yout[1]))/(8*numpy.pi/180)*100) \n    except:\n        print(\"Error in the calculation of step info.\")\n    \n    fig = plt.figure(num='Simulation1', figsize=(14,12))\n    \n    fig.add_subplot(221)\n    plt.title('Output response')\n    plt.ylabel('Output')\n    plt.plot(T,yout[0],T,U,'r--')\n    plt.xlabel('$t$ [s]')\n    plt.legend(['$y$','Reference'])\n    plt.axvline(x=0,color='black',linewidth=0.8)\n    plt.axhline(y=0,color='black',linewidth=0.8)\n    plt.grid()\n    \n    fig.add_subplot(222)\n    plt.title('Input')\n    plt.ylabel('$u$ [deg]')\n    plt.plot(T,yout[1]*180/numpy.pi)\n    plt.plot(T,[8 for i in range(len(T))],'r--')\n    plt.plot(T,[-8 for i in range(len(T))],'r--')\n    plt.xlabel('$t$ [s]')\n    plt.axvline(x=0,color='black',linewidth=0.8)\n    plt.axhline(y=0,color='black',linewidth=0.8)\n    plt.grid()\n    \n    fig.add_subplot(223)\n    plt.title('States response')\n    plt.ylabel('States')\n    plt.plot(T,xout[0],\n             T,xout[1],\n             T,xout[2],\n             T,xout[3])\n    plt.xlabel('$t$ [s]')\n    plt.axvline(x=0,color='black',linewidth=0.8)\n    plt.axhline(y=0,color='black',linewidth=0.8)\n    plt.legend(['$x_{1}$','$x_{2}$','$x_{3}$','$x_{4}$'])\n    plt.grid()\n    \n    fig.add_subplot(224)\n    plt.title('Estimation errors')\n    plt.ylabel('Errors')\n    plt.plot(T,xout[4]-xout[0])\n    plt.plot(T,xout[5]-xout[1])\n    plt.plot(T,xout[6]-xout[2])\n    plt.plot(T,xout[7]-xout[3])\n    plt.xlabel('$t$ [s]')\n    plt.axvline(x=0,color='black',linewidth=0.8)\n    plt.axhline(y=0,color='black',linewidth=0.8)\n    plt.legend(['$e_{1}$','$e_{2}$','$e_{3}$','$e_{4}$'])\n    plt.grid()\n    #plt.tight_layout()\n   \nalltogether2 = widgets.VBox([widgets.HBox([selm, \n                                          selec,\n                                          seleo,\n                                          selu]),\n                            widgets.Label(' ',border=3),\n                            widgets.HBox([widgets.HBox([widgets.Label('K:',border=3), Kw, \n                                                        widgets.Label('Eigenvalues:',border=3),\n                                                        widgets.HBox([eig1c, \n                                                                      eig2c, \n                                                                      eig3c,\n                                                                      eig4c])])]),\n                            widgets.Label(' ',border=3),\n                            widgets.HBox([widgets.VBox([widgets.HBox([widgets.Label('L:',border=3), Lw, widgets.Label(' ',border=3),\n                                          widgets.Label(' ',border=3),\n                                          widgets.Label('Eigenvalues:',border=3), \n                                          eig1o, \n                                          eig2o,\n                                          eig3o, \n                                          eig4o,\n                                          widgets.Label(' ',border=3),\n                                          widgets.Label(' ',border=3),\n                                          widgets.Label('X0 est.:',border=3), X0w]),\n                                          widgets.Label(' ',border=3),\n                                                       widgets.HBox([\n                                          widgets.VBox([widgets.Label('Simulation time [s]:',border=3)]),\n                                          widgets.VBox([simTime])])]),\n                                          widgets.Label(' ',border=3)]),\n                            widgets.Label(' ',border=3),\n                            widgets.HBox([u,\n                                          v,\n                                          period, \n                                          START])])\nout2 = widgets.interactive_output(main_callback2, {'v':v, 'X0w':X0w, 'K':Kw, 'L':Lw,\n                                                   'eig1c':eig1c, 'eig2c':eig2c, 'eig3c':eig3c, 'eig4c':eig4c, \n                                                   'eig1o':eig1o, 'eig2o':eig2o, 'eig3o':eig3o, 'eig4o':eig4o,  \n                                                   'u':u, 'period':period, 'selm':selm, 'selec':selec, 'seleo':seleo, 'selu':selu, 'simTime':simTime, 'DW':DW})\nout2.layout.height = '860px'\ndisplay(out2, alltogether2)"
  },
  {
    "objectID": "ICCT_en/examples/04/SS-47-Pneumatic_position_control.html",
    "href": "ICCT_en/examples/04/SS-47-Pneumatic_position_control.html",
    "title": "Pneumatic position control",
    "section": "",
    "text": "#remove cell visibility\nfrom IPython.display import HTML\ntag = HTML('''&lt;script&gt;\ncode_show=true; \nfunction code_toggle() {\n    if (code_show){\n        $('div.input').hide()\n    } else {\n        $('div.input').show()\n    }\n    code_show = !code_show\n} \n$( document ).ready(code_toggle);\n&lt;/script&gt;\nToggle cell visibility &lt;a href=\"javascript:code_toggle()\"&gt;here&lt;/a&gt;.''')\ndisplay(tag)\n\n\nToggle cell visibility here.\n\n\n\n%matplotlib inline\nimport control\nimport numpy\nimport sympy as sym\nfrom IPython.display import display, Markdown\nimport ipywidgets as widgets\nimport matplotlib.pyplot as plt\n\n\n#print a matrix latex-like\ndef bmatrix(a):\n     \"\"\"Returns a LaTeX bmatrix - by Damir Arbula (ICCT project)\n\n     :a: numpy array\n     :returns: LaTeX bmatrix as a string\n     \"\"\"\n     if len(a.shape) &gt; 2:\n         raise ValueError('bmatrix can at most display two dimensions')\n     lines = str(a).replace('[', '').replace(']', '').splitlines()\n     rv = [r'\\begin{bmatrix}']\n     rv += ['  ' + ' & '.join(l.split()) + r'\\\\' for l in lines]\n     rv +=  [r'\\end{bmatrix}']\n     return '\\n'.join(rv)\n\n\n# Display formatted matrix: \ndef vmatrix(a):\n    if len(a.shape) &gt; 2:\n         raise ValueError('bmatrix can at most display two dimensions')\n    lines = str(a).replace('[', '').replace(']', '').splitlines()\n    rv = [r'\\begin{vmatrix}']\n    rv += ['  ' + ' & '.join(l.split()) + r'\\\\' for l in lines]\n    rv +=  [r'\\end{vmatrix}']\n    return '\\n'.join(rv)\n\n\n#matrixWidget is a matrix looking widget built with a VBox of HBox(es) that returns a numPy array as value !\nclass matrixWidget(widgets.VBox):\n    def updateM(self,change):\n        for irow in range(0,self.n):\n            for icol in range(0,self.m):\n                self.M_[irow,icol] = self.children[irow].children[icol].value\n                #print(self.M_[irow,icol])\n        self.value = self.M_\n\n    def dummychangecallback(self,change):\n        pass\n    \n    \n    def __init__(self,n,m):\n        self.n = n\n        self.m = m\n        self.M_ = numpy.matrix(numpy.zeros((self.n,self.m)))\n        self.value = self.M_\n        widgets.VBox.__init__(self,\n                             children = [\n                                 widgets.HBox(children = \n                                              [widgets.FloatText(value=0.0, layout=widgets.Layout(width='90px')) for i in range(m)]\n                                             ) \n                                 for j in range(n)\n                             ])\n        \n        #fill in widgets and tell interact to call updateM each time a children changes value\n        for irow in range(0,self.n):\n            for icol in range(0,self.m):\n                self.children[irow].children[icol].value = self.M_[irow,icol]\n                self.children[irow].children[icol].observe(self.updateM, names='value')\n        #value = Unicode('example@example.com', help=\"The email value.\").tag(sync=True)\n        self.observe(self.updateM, names='value', type= 'All')\n        \n    def setM(self, newM):\n        #disable callbacks, change values, and reenable\n        self.unobserve(self.updateM, names='value', type= 'All')\n        for irow in range(0,self.n):\n            for icol in range(0,self.m):\n                self.children[irow].children[icol].unobserve(self.updateM, names='value')\n        self.M_ = newM\n        self.value = self.M_\n        for irow in range(0,self.n):\n            for icol in range(0,self.m):\n                self.children[irow].children[icol].value = self.M_[irow,icol]\n        for irow in range(0,self.n):\n            for icol in range(0,self.m):\n                self.children[irow].children[icol].observe(self.updateM, names='value')\n        self.observe(self.updateM, names='value', type= 'All')        \n\n                #self.children[irow].children[icol].observe(self.updateM, names='value')\n\n             \n#overlaod class for state space systems that DO NOT remove \"useless\" states (what \"professor\" of automatic control would do this?)\nclass sss(control.StateSpace):\n    def __init__(self,*args):\n        #call base class init constructor\n        control.StateSpace.__init__(self,*args)\n    #disable function below in base class\n    def _remove_useless_states(self):\n        pass\n\n\nA ball is suspended inside a vertical tube by airflow \\(u\\) and connected via a spring (of equivalent zero rest length) of stiffness \\(K\\) to the bottom of the tube; the ball is subjected to gravity and a viscous friction with coefficient \\(B\\). The force \\(F\\) exerted on the ball by airflow is proportional to airflow \\(u\\) (in m/s) via the constant \\(G\\); airflow can only be positive (entering the tube). Given the ball mass \\(m=2\\) g, \\(B=1\\) g/s, \\(K=2\\) g/\\(\\text{s}^2\\) and \\(G=3\\) Ns/m, the goal is to design a regulator with \\(u\\) as the input and the ball’s altitude \\(z\\) as the output according to the following requirements: - zero steady-state error (in response to a desired altitude step input); - maximum overshoot 30% - settling time for 5% tolerance band of less than 8 seconds.\nThe dynamic equation that describes the system is:\n\\[\n    m\\ddot{z} = -Kz -B\\dot{z} + Gu\n\\]\nand defining the state vector as \\(x=\\begin{bmatrix} x_1 & x_2 \\end{bmatrix}^T=\\begin{bmatrix} z & \\dot{z} \\end{bmatrix}^T\\) we can write:\n\\[\\begin{cases}\n    \\dot{x} = \\begin{bmatrix} 0 & 1 \\\\ -\\frac{K}{m} & -\\frac{B}{m} \\end{bmatrix}x + \\begin{bmatrix} 0 \\\\ \\frac{G}{m} \\end{bmatrix}u \\\\\n    y = \\begin{bmatrix} 1 & 0 \\end{bmatrix}x\n\\end{cases}\\]\nThe poles of the system are \\(-0.25\\pm0.97i\\).\n\nRegulator design\n\nController design\nTo meet zero steady-state error in case of a step input request we add an integrator at the system by augmenting the state vector with \\(\\dot{x_3} = x_1 - y_d\\), where \\(y_d\\) is the reference. The augmented system is thus:\n\\[\\begin{cases}\n    \\dot{x_a} = \\begin{bmatrix} 0 & 1 & 0 \\\\ -\\frac{K}{m} & -\\frac{B}{m} & 0 \\\\ 1 & 0 & 0 \\end{bmatrix}x_a + \\begin{bmatrix} 0 & 0 \\\\ \\frac{G}{m} & 0 \\\\ 0 & -1 \\end{bmatrix}u \\\\\n    y_a = \\begin{bmatrix} 1 & 0 & 0 \\\\ 0 & 0 & 1 \\end{bmatrix}x_a \\, .\n\\end{cases}\\]\nSince the poles of the system are slow with respect to the requirements, we increase the natural frequency of the complex poles by placing them in \\(-0.5\\pm1.94\\) and we also replace the integrator with a pole in \\(-2\\).\n\n\nObserver design\nFor the estimate of the states we develop an observer for the subsystem \\((x_1,\\, x_2)\\) and then we take only the estimate of \\(x_2\\) since the other states are measured directly. We choose \\(-5\\) as the location for the poles of the full standard observer.\n\n\n\nHow to use this notebook?\n\nVerify the performance of regulator by relative variation of the ball mass (parameter delta m below) and, if needed, try to correct the pole placement.\nTest the regulator with initial error in the estimated state.\nTest the regulator with different types of reference input.\n\n\n# Preparatory cell\nb = 1E-03\nk = 2E-03\nG = 3\nm = 2E-03\nAa = numpy.matrix([[0, 1, 0],\n                   [-k/m, -b/m, 0],\n                   [1, 0, 0]])\nBa = numpy.matrix([[0, 0],\n                   [G/m, 0],\n                   [0,-1]])\nCa = numpy.matrix([[1, 0, 0],\n                   [0, 0, 1]])\nA = Aa[0:2,0:2]\nB = Ba[0:2,0]\nC = Ca[0,0:2]\n\nX0 = numpy.matrix('0.0')\nK = numpy.matrix([8/15,-4.4,-4])\nL = numpy.matrix([[23],[66]])\n\nX0w = matrixWidget(1,1)\nX0w.setM(X0)\nKw = matrixWidget(1,3)\nKw.setM(K)\nLw = matrixWidget(2,1)\nLw.setM(L)\n\n\neig1c = matrixWidget(1,1)\neig2c = matrixWidget(2,1)\neig3c = matrixWidget(1,1)\neig1c.setM(numpy.matrix([-2.0])) \neig2c.setM(numpy.matrix([[-0.5],[-1.94]]))\neig3c.setM(numpy.matrix([-2.0]))\n\neig1o = matrixWidget(1,1)\neig2o = matrixWidget(2,1)\neig1o.setM(numpy.matrix([-5.])) \neig2o.setM(numpy.matrix([[-5.],[0.]]))\n\n\n# Misc\n\n#create dummy widget \nDW = widgets.FloatText(layout=widgets.Layout(width='0px', height='0px'))\n\n#create button widget\nSTART = widgets.Button(\n    description='Test',\n    disabled=False,\n    button_style='', # 'success', 'info', 'warning', 'danger' or ''\n    tooltip='Test',\n    icon='check'\n)\n                       \ndef on_start_button_clicked(b):\n    #This is a workaround to have intreactive_output call the callback:\n    #   force the value of the dummy widget to change\n    if DW.value&gt; 0 :\n        DW.value = -1\n    else: \n        DW.value = 1\n    pass\nSTART.on_click(on_start_button_clicked)\n\n# Define type of method \nselm = widgets.Dropdown(\n    options= ['Set K and L', 'Set the eigenvalues'],\n    value= 'Set the eigenvalues',\n    description='',\n    disabled=False\n)\n\n# Define the number of complex eigenvalues\nsele = widgets.Dropdown(\n    options= ['0 complex eigenvalues', '2 complex eigenvalues'],\n    value= '2 complex eigenvalues',\n    description='Complex eigenvalues:',\n    disabled=False\n)\n\n#define type of ipout \nselu = widgets.Dropdown(\n    options=['impulse', 'step', 'sinusoid', 'square wave'],\n    value='step',\n    description='Type of disturbance:',\n    style = {'description_width': 'initial'},\n    disabled=False\n)\n# Define the values of the input\nu = widgets.FloatSlider(\n    value=0.1,\n    min=0,\n    max=0.8,\n    step=0.1,\n    description='Reference [m]:',\n    style = {'description_width': 'initial'},\n    disabled=False,\n    continuous_update=False,\n    orientation='horizontal',\n    readout=True,\n    readout_format='.1f',\n)\nmw = widgets.FloatSlider(\n    value=0,\n    min=-30,\n    max=30,\n    step=1,\n    description='delta m [%]:',\n    disabled=False,\n    continuous_update=False,\n    orientation='horizontal',\n    readout=True,\n    readout_format='.1f',\n)\nperiod = widgets.FloatSlider(\n    value=2,\n    min=0.1,\n    max=3,\n    step=0.05,\n    description='Period [s]: ',\n    disabled=False,\n    continuous_update=False,\n    orientation='horizontal',\n    readout=True,\n    readout_format='.2f',\n)\nsimTime = widgets.FloatText(\n    value=8,\n    description='',\n    disabled=False\n)\n\n\n# Support functions\n\ndef eigen_choice(sele):\n    if sele == '0 complex eigenvalues':\n        eig1c.children[0].children[0].disabled = False\n        eig2c.children[1].children[0].disabled = True\n        eig1o.children[0].children[0].disabled = False\n        eig2o.children[1].children[0].disabled = True\n        eig = 0\n    if sele == '2 complex eigenvalues':\n        eig1c.children[0].children[0].disabled = True\n        eig2c.children[1].children[0].disabled = False\n        eig1o.children[0].children[0].disabled = True\n        eig2o.children[1].children[0].disabled = False\n        eig = 2\n    return eig\n\ndef method_choice(selm):\n    if selm == 'Set K and L':\n        method = 1\n        sele.disabled = True\n    if selm == 'Set the eigenvalues':\n        method = 2\n        sele.disabled = False\n    return method\n\ndef simulation(m,Kw,L,uw,selu,period,simTime,X0w):\n    Aa = numpy.matrix([[0, 1, 0],\n                   [-k/(0.002*(1+m/100.0)), -b/(0.002*(1+m/100.0)), 0],\n                   [1, 0, 0]])\n    Ba = numpy.matrix([[0, 0],\n                       [G/(0.002*(1+m/100.0)), 0],\n                       [0,-1]])\n    A = Aa[0:2,0:2]\n    B = Ba[0:2,0]\n    \n    e1 = numpy.linalg.eig(Aa-Ba[:,0]*Kw)[0]\n    e1n = numpy.array([numpy.linalg.norm(e1[i]) for i in range(3)])\n    e2 = numpy.linalg.eig(A-L*C)[0]\n    e2n = numpy.array([numpy.linalg.norm(e2[i]) for i in range(2)])\n    # print(e1n,e2n)\n    \n    n1 = 0\n    if all(e1n &gt; 0):\n        if all(numpy.real(e1)&lt;0):\n            n1 = int(max(e1n)/2/numpy.pi*1000)\n    if n1==0:\n        n1 = 10000\n    \n    n2 = 0\n    if all(e2n &gt; 0):\n        if all(numpy.real(e2)&lt;0):\n            n2 = int(max(e2n)/2/numpy.pi*1000)\n    if n2==0:\n        n2 = 10000\n    if n1 &gt;= n2:\n        n = n1\n    else:\n        n = n2\n    \n    T = numpy.linspace(0,simTime,n)\n    ts = T[1]-T[0]\n    if selu == 'impulse': #selu\n        R = [0 for t in range(0,len(T))]\n        R[0] = uw        \n    if selu == 'step':\n        R = [uw for t in range(0,len(T))]\n    if selu == 'sinusoid':\n        R = uw*numpy.sin(2*numpy.pi/period*T)\n        #print(R)\n    if selu == 'square wave':\n        R = uw*numpy.sign(numpy.sin(2*numpy.pi/period*T))\n        #print(R)\n    \n    Aad = (numpy.eye(3)+ts*Aa)\n    Bad = ts*Ba\n    Ad = (numpy.eye(2)+ts*(A-L*C))\n    Bd = ts*B\n    Ld = ts*L\n    xa = numpy.matrix([[0],[0],[0]])\n    xe = numpy.matrix([[0],[X0w]])\n    x = numpy.vstack((xa,xe))\n    X = [x]\n    U = []\n    \n    for i in range(len(T)):\n        u = (-Kw*numpy.matrix([[xa[0,0]],[xe[1,0]],[xa[2,0]]]))[0,0]\n        if u &lt; 0:\n            u = 0\n            \n        xe = Ad*xe+Bd*u+Ld*xa[0,0]\n        xa = Aad*xa+Bad*numpy.matrix([[u],[R[i]]])\n        \n        X.append(numpy.vstack((xa,xe)))\n        U.append(u)\n    \n    xout = [\n        [X[i][0,0] for i in range(len(T))],\n        [X[i][1,0] for i in range(len(T))],\n        [X[i][2,0] for i in range(len(T))],\n        [X[i][3,0] for i in range(len(T))],\n        [X[i][4,0] for i in range(len(T))]\n    ]\n    return T, U, R, xout, e1, e2\n\n\ndef main_callback2(mw, X0w, K, L, eig1c, eig2c, eig3c, eig1o, eig2o, u, period, selm, sele, selu, simTime, DW):\n    eige = eigen_choice(sele)\n    method = method_choice(selm)\n    \n    if method == 1:\n        solc = numpy.linalg.eig(Aa-Ba[:,0]*K)[0]\n        solo = numpy.linalg.eig(A-L*C)[0]\n    if method == 2:\n        if eige == 0:\n            K = control.acker(Aa, Ba[:,0], [eig1c[0,0], eig2c[0,0], eig3c[0,0]])\n            Kw.setM(K)\n            L = control.acker(A.T, C.T, [eig1o[0,0], eig2o[0,0]]).T\n            Lw.setM(L)\n        if eige == 2:\n            K = control.acker(Aa, Ba[:,0], [eig3c[0,0], \n                                     numpy.complex(eig2c[0,0],eig2c[1,0]), \n                                     numpy.complex(eig2c[0,0],-eig2c[1,0])])\n            Kw.setM(K)\n            L = control.acker(A.T, C.T, [numpy.complex(eig2o[0,0],eig2o[1,0]), \n                                         numpy.complex(eig2o[0,0],-eig2o[1,0])]).T\n            Lw.setM(L)\n            \n    if simTime != 0:\n        pass\n    else:\n        simTime = 7\n        \n    T, U, R, xout, sol1, sol2 = simulation(mw,K,L,u,selu,period,simTime,X0w[0,0])\n    \n    if selu == 'step':\n        found = False\n        ST5 = 0\n        for i in range(len(T)):\n            if R[i] != 0:\n                if abs((xout[0][i]-R[i])/R[i]) &lt;= 0.05 and not found:\n                    ST5 = T[i]\n                    found = True\n                if abs((xout[0][i]-R[i])/R[i]) &gt; 0.05:\n                    found = False\n        OV = 0\n        for i in range(len(T)):\n            if R[i] != 0:\n                if R[0]&gt;0:\n                    if (xout[0][i]-R[i]) &gt; 0:\n                        if abs((xout[0][i]-R[i])/R[i])*100 &gt; OV:\n                            OV = abs((xout[0][i]-R[i])/R[i])*100\n                else:\n                    if (xout[0][i]-R[i]) &lt; 0:\n                        if abs((xout[0][i]-R[i])/R[i])*100 &gt; OV:\n                            OV = abs((xout[0][i]-R[i])/R[i])*100\n    else:\n        ST5 = 'Not defined' \n        OV = 'Not defined'\n    print('Closed loop system eigenvalues:',sol1)\n    print('Observer eigenvalues:',sol2)\n    print('Step info: \\n\\tSettling time (5%) [s]=',ST5,'\\n\\tOvershoot (%)=',OV)\n    \n    fig = plt.figure(num='Simulation1', figsize=(14,12))\n    \n    fig.add_subplot(221)\n    plt.title('Output response')\n    plt.ylabel('Output [m]')\n    plt.plot(T,xout[0])\n    plt.plot(T,R,'g--')\n    plt.xlabel('$t$ [s]')\n    plt.axvline(x=0,color='black',linewidth=0.8)\n    plt.axhline(y=0,color='black',linewidth=0.8)\n    plt.legend(['$y$','Reference'])\n    plt.grid()\n    \n    fig.add_subplot(222)\n    plt.title('Input')\n    plt.ylabel('$u$ [N]')\n    plt.plot(T,U)\n    plt.xlabel('$t$ [s]')\n    plt.axvline(x=0,color='black',linewidth=0.8)\n    plt.axhline(y=0,color='black',linewidth=0.8)\n    plt.grid()\n    \n    fig.add_subplot(223)\n    plt.title('States response')\n    plt.ylabel('States')\n    plt.plot(T,xout[0],\n             T,xout[1],\n             T,xout[2])\n    plt.xlabel('$t$ [s]')\n    plt.axvline(x=0,color='black',linewidth=0.8)\n    plt.axhline(y=0,color='black',linewidth=0.8)\n    plt.legend(['$x_{1}$','$x_{2}$','$x_{3}$'])\n    plt.grid()\n    \n    fig.add_subplot(224)\n    plt.title('Estimation errors')\n    plt.ylabel('Error')\n    plt.plot(T,numpy.array(xout[1])-numpy.array(xout[4]))\n    plt.xlabel('$t$ [s]')\n    plt.axvline(x=0,color='black',linewidth=0.8)\n    plt.axhline(y=0,color='black',linewidth=0.8)\n    plt.legend(['$e_{2}$'])\n    plt.grid()\n    #plt.tight_layout()\n   \nalltogether2 = widgets.VBox([widgets.HBox([selm, \n                                          sele,\n                                          selu]),\n                            widgets.Label(' ',border=3),\n                            widgets.HBox([widgets.Label('K:',border=3), Kw, \n                                          widgets.Label(' ',border=3),\n                                          widgets.Label(' ',border=3),\n                                          widgets.Label('Eigenvalues:',border=3), \n                                          eig1c, \n                                          eig2c, \n                                          eig3c,\n                                          widgets.Label(' ',border=3),\n                                          widgets.Label(' ',border=3),\n                                          widgets.Label('X0 est.:',border=3), X0w]),\n                            widgets.Label(' ',border=3),\n                            widgets.HBox([widgets.Label('L:',border=3), Lw, \n                                          widgets.Label(' ',border=3),\n                                          widgets.Label(' ',border=3),\n                                          widgets.Label('Eigenvalues:',border=3), \n                                          eig1o, \n                                          eig2o,\n                                          widgets.Label(' ',border=3),\n                                          widgets.VBox([widgets.Label('Simulation time [s]:',border=3)]),\n                                          widgets.VBox([simTime])]),\n                            widgets.Label(' ',border=3),\n                            widgets.HBox([u,\n                                          mw,\n                                          period, \n                                          START])])\nout2 = widgets.interactive_output(main_callback2, {'mw':mw, 'X0w':X0w, 'K':Kw, 'L':Lw,\n                                                 'eig1c':eig1c, 'eig2c':eig2c, 'eig3c':eig3c, 'eig1o':eig1o, 'eig2o':eig2o, \n                                                 'u':u, 'period':period, 'selm':selm, 'sele':sele, 'selu':selu, 'simTime':simTime, 'DW':DW})\nout2.layout.height = '860px'\ndisplay(out2, alltogether2)"
  },
  {
    "objectID": "ICCT_en/examples/04/SS-49-AUV_heading_control.html",
    "href": "ICCT_en/examples/04/SS-49-AUV_heading_control.html",
    "title": "Autonomous Underwater Vehicle (AUV) Heading Control",
    "section": "",
    "text": "#remove cell visibility\nfrom IPython.display import HTML\ntag = HTML('''&lt;script&gt;\ncode_show=true; \nfunction code_toggle() {\n    if (code_show){\n        $('div.input').hide()\n    } else {\n        $('div.input').show()\n    }\n    code_show = !code_show\n} \n$( document ).ready(code_toggle);\n&lt;/script&gt;\nToggle cell visibility &lt;a href=\"javascript:code_toggle()\"&gt;here&lt;/a&gt;.''')\ndisplay(tag)\n\n\nToggle cell visibility here.\n\n\n\n%matplotlib inline\nimport control\nimport numpy\nimport sympy as sym\nfrom IPython.display import display, Markdown\nimport ipywidgets as widgets\nimport matplotlib.pyplot as plt\n\n\n#print a matrix latex-like\ndef bmatrix(a):\n     \"\"\"Returns a LaTeX bmatrix - by Damir Arbula (ICCT project)\n\n     :a: numpy array\n     :returns: LaTeX bmatrix as a string\n     \"\"\"\n     if len(a.shape) &gt; 2:\n         raise ValueError('bmatrix can at most display two dimensions')\n     lines = str(a).replace('[', '').replace(']', '').splitlines()\n     rv = [r'\\begin{bmatrix}']\n     rv += ['  ' + ' & '.join(l.split()) + r'\\\\' for l in lines]\n     rv +=  [r'\\end{bmatrix}']\n     return '\\n'.join(rv)\n\n\n# Display formatted matrix: \ndef vmatrix(a):\n    if len(a.shape) &gt; 2:\n         raise ValueError('bmatrix can at most display two dimensions')\n    lines = str(a).replace('[', '').replace(']', '').splitlines()\n    rv = [r'\\begin{vmatrix}']\n    rv += ['  ' + ' & '.join(l.split()) + r'\\\\' for l in lines]\n    rv +=  [r'\\end{vmatrix}']\n    return '\\n'.join(rv)\n\n\n#matrixWidget is a matrix looking widget built with a VBox of HBox(es) that returns a numPy array as value !\nclass matrixWidget(widgets.VBox):\n    def updateM(self,change):\n        for irow in range(0,self.n):\n            for icol in range(0,self.m):\n                self.M_[irow,icol] = self.children[irow].children[icol].value\n                #print(self.M_[irow,icol])\n        self.value = self.M_\n\n    def dummychangecallback(self,change):\n        pass\n    \n    \n    def __init__(self,n,m):\n        self.n = n\n        self.m = m\n        self.M_ = numpy.matrix(numpy.zeros((self.n,self.m)))\n        self.value = self.M_\n        widgets.VBox.__init__(self,\n                             children = [\n                                 widgets.HBox(children = \n                                              [widgets.FloatText(value=0.0, layout=widgets.Layout(width='90px')) for i in range(m)]\n                                             ) \n                                 for j in range(n)\n                             ])\n        \n        #fill in widgets and tell interact to call updateM each time a children changes value\n        for irow in range(0,self.n):\n            for icol in range(0,self.m):\n                self.children[irow].children[icol].value = self.M_[irow,icol]\n                self.children[irow].children[icol].observe(self.updateM, names='value')\n        #value = Unicode('example@example.com', help=\"The email value.\").tag(sync=True)\n        self.observe(self.updateM, names='value', type= 'All')\n        \n    def setM(self, newM):\n        #disable callbacks, change values, and reenable\n        self.unobserve(self.updateM, names='value', type= 'All')\n        for irow in range(0,self.n):\n            for icol in range(0,self.m):\n                self.children[irow].children[icol].unobserve(self.updateM, names='value')\n        self.M_ = newM\n        self.value = self.M_\n        for irow in range(0,self.n):\n            for icol in range(0,self.m):\n                self.children[irow].children[icol].value = self.M_[irow,icol]\n        for irow in range(0,self.n):\n            for icol in range(0,self.m):\n                self.children[irow].children[icol].observe(self.updateM, names='value')\n        self.observe(self.updateM, names='value', type= 'All')        \n\n                #self.children[irow].children[icol].observe(self.updateM, names='value')\n\n             \n#overlaod class for state space systems that DO NOT remove \"useless\" states (what \"professor\" of automatic control would do this?)\nclass sss(control.StateSpace):\n    def __init__(self,*args):\n        #call base class init constructor\n        control.StateSpace.__init__(self,*args)\n    #disable function below in base class\n    def _remove_useless_states(self):\n        pass\n\nDynamics of the heading angle \\(\\psi\\) of an Autonomous Underwater Vehicle (AUV), equipped with jet pumps on its tail to produce rotations, can be modelled as:\n\\[\nJ_z\\ddot{\\psi} = −DV\\dot{\\psi} + P\\alpha,\n\\]\nwhere \\(J_z = 3.75\\) kg\\(\\text{m}^2\\) is the vehicle moment of inertia around the yaw/heading axis, \\(D = 25\\) Nms the drag coefficient, \\(V\\) the current vehicle surge velocity (in m/s), \\(P = 0.32\\) Nms the jet pump coefficient and \\(\\alpha\\) the jet pump propeller rotation speed (in rad/s). The propeller inside the jet pump is actuated by an electric motor which speed must be kept within \\(\\pm100\\) revolutions per minute (RPM). The electric motor dynamics can be modelled as:\n\\[\nM(s)=\\frac{\\alpha(s)}{u(s)}=0.45\\frac{\\omega_n^2}{s^2+2\\omega_n\\xi s +\\omega_n^2}\n\\]\nwith \\(\\omega_n = 9\\) and \\(\\xi = 0.8\\), where \\(u(𝑠)\\) is the motor applied voltage. The heading velocity is measured with an electronic gyro-compass.\nThe maximum allowed steady-state voltage \\(u\\) in order to respect the limit of RPM of the motor can be computed as (final value theorem): \\[\nu_{\\text{max}} = \\frac{\\alpha_{\\text{max}}}{M(s)|_{s=0}} = \\frac{\\pm100 \\frac{2\\pi}{60}}{0.45} \\approx \\pm 23.3 \\text{V} \\, .\n\\]\nConsidering a surge velocity \\(V\\) of 1 m/s and a step request equal to half the maximum \\(\\dot{\\psi}\\) achievable in steady state, we want to develop a regulator for the heading velocity that respects the following requirements: - settling time for 5% tolerance band of less than 5 seconds, - no overshoot, - no steady-state error in response to a step velocity request, - maximum jet pump propeller speed not exceeded.\nFirst, we have to make a realisation of the electric motor dynamics and append it to the AUV’s heading dynamics. A possible realisation, defining \\(z=\\begin{bmatrix} z_1 & z_2 \\end{bmatrix}^T\\), is\n\\[\\begin{cases}\n    \\dot{z} = \\underbrace{\\begin{bmatrix} 0 & 1 \\\\ -\\omega_n^2 & -2\\xi\\omega_n \\end{bmatrix}}_{A_m}z + \\begin{bmatrix} 0 \\\\ 0.45 \\end{bmatrix}u \\\\\n    \\alpha = \\begin{bmatrix} \\omega_n^2 & 0 \\end{bmatrix}z\n\\end{cases}\\]\nso the total dynamics in state space form, with \\(x = \\begin{bmatrix} x_1 & x_2 & x_3 \\end{bmatrix}^T = \\begin{bmatrix} \\dot{\\psi} & z_1 & z_2 \\end{bmatrix}^T\\), can be written as:\n\\[\\begin{cases}\n    \\dot{x} = \\begin{bmatrix} -\\frac{DV}{J_z} & \\frac{P}{J_z}\\omega_n^2 & 0 \\\\ 0 & 0 & 1 \\\\ 0 & -\\omega_n^2 & -2\\xi\\omega_n \\end{bmatrix}x + \\begin{bmatrix} 0 \\\\ 0 \\\\ 0.45 \\end{bmatrix}u \\\\\n    y = \\begin{bmatrix} 1 & 0 & 0 \\end{bmatrix}x \\, .\n\\end{cases}\\]\n\\(\\dot{\\psi}_{\\text{max}} = \\frac{P}{DV}\\alpha_{\\text{max}} = \\frac{P}{DV}100 \\frac{2\\pi}{60} \\approx 0.134\\) rad/s.\n\nRegulator design\n\nController design\nTo meet the requirements of zero steady-state error we add a new state: \\[\n\\dot{x_4} = \\dot{\\psi}-y_d = x_1 - y_d\n\\] The resulting augmented system is thus\n\\[\\begin{cases}\n    \\dot{x_a} = \\begin{bmatrix} -\\frac{DV}{J_z} & \\frac{P}{J_z}\\omega_n^2 & 0 & 0 \\\\ 0 & 0 & 1 & 0 \\\\ 0 & -\\omega_n^2 & -2\\xi\\omega_n & 0 \\\\ 1 & 0 & 0 & 0 \\end{bmatrix}x_a + \\begin{bmatrix} 0 & 0 \\\\ 0 & 0 \\\\ 0.45 & 0 \\\\ 0 & -1 \\end{bmatrix}\\begin{bmatrix} u \\\\ y_d \\end{bmatrix} \\\\\n    y_a = \\begin{bmatrix} 1 & 0 & 0 & 0 \\\\ 0 & 0 & 0 & 1 \\end{bmatrix}x_a,\n\\end{cases}\\]\nwhere \\(x_a = \\begin{bmatrix} x_1 & x_2 & x_3 & x_4 \\end{bmatrix}^T = \\begin{bmatrix} \\dot{\\psi} & z_1 & z_2 & x_4 \\end{bmatrix}^T\\) and the second output is added to maintain the observability. In order to try to limit the amplitude of input \\(u\\) and thus \\(\\alpha\\), given that the open-loop poles are fast with respect to the requirements, we change only the pole associated with the state \\(x_4\\). The selected poles are \\(-\\frac{DV}{J_z} \\approx -6.67\\), \\(-\\xi\\omega_n \\pm \\sqrt{1-\\xi^2}\\omega_n = -7.2 \\pm -5.4i\\) and \\(-0.7\\).\n\n\nObserver design\nSince measurements of \\(x_1\\) and \\(x_4\\) are available, we only need to estimate \\(x_1\\) and \\(x_2\\). We work with the full \\(4\\times4\\) system and design a state observer with poles in \\(-15\\).\n\n\n\nHow to use this notebook?\n\nTry, by changing the poles of the controller, to meet the requirements with \\(V = 1.5\\) m/s.\nTry to reduce the settling time below 3 s allowing a maximum overshoot of 10%.\n\n\n# Preparatory cell\n\nX0 = numpy.matrix('0.0; 0.0; 0.0; 0.0')\nK = numpy.matrix([0,0,0,0])\nL = numpy.matrix([[0,0],[0,0],[0,0],[0,0]])\n\nX0w = matrixWidget(4,1)\nX0w.setM(X0)\nKw = matrixWidget(1,4)\nKw.setM(K)\nLw = matrixWidget(4,2)\nLw.setM(L)\n\n\neig1c = matrixWidget(1,1)\neig2c = matrixWidget(2,1)\neig3c = matrixWidget(1,1)\neig4c = matrixWidget(2,1)\neig1c.setM(numpy.matrix([-6.67])) \neig2c.setM(numpy.matrix([[-7.2],[-5.4]]))\neig3c.setM(numpy.matrix([-0.7]))\neig4c.setM(numpy.matrix([[-1.],[-1.]]))\n\neig1o = matrixWidget(1,1)\neig2o = matrixWidget(2,1)\neig3o = matrixWidget(1,1)\neig4o = matrixWidget(2,1)\neig1o.setM(numpy.matrix([-15.])) \neig2o.setM(numpy.matrix([[-15.],[0.]]))\neig3o.setM(numpy.matrix([-15.]))\neig4o.setM(numpy.matrix([[-15.],[0.]]))\n\n\n# Misc\n\n#create dummy widget \nDW = widgets.FloatText(layout=widgets.Layout(width='0px', height='0px'))\n\n#create button widget\nSTART = widgets.Button(\n    description='Test',\n    disabled=False,\n    button_style='', # 'success', 'info', 'warning', 'danger' or ''\n    tooltip='Test',\n    icon='check'\n)\n                       \ndef on_start_button_clicked(b):\n    #This is a workaround to have intreactive_output call the callback:\n    #   force the value of the dummy widget to change\n    if DW.value&gt; 0 :\n        DW.value = -1\n    else: \n        DW.value = 1\n    pass\nSTART.on_click(on_start_button_clicked)\n\n# Define type of method \nselm = widgets.Dropdown(\n    options= ['Set K and L', 'Set the eigenvalues'],\n    value= 'Set the eigenvalues',\n    description='',\n    disabled=False\n)\n\n# Define the number of complex eigenvalues\nselec = widgets.Dropdown(\n    options= ['0 complex eigenvalues', '2 complex eigenvalues', '4 complex eigenvalues'],\n    value= '2 complex eigenvalues',\n    description='Eig controller:',\n    disabled=False\n)\nseleo = widgets.Dropdown(\n    options= ['0 complex eigenvalues', '2 complex eigenvalues', '4 complex eigenvalues'],\n    value= '0 complex eigenvalues',\n    description='Eig observer:',\n    disabled=False\n)\n\n#define type of ipout \nselu = widgets.Dropdown(\n    options=['impulse', 'step', 'sinusoid', 'square wave'],\n    value='step',\n    description='Type of reference:',\n    style = {'description_width': 'initial'},\n    disabled=False\n)\n# Define the values of the input\nu = widgets.FloatSlider(\n    value=0.134,\n    min=0,\n    max=0.5,\n    step=0.001,\n    description='',\n    disabled=False,\n    continuous_update=False,\n    orientation='horizontal',\n    readout=True,\n    readout_format='.3f',\n)\nv = widgets.FloatSlider(\n    value=1,\n    min=0.5,\n    max=4,\n    step=0.1,\n    description=r'$V$:',\n    disabled=False,\n    continuous_update=False,\n    orientation='horizontal',\n    readout=True,\n    readout_format='.3f',\n)\nperiod = widgets.FloatSlider(\n    value=0.5,\n    min=0.001,\n    max=10,\n    step=0.001,\n    description='Period: ',\n    disabled=False,\n    continuous_update=False,\n    orientation='horizontal',\n    readout=True,\n    readout_format='.3f',\n)\n\nsimTime = widgets.FloatText(\n    value=10,\n    description='',\n    disabled=False\n)\n\n\n# Support functions\n\ndef eigen_choice(selec,seleo):\n    if selec == '0 complex eigenvalues':\n        eig1c.children[0].children[0].disabled = False\n        eig2c.children[1].children[0].disabled = True\n        eig3c.children[0].children[0].disabled = False\n        eig4c.children[0].children[0].disabled = False\n        eig4c.children[1].children[0].disabled = True\n        eigc = 0\n    if seleo == '0 complex eigenvalues':\n        eig1o.children[0].children[0].disabled = False\n        eig2o.children[1].children[0].disabled = True\n        eig3o.children[0].children[0].disabled = False\n        eig4o.children[0].children[0].disabled = False\n        eig4o.children[1].children[0].disabled = True\n        eigo = 0\n    if selec == '2 complex eigenvalues':\n        eig1c.children[0].children[0].disabled = False\n        eig2c.children[1].children[0].disabled = False\n        eig3c.children[0].children[0].disabled = False\n        eig4c.children[0].children[0].disabled = True\n        eig4c.children[1].children[0].disabled = True\n        eigc = 2\n    if seleo == '2 complex eigenvalues':\n        eig1o.children[0].children[0].disabled = False\n        eig2o.children[1].children[0].disabled = False\n        eig3o.children[0].children[0].disabled = False\n        eig4o.children[0].children[0].disabled = True\n        eig4o.children[1].children[0].disabled = True\n        eigo = 2\n    if selec == '4 complex eigenvalues':\n        eig1c.children[0].children[0].disabled = True\n        eig2c.children[1].children[0].disabled = False\n        eig3c.children[0].children[0].disabled = True\n        eig4c.children[0].children[0].disabled = False\n        eig4c.children[1].children[0].disabled = False\n        eigc = 4\n    if seleo == '4 complex eigenvalues':\n        eig1o.children[0].children[0].disabled = True\n        eig2o.children[1].children[0].disabled = False\n        eig3o.children[0].children[0].disabled = True\n        eig4o.children[0].children[0].disabled = False\n        eig4o.children[1].children[0].disabled = False\n        eigo = 4\n    return eigc, eigo\n\ndef method_choice(selm):\n    if selm == 'Set K and L':\n        method = 1\n        selec.disabled = True\n        seleo.disabled = True\n    if selm == 'Set the eigenvalues':\n        method = 2\n        selec.disabled = False\n        seleo.disabled = False\n    return method\n\n\nD = 25\nP = 0.32\nV = 1\nJz = 3.75\n\nA = numpy.matrix([[-D*V/Jz, P/Jz*9**2, 0, 0],\n                  [0, 0, 1, 0],\n                  [0, -9**2, -2*0.8*9, 0],\n                  [1, 0, 0, 0]])\nBu = numpy.matrix([[0],[0],[0.45],[0]])\nBref = numpy.matrix([[0],[0],[0],[-1]])\nC = numpy.matrix([[1,0,0,0],[0,0,0,1]])\n\ndef main_callback2(v, X0w, K, L, eig1c, eig2c, eig3c, eig4c, eig1o, eig2o, eig3o, eig4o, u, period, selm, selec, seleo, selu, simTime, DW):\n    eigc, eigo = eigen_choice(selec,seleo)\n    method = method_choice(selm)\n    \n    A = numpy.matrix([[-D*v/Jz, P/Jz*9**2, 0, 0],\n                  [0, 0, 1, 0],\n                  [0, -9**2, -2*0.8*9, 0],\n                  [1, 0, 0, 0]])\n    \n    if method == 1:\n        solc = numpy.linalg.eig(A-Bu*K)\n        solo = numpy.linalg.eig(A-L*C)\n    if method == 2:\n        #for better numerical stability of place\n        if eig1c[0,0]==eig2c[0,0] or eig1c[0,0]==eig3c[0,0] or eig1c[0,0]==eig4c[0,0]:\n            eig1c[0,0] *= 1.01\n        if eig2c[0,0]==eig3c[0,0] or eig2c[0,0]==eig4c[0,0]:\n            eig3c[0,0] *= 1.015\n        if eig1o[0,0]==eig2o[0,0] or eig1o[0,0]==eig3o[0,0] or eig1o[0,0]==eig4o[0,0]:\n            eig1o[0,0] *= 1.01\n        if eig2o[0,0]==eig3o[0,0] or eig2o[0,0]==eig4o[0,0]:\n            eig3o[0,0] *= 1.015\n            \n        if eigc == 0:\n            K = control.acker(A, Bu, [eig1c[0,0], eig2c[0,0], eig3c[0,0], eig4c[0,0]])\n            Kw.setM(K)\n        if eigc == 2:\n            K = control.acker(A, Bu, [eig3c[0,0],\n                                      eig1c[0,0],\n                                      numpy.complex(eig2c[0,0], eig2c[1,0]), \n                                      numpy.complex(eig2c[0,0],-eig2c[1,0])])\n            Kw.setM(K)\n        if eigc == 4:\n            K = control.acker(A, Bu, [numpy.complex(eig4c[0,0], eig4c[1,0]), \n                                      numpy.complex(eig4c[0,0],-eig4c[1,0]),\n                                      numpy.complex(eig2c[0,0], eig2c[1,0]), \n                                      numpy.complex(eig2c[0,0],-eig2c[1,0])])\n            Kw.setM(K)\n        if eigo == 0:\n            L = control.place(A.T, C.T, [eig1o[0,0], eig2o[0,0], eig3o[0,0], eig4o[0,0]]).T\n            Lw.setM(L)\n        if eigo == 2:\n            L = control.place(A.T, C.T, [eig3o[0,0],\n                                         eig1o[0,0],\n                                         numpy.complex(eig2o[0,0], eig2o[1,0]), \n                                         numpy.complex(eig2o[0,0],-eig2o[1,0])]).T\n            Lw.setM(L)\n        if eigo == 4:\n            L = control.place(A.T, C.T, [numpy.complex(eig4o[0,0], eig4o[1,0]), \n                                      numpy.complex(eig4o[0,0],-eig4o[1,0]),\n                                      numpy.complex(eig2o[0,0], eig2o[1,0]), \n                                      numpy.complex(eig2o[0,0],-eig2o[1,0])]).T\n            Lw.setM(L)\n            \n    sys = sss(A,numpy.hstack((Bu,Bref)),[[1,0,0,0],[0,0,0,1],[0,0,0,0]],[[0,0],[0,0],[0,1]])\n    syse = sss(A-L*C,numpy.hstack((Bu,Bref,L)),numpy.eye(4),numpy.zeros((4,4)))\n    sysc = sss(0,[0,0,0,0],0,-K)\n    sys_append = control.append(sys,syse,sysc)\n    try:\n        sys_CL = control.connect(sys_append,\n                                 [[1,8],[3,8],[5,1],[6,2],[7,4],[8,5],[9,6],[10,7],[4,3]],\n                                 [2],\n                                 [1,8])\n    except:\n        sys_CL = control.connect(sys_append,\n                                 [[1,8],[3,8],[5,1],[6,2],[7,4],[8,5],[9,6],[10,7],[4,3]],\n                                 [2],\n                                 [1,8])\n\n    X0w1 = numpy.zeros((8,1))\n    X0w1[4,0] = X0w[0,0]\n    X0w1[5,0] = X0w[1,0]\n    X0w1[6,0] = X0w[2,0]\n    X0w1[7,0] = X0w[3,0]\n    if simTime != 0:\n        T = numpy.linspace(0, simTime, 10000)\n    else:\n        T = numpy.linspace(0, 1, 10000)\n      \n    if selu == 'impulse': #selu\n        U = [0 for t in range(0,len(T))]\n        U[0] = u\n        T, yout, xout = control.forced_response(sys_CL,T,U,X0w1)\n    if selu == 'step':\n        U = [u for t in range(0,len(T))]\n        T, yout, xout = control.forced_response(sys_CL,T,U,X0w1)\n    if selu == 'sinusoid':\n        U = u*numpy.sin(2*numpy.pi/period*T)\n        T, yout, xout = control.forced_response(sys_CL,T,U,X0w1)\n    if selu == 'square wave':\n        U = u*numpy.sign(numpy.sin(2*numpy.pi/period*T))\n        T, yout, xout = control.forced_response(sys_CL,T,U,X0w1)\n    \n    try:\n        step_info_dict = control.step_info(sys_CL[0,0],SettlingTimeThreshold=0.05,T=T)\n        print('Step info: \\n\\tRise time =',step_info_dict['RiseTime'],'\\n\\tSettling time (5%) =',step_info_dict['SettlingTime'],'\\n\\tOvershoot (%)=',step_info_dict['Overshoot'])\n        print('Max alpha value (% of 100 RPM)=', max(abs(xout[1]*9**2*60/2/numpy.pi))/(100)*100)\n        print('Max u value (% of 23.3V)=', max(abs(yout[1]))/(23.3)*100)\n    except:\n        print(\"Error in the calculation of step info.\")\n    \n    fig = plt.figure(num='Simulation1', figsize=(14,12))\n    \n    fig.add_subplot(221)\n    plt.title('Output response')\n    plt.ylabel('Output')\n    plt.plot(T,yout[0],T,U,'r--')\n    plt.xlabel('$t$ [s]')\n    plt.axvline(x=0,color='black',linewidth=0.8)\n    plt.axhline(y=0,color='black',linewidth=0.8)\n    plt.legend(['$y$','Reference'])\n    plt.grid()\n    \n    fig.add_subplot(222)\n    plt.title('Input')\n    plt.ylabel('$u$')\n    plt.plot(T,yout[1])\n    plt.plot(T,[23.3 for i in range(len(T))],'r--')\n    plt.plot(T,[-23.3 for i in range(len(T))],'r--')\n    plt.xlabel('$t$ [s]')\n    plt.axvline(x=0,color='black',linewidth=0.8)\n    plt.axhline(y=0,color='black',linewidth=0.8)\n    plt.grid()\n    \n    fig.add_subplot(223)\n    plt.title('States response')\n    plt.ylabel('States')\n    plt.plot(T,xout[0],\n             T,xout[1],\n             T,xout[2],\n             T,xout[3],\n             T,[100*2*numpy.pi/60/9**2 for i in range(len(T))],'r--',\n             T,[-100*2*numpy.pi/60/9**2 for i in range(len(T))],'r--')\n    plt.xlabel('$t$ [s]')\n    plt.axvline(x=0,color='black',linewidth=0.8)\n    plt.axhline(y=0,color='black',linewidth=0.8)\n    plt.legend(['$x_{1}$','$x_{2}$','$x_{3}$','$x_{4}$','+lim $x_2$','-lim $x_2$'])\n    plt.grid()\n    \n    fig.add_subplot(224)\n    plt.title('Estimation errors')\n    plt.ylabel('Errors')\n    plt.plot(T,xout[4]-xout[0])\n    plt.plot(T,xout[5]-xout[1])\n    plt.plot(T,xout[6]-xout[2])\n    plt.plot(T,xout[7]-xout[3])\n    plt.xlabel('$t$ [s]')\n    plt.axvline(x=0,color='black',linewidth=0.8)\n    plt.axhline(y=0,color='black',linewidth=0.8)\n    plt.legend(['$e_{1}$','$e_{2}$','$e_{3}$','$e_{4}$'])\n    plt.grid()\n    #plt.tight_layout()\n   \nalltogether2 = widgets.VBox([widgets.HBox([selm, \n                                          selec,\n                                          seleo,\n                                          selu]),\n                            widgets.Label(' ',border=3),\n                            widgets.HBox([widgets.HBox([widgets.Label('K:',border=3), Kw, \n                                                        widgets.Label('Eigenvalues:',border=3),\n                                                        widgets.HBox([eig1c, \n                                                                      eig2c, \n                                                                      eig3c,\n                                                                      eig4c])])]),\n                            widgets.Label(' ',border=3),\n                            widgets.HBox([widgets.VBox([widgets.HBox([widgets.Label('L:',border=3), Lw, widgets.Label(' ',border=3),\n                                          widgets.Label(' ',border=3),\n                                          widgets.Label('Eigenvalues:',border=3), \n                                          eig1o, \n                                          eig2o,\n                                          eig3o, \n                                          eig4o,\n                                          widgets.Label(' ',border=3),\n                                          widgets.Label(' ',border=3),\n                                          widgets.Label('X0 est.:',border=3), X0w]),\n                                          widgets.Label(' ',border=3),\n                                                       widgets.HBox([\n                                          widgets.VBox([widgets.Label('Simulation time [s]:',border=3)]),\n                                          widgets.VBox([simTime])])]),\n                                          widgets.Label(' ',border=3)]),\n                            widgets.Label(' ',border=3),\n                            widgets.HBox([widgets.Label('Reference [rad]:',border=3),\n                                          u,\n                                          v]),\n                            widgets.HBox([period,START])])\nout2 = widgets.interactive_output(main_callback2, {'v':v, 'X0w':X0w, 'K':Kw, 'L':Lw,\n                                                   'eig1c':eig1c, 'eig2c':eig2c, 'eig3c':eig3c, 'eig4c':eig4c, \n                                                   'eig1o':eig1o, 'eig2o':eig2o, 'eig3o':eig3o, 'eig4o':eig4o,  \n                                                   'u':u, 'period':period, 'selm':selm, 'selec':selec, 'seleo':seleo, 'selu':selu, 'simTime':simTime, 'DW':DW})\nout2.layout.height = '880px'\ndisplay(out2, alltogether2)"
  },
  {
    "objectID": "ICCT_en/FAQ-en.html#basic-information",
    "href": "ICCT_en/FAQ-en.html#basic-information",
    "title": "FAQ",
    "section": "Basic information",
    "text": "Basic information\n\n\nCan I see a demonstration of the examples featured in this interactive course?\nThere are two video demonstrations available. The first one presents the water level control system (view on YouTube) and the second one the Fast Fourier Transform (view on YouTube).\n\n\nI would like to give my students/colleagues short instructions on how to register to the course, login and interact with the examples within the course. Do you have such instructions?\nInstructions for registration, login procedure and interaction with the examples are available in the form of an iorad tutorial, available here.\n\n\nWhere can I find the handbook that accompanies the interactive course?\nThe PDF version of the handbook (available in English, Croatian, Hungarian, Italian and Slovene language) can be downloaded from ICCT webpage.\n\n\nWhere can I learn more about the ICCT project?\nYou can visit project website, Twitter page, Reddit, GitHub to gather more information about the project. You can also follow the project via ResearchGate, SCIENTIX or Erasmus+ Project Results."
  },
  {
    "objectID": "ICCT_en/FAQ-en.html#exams",
    "href": "ICCT_en/FAQ-en.html#exams",
    "title": "FAQ",
    "section": "Exams",
    "text": "Exams\n\n\nI am a Student. How can I take part in an exam and how do I obtain my grade?\nExam can be taken after a Mentor has prepared and released an exam. Once this is done, you have to fetch the exam and provide the answers (see this tutorial for the instructions). Once you have successfully submitted your answers, you have to wait for a Mentor to collect all the submissions, grade them and generate the feedback. Once this is done you will be able to obtain and inspect Mentor’s feedback (see this tutorial for the instructions).\n\n\nI am a Mentor (teacher/lecturer). How can I prepare an exam for Students?\nFirst, you need to prepare and release an exam (see this tutorial for more information). Then, you have to wait for the exam to end, so that you can collect all submissions, autograde them and generate feedback for Students (see this tutorial for more information). Once you are done, Students will be able to obtain and inspect provided feedback."
  },
  {
    "objectID": "ICCT_en/FAQ-en.html#personal-and-commercial-use-of-the-contents-of-the-interactive-course",
    "href": "ICCT_en/FAQ-en.html#personal-and-commercial-use-of-the-contents-of-the-interactive-course",
    "title": "FAQ",
    "section": "Personal and commercial use of the contents of the interactive course",
    "text": "Personal and commercial use of the contents of the interactive course\n\n\nIs it possible to download the examples and adopt them to my own needs?\nYes, download of the examples available within the interactive course is possible via ICCT’s GitHub Repository. The instructions are available here. You can adopt the examples according to your needs, however, their usage has to comply with the 3-Clause BSD license. For more information about this license, please click here.\n\n\nI would like to use the interactive examples for my home/school project. Is it allowed to do it?\nAll the interactive examples (Juypter Notebooks) within the course are authored by ICCT Project Consortium, and are licensed under the terms of the 3-Clause BSD license, which is part of the permissive free software licenses. For more information about it, please click here.\n\n\nI would like to use the interactive examples for commercial purposes. Is it allowed to do it?\nAll the interactive examples (Juypter Notebooks) within the course are authored by ICCT Project Consortium, and are licensed under the terms of the 3-Clause BSD license, which is part of the permissive free software licenses. For more information about it, please click here.\n\n\nI would like to translate the examples to my language. Is it possible to do it?\nYes, the interactive examples can be translated to any language by anyone interested. Prior to starting the translations, please contact us via icct.erasmus@gmail.com, so that we provide you with instructions. Please note that our course is currently being translated to Indonesian and Spanish languages."
  },
  {
    "objectID": "ICCT_en/FAQ-en.html#issues",
    "href": "ICCT_en/FAQ-en.html#issues",
    "title": "FAQ",
    "section": "Issues",
    "text": "Issues\n\n\nAfter running the selected example by clicking Cell-Run All or the corresponding button in the toolbar, the the example does not load properly.\n\nFirst, notebook should be run only when the kernel is ready. The ‘transient info’ about the kernel can be seen in the upper right part of the notebook, during the initial loading (please see Figure 1 below).\nSecond, wait for the icon in the browser tab to change from the hourglass to the book symbol at the initial loading stage (please see Figure 2 below). Please note that examples with long-running simulations may have hourglass visible even after initial loading, i.e., once the simulation actually starts, or when some processing is done in the background.\nLast, if none of the above solutions work, please run the example twice (by clicking on Cell-Run All or the corresponding button once again after the kernel is ready and book symbol is displayed).\n\n\n\n\nFigure 1. Kernel information\n\n\nFigure 2. Loading information\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nThe examples are loading and running rather slow. What can I do?\n\nFirst, make sure that you have closed and halted the previously opened examples by clicking on File-Close and Halt. You can see the examples that are still running under the Running tab accessible via the starting page of the course.\nSecond, there might be a lot of users concurrently logged in the course, which might slow down the system.\nIf the issue persists, please contact us via icct.erasmus@gmail.com.\nNote: You can also always run your examples locally (the loading and running times will depend on your resources). For more information, click here.\n\n\n\nI registered to the course and my default role is Student. How can I change it to Mentor?\nPlease note the Mentor role is available only for teachers/lecturers. For obtaining the Mentor role, please send a request to icct.erasmus@gmail.com.\n\n\nI have already registered on the old course site (https://icct.riteh.hr). Do I need to register once again on the new site (https://icct.unipi.it)?\nYes, you have to register on the new site as well. Please note that the old page is not maintained anymore and will be removed after some time. Thank you for your understanding.\n\n\nMy issue is not listed here. How can I contact the team behind the interactive course?\nYou can contact the ICCT team via email icct.erasmus@gmail.com or through any of the channels listed in the Basic information section of these FAQs."
  },
  {
    "objectID": "control_21.html#learning-objectives",
    "href": "control_21.html#learning-objectives",
    "title": "Modeling in the Frequency Domain",
    "section": "Learning Objectives",
    "text": "Learning Objectives\nBy the end of this session, you will be able to:\n\nUnderstand the advantages of the frequency domain over the time domain for system modeling.\nApply the Laplace Transform to convert differential equations into algebraic equations.\nPerform Partial-Fraction Expansion for real, repeated, and complex roots.\nDerive Transfer Functions (\\(G(s)\\)) from linear, time-invariant (LTI) differential equations.\nCalculate system time responses using the Inverse Laplace Transform."
  },
  {
    "objectID": "control_21.html#introduction-why-frequency-domain",
    "href": "control_21.html#introduction-why-frequency-domain",
    "title": "Modeling in the Frequency Domain",
    "section": "2.1 Introduction: Why Frequency Domain?",
    "text": "2.1 Introduction: Why Frequency Domain?\n\n\nThe Challenge\nDifferential equations are the “natural” language of physics, but they are difficult to use when: - Interconnecting multiple subsystems. - Visualizing system behavior at a glance. - Parameters are scattered across terms.\n\nThe Solution\nMathematical representations where Input, System, and Output are distinct parts.\n\n\n\n\n\n\n\n\n\n\n\n\n\nIn Chapter 1, we saw that differential equations relate input and output. However, to a control engineer, we want a “Lego-block” approach where we can cascade systems easily."
  },
  {
    "objectID": "control_21.html#moving-from-schematic-to-model",
    "href": "control_21.html#moving-from-schematic-to-model",
    "title": "Modeling in the Frequency Domain",
    "section": "Moving from Schematic to Model",
    "text": "Moving from Schematic to Model\nTo develop a mathematical model, we follow these steps:\n\nPhysical Laws: Apply Ohm’s Law, Kirchhoff’s Laws (Electrical), or Newton’s Laws (Mechanical).\nDifferential Equation: Describe the relationship between input \\(r(t)\\) and output \\(c(t)\\).\nTransform: Use Laplace to move to the frequency domain.\n\n\n\n\n\n\n\nHistorical Context\n\n\nThis methodology allows us to replace calculus (derivatives/integrals) with simple algebra (multiplication/division)."
  },
  {
    "objectID": "control_21.html#the-laplace-transform",
    "href": "control_21.html#the-laplace-transform",
    "title": "Modeling in the Frequency Domain",
    "section": "2.2 The Laplace Transform",
    "text": "2.2 The Laplace Transform\nThe Laplace transform of a signal \\(f(t)\\) is defined as:\n\\[\\mathcal{L}[f(t)] = F(s) = \\int_{0-}^{\\infty} f(t)e^{-st} dt\\]\nWhere \\(s = \\sigma + j\\omega\\) is a complex frequency variable.\nCommon Transform Pairs (Table 2.1)\n\n\n\n\\(f(t)\\)\n\\(F(s)\\)\nItem\n\n\n\n\n\\(\\delta(t)\\) (Impulse)\n\\(1\\)\n1\n\n\n\\(u(t)\\) (Step)\n\\(1/s\\)\n2\n\n\n\\(e^{-at}u(t)\\) (Exponential)\n\\(1/(s+a)\\)\n5\n\n\n\\(\\sin \\omega t u(t)\\)\n\\(\\omega/(s^2 + \\omega^2)\\)\n6"
  },
  {
    "objectID": "control_21.html#example-2.1-transforming-a-function",
    "href": "control_21.html#example-2.1-transforming-a-function",
    "title": "Modeling in the Frequency Domain",
    "section": "Example 2.1: Transforming a Function",
    "text": "Example 2.1: Transforming a Function\nProblem: Find the Laplace transform of \\(f(t) = Ae^{-at}u(t)\\).\nSolution: Using the definition: \\[F(s) = \\int_{0}^{\\infty} A e^{-at} e^{-st} dt = A \\int_{0}^{\\infty} e^{-(s+a)t} dt\\]\n\\[F(s) = \\left[ -\\frac{A}{s+a} e^{-(s+a)t} \\right]_{0}^{\\infty}\\]\n\\[F(s) = \\frac{A}{s+a}\\]\n\nNotice how the exponential decay in time becomes a simple pole at -a in the s-domain."
  },
  {
    "objectID": "control_21.html#laplace-transform-theorems",
    "href": "control_21.html#laplace-transform-theorems",
    "title": "Modeling in the Frequency Domain",
    "section": "Laplace Transform Theorems",
    "text": "Laplace Transform Theorems\nTheorems allow us to transform complex functions without using the integral definition.\n\n\n\nName\nTime Domain\nFrequency Domain\n\n\n\n\nLinearity\n\\(af_1(t) + bf_2(t)\\)\n\\(aF_1(s) + bF_2(s)\\)\n\n\nFreq. Shift\n\\(e^{-at}f(t)\\)\n\\(F(s+a)\\)\n\n\nDifferentiation\n\\(df/dt\\)\n\\(sF(s) - f(0-)\\)\n\n\nFinal Value\n\\(f(\\infty)\\)\n\\(\\lim_{s \\to 0} sF(s)\\)\n\n\n\n\n\n\n\n\n\nImportant\n\n\nThe Final Value Theorem is only valid if all roots of the denominator of \\(sF(s)\\) have negative real parts (stable system)."
  },
  {
    "objectID": "control_21.html#partial-fraction-expansion",
    "href": "control_21.html#partial-fraction-expansion",
    "title": "Modeling in the Frequency Domain",
    "section": "Partial-Fraction Expansion",
    "text": "Partial-Fraction Expansion\nWhen we have a complex \\(F(s)\\), we break it into simpler terms to find the inverse transform.\nCase 1: Real and Distinct Roots\nIf \\(F(s) = \\frac{2}{(s+1)(s+2)}\\), we expand to: \\[F(s) = \\frac{K_1}{s+1} + \\frac{K_2}{s+2}\\]\nFinding Residues (Cover-up Method): - \\(K_1 = [(s+1)F(s)]_{s=-1} = \\frac{2}{-1+2} = 2\\) - \\(K_2 = [(s+2)F(s)]_{s=-2} = \\frac{2}{-2+1} = -2\\)\nResult: \\(f(t) = (2e^{-t} - 2e^{-2t})u(t)\\)"
  },
  {
    "objectID": "control_21.html#interactive-exercise-residue-calculation",
    "href": "control_21.html#interactive-exercise-residue-calculation",
    "title": "Modeling in the Frequency Domain",
    "section": "Interactive Exercise: Residue Calculation",
    "text": "Interactive Exercise: Residue Calculation\nTry calculating residues for a custom transfer function using the Python code below."
  },
  {
    "objectID": "control_21.html#case-2-repeated-roots",
    "href": "control_21.html#case-2-repeated-roots",
    "title": "Modeling in the Frequency Domain",
    "section": "Case 2: Repeated Roots",
    "text": "Case 2: Repeated Roots\nIf the denominator has \\((s+p)^r\\), the expansion includes terms for every power from 1 to \\(r\\).\nExample: \\(F(s) = \\frac{2}{(s+1)(s+2)^2}\\) \\[F(s) = \\frac{K_1}{s+1} + \\frac{K_2}{(s+2)^2} + \\frac{K_3}{s+2}\\]\nThe residue for the lower-order repeated term (\\(K_3\\)) requires differentiation: \\[K_3 = \\frac{d}{ds} [(s+2)^2 F(s)]_{s=-2}\\]\n\nRepeated roots in the s-domain lead to terms like \\(t e^{-at}\\) in the time domain. This is common in critically damped systems."
  },
  {
    "objectID": "control_21.html#case-3-complex-conjugate-roots",
    "href": "control_21.html#case-3-complex-conjugate-roots",
    "title": "Modeling in the Frequency Domain",
    "section": "Case 3: Complex Conjugate Roots",
    "text": "Case 3: Complex Conjugate Roots\nFor denominators with \\(s^2 + as + b\\) (where roots are complex): We usually complete the square to match Sine or Cosine forms.\n\\[F(s) = \\frac{A(s+a) + B\\omega}{(s+a)^2 + \\omega^2}\\]\nTime Domain Result: \\[f(t) = e^{-at}(A \\cos \\omega t + B \\sin \\omega t)\\]\nWhich can be simplified to a single damped cosine: \\[f(t) = Ce^{-at} \\cos(\\omega t - \\phi)\\]"
  },
  {
    "objectID": "control_21.html#the-transfer-function",
    "href": "control_21.html#the-transfer-function",
    "title": "Modeling in the Frequency Domain",
    "section": "2.3 The Transfer Function",
    "text": "2.3 The Transfer Function\nThe Transfer Function, \\(G(s)\\), is the ratio of the Laplace transform of the output to the Laplace transform of the input, assuming zero initial conditions.\n\\[G(s) = \\frac{C(s)}{R(s)}\\]\nFrom Differential Equation to \\(G(s)\\):\n\nTake Laplace transform of the DE.\nSet initial conditions to zero.\nFactor out \\(C(s)\\) and \\(R(s)\\).\nDivide to get \\(C(s)/R(s)\\)."
  },
  {
    "objectID": "control_21.html#visualizing-poles-and-step-response",
    "href": "control_21.html#visualizing-poles-and-step-response",
    "title": "Modeling in the Frequency Domain",
    "section": "Visualizing Poles and Step Response",
    "text": "Visualizing Poles and Step Response\nAdjust the pole location to see how the system response \\(c(t) = \\mathcal{L}^{-1}[G(s) \\cdot \\frac{1}{s}]\\) changes.\n\nviewof pole_val = Inputs.range([-5, -0.1], {step: 0.1, label: \"Pole Location (a)\", value: -2})"
  },
  {
    "objectID": "control_21.html#example-2.5-response-from-transfer-function",
    "href": "control_21.html#example-2.5-response-from-transfer-function",
    "title": "Modeling in the Frequency Domain",
    "section": "Example 2.5: Response from Transfer Function",
    "text": "Example 2.5: Response from Transfer Function\nProblem: Given \\(G(s) = \\frac{1}{s+2}\\), find the response to a unit step input \\(r(t) = u(t)\\).\nSolution: 1. Input: \\(R(s) = \\frac{1}{s}\\) 2. Output: \\(C(s) = R(s)G(s) = \\frac{1}{s(s+2)}\\) 3. Partial Fractions: \\[C(s) = \\frac{1/2}{s} - \\frac{1/2}{s+2}\\] 4. Inverse Transform: \\[c(t) = \\frac{1}{2} - \\frac{1}{2}e^{-2t}\\]"
  },
  {
    "objectID": "control_21.html#summary-key-points",
    "href": "control_21.html#summary-key-points",
    "title": "Modeling in the Frequency Domain",
    "section": "Summary / Key Points",
    "text": "Summary / Key Points\n\nFrequency Domain modeling simplifies complex system analysis into algebraic manipulation.\nThe Laplace Transform is the primary tool for this conversion.\nTransfer Functions represent a system’s dynamics independently of the input signal.\nInitial Conditions must be zero for the standard definition of a Transfer Function.\nPartial Fraction Expansion is the bridge back to the time domain (\\(t\\))."
  },
  {
    "objectID": "control_21.html#formulas-summary",
    "href": "control_21.html#formulas-summary",
    "title": "Modeling in the Frequency Domain",
    "section": "Formulas Summary",
    "text": "Formulas Summary\nLaplace Transform: \\(F(s) = \\int_{0-}^{\\infty} f(t)e^{-st} dt\\)\nTransfer Function: \\(G(s) = \\frac{C(s)}{R(s)}\\)\nResidue (Distinct Roots): \\(K_i = [(s+p_i)F(s)]_{s \\to -p_i}\\)\nInitial Value Theorem: \\(f(0+) = \\lim_{s \\to \\infty} sF(s)\\)\nFinal Value Theorem: \\(f(\\infty) = \\lim_{s \\to 0} sF(s)\\)# Modeling in the Frequency Domain\n2.1–2.3: Laplace Transform & Transfer Functions"
  },
  {
    "objectID": "control_21.html#learning-objectives-1",
    "href": "control_21.html#learning-objectives-1",
    "title": "Modeling in the Frequency Domain",
    "section": "Learning Objectives",
    "text": "Learning Objectives\nBy the end of this session, you will be able to:\n\nExplain why control engineers prefer transfer functions over raw differential equations.\nRecall and use key Laplace transform pairs and theorems.\nPerform partial‑fraction expansion for real, repeated, and complex roots.\nUse Laplace transforms to solve linear differential equations with zero initial conditions.\nDefine and compute a transfer function from a given differential equation.\nRelate simple transfer functions to time‑domain responses (step, ramp) relevant to ECE systems.\n\n\nThis slide sets expectations. Emphasize the “why” (motivation) first: modeling in the frequency domain lets us separate input/system/output and use algebra instead of calculus. Then connect each objective to a concrete action they’ll perform in examples or interactive blocks."
  },
  {
    "objectID": "control_21.html#from-differential-equations-to-block-diagrams",
    "href": "control_21.html#from-differential-equations-to-block-diagrams",
    "title": "Modeling in the Frequency Domain",
    "section": "From Differential Equations to Block Diagrams",
    "text": "From Differential Equations to Block Diagrams\n\n\n\nMany physical systems → differential equations (DEs) relating input and output.\nBut DEs:\n\nMix input, output, and parameters everywhere.\nAre hard to interconnect for multi‑block systems.\n\nWe want:\n\nA clean separation: input, system, output.\nSimple rules for connecting subsystems in cascade, feedback, etc.\n\n\n\nSingle block:\n\n\n\n\n\n\n\n\n\n\n\nCascaded blocks:\n\n\n\n\n\n\n\n\n\n\n\n\n\nRelate to a concrete example from Chapter 1: a position control system with motor + gear + load. In DE form, parameters for each physical part are intermingled. In block form, each is a block with its own transfer function. Point out that for cascaded blocks, the overall transfer function is simply the product of individual transfer functions G1(s)G2(s), which is far easier than combining DEs directly."
  },
  {
    "objectID": "control_21.html#why-frequencydomain-modeling-ece-perspective",
    "href": "control_21.html#why-frequencydomain-modeling-ece-perspective",
    "title": "Modeling in the Frequency Domain",
    "section": "Why Frequency‑Domain Modeling? ECE Perspective",
    "text": "Why Frequency‑Domain Modeling? ECE Perspective\n\nIn ECE you already:\n\nUse phasors for AC circuits → algebra instead of DEs.\nUse frequency response (Bode plots, filters) to design circuits.\n\nLaplace transform is like a super‑phasor:\n\nHandles transients (exponentials) and sinusoids.\nTurns \\(d/dt\\) into multiplication by \\(s\\).\n\nThis leads to transfer functions: algebraic ratios in \\(s\\) that:\n\nModel circuits, motors, sensors, amplifiers.\nAre easy to connect and analyze.\n\n\n\n\n\n\n\n\nTip\n\n\nThink: time domain = “oscilloscope view”. Laplace/frequency domain = “algebra and plots” view for design.\n\n\n\n\nMake explicit analogy: phasors are to sinusoidal steady state as Laplace transforms are to full transient + steady state. Remind them that \\(s = \\sigma + j\\omega\\); phasors correspond to the special case \\(\\sigma = 0\\). This helps ECE students connect current knowledge to Laplace and transfer functions."
  },
  {
    "objectID": "control_21.html#laplace-transform-definition",
    "href": "control_21.html#laplace-transform-definition",
    "title": "Modeling in the Frequency Domain",
    "section": "Laplace Transform: Definition",
    "text": "Laplace Transform: Definition\nWe define the (unilateral) Laplace transform as\n\\[\n\\mathcal{L}[f(t)] = F(s) = \\int_{0^-}^{\\infty} f(t) e^{-st}\\, dt,\\quad s=\\sigma + j\\omega\n\\]\n\n\\(f(t)\\): time‑domain signal (usually \\(t\\ge 0\\) in control).\n\\(F(s)\\): Laplace‑domain representation.\nLower limit \\(0^-\\) means we can handle discontinuities at \\(t=0\\), including impulses.\n\nInverse Laplace transform:\n\\[\n\\mathcal{L}^{-1}[F(s)] = \\frac{1}{2\\pi j} \\int_{\\sigma - j\\infty}^{\\sigma + j\\infty} F(s)e^{st} ds = f(t) u(t)\n\\]\n\n\\(u(t)\\): unit step, forcing causality (zero for \\(t&lt;0\\)).\n\n\nStress that in control we almost always use the unilateral transform (starting at 0^-), because we care about system response after an input is applied. Emphasize that the inverse integral is not something they will compute by hand; instead, they’ll use tables and partial fractions."
  },
  {
    "objectID": "control_21.html#key-laplace-transform-pairs-table-2.1-excerpts",
    "href": "control_21.html#key-laplace-transform-pairs-table-2.1-excerpts",
    "title": "Modeling in the Frequency Domain",
    "section": "Key Laplace Transform Pairs (Table 2.1 Excerpts)",
    "text": "Key Laplace Transform Pairs (Table 2.1 Excerpts)\n\n\nTime domain \\(f(t)\\)\n\n\\(\\delta(t)\\)\n\\(u(t)\\)\n\\(t u(t)\\)\n\\(t^{n}u(t)\\)\n\\(e^{-a t} u(t)\\)\n\\(\\sin \\omega t \\, u(t)\\)\n\\(\\cos \\omega t \\, u(t)\\)\n\n\nLaplace domain \\(F(s)\\)\n\n\\(1\\)\n\\(\\dfrac{1}{s}\\)\n\\(\\dfrac{1}{s^{2}}\\)\n\\(\\dfrac{n!}{s^{n+1}}\\)\n\\(\\dfrac{1}{s + a}\\)\n\\(\\dfrac{\\omega}{s^{2} + \\omega^{2}}\\)\n\\(\\dfrac{s}{s^{2} + \\omega^{2}}\\)\n\n\n\n\n\n\n\n\nImportant\n\n\nThese seven pairs cover most standard test signals in control: impulse, step, ramp, exponentials, and sinusoids. You should be able to recognize and use them without a table over time.\n\n\n\n\nEncourage students to memorize at least the impulse, step, ramp, exponential, and sin/cos pairs. Point out that many more complicated transforms can be built using these plus the theorems (shift, scaling, differentiation)."
  },
  {
    "objectID": "control_21.html#interactive-check-compute-a-simple-laplace-transform",
    "href": "control_21.html#interactive-check-compute-a-simple-laplace-transform",
    "title": "Modeling in the Frequency Domain",
    "section": "Interactive Check: Compute a Simple Laplace Transform",
    "text": "Interactive Check: Compute a Simple Laplace Transform\nUse the definition to compute the Laplace transform of \\(f(t) = Ae^{-at}u(t)\\).\n\n\n\n\n\n\n\nWalk through the steps from the output: they should see A/(s+a). Connect this back to Item 5 in Table 2.1 and to Example 2.1. Emphasize that we can always fall back to the integral definition when in doubt."
  },
  {
    "objectID": "control_21.html#example-2.1-laplace-transform-of-a-e-a-t-ut",
    "href": "control_21.html#example-2.1-laplace-transform-of-a-e-a-t-ut",
    "title": "Modeling in the Frequency Domain",
    "section": "Example 2.1 – Laplace Transform of \\(A e^{-a t} u(t)\\)",
    "text": "Example 2.1 – Laplace Transform of \\(A e^{-a t} u(t)\\)\nWe want \\(\\mathcal{L}[f(t)]\\) for \\(f(t) = A e^{-a t} u(t)\\).\nSince there is no impulse at \\(t=0\\), we can start at 0:\n\\[\n\\begin{aligned}\nF(s) &= \\int_{0}^{\\infty} A e^{-a t} e^{-s t} dt \\\\\n&= A \\int_{0}^{\\infty} e^{-(s + a)t} dt \\\\\n&= -\\frac{A}{s+a} e^{-(s+a)t} \\bigg|_{0}^{\\infty} \\\\\n&= \\frac{A}{s+a}\n\\end{aligned}\n\\]\nSo\n\\[\n\\mathcal{L}[A e^{-a t} u(t)] = \\frac{A}{s + a}\n\\]\n\nShow the convergence reasoning: the exponential term goes to zero as \\(t \\to \\infty\\) if \\(\\text{Re}(s+a) &gt; 0\\). Also highlight that \\(A\\) just factors out (linearity)."
  },
  {
    "objectID": "control_21.html#laplace-transform-theorems-table-2.2-highlights",
    "href": "control_21.html#laplace-transform-theorems-table-2.2-highlights",
    "title": "Modeling in the Frequency Domain",
    "section": "Laplace Transform Theorems (Table 2.2 – Highlights)",
    "text": "Laplace Transform Theorems (Table 2.2 – Highlights)\n\n\nLinearity\n\n\\(\\mathcal{L}[k f(t)] = k F(s)\\)\n\\(\\mathcal{L}[f_1(t) + f_2(t)] = F_1(s) + F_2(s)\\)\n\nFrequency shift\n\n\\(\\mathcal{L}[e^{-a t} f(t)] = F(s + a)\\)\n\n\nDifferentiation in time\n\n\\(\\mathcal{L}\\left[\\dfrac{df}{dt}\\right] = sF(s) - f(0^-)\\)\n\nIntegration in time\n\n\\(\\mathcal{L}\\left[\\int_0^t f(\\tau)\\, d\\tau \\right] = \\dfrac{F(s)}{s}\\)\n\n\nValue theorems:\n\nFinal value: \\(f(\\infty) = \\displaystyle\\lim_{s\\to 0} s F(s)\\) (under stability conditions).\nInitial value: \\(f(0^+) = \\displaystyle\\lim_{s\\to\\infty} s F(s)\\) (under continuity conditions).\n\n\n\n\n\n\n\nWarning\n\n\nValue theorems have conditions: - Final value only if all poles of \\(sF(s)\\) have negative real parts or at most one at the origin. - Initial value only if \\(f(t)\\) has no impulses at \\(t=0\\).\n\n\n\n\nExplain that these theorems are tools to avoid doing full inverses. In control design we often care about steady‑state error → final value theorem is heavily used. Give a quick mental example: step response of 1/(s+2) has \\(C(s)=1/(s(s+2))\\), so \\(c(\\infty) = \\lim_{s→0} s /(s(s+2)) = 1/2\\), matching the time‑domain expression."
  },
  {
    "objectID": "control_21.html#inverse-laplace-via-tables-theorems-example-2.2",
    "href": "control_21.html#inverse-laplace-via-tables-theorems-example-2.2",
    "title": "Modeling in the Frequency Domain",
    "section": "Inverse Laplace via Tables & Theorems – Example 2.2",
    "text": "Inverse Laplace via Tables & Theorems – Example 2.2\nGiven:\n\\[\nF_1(s) = \\frac{1}{(s+3)^2}\n\\]\nWe know from Table 2.1:\n\n\\(\\mathcal{L}[t u(t)] = \\dfrac{1}{s^2}\\).\n\nUse the frequency shift theorem:\n\nIf \\(\\mathcal{L}[t] = \\dfrac{1}{s^2}\\), then \\(\\mathcal{L}[e^{-a t} t] = \\dfrac{1}{(s + a)^2}\\).\n\nSo with \\(a = 3\\):\n\\[\n\\mathcal{L}^{-1}\\left[\\frac{1}{(s+3)^2}\\right] = e^{-3t} t u(t)\n\\]\n\nAsk students what \\(f(t)\\) would be if the denominator was \\((s+3)^3\\) to see if they infer \\(t^2 e^{-3t}/2!\\). Reinforce the pattern \\(t^n u(t) \\leftrightarrow n! / s^{n+1}\\) and its shifted version."
  },
  {
    "objectID": "control_21.html#why-partialfraction-expansion",
    "href": "control_21.html#why-partialfraction-expansion",
    "title": "Modeling in the Frequency Domain",
    "section": "Why Partial‑Fraction Expansion?",
    "text": "Why Partial‑Fraction Expansion?\n\nMany \\(F(s)\\) arise as ratios of polynomials:\n\\[\nF(s) = \\frac{N(s)}{D(s)},\\quad \\deg N &lt; \\deg D\n\\]\nUsually not in table form directly.\nStrategy:\n\nFactor \\(D(s)\\) into simple factors.\nExpress \\(F(s)\\) as a sum of simple terms.\nUse the table on each term.\n\n\n\n\n\n\n\n\nNote\n\n\nIf \\(\\deg N \\ge \\deg D\\), perform polynomial long division first to get polynomial + proper fraction (numerator degree &lt; denominator degree).\n\n\n\n\nConnect with circuits: when finding time response of an RLC network, the natural response terms come from the poles (roots of the denominator) and are exponentials or damped sinusoids. Partial fractions is how we expose these modes."
  },
  {
    "objectID": "control_21.html#example-need-for-long-division",
    "href": "control_21.html#example-need-for-long-division",
    "title": "Modeling in the Frequency Domain",
    "section": "Example: Need for Long Division",
    "text": "Example: Need for Long Division\nGiven\n\\[\nF_1(s) = \\frac{s^3 + 2s^2 + 6s + 7}{s^2 + s + 5}\n\\]\nPerform polynomial division:\n\\[\nF_1(s) = s + 1 + \\frac{2}{s^2 + s + 5}\n\\]\nThen inverse Laplace:\n\\[\nf_1(t) = \\frac{d\\delta(t)}{dt} + \\delta(t) + \\mathcal{L}^{-1}\\left[\\frac{2}{s^2 + s + 5}\\right]\n\\]\n\nThe polynomial part (\\(s + 1\\)) represents impulses and derivatives at \\(t=0\\).\nThe proper fraction is where the physical transient lies.\n\n\nDon’t dwell on the impulse terms for now; just point out: polynomial terms in \\(s\\) → combinations of \\(\\delta(t)\\) and its derivatives. Our main interest in control is typically the proper fraction part (for \\(t&gt;0\\) responses)."
  },
  {
    "objectID": "control_21.html#case-1-real-distinct-poles",
    "href": "control_21.html#case-1-real-distinct-poles",
    "title": "Modeling in the Frequency Domain",
    "section": "Case 1: Real, Distinct Poles",
    "text": "Case 1: Real, Distinct Poles\nExample:\n\\[\nF(s) = \\frac{2}{(s+1)(s+2)}\n\\]\nAssume\n\\[\nF(s) = \\frac{K_1}{s+1} + \\frac{K_2}{s+2}\n\\]\nSolve residues:\n\nMultiply by \\((s+1)\\) and set \\(s=-1\\) → \\(K_1 = \\dfrac{2}{-1+2} = 2\\).\nMultiply by \\((s+2)\\) and set \\(s=-2\\) → \\(K_2 = \\dfrac{2}{-2+1} = -2\\).\n\nSo\n\\[\nF(s) = \\frac{2}{s+1} - \\frac{2}{s+2}\n\\]\nInverse Laplace:\n\\[\nf(t) = 2 e^{-t} - 2 e^{-2t}\n\\]\n\n\n\n\n\n\nTip\n\n\nFor distinct real poles at \\(-p_1, -p_2, ..., -p_n\\):\n\\[\nF(s) = \\sum_{i=1}^n \\frac{K_i}{s + p_i},\\quad\nK_i = (s + p_i) F(s)\\big|_{s = -p_i}\n\\]\n\n\n\n\nStress the “cover‑up” trick for simple real poles: multiply by the factor, then substitute the corresponding root. Mention that the exponents in time domain correspond to pole locations (modes of the system)."
  },
  {
    "objectID": "control_21.html#example-2.3-de-solution-via-laplace-setup",
    "href": "control_21.html#example-2.3-de-solution-via-laplace-setup",
    "title": "Modeling in the Frequency Domain",
    "section": "Example 2.3 – DE Solution via Laplace (Setup)",
    "text": "Example 2.3 – DE Solution via Laplace (Setup)\nGiven system:\n\\[\n\\frac{d^2 y}{dt^2} + 12 \\frac{dy}{dt} + 32 y = 32 u(t),\\quad y(0^-) = 0,\\ \\dot{y}(0^-) = 0\n\\]\n\nTake Laplace of each term using differentiation theorems and \\(u(t) \\leftrightarrow 1/s\\):\n\n\\[\ns^2 Y(s) + 12 s Y(s) + 32 Y(s) = \\frac{32}{s}\n\\]\n\nSolve for \\(Y(s)\\):\n\n\\[\nY(s) = \\frac{32}{s(s^2 + 12s + 32)} = \\frac{32}{s (s+4)(s+8)}\n\\]\nNow we just need partial fractions.\n\nAsk students to verify the factorization \\((s^2+12s+32)=(s+4)(s+8)\\). Note what the poles are: 0, −4, −8. This already hints at a step response with two decaying exponentials and a constant term."
  },
  {
    "objectID": "control_21.html#example-2.3-partial-fractions-and-solution",
    "href": "control_21.html#example-2.3-partial-fractions-and-solution",
    "title": "Modeling in the Frequency Domain",
    "section": "Example 2.3 – Partial Fractions and Solution",
    "text": "Example 2.3 – Partial Fractions and Solution\nAssume\n\\[\nY(s) = \\frac{K_1}{s} + \\frac{K_2}{s+4} + \\frac{K_3}{s+8}\n\\]\nUse cover‑up method:\n\n\\(K_1 = \\dfrac{32}{(s+4)(s+8)}\\bigg|_{s=0} = 1\\)\n\\(K_2 = \\dfrac{32}{s(s+8)}\\bigg|_{s=-4} = -2\\)\n\\(K_3 = \\dfrac{32}{s(s+4)}\\bigg|_{s=-8} = 1\\)\n\nSo\n\\[\nY(s) = \\frac{1}{s} - \\frac{2}{s+4} + \\frac{1}{s+8}\n\\]\nInverse Laplace:\n\\[\ny(t) = 1 - 2 e^{-4t} + e^{-8t}\n\\]\n\n\n\n\n\n\nNote\n\n\nWe often drop the explicit \\(u(t)\\) factor in notation, assuming causal systems with inputs applied at \\(t=0\\).\n\n\n\n\nInterpret the result physically: final value is 1 (matches right‑hand side 32 with static gain 1). Two decaying exponentials represent system dynamics with time constants 1/4 and 1/8 s. You can also quickly check final value via \\(\\lim_{s\\to0} sY(s)\\)."
  },
  {
    "objectID": "control_21.html#interactive-practice-partial-fractions-in-python",
    "href": "control_21.html#interactive-practice-partial-fractions-in-python",
    "title": "Modeling in the Frequency Domain",
    "section": "Interactive Practice: Partial Fractions in Python",
    "text": "Interactive Practice: Partial Fractions in Python\nTry a partial‑fraction expansion of\n\\[\nF(s) = \\frac{2}{(s+1)(s+2)}\n\\]\n\n\n\n\n\n\nModify the expression in the code cell to experiment with other denominators.\n\nAfter running, discuss the output: Sympy should give 2/(s+1) - 2/(s+2). Encourage students to try a denominator with a repeated pole or quadratic term to observe how the structure of the result changes."
  },
  {
    "objectID": "control_21.html#case-2-real-repeated-poles",
    "href": "control_21.html#case-2-real-repeated-poles",
    "title": "Modeling in the Frequency Domain",
    "section": "Case 2: Real, Repeated Poles",
    "text": "Case 2: Real, Repeated Poles\nExample:\n\\[\nF(s) = \\frac{2}{(s+1)(s+2)^2}\n\\]\nWe write:\n\\[\nF(s) = \\frac{K_1}{s+1} + \\frac{K_2}{(s+2)^2} + \\frac{K_3}{s+2}\n\\]\nProcedure:\n\n\\(K_1\\) via cover‑up (still simple pole):\n\nMultiply by \\((s+1)\\) and set \\(s=-1\\): \\(K_1 = 2\\).\n\n\\(K_2\\) isolate by multiplying by \\((s+2)^2\\) and setting \\(s=-2\\):\n\n\\(K_2 = -2\\).\n\nFor \\(K_3\\) (other term in repeated root):\n\nDifferentiate the expression where \\((s+2)^2 F(s)\\) is isolated, then set \\(s=-2\\) to solve for \\(K_3\\): \\(K_3 = -2\\).\n\n\nSo\n\\[\nf(t) = 2 e^{-t} - 2 t e^{-2t} - 2 e^{-2t}\n\\]\n\n\n\n\n\n\nTip\n\n\nFor a repeated pole at \\(s = -p\\) of multiplicity \\(r\\), the expansion is\n\\[\n\\sum_{i=1}^r \\frac{K_i}{(s+p)^i}\n\\]\nCorresponding time terms are of the form \\(t^{i-1} e^{-p t}\\).\n\n\n\n\nHighlight that repeated poles lead to polynomial factors in time (e.g., \\(t e^{-2t}\\)), which correspond to non‑distinct system modes, such as critically damped or higher‑order repeated behavior."
  },
  {
    "objectID": "control_21.html#case-3-complex-or-imaginary-poles",
    "href": "control_21.html#case-3-complex-or-imaginary-poles",
    "title": "Modeling in the Frequency Domain",
    "section": "Case 3: Complex or Imaginary Poles",
    "text": "Case 3: Complex or Imaginary Poles\nExample:\n\\[\nF(s) = \\frac{3}{s(s^2 + 2s + 5)}\n\\]\nWe use\n\\[\nF(s) = \\frac{K_1}{s} + \\frac{K_2 s + K_3}{s^2 + 2s + 5}\n\\]\n\n\\(K_1 = \\dfrac{3}{5}\\).\nMultiply both sides by \\(s(s^2+2s+5)\\) and equate coefficients to find \\(K_2\\), \\(K_3\\).\n\nResult: \\(K_2 = -\\dfrac{3}{5}\\), \\(K_3 = -\\dfrac{6}{5}\\).\n\n\nSo\n\\[\nF(s) = \\frac{3/5}{s} - \\frac{3}{5}\\frac{s+2}{s^2 + 2s + 5}\n\\]\nComplete the square:\n\\[\ns^2 + 2s + 5 = (s + 1)^2 + 2^2\n\\]\nRewrite:\n\\[\nF(s) = \\frac{3/5}{s} - \\frac{3}{5} \\frac{(s+1) + 1}{(s+1)^2 + 4}\n\\]\nMatch with\n\\[\n\\mathcal{L}[A e^{-a t}\\cos\\omega t + B e^{-a t}\\sin\\omega t] =\n\\frac{A(s+a) + B\\omega}{(s+a)^2 + \\omega^2}\n\\]\nYield\n\\[\nf(t) = \\frac{3}{5} - \\frac{3}{5} e^{-t}\\left(\\cos 2t + \\frac{1}{2} \\sin 2t\\right)\n\\]\nOr equivalently\n\\[\nf(t) = 0.6 - 0.671 e^{-t} \\cos(2t - \\phi), \\quad \\phi \\approx 26.57^\\circ\n\\]\n\n\n\n\n\n\nNote\n\n\nComplex poles → damped sinusoidal modes (oscillations that decay over time). This is crucial for understanding underdamped systems (e.g., RLC circuits, motor torque responses).\n\n\n\n\nEmphasize geometric interpretation: complex poles at \\(-1 \\pm j2\\) have real part −1 (decay rate) and imaginary part 2 (oscillation frequency). Students will see these again in second‑order system analysis."
  },
  {
    "objectID": "control_21.html#alternate-complexresidue-method-outline",
    "href": "control_21.html#alternate-complexresidue-method-outline",
    "title": "Modeling in the Frequency Domain",
    "section": "Alternate Complex‑Residue Method (Outline)",
    "text": "Alternate Complex‑Residue Method (Outline)\nWe can also expand\n\\[\n\\frac{3}{s(s^2+2s+5)} = \\frac{3}{s(s+1+j2)(s+1-j2)}\n\\]\nas\n\\[\nF(s) = \\frac{K_1}{s} + \\frac{K_2}{s+1+j2} + \\frac{K_3}{s+1-j2}\n\\]\n\n\\(K_2\\) and \\(K_3\\) are complex conjugates.\nAfter inverse Laplace, exponentials with \\(e^{\\pm j2t}\\) combine via\n\\[\n\\cos\\theta = \\frac{e^{j\\theta}+e^{-j\\theta}}{2},\\quad\n\\sin\\theta = \\frac{e^{j\\theta}-e^{-j\\theta}}{2j}\n\\]\n\nto the same real expression as before.\n\nThis method is more algebraically heavy and conceptually advanced. Mention that computational tools (MATLAB, Python) often give complex residues, but the physical time‑domain solution is real, obtained by combining conjugate pairs."
  },
  {
    "objectID": "control_21.html#interactive-slider-visualizing-a-damped-sinusoid",
    "href": "control_21.html#interactive-slider-visualizing-a-damped-sinusoid",
    "title": "Modeling in the Frequency Domain",
    "section": "Interactive Slider: Visualizing a Damped Sinusoid",
    "text": "Interactive Slider: Visualizing a Damped Sinusoid\n\nviewof a = Inputs.range([0, 2], {step: 0.1, value: 1, label: \"decay rate a\"})\nviewof w = Inputs.range([0, 5], {step: 0.5, value: 2, label: \"frequency ω\"})\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nInvite students to move sliders and observe how increasing a speeds up decay, while changing ω changes oscillation frequency. Connect back to the example with poles at −1 ± j2, so a=1, ω=2. This is a bridge to second‑order system classification."
  },
  {
    "objectID": "control_21.html#skillassessment-quick-laplace-transform",
    "href": "control_21.html#skillassessment-quick-laplace-transform",
    "title": "Modeling in the Frequency Domain",
    "section": "Skill‑Assessment: Quick Laplace Transform",
    "text": "Skill‑Assessment: Quick Laplace Transform\nExercise 2.1: Find \\(\\mathcal{L}[f(t)]\\) for \\(f(t) = t e^{-5t} u(t)\\).\nUsing Table 2.1 and frequency shift:\n\n\\(t u(t) \\leftrightarrow 1/s^2\\).\nMultiply by \\(e^{-5t}\\) → shift \\(s \\to s+5\\):\n\n\\[\n\\mathcal{L}[t e^{-5t} u(t)] = \\frac{1}{(s + 5)^2}\n\\]\n\nEncourage students to do this mentally: identify base transform, then apply shift. Ask them what the ROC (region of convergence) condition is: Re(s) &gt; −5."
  },
  {
    "objectID": "control_21.html#laplace-transform-transfer-function",
    "href": "control_21.html#laplace-transform-transfer-function",
    "title": "Modeling in the Frequency Domain",
    "section": "Laplace Transform → Transfer Function",
    "text": "Laplace Transform → Transfer Function\nWe now connect Laplace transforms to transfer functions.\nStart from a general LTI differential equation:\n\\[\na_n \\frac{d^n c}{dt^n} + a_{n-1} \\frac{d^{n-1} c}{dt^{n-1}} + \\cdots + a_0 c(t)\n= b_m \\frac{d^m r}{dt^m} + \\cdots + b_0 r(t)\n\\]\nTake Laplace transforms (with zero initial conditions):\n\\[\n(a_n s^n + a_{n-1} s^{n-1} + \\cdots + a_0) C(s)\n= (b_m s^m + b_{m-1} s^{m-1} + \\cdots + b_0) R(s)\n\\]\nForm the ratio\n\\[\n\\frac{C(s)}{R(s)} = G(s) =\n\\frac{b_m s^m + b_{m-1} s^{m-1} + \\cdots + b_0}\n     {a_n s^n + a_{n-1} s^{n-1} + \\cdots + a_0}\n\\]\nThis \\(G(s)\\) is the transfer function:\n\nDescribes the system alone (zero initial conditions).\nInput/output relationship: \\(C(s) = G(s) R(s)\\).\n\n\n\n\n\n\n\nImportant\n\n\nThe denominator of \\(G(s)\\) is the characteristic polynomial. Its roots → poles → fundamental dynamics (stability, oscillation, speed).\n\n\n\n\nHighlight that initial conditions enter the Laplace transform as extra terms, but for the transfer function definition we set them to zero to isolate pure system behavior. Make sure they see that this is why the ratio is independent of particular initial conditions."
  },
  {
    "objectID": "control_21.html#transfer-function-block-representation",
    "href": "control_21.html#transfer-function-block-representation",
    "title": "Modeling in the Frequency Domain",
    "section": "Transfer Function Block Representation",
    "text": "Transfer Function Block Representation\n\n\n\nBlock diagram of a transfer function\n\n\n\nInput: \\(R(s)\\) (Laplace transform of \\(r(t)\\)).\nOutput: \\(C(s)\\) (Laplace transform of \\(c(t)\\)).\nBlock: \\(G(s)\\) (system).\nRelationship: \\(C(s) = G(s) R(s)\\).\n\n\nRelate this picture back to Figure 2.1 and to state the main advantage: we can now treat cascades, feedback loops, and other interconnections via algebra on these \\(G(s)\\) blocks rather than combining differential equations directly."
  },
  {
    "objectID": "control_21.html#example-2.4-transfer-function-from-de",
    "href": "control_21.html#example-2.4-transfer-function-from-de",
    "title": "Modeling in the Frequency Domain",
    "section": "Example 2.4 – Transfer Function from DE",
    "text": "Example 2.4 – Transfer Function from DE\nGiven DE:\n\\[\n\\frac{dc}{dt} + 2c(t) = r(t)\n\\]\n\nLaplace transform with zero initial conditions:\n\n\\[\ns C(s) + 2 C(s) = R(s)\n\\]\n\nSolve for \\(C(s)/R(s)\\):\n\n\\[\nG(s) = \\frac{C(s)}{R(s)} = \\frac{1}{s + 2}\n\\]\nSo the system is a first‑order low‑pass with pole at \\(s = -2\\).\n\nPoint out physical analogies: this could represent an RC or RL circuit, or a simple thermal or mechanical first‑order system. The time constant is 1/2 s. Ask: what’s the DC gain? (1/2 if we consider step input; actually the transfer function’s DC gain is 1/2 only if the input is a step – help them separate system gain vs full step response)."
  },
  {
    "objectID": "control_21.html#example-2.5-step-response-from-gs",
    "href": "control_21.html#example-2.5-step-response-from-gs",
    "title": "Modeling in the Frequency Domain",
    "section": "Example 2.5 – Step Response from \\(G(s)\\)",
    "text": "Example 2.5 – Step Response from \\(G(s)\\)\nWe use \\(G(s) = 1/(s+2)\\) and input \\(r(t) = u(t)\\).\n\nLaplace of input: \\(R(s) = 1/s\\).\nOutput transform:\n\n\\[\nC(s) = G(s) R(s) = \\frac{1}{s(s+2)}\n\\]\n\nPartial fractions:\n\n\\[\nC(s) = \\frac{1/2}{s} - \\frac{1/2}{s+2}\n\\]\n\nInverse Laplace:\n\n\\[\nc(t) = \\frac{1}{2} - \\frac{1}{2} e^{-2t}\n\\]\nInterpretation:\n\nStarts at 0, asymptotically approaches 0.5.\nTime constant: 0.5 s → at \\(t = 0.5\\) s, ~63% of the way to 0.5.\n\n\n\n\n\n\n\nTip\n\n\nYou can check final value via final value theorem:\n\\[\nc(\\infty) = \\lim_{s\\to0} s \\cdot C(s) = \\lim_{s\\to0} \\frac{s}{s(s+2)} = \\frac{1}{2}\n\\]\n\n\n\n\nIf time permits, sketch or quickly plot the response. Emphasize that this procedure (transfer function + Laplace of input + partial fractions) is the standard pipeline for computing time responses."
  },
  {
    "objectID": "control_21.html#interactive-plot-firstorder-step-response",
    "href": "control_21.html#interactive-plot-firstorder-step-response",
    "title": "Modeling in the Frequency Domain",
    "section": "Interactive Plot: First‑Order Step Response",
    "text": "Interactive Plot: First‑Order Step Response\n\nviewof a1 = Inputs.range([0.1, 5], {step: 0.1, value: 2, label: \"Pole at s = -a\"})\n\n\n\n\n\n\n\n\n\n\n\n\n\nExplain that for G(s)=a/(s+a), DC gain is 1. Students can see how moving the pole (changing a) affects how fast the system responds: larger a → faster exponential decay. Link pole position in s‑plane to speed of response, a central theme in control."
  },
  {
    "objectID": "control_21.html#additional-skillassessment-examples-conceptually",
    "href": "control_21.html#additional-skillassessment-examples-conceptually",
    "title": "Modeling in the Frequency Domain",
    "section": "Additional Skill‑Assessment Examples (Conceptually)",
    "text": "Additional Skill‑Assessment Examples (Conceptually)\n\nExercise 2.3: From DE\n\\[\n\\frac{d^3 c}{dt^3} + 3\\frac{d^2 c}{dt^2} + 7\\frac{dc}{dt} + 5c =\n\\frac{d^2 r}{dt^2} + 4\\frac{dr}{dt} + 3r\n\\]\nTransfer function:\n\\[\nG(s) = \\frac{s^2 + 4s + 3}{s^3 + 3s^2 + 7s + 5}\n\\]\nExercise 2.4: From \\(G(s)\\) back to DE:\n\\[\nG(s) = \\frac{2s + 1}{s^2 + 6s + 2}\n\\]\nmultiply both sides by denominator and inverse Laplace to get\n\\[\n\\frac{d^2 c}{dt^2} + 6\\frac{dc}{dt} + 2c = 2\\frac{dr}{dt} + r\n\\]\nExercise 2.5: Ramp response from \\(G(s) = \\dfrac{s}{(s+4)(s+8)}\\)\n\nRamp input: \\(r(t) = t u(t) \\Rightarrow R(s) = 1/s^2\\).\nThen \\(C(s) = G(s)R(s)\\), do partial fractions, invert.\n\n\n\nYou don’t need to derive these fully in class, but use them to illustrate both directions: DE → G(s) and G(s) → DE, and also different inputs (step, ramp). Emphasize ramp as modeling linearly increasing commands, like a linearly increasing set‑point voltage or speed reference."
  },
  {
    "objectID": "control_21.html#realworld-ece-application-examples",
    "href": "control_21.html#realworld-ece-application-examples",
    "title": "Modeling in the Frequency Domain",
    "section": "Real‑World ECE Application Examples",
    "text": "Real‑World ECE Application Examples\n\n\n1. RC low‑pass filter\n\nCircuit: resistor R in series, capacitor C to ground.\nInput: \\(v_{in}(t)\\), output: \\(v_{out}(t)\\) across C.\nDE:\n\\[\nRC \\frac{dv_{out}}{dt} + v_{out} = v_{in}\n\\]\nTransfer function:\n\\[\nG(s) = \\frac{V_{out}(s)}{V_{in}(s)} = \\frac{1}{RC s + 1}\n\\]\n\n\n2. DC motor speed control (simplified)\n\nInput: armature voltage \\(V_a(t)\\).\nOutput: angular speed \\(\\omega(t)\\).\nLinearized model often:\n\\[\nJ \\frac{d\\omega}{dt} + B \\omega = K_t i_a,\\quad\nL \\frac{di_a}{dt} + R i_a + K_e \\omega = V_a\n\\]\nCombine and Laplace to get \\(G(s) = \\Omega(s)/V_a(s)\\): typically a second‑order transfer function.\n\n\n\nUse the RC filter as a simple first‑order transfer function example where students can easily map component values to pole location. For the DC motor, you don’t need to derive the full \\(G(s)\\) in detail now; just show that the same Laplace and DE tools extend directly to more complex systems in controls."
  },
  {
    "objectID": "control_21.html#summary-key-points-1",
    "href": "control_21.html#summary-key-points-1",
    "title": "Modeling in the Frequency Domain",
    "section": "Summary / Key Points",
    "text": "Summary / Key Points\n\nLaplace transform converts time‑domain functions and differential equations into algebraic expressions in \\(s\\).\nLaplace pairs and theorems (linearity, shift, differentiation, integration, value theorems) are essential tools.\nPartial‑fraction expansion is the main technique to invert rational \\(F(s)\\):\n\nCase 1: real distinct poles → sums of exponentials.\nCase 2: repeated poles → exponentials times polynomials in \\(t\\).\nCase 3: complex poles → exponentially damped sinusoids.\n\nA transfer function \\(G(s) = C(s)/R(s)\\) (zero initial conditions) cleanly separates input, system, and output and corresponds to block diagrams.\nFrom a DE ↔︎ transfer function:\n\nDE → Laplace → algebra → \\(C(s)/R(s) = G(s)\\).\n\\(G(s)\\) + input Laplace → \\(C(s)\\) → partial fractions → \\(c(t)\\).\n\nThese tools are the foundation for modeling ECE systems (circuits, motors, sensors) in the frequency domain and for later topics: stability, transient response, and design.\n\n\nReinforce that everything in later Chapters 2–6 (root locus, Bode plots, steady‑state error) will assume comfort with Laplace transforms and transfer functions. Encourage students to practice going back and forth between differential equations, transfer functions, and time‑domain responses."
  },
  {
    "objectID": "control_21.html#formulas-summary-1",
    "href": "control_21.html#formulas-summary-1",
    "title": "Modeling in the Frequency Domain",
    "section": "Formulas Summary",
    "text": "Formulas Summary\nLaplace transform definition:\n\\[\n\\mathcal{L}[f(t)] = F(s) = \\int_{0^-}^{\\infty} f(t) e^{-s t}\\, dt\n\\]\nInverse Laplace:\n\\[\n\\mathcal{L}^{-1}[F(s)] = \\frac{1}{2\\pi j} \\int_{\\sigma - j\\infty}^{\\sigma + j\\infty} F(s)e^{st}\\, ds = f(t)u(t)\n\\]\nSelected transform pairs:\n\n\\(\\delta(t) \\leftrightarrow 1\\)\n\\(u(t) \\leftrightarrow \\dfrac{1}{s}\\)\n\\(t^n u(t) \\leftrightarrow \\dfrac{n!}{s^{n+1}}\\)\n\\(e^{-at} u(t) \\leftrightarrow \\dfrac{1}{s+a}\\)\n\\(\\sin \\omega t\\, u(t) \\leftrightarrow \\dfrac{\\omega}{s^2 + \\omega^2}\\)\n\\(\\cos \\omega t\\, u(t) \\leftrightarrow \\dfrac{s}{s^2 + \\omega^2}\\)\n\nKey theorems:\n\nLinearity: \\(\\mathcal{L}[k f(t)] = kF(s)\\), \\(\\mathcal{L}[f_1+f_2] = F_1+F_2\\).\nFrequency shift: \\(\\mathcal{L}[e^{-at} f(t)] = F(s + a)\\).\nDifferentiation: \\(\\mathcal{L}\\left[\\dfrac{df}{dt}\\right] = sF(s) - f(0^-)\\).\nIntegration: \\(\\mathcal{L}\\left[\\int_0^{t} f(\\tau)d\\tau\\right] = \\dfrac{F(s)}{s}\\).\nFinal value: \\(f(\\infty) = \\lim_{s\\to 0} sF(s)\\) (under stability conditions).\nInitial value: \\(f(0^+) = \\lim_{s\\to \\infty} sF(s)\\) (if no impulses at 0).\n\nTransfer function (zero initial conditions):\n\nFrom DE:\n\\[\n\\frac{C(s)}{R(s)} = G(s) =\n\\frac{b_m s^m + \\cdots + b_0}\n     {a_n s^n + \\cdots + a_0}\n\\]\nInput–output relation:\n\\[\nC(s) = G(s) R(s)\n\\]\n\n\nLeave this as a concise reference slide. Suggest students copy or print it as a quick cheat‑sheet for homework and future lectures."
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Control System",
    "section": "",
    "text": "This is Control Systems Lecture Notes"
  },
  {
    "objectID": "index.html#week-1-introduction-to-control",
    "href": "index.html#week-1-introduction-to-control",
    "title": "Control System",
    "section": "Week 1 (Introduction to Control)",
    "text": "Week 1 (Introduction to Control)\n\nRPS\nControl 1\nControl 2.1\nControl 2.2"
  },
  {
    "objectID": "index.html#week-2",
    "href": "index.html#week-2",
    "title": "Control System",
    "section": "Week 2",
    "text": "Week 2"
  },
  {
    "objectID": "index.html#week-3",
    "href": "index.html#week-3",
    "title": "Control System",
    "section": "Week 3",
    "text": "Week 3"
  },
  {
    "objectID": "index.html#week-4",
    "href": "index.html#week-4",
    "title": "Control System",
    "section": "Week 4",
    "text": "Week 4"
  },
  {
    "objectID": "index.html#week-5",
    "href": "index.html#week-5",
    "title": "Control System",
    "section": "Week 5",
    "text": "Week 5"
  },
  {
    "objectID": "index.html#week-6",
    "href": "index.html#week-6",
    "title": "Control System",
    "section": "Week 6",
    "text": "Week 6"
  },
  {
    "objectID": "index.html#week-7",
    "href": "index.html#week-7",
    "title": "Control System",
    "section": "Week 7",
    "text": "Week 7"
  },
  {
    "objectID": "index.html#week-8",
    "href": "index.html#week-8",
    "title": "Control System",
    "section": "Week 8",
    "text": "Week 8\n\nUTS"
  },
  {
    "objectID": "rps.html#identitas-mk",
    "href": "rps.html#identitas-mk",
    "title": "Sistem Kendali",
    "section": "Identitas MK",
    "text": "Identitas MK\n\nJenis MK: Wajib\nKode MK: TKE222221\nKurikulum: 2024\nSemester: 4\nSKS: 3"
  },
  {
    "objectID": "rps.html#deskripsi-mk",
    "href": "rps.html#deskripsi-mk",
    "title": "Sistem Kendali",
    "section": "Deskripsi MK",
    "text": "Deskripsi MK\nMata kuliah sistem kendali mempelajari tentang dasar-dasar sistem kendali, pemodelan sistem fisik, diagram blok sistem kendali, sistem orde 1 dan orde 2, stabilitas, root locus, dan pemodelan state space"
  },
  {
    "objectID": "rps.html#references",
    "href": "rps.html#references",
    "title": "Sistem Kendali",
    "section": "References",
    "text": "References\n\nNise, Norman S. 2015. Control System Engineering 7th edition. USA: Wiley\nOgata, Kotsuhiko. 2010. Modern Control Engineering 5th edition. Pearson"
  },
  {
    "objectID": "rps.html#bahan-kajian",
    "href": "rps.html#bahan-kajian",
    "title": "Sistem Kendali",
    "section": "Bahan Kajian",
    "text": "Bahan Kajian\n\nIntroduction Control system\nModelling in electrical and mechanical systems\nBlock Diagrams\nTime response: first and second order\nSteady state error analysis\nStability\nRoot locus\nModelling in state space"
  },
  {
    "objectID": "rps.html#jadwal-dan-pengampu",
    "href": "rps.html#jadwal-dan-pengampu",
    "title": "Sistem Kendali",
    "section": "Jadwal dan Pengampu",
    "text": "Jadwal dan Pengampu\n\nPengampu MK: Imron Rosyadi, Priswanto, Agung Mubyarto, M. Zakki Irfani\nJadwal:\n\nSistem Kendali A SELASA 09:45-10:35 s/d 11:35-12:25 : Agung Mubyarto (Pertemuan 1-7), M. Zakki Irfani (Pertemuan 8-15)\nSistem Kendali B SELASA 13:00-13:50 s/d 14:50-15:40 : Imron Rosyadi (Pertemuan 1-7), Priswanto (Pertemuan 9-15)\nSistem Kendali C SELASA 07:00-07:50 s/d 08:50-09:40 : Imron Rosyadi (Pertemuan 1-7), Priswanto (Pertemuan 8-15)\nSistem Kendali D RABU 07:00-07:50 s/d 08:50-09:40 : Agung Mubyarto (Pertemuan 1-7), M. Zakki Irfani (Pertemuan 8-15)"
  },
  {
    "objectID": "rps.html#cpl",
    "href": "rps.html#cpl",
    "title": "Sistem Kendali",
    "section": "CPL",
    "text": "CPL\n\n(CP-01) Menguasai matematika, fisika, kimia dan statistik, teknologi informasi dan rekayasa sebagai landasan penerapan di bidang teknik elektro\n(CP-02) Mampu merancang suatu komponen, sistem, atau proses yang berkelanjutan untuk memenuhi kebutuhan yang diinginkan sesuai dengan batasan yang realistis meliputi hukum, ekonomi, lingkungan, humaniora, keberlanjutan, kesehatan dan keselamatan kerja, atau standar keteknikan yang berlaku\n(CP-04) Mampu mengidentifikasi, merumuskan, dan memecahkan masalah keteknikan untuk mengambil keputusan secara tepat dalam konteks penyelesaian masalah yang kompleks di bidang teknik elektro"
  },
  {
    "objectID": "rps.html#cpmk",
    "href": "rps.html#cpmk",
    "title": "Sistem Kendali",
    "section": "CPMK",
    "text": "CPMK\n\nCPMK-01: Mahasiswa mampu menganalisis konsep dasar teknik kendali dan pemodelan sistem fisik\nCPMK-02: Mahasiswa mampu menganalisis respon transient dan steady-state\nCPMK-03: Mahasiswa mampu mengevaluasi stabilitas dan root locus dari suatu sistem kendali\nCPMK-04: Mahasiswa mampu menganalisis pemodelan secara state space"
  },
  {
    "objectID": "rps.html#cpmk-1",
    "href": "rps.html#cpmk-1",
    "title": "Sistem Kendali",
    "section": "CPMK-1",
    "text": "CPMK-1\n\nWeek 1: Introduction - Control System (Ref: Nise 1.1-1.7, Ogata 1.1-1.4) Modeling - Introduction (Ref: Nise 2.1-2.3, Ogata 2.1-2.2, Ogata 3.1), Selasa, 24 Februari 2026\nWeek 2: Modeling in Frequency Domain - Electrical Systems (Ref: Nise 2.4-2.6, Ogata 3.2-3.3), Selasa, 3 Maret 2026\nWeek 3: Modeling in Frequency Domain - Mechanical Systems (Ref: Nise 2.6-2.9, Ogata 3.2-3.3) Block Diagrams - Introduction (5.1-5.2), Selasa, 10 Maret 2026\nWeek 4:  Reduction of Multiple Subsystems - Block Diagrams - Signal-Flow Graphs (Ref Nise 5.3-5.6), Selasa, 17 Maret 2026"
  },
  {
    "objectID": "rps.html#cpmk-2",
    "href": "rps.html#cpmk-2",
    "title": "Sistem Kendali",
    "section": "CPMK-2",
    "text": "CPMK-2\n\nWeek 5: Time Response - First Order (Ref: Nise 4.1-4.3, Ogata 5.1-5.2), Selasa, 31 Maret 2026\nWeek 6: Time Response - Second Order (Ref: Nise 4.4-4.6, Ogata 5.3-5.4), Selasa, 7 April 2026\nWeek 7: Time Response - Steady-State Error Analysis (Ref: Nise 7.1-7.6, Ogata 5.8), Selasa, 14 April 2026\nWeek 8: Midterm Exam - UTS, Selasa, 21 April 2026"
  },
  {
    "objectID": "rps.html#cpmk-3-cpmk-4",
    "href": "rps.html#cpmk-3-cpmk-4",
    "title": "Sistem Kendali",
    "section": "CPMK-3 & CPMK-4",
    "text": "CPMK-3 & CPMK-4\n\nWeek 9: Stability\nWeek 10: Root Locus\nWeek 11: Root Locus\nWeek 12: Root Locus\nWeek 13: Modeling in The Time Domain\nWeek 14: Time Response\nWeek 15: Steady-State Errors\nWeek 16: Final Exam - UAS"
  },
  {
    "objectID": "rps.html#tautan-penting-imron-rosyadi",
    "href": "rps.html#tautan-penting-imron-rosyadi",
    "title": "Sistem Kendali",
    "section": "Tautan Penting (Imron Rosyadi)",
    "text": "Tautan Penting (Imron Rosyadi)\n\nCourse Page: imron-course.vercel.app\nPresentation: imron-slide.vercel.app\nDiscussion: discord.gg/6nNTvfmz, expired at 29 Aug 2025\nAttendance: teraversa.unsoed.ac.id\nOnline Learning: eldiru.unsoed.ac.id"
  },
  {
    "objectID": "rps.html#metode-pembelajaran-imron-rosyadi",
    "href": "rps.html#metode-pembelajaran-imron-rosyadi",
    "title": "Sistem Kendali",
    "section": "Metode Pembelajaran (Imron Rosyadi)",
    "text": "Metode Pembelajaran (Imron Rosyadi)\n\nEnglish-Indonesia: Salindia presentasi dalam bahasa Inggris, tetapi penyampaian menggunakan bahasa Indonesia.\nLuring-Daring: Pembelajaran dilakukan dengan tatap muka luring, tetapi diselingi secara daring. Cek Discord untuk informasi.\nVisualisasi-Interaktif: Pembelajaran akan menyediakan sumberdaya berupa visualisasi interaktif untuk memudahkan pemahaman. Cek berbagai link yang disediakan.\nCase-based Approach: Pembelajaran akan dikaitkan dengan topik bidang Electrical and Computer Engineering\nDiskusi-Informasi via Discord: Diskusikan materi, ajukan pertanyaan, langsung via Discord (channel #instrumentasi).\nWeb-based Presentation: Salindia presentasi berbentuk laman web, tetapi anda bisa mengekspornya ke PDF.\nRileks: Pembelajaran dilakukan secara rileks."
  },
  {
    "objectID": "rps.html#faq-imron-rosyadi",
    "href": "rps.html#faq-imron-rosyadi",
    "title": "Sistem Kendali",
    "section": "FAQ (Imron Rosyadi)",
    "text": "FAQ (Imron Rosyadi)\n\nBagaimana cara menerjemahkan materi kuliah ke bahasa Indonesia?\n\nInstall browser plugin untuk translation, misal: Immersive Translate\n\nBagaimana cara mencetak/menyimpan presentasi ke PDF?\n\nTekan menu kiri bawah (☰) &gt;&gt; Tools &gt;&gt; PDF Export Mode &gt;&gt; Ctrl+P &gt;&gt; Save as PDF &gt;&gt; Save\nTekan huruf e &gt;&gt; Ctrl+P &gt;&gt; Save as PDF &gt;&gt; Save"
  }
]