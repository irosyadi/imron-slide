---
title: "Linear Algebra"
subtitle: "1.9 Applications of Linear Systems"
author: "Imron Rosyadi"
format:
  live-revealjs:
    logo: "qrjs_assets/unsoed_logo.png"
    footer: "[irosyadi-2025](https://imron-slide.vercel.app)"
    slide-number: true
    chalkboard: true
    scrollable: true
    controls: true
    progress: true
    preview-links: false
    transition: fade
    incremental: false
    smaller: false
    theme: [default, qrjs_assets/ir_style.scss]
filters:
  - pyodide
---

# Linear Algebra in ECE
## 1.9 Applications of Linear Systems

### Imron Rosyadi

<br>
<br>
*Unlocking the real-world power of linear systems in Network Analysis, Chemical Balancing, Polynomial Interpolation, and Economic Modeling.*

::: {.notes}
Good morning everyone! Until now, we've focused on the mechanics of linear systems, understanding how to solve them and exploring properties of matrices. Today, we're transitioning to *why* this is all so important. We'll explore diverse, real-world applications where systems of linear equations provide the fundamental tools for analysis and problem-solving, particularly relevant to Electrical and Computer Engineering. We'll cover network analysis including electrical circuits, balancing chemical equations, polynomial interpolation, and even touch upon economic input-output models.
:::

---

## Network Analysis: Core Principle

A **network** is a set of branches through which something "flows". Branches meet at **nodes** or **junctions**.

*   **Examples:** Electrical wires, pipes, traffic lanes, financial flows.
*   **Flow Rate:** Measured in units like amperes (electricity), gallons/minute (water), vehicles/hour (traffic).
*   **Core Principle: Flow Conservation**
    *   At each node, **rate of flow into the node = rate of flow out of the node**.
    *   This prevents buildup and ensures free movement.

A common problem is to use known flow rates in some branches to find rates in all branches.

::: {.notes}
Networks are everywhere in ECE. Think of power grids, communication networks, or even data flow in a computer system. The fundamental principle governing most networks is flow conservation. Whatever amount of "stuff" enters a junction must also leave it. This simple rule translates directly into linear equations, forming the basis for analyzing complex systems. This is the first step in formulating many engineering problems as linear systems.
:::

---

## Example 1: Simple Network Analysis

Find the flow rates and directions in the remaining branches.

:::: {.columns}
::: {.column width="50%"}
<p align="center">
  <img src="https://cdn-mineru.openxlab.org.cn/result/2025-08-19/d28de157-cffb-4586-85b2-10e6c17e5d20/0197b66d07c36e99b483d626aef30ebfa858c413fe506b712a536e2d6f59b269.jpg" alt="Network Diagram" style="width:50%;">
</p>

Arbitrarily assign directions for unknown flows $x_1, x_2, x_3$.
:::
::: {.column width="50%"}
**Equations from Flow Conservation:**

*   **Node A:** $x_1 + x_2 = 30$
*   **Node B:** $x_2 + x_3 = 35$
*   **Node C:** $x_3 + 15 = 60 \implies x_3 = 45$
*   **Node D:** $x_1 + 15 = 55 \implies x_1 = 40$

**Linear System:**
$$
\begin{array}{r}x_1 + x_2 \qquad = 30\\ \qquad x_2 + x_3 = 35\\ x_3 = 45\\ x_1 = 40\end{array}
$$
:::
::::

::: {.notes}
Here, we have a simple network with four nodes and known incoming/outgoing flows at its boundaries. The unknown internal flows are $x_1, x_2, x_3$. The first step is to arbitrarily assign directions to these unknowns. If our assumed direction is wrong, the solved value will simply be negative, indicating the actual flow is in the opposite direction.
Then, for each node, we apply the conservation of flow rule: flow in equals flow out. This gives us a system of linear equations. This system is straightforward enough to be solved by inspection, starting from the bottom equations.
:::

---

## Example 1: Solving the Network System

Let's solve the system using Python.

System:
$x_1 + x_2 = 30$  
$x_2 + x_3 = 35$  
$x_3 = 45$  
$x_1 = 40$  

```{.pyodide}
#| max-lines: 10
import numpy as np

# This system is simpler for substitution, but for demonstration:
# Represent as Ax = b
A = np.array([
    [1, 1, 0],
    [0, 1, 1],
    [0, 0, 1],
    [1, 0, 0]
])

b = np.array([30, 35, 45, 40])

# Direct substitution from last two equations:
x1 = 40
x3 = 45

# Substitute x3 into second equation
x2 = 35 - x3

# Check with first equation
# x1 + x2 = 40 + (35 - 45) = 40 - 10 = 30 (Matches!)

print(f"x1 = {x1}")
print(f"x2 = {x2}")
print(f"x3 = {x3}")

if x2 < 0:
    print("\nNote: x2 is negative, meaning the actual flow direction is opposite to the one assigned in the diagram.")
```
**Solution:** $x_1 = 40, x_2 = -10, x_3 = 45$.

The negative value for $x_2$ indicates its actual flow direction is opposite to the one assumed.

::: {.notes}
Even though this system can be solved by substitution easily, converting it to matrix form and solving numerically demonstrates the general approach for larger, more complex networks. Our solution shows $x_1=40$, $x_3=45$, and $x_2=-10$. The negative sign for $x_2$ is key: it tells us that the initial direction we assigned to $x_2$ in the diagram was incorrect. The actual flow for $x_2$ is into node A, not out of it. This highlights how linear systems automatically reveal the real-world conditions.
:::

---

## Example 2: Design of Traffic Patterns

Analyzing traffic flow around a new park in Philadelphia.

<p align="center">
  <img src="https://cdn-mineru.openxlab.org.cn/result/2025-08-19/d28de157-cffb-4586-85b2-10e6c17e5d20/1ebf92ce8e826a06142eed6fe657a36aebd63c1475e348ea0f2189bf1afce284.jpg" alt="Traffic Network" style="width:100%;">
</p>

**Part (a): Traffic Light Setting**  
Total Flow In = Total Flow Out  
$500 + 400 + 600 + 200 = x + 700 + 400$  
$1700 = x + 1100$  
$x = 600$ vehicles/hour.

---

## Example 2: Design of Traffic Patterns

**Part (b): Streets' Flow Rates**  
With $x = 600$, apply flow conservation at each intersection (A, B, C, D):  

*   A: $400 + 600 = x_1 + x_2 \implies x_1 + x_2 = 1000$
*   B: $x_2 + x_3 = 400 + x \implies x_2 + x_3 = 1000$
*   C: $500 + 200 = x_3 + x_4 \implies x_3 + x_4 = 700$
*   D: $x_1 + x_4 = 700$

**Linear System:**
$$
\begin{array}{r l l}x_1 + x_2 \qquad & = 1000\\ \qquad x_2 + x_3 & = 1000\\ \qquad x_3 + x_4 &= 700\\ x_1 \qquad + x_4 &= 700 \end{array}
$$

::: {.notes}
Traffic management is a crucial area where linear systems are applied to prevent congestion. We first determine the necessary traffic light setting to balance total incoming and outgoing flow for the entire complex. Once that's set, we then apply the flow conservation principle to each internal intersection. This creates a more involved system of linear equations for the flow rates on the internal streets ($x_1, x_2, x_3, x_4$).
:::

---

## Example 2: Solving the Traffic Flow System

```{.pyodide}
#| max-lines: 10
import numpy as np

# Coefficients matrix A and constants vector b
A = np.array([
    [1, 1, 0, 0],
    [0, 1, 1, 0],
    [0, 0, 1, 1],
    [1, 0, 0, 1]
])

b = np.array([1000, 1000, 700, 700])

# Using Gaussian elimination (RREF) to find general solution
# Augmented matrix [A | b]
aug_matrix = np.concatenate((A, b.reshape(-1, 1)), axis=1)

# Manual RREF steps (for illustrative purposes, usually done by software)
# Row 4 = Row 4 - Row 1
aug_matrix[3] -= aug_matrix[0]
# From here, we'd continue reduction.
# The system has more variables than pivot rows after reduction,
# leading to infinitely many solutions.

# The general solution from the textbook:
# x1 = 700 - t
# x2 = 300 + t
# x3 = 700 - t
# x4 = t

print("Coefficient Matrix A:\n", A)
print("\nConstant Vector b:\n", b)
print("\nThis system has infinitely many solutions. (A is singular)")
print("General solution (from RREF of augmented matrix):")
print("x1 = 700 - t")
print("x2 = 300 + t")
print("x3 = 700 - t")
print("x4 = t")

print("\nPhysical constraints: x_i >= 0")
print("x1 >= 0  => 700 - t >= 0  => t <= 700")
print("x2 >= 0  => 300 + t >= 0  => t >= -300")
print("x3 >= 0  => 700 - t >= 0  => t <= 700")
print("x4 >= 0  => t >= 0")
print("\nCombining these: 0 <= t <= 700")
print("This defines the range of possible average flow rates for each street.")
```

This system has **infinitely many solutions**, given by parametric equations. Physical constraints (e.g., non-negative flow) limit the parameter $t$.

::: {.notes}
When we set up and solve the traffic flow system, we find that it has infinitely many solutions, expressible in terms of a parameter 't'. This means there isn't a single unique way to distribute the traffic flow, which can actually be a good thing for traffic engineers as it provides flexibility. However, these solutions aren't entirely arbitrary. Physical constraints, like one-way streets implying non-negative flow rates, impose limits on what 't' can be. Here, 't' must be between 0 and 700, which then defines the range of average flow rates for each street. This demonstrates how linear systems, combined with real-world constraints, help in designing adaptable systems.
:::

---

## Network Analysis: Electrical Circuits

Linear systems are fundamental to circuit analysis.

*   **Ohm's Law:** Voltage drop $E = IR$ (Current $\times$ Resistance).
*   **Kirchhoff's Current Law (KCL):** Sum of currents entering a node = Sum of currents leaving a node. (Flow Conservation)
*   **Kirchhoff's Voltage Law (KVL):** In any closed loop, sum of voltage rises = sum of voltage drops.

<p align="center">
  <img src="https://cdn-mineru.openxlab.org.cn/result/2025-08-19/d28de157-cffb-4586-85b2-10e6c17e5d20/dce39dd2b0c31a1a858cb4ee4b02e7cd3217afd022fbd2144fe933cadbd03c71.jpg" alt="Electrical Network Example" style="width:30%;">
  <img src="https://cdn-mineru.openxlab.org.cn/result/2025-08-19/d28de157-cffb-4586-85b2-10e6c17e5d20/15de6cbcd34ef73bdeaee4d6419e72affe40ff52c1e625e925b48371f7dc7e49.jpg" alt="Clockwise Loop Convention" style="width:30%;">
</p>

**Conventions:** For KVL, we often assume clockwise loops and define voltage rises/drops for batteries and resistors consistently.

::: {.notes}
For electrical and computer engineers, applying linear systems to circuits is a daily task. Ohm's Law gives us the relationship between voltage, current, and resistance. But to analyze complex circuits, we primarily rely on Kirchhoff's laws. KCL is a direct application of the flow conservation principle we just discussed, but now for electron flow (current). KVL relates all the voltage changes around any closed path in the circuit. By systematically applying these laws and following specific conventions for how we assign directions and rises/drops, we can formulate systems of linear equations to solve for unknown currents or voltages in a circuit.
:::

---

## Example 3: Circuit with One Closed Loop

Determine the current $I$.

<p align="center">
  <img src="https://cdn-mineru.openxlab.org.cn/result/2025-08-19/d28de157-cffb-4586-85b2-10e6c17e5d20/d987a2592e4eaa1de16a85afbda7e9176199721523a14152bc6e19d21a801181.jpg" alt="Single Loop Circuit" style="width:30%;">
</p>

*   **Resistor (3 &Omega;):** Current $I$ flows in same direction as loop $\implies$ **Voltage Drop** $E_R = IR = 3I$.
*   **Battery (6 V):** Loop direction from $-$ to $+$ through battery $\implies$ **Voltage Rise** $E_{Batt} = 6$V.

**Applying KVL:**
Sum of voltage rises = Sum of voltage drops  
$6 = 3I$  
$I = 2$ A.

Since $I$ is positive, the assigned direction is correct.

::: {.notes}
In the simplest case, a single closed loop, KVL helps us find the current directly. We have a 6V battery providing a voltage rise and a 3 Ohm resistor causing a voltage drop. According to KVL, these must balance. The equation $6 = 3I$ is a simple linear equation that immediately gives us $I=2$A. The positive value confirms our assumed current direction. This is a fundamental building block for analyzing more complex multi-loop circuits.
:::

---

## Example 4: Circuit with Three Closed Loops

Determine the currents $I_1, I_2, I_3$.

<p align="center">
  <img src="https://cdn-mineru.openxlab.org.cn/result/2025-08-19/d28de157-cffb-4586-85b2-10e6c17e5d20/076202634764f242d324db99a9fb6b4da85b2b91e0f72a16f7437ccc1049ecff.jpg" alt="Three Loop Circuit" style="width:30%;">
</p>

**KCL at Node A (or B):**
$I_1 + I_2 = I_3 \implies I_1 + I_2 - I_3 = 0$

**KVL for Loops (clockwise traversal):**

*   **Left Inside Loop:** $50 = 5I_1 + 20I_3$
*   **Right Inside Loop:** $30 = 10I_2 + 20I_3$

**Combined Linear System:**
$$
\begin{array}{r l l}I_1 + \quad I_2 - \quad I_3 & = \quad 0\\ 5I_1 \qquad + 20I_3 & = \quad 50\\ \qquad 10I_2 + 20I_3 & = -30\end{array}
$$

::: {.notes}
Now for a more complex circuit, which is common in many ECE devices. We have three unknown currents.
First, KCL is applied at either node A or B. Both yield the same equation relating $I_1, I_2, I_3$.
Next, KVL is applied to two independent closed loops. We chose the left and right inner loops, defining voltage rises from batteries and drops across resistors using Ohm's law.
This systematic application results in a $3 \times 3$ system of linear equations. This system is what we'll solve to determine the unknown currents.
:::

---

## Example 4: Solving the Circuit System

Let's solve for $I_1, I_2, I_3$ using Python.

System:
$I_1 + I_2 - I_3 = 0$  
$5I_1 + 20I_3 = 50$  
$10I_2 + 20I_3 = -30$  

```{.pyodide}
#| max-lines: 10
import numpy as np

# Coefficients matrix A
A = np.array([
    [1, 1, -1],
    [5, 0, 20],
    [0, 10, 20]
])

# Constants vector b
b = np.array([0, 50, -30])

# Solve the linear system Ax = b
try:
    currents = np.linalg.solve(A, b)
    I1, I2, I3 = currents
    print(f"I1 = {I1:.2f} A")
    print(f"I2 = {I2:.2f} A")
    print(f"I3 = {I3:.2f} A")

    if I2 < 0:
        print("\nNote: I2 is negative, meaning the actual current direction is opposite to the one assigned.")

except np.linalg.LinAlgError:
    print("Error: The system is singular or ill-conditioned.")
```
Solution: $I_1 = 6$ A, $I_2 = -5$ A, $I_3 = 1$ A.

The negative value for $I_2$ indicates its actual direction is opposite to the assumption.

::: {.notes}
We use `numpy.linalg.solve` for a quick and accurate solution. The results are $I_1=6$A, $I_2=-5$A, and $I_3=1$A. Again, the negative sign for $I_2$ simply confirms that the assumed direction in the diagram was opposite to the actual flow. Linear algebra provides us with a robust method to solve even complex circuits, which is critical for design and troubleshooting in any electrical system.
:::

---

## Balancing Chemical Equations

Chemical equations represent reactions where atoms rearrange. A balanced equation means the **same number of atoms of each type appears on both sides** of the equation.

**Systematic Method using Linear Systems:**

1.  Assign unknown coefficients ($x_1, x_2, \ldots$) to each molecule.
2.  For each type of atom (e.g., C, H, O), set up an equation ensuring the number of atoms on the reactant side equals the number on the product side.
3.  This forms a homogeneous linear system.
4.  Solve the system; the smallest positive integer solution for the coefficients is the balanced equation.

::: {.notes}
Balancing chemical equations might seem like a chemistry problem, but it's a perfect illustration of conservation, and thus, where linear systems are very useful. For complex reactions, trial and error is inefficient. Linear algebra provides a systematic, foolproof method. The core idea is that for each type of atom involved, their count must be conserved across the reaction. This translates directly into a system of homogeneous linear equations, as all terms are brought to one side to sum to zero.
:::

---

## Example: Balancing Methane Combustion

Balance the equation: $\mathrm{CH_4} + \mathrm{O_2} \longrightarrow \mathrm{CO_2} + \mathrm{H_2O}$

Assign coefficients: $x_1(\mathrm{CH_4}) + x_2(\mathrm{O_2}) \longrightarrow x_3(\mathrm{CO_2}) + x_4(\mathrm{H_2O})$

**Atom Balance Equations:**

*   **Carbon (C):** $x_1 = x_3 \implies x_1 - x_3 = 0$
*   **Hydrogen (H):** $4x_1 = 2x_4 \implies 4x_1 - 2x_4 = 0$
*   **Oxygen (O):** $2x_2 = 2x_3 + x_4 \implies 2x_2 - 2x_3 - x_4 = 0$

**Homogeneous Linear System:**
$$
\begin{array}{r}x_1 \qquad - x_3 \qquad \quad = 0\\ 4x_1 \qquad \qquad - 2x_4 = 0\\ \qquad 2x_2 - 2x_3 - x_4 = 0\end{array}
$$

Augmented Matrix: $\left[ \begin{array}{rrrrr}1 & 0 & -1 & 0 & 0\\ 4 & 0 & 0 & -2 & 0\\ 0 & 2 & -2 & -1 & 0 \end{array} \right]$

::: {.notes}
The first step is to assign variables, $x_1, x_2, x_3, x_4$, to represent the number of molecules of each compound. Then, for each element (Carbon, Hydrogen, Oxygen), we write an equation ensuring the number of atoms is conserved. For example, for carbon, $x_1$ carbon atoms on the left must equal $x_3$ carbon atoms on the right. This yields a system of homogeneous linear equations.
:::

---

## Example: Solving for Methane Combustion

Let's solve the system:  
$x_1 - x_3 = 0$  
$4x_1 \qquad - 2x_4 = 0$  
$2x_2 - 2x_3 - x_4 = 0$  

```{.pyodide}
#| max-lines: 10
import numpy as np

# Coefficients matrix for the homogeneous system
A_chem = np.array([
    [1, 0, -1, 0],
    [4, 0, 0, -2],
    [0, 2, -2, -1]
])

# Use SVD to find a basis for the null space (solutions to Ax=0)
# A must be full rank for unique solution, here it's Ax=0 so null space
U, S, Vt = np.linalg.svd(A_chem)
# The last column of Vt (transposed) is the solution vector for Ax=0
# if the last singular value is close to zero.
null_space_basis = Vt[-1, :]

# Scale to smallest integers
# General solution: x = t * null_space_basis.
# Here, null_space_basis might be something like [0.5, 1, 0.5, 1] for t=2 (as found in textbook)
# Or a scaled version like [0.22, 0.44, 0.22, 0.44] if not normalized for integers.
# Let's verify by manual substitution as in textbook if we assume x4 = t:
# From 4x1 - 2x4 = 0 => x1 = 0.5 * x4
# From x1 - x3 = 0 => x3 = x1 = 0.5 * x4
# From 2x2 - 2x3 - x4 = 0 => 2x2 = 2(0.5 * x4) + x4 = x4 + x4 = 2x4 => x2 = x4

# To get smallest integers, let x4 = t.
# x1 = t/2, x2 = t, x3 = t/2, x4 = t
# Smallest integers when t=2:
x1_sol = 1
x2_sol = 2
x3_sol = 1
x4_sol = 2

print(f"Smallest integer solution:")
print(f"x1 (CH4) = {x1_sol}")
print(f"x2 (O2) = {x2_sol}")
print(f"x3 (CO2) = {x3_sol}")
print(f"x4 (H2O) = {x4_sol}")
```

The general solution is $x_1 = t/2, x_2 = t, x_3 = t/2, x_4 = t$.  
Smallest positive integers occur at $t=2$: $x_1=1, x_2=2, x_3=1, x_4=2$.  

Balanced equation: $\mathrm{CH_4} + 2\mathrm{O_2} \longrightarrow \mathrm{CO_2} + 2\mathrm{H_2O}$.

::: {.notes}
We use `numpy` to represent the coefficient matrix. Solving homogeneous systems like $A\mathbf{x}=\mathbf{0}$ often involves finding the null space. For this simple case, we can deduce the general solution $x_1=t/2, x_2=t, x_3=t/2, x_4=t$. The smallest positive integer solution is obtained by choosing the smallest 't' that makes all variables integers. Here, $t=2$ gives the coefficients 1, 2, 1, 2. This systematic method is highly effective for more complex chemical equations where trial-and-error fails.
:::

---

## Example: Balancing $\mathrm{HCl} + \mathrm{Na_3PO_4}$

Balance: $\mathrm{HCl} + \mathrm{Na_3PO_4} \longrightarrow \mathrm{H_3PO_4} + \mathrm{NaCl}$

Assign coefficients: $x_1(\mathrm{HCl}) + x_2(\mathrm{Na_3PO_4}) \longrightarrow x_3(\mathrm{H_3PO_4}) + x_4(\mathrm{NaCl})$

**Atom Balance Equations:**

*   H: $x_1 = 3x_3 \implies x_1 - 3x_3 = 0$
*   Cl: $x_1 = x_4 \implies x_1 - x_4 = 0$
*   Na: $3x_2 = x_4 \implies 3x_2 - x_4 = 0$
*   P: $x_2 = x_3 \implies x_2 - x_3 = 0$
*   O: $4x_2 = 4x_3 \implies 4x_2 - 4x_3 = 0$

**Homogeneous Linear System:**
$$
\begin{array}{r l l l l l}x_1 \qquad \qquad - 3x_3 \qquad \quad &= 0\\ x_1 \qquad \qquad \qquad - x_4 &= 0\\ \qquad 3x_2 \qquad \qquad - x_4 &= 0\\ \qquad x_2 - x_3 \qquad \quad &= 0\\ \qquad 4x_2 - 4x_3 \qquad \quad &= 0\end{array}
$$

::: {.notes}
This chemical equation is slightly more complex. Again, we assign coefficients and set up balance equations for each atom type (Hydrogen, Chlorine, Sodium, Phosphorus, Oxygen). Notice that the last two equations are dependent ($4x_2 - 4x_3 = 0$ is a multiple of $x_2 - x_3 = 0$), so the system will have infinitely many solutions, and we'll seek the smallest positive integer set.
:::

---

## Example: Solving for $\mathrm{HCl} + \mathrm{Na_3PO_4}$

System:
$x_1 - 3x_3 = 0$  
$x_1 - x_4 = 0$  
$3x_2 - x_4 = 0$  
$x_2 - x_3 = 0$  
$4x_2 - 4x_3 = 0$  

```{.pyodide}
#| max-lines: 10
import numpy as np

# Coefficients matrix
A_chem2 = np.array([
    [1, 0, -3,  0],
    [1, 0,  0, -1],
    [0, 3,  0, -1],
    [0, 1, -1,  0],
    [0, 4, -4,  0]
])


# The solution involves finding null space. From the text, the general solution is:
# x1 = t, x2 = t/3, x3 = t/3, x4 = t
# We need to find the smallest integer t that makes all x_i integers.
# The common denominator for t/3 is 3.

t_val = 3
x1_final = t_val
x2_final = t_val / 3
x3_final = t_val / 3
x4_final = t_val

print(f"Smallest integer solution for t={t_val}:")
print(f"x1 (HCl) = {int(x1_final)}")
print(f"x2 (Na3PO4) = {int(x2_final)}")
print(f"x3 (H3PO4) = {int(x3_final)}")
print(f"x4 (NaCl) = {int(x4_final)}")
```

General solution: $x_1 = t, x_2 = t/3, x_3 = t/3, x_4 = t$.  
Smallest positive integers occur at $t=3$: $x_1=3, x_2=1, x_3=1, x_4=3$. 

Balanced equation: $3\mathrm{HCl} + \mathrm{Na_3PO_4} \longrightarrow \mathrm{H_3PO_4} + 3\mathrm{NaCl}$.

::: {.notes}
Similar to the previous example, this system also leads to infinitely many solutions due to the dependency among equations. The general solution reveals that we need to choose 't' as a multiple of 3 to obtain integer values for $x_2$ and $x_3$. The smallest such positive integer 't' is 3, yielding the coefficients 3, 1, 1, 3. This systematic approach ensures accurate balancing for any chemical equation, no matter how complex.
:::

---

## Polynomial Interpolation

**Problem:** Find a polynomial whose graph passes through a specified set of points $(x_1, y_1), \ldots, (x_n, y_n)$.

**THEOREM 1.9.1 (Polynomial Interpolation):** Given any $n$ points in the $xy$-plane with distinct $x$-coordinates, there is a unique polynomial of degree $n-1$ or less whose graph passes through those points.

---

## Polynomial Interpolation

We seek a polynomial $p(x) = a_0 + a_1x + a_2x^2 + \dots + a_{n-1}x^{n-1}$.
Substituting each point $(x_i, y_i)$ into the polynomial gives a linear system for the coefficients $a_0, \ldots, a_{n-1}$:
$$
\begin{array}{r l} a_{0} + a_{1}x_{1} + a_{2}x_{1}^{2} + \dots +a_{n - 1}x_{1}^{n - 1} &= y_{1}\\ \vdots \\ a_{0} + a_{1}x_{n} + a_{2}x_{n}^{2} + \dots +a_{n - 1}x_{n}^{n - 1} &= y_{n} \end{array}
$$
This system can be written with an augmented matrix:
$$
\left[{\begin{array}{l l l l l l}{1}&{x_{1}}&{x_{1}^{2}}&{\cdots}&{x_{1}^{n-1}}&{y_{1}}\\ {1}&{x_{2}}&{x_{2}^{2}}&{\cdots}&{x_{2}^{n-1}}&{y_{2}}\\ {\vdots}&{\vdots}&{\vdots}&&{\vdots}&{\vdots}\\ {1}&{x_{n}}&{x_{n}^{2}}&{\cdots}&{x_{n}^{n-1}}&{y_{n}}\end{array}}\right]
$$
Solving this system yields the unique coefficients of the interpolating polynomial.

::: {.notes}
Polynomial interpolation is a core concept in numerical analysis and engineering. Often, we don't have a perfect formula for a function, but we have a set of data points. Interpolation allows us to find a polynomial that neatly passes through all these points. This polynomial can then be used to approximate function values between known points. The key insight is that the requirement for the polynomial to pass through N points translates directly into a system of N linear equations for the N unknown coefficients of the polynomial. The augmented matrix of this system is related to the Vandermonde matrix, which we'll see later has properties guaranteeing a unique solution for distinct x-coordinates.
:::

---

## Example 6: Cubic Polynomial Interpolation

Find a cubic polynomial whose graph passes through the points:
$(1,3),\ (2, - 2),\ (3, - 5),\ (4,0)$

The polynomial is $p(x) = a_0 + a_1x + a_2x^2 + a_3x^3$.
Using the augmented matrix from the previous slide:
$$
\left[{\begin{array}{r r r r r}{1}&{x_{1}}&{x_{1}^{2}}&{x_{1}^{3}}&{y_{1}}\\ {1}&{x_{2}}&{x_{2}^{2}}&{x_{2}^{3}}&{y_{2}}\\ {1}&{x_{3}}&{x_{3}^{2}}&{x_{3}^{3}}&{y_{3}}\\ {1}&{x_{4}}&{x_{4}^{2}}&{x_{4}^{3}}&{y_{4}}\end{array}}\right]={\left[\begin{array}{r r r r r}{1}&{1}&{1}&{1}&{3}\\ {1}&{2}&{4}&{8}&{-2}\\ {1}&{3}&{9}&{27}&{-5}\\ {1}&{4}&{16}&{64}&{0}\end{array}\right]}
$$

We will solve this system for $a_0, a_1, a_2, a_3$.

::: {.notes}
We have four points, so we expect a polynomial of degree up to 3. We set up the augmented matrix directly from the given points. The columns are powers of the x-coordinates, and the last column contains the y-coordinates. Solving this system for $a_0, a_1, a_2, a_3$ will give us our unique cubic interpolating polynomial.
:::

---

## Example 6: Solving and Plotting

```{.pyodide}
#| fig-cap: "Cubic interpolating polynomial passing through the given points."
#| max-lines: 10
import numpy as np
import matplotlib.pyplot as plt

# Augmented matrix from the problem
aug_matrix = np.array([
    [1, 1,  1,  1,  3],
    [1, 2,  4,  8, -2],
    [1, 3,  9, 27, -5],
    [1, 4, 16, 64,  0]
])

# Extract A and b
A_interp = aug_matrix[:, :4]
b_interp = aug_matrix[:, 4]

# Solve for coefficients [a0, a1, a2, a3]
coefficients = np.linalg.solve(A_interp, b_interp)
a0, a1, a2, a3 = coefficients

print(f"Coefficients: a0={a0:.2f}, a1={a1:.2f}, a2={a2:.2f}, a3={a3:.2f}")
print(f"The unique interpolating polynomial is: p(x) = {a0:.2f} + {a1:.2f}x + {a2:.2f}x^2 + {a3:.2f}x^3")

# Plotting the polynomial and points
x_points = aug_matrix[:, 1]
y_points = aug_matrix[:, 4]

x_vals = np.linspace(min(x_points)-0.5, max(x_points)+0.5, 100)
p_x_vals = a0 + a1*x_vals + a2*x_vals**2 + a3*x_vals**3

plt.figure(figsize=(7, 4))
plt.plot(x_vals, p_x_vals, label='p(x)')
plt.scatter(x_points, y_points, color='red', zorder=5, label='Given Points')
plt.title('Polynomial Interpolation')
plt.xlabel('x')
plt.ylabel('y')
plt.grid(True)
plt.axhline(0, color='black',linewidth=0.5)
plt.axvline(0, color='black',linewidth=0.5)
plt.legend()
plt.show()
```

The coefficients obtained are $a_0 = 4, a_1 = 3, a_2 = -5, a_3 = 1$.
Thus, $p(x) = 4 + 3x - 5x^2 + x^3$.

::: {.notes}
Using `numpy.linalg.solve`, we quickly find the coefficients: $a_0=4, a_1=3, a_2=-5, a_3=1$. This gives us the unique cubic polynomial. The plot clearly shows how this polynomial smoothly passes through all four given points. In engineering, interpolation is used in sensor calibration, generating smooth curves for robot movements, or in signal processing to reconstruct missing data points.
:::

---

## Example 7: Approximate Integration

One application is approximating integrals of complex functions by interpolating them with simpler polynomials.

Example: $\int_{0}^{1} \sin \left(\frac{\pi x^{2}}{2}\right) dx$

1.  Use points on the function's graph (e.g., $(x_i, f(x_i))$).
2.  Find an interpolating polynomial $p(x)$ for these points.
3.  Integrate the polynomial $\int p(x) dx$ as an approximation.

<p align="center">
  <img src="https://cdn-mineru.openxlab.org.cn/result/2025-08-19/d28de157-cffb-4586-85b2-10e6c17e5d20/c3b6cdace361a14eda4bbb8ba397e1992fb6a412f50ee410f0244cacd5910a80.jpg" alt="Approximate Integration Graph" style="width:30%;">
</p>

The interpolating polynomial $p(x) = 0.098796x + 0.762356x^2 + 2.14429x^3 - 2.00544x^4$ closely approximates $f(x)$ over $[0,1]$.

::: {.notes}
Many functions don't have simple antiderivatives, making their integrals hard to compute exactly. This is where approximate integration comes in. A powerful method involves using polynomial interpolation: first, you choose several points on the curve of your complex function. Then, you find an interpolating polynomial that passes through these points. Since polynomials are easy to integrate, you integrate the polynomial as an approximation for the original function's integral. The graph visually shows how closely an interpolating polynomial can match a more complex function over an interval, leading to accurate approximations valuable in fields like signal processing or control theory.
:::

---

## Leontief Input-Output Models

Developed by economist Wassily Leontief (Nobel Prize, 1973).
Analyzes interdependencies between sectors of an economy.

*   **Sectors:** Manufacturing, Agriculture, Utilities. Each produces outputs and requires inputs (from itself or other sectors).
*   **Consumption Matrix (C):** Entries $c_{ij}$ represent the dollar value of output from sector $i$ required by sector $j$ to produce one dollar's worth of output.
    *   Example: $C = \left[ \begin{array}{ccc}0.5 & 0.1 & 0.1\\ 0.2 & 0.5 & 0.3\\ 0.1 & 0.3 & 0.4 \end{array} \right]$
        *   (0.5, 0.2, 0.1) in first column means manufacturing needs \$0.50 of its own, \$0.20 agricultural, \$0.10 utilities to produce \$1.00 of manufacturing output.
*   **Outside Demand Vector ($\mathbf{d}$):** Demand from the "open sector" (e.g., consumers).
*   **Production Vector ($\mathbf{x}$):** Total output from each sector needed to satisfy internal consumption AND outside demand.

::: {.notes}
The Leontief Input-Output model provides a powerful framework for understanding how different sectors of an economy rely on each other. It's a macroscopic view, crucial for economic planning and understanding supply chains. The core idea is that to produce goods, industries need inputs, which themselves are outputs from other industries. The consumption matrix, C, quantifies these interdependencies. Each column of C represents the inputs needed by a sector to produce one dollar of its own output. The model aims to find the total production for each sector to meet both its internal consumption needs and external demands.
:::

---

## Leontief Equation

The total production $\mathbf{x}$ must cover:
1.  **Intermediate Demand ($C\mathbf{x}$):** What product-producing sectors consume from each other.
2.  **Outside Demand ($\mathbf{d}$):** What the open sector demands.

Thus: $\mathbf{x} = C\mathbf{x} + \mathbf{d}$

Rearranging this, we get the **Leontief Equation**:
$$
(I - C)\mathbf{x} = \mathbf{d}
$$
The matrix $(I - C)$ is called the **Leontief Matrix**.
If $(I-C)$ is invertible, the unique solution is $\mathbf{x} = (I - C)^{-1}\mathbf{d}$.

::: {.notes}
This simple equation is the heart of the Leontief model. It states that the total output (production) of each sector must be equal to what is consumed internally by other industries *plus* what is demanded by outside consumers. Rearranging this leads to the Leontief equation, $(I-C)\mathbf{x}=\mathbf{d}$. If the Leontief matrix $(I-C)$ is invertible, we can directly calculate the necessary production levels $\mathbf{x}$ for any given external demand $\mathbf{d}$. This is a classic example of linear systems solving a complex economic problem.
:::

---

## Example 1 (Leontief): Satisfying Outside Demand

Consider $C = \left[ \begin{array}{lll}0.5 & 0.1 & 0.1\\ 0.2 & 0.5 & 0.3\\ 0.1 & 0.3 & 0.4 \end{array} \right]$
Outside demand $\mathbf{d} = \left[ \begin{array}{l}7900\\ 3950\\ 1975 \end{array} \right]$ (Manufactured, Agricultural, Utilities)

We need to solve $(I - C)\mathbf{x} = \mathbf{d}$.
First, compute $I - C$:
$$
I - C = \left[ \begin{array}{lll}1 & 0 & 0\\ 0 & 1 & 0\\ 0 & 0 & 1 \end{array} \right] - \left[ \begin{array}{lll}0.5 & 0.1 & 0.1\\ 0.2 & 0.5 & 0.3\\ 0.1 & 0.3 & 0.4 \end{array} \right] = \left[ \begin{array}{rrr}0.5 & -0.1 & -0.1\\ -0.2 & 0.5 & -0.3\\ -0.1 & -0.3 & 0.6 \end{array} \right]
$$
Now, solve the system $\left[ \begin{array}{rrr}0.5 & -0.1 & -0.1\\ -0.2 & 0.5 & -0.3\\ -0.1 & -0.3 & 0.6 \end{array} \right]\left[ \begin{array}{c}x_{1}\\ x_{2}\\ x_{3} \end{array} \right] = \left[ \begin{array}{c}7900\\ 3950\\ 1975 \end{array} \right]$.

::: {.notes}
Let's apply the Leontief model to a specific scenario. We're given the consumption matrix $C$ and an external demand vector $\mathbf{d}$. The first step is to construct the Leontief matrix $(I-C)$. Then, we set up the linear system $(I-C)\mathbf{x}=\mathbf{d}$. Solving this system will directly give us the production vector $\mathbf{x}$, which tells us how much each sector needs to produce to satisfy both internal and external demands.
:::

---

## Example 1 (Leontief): Solving for $\mathbf{x}$

```{.pyodide}
#| max-lines: 10
import numpy as np

# Identity matrix
I = np.identity(3)

# Consumption matrix C
C = np.array([
    [0.5, 0.1, 0.1],
    [0.2, 0.5, 0.3],
    [0.1, 0.3, 0.4]
])

# Leontief matrix (I - C)
leontief_matrix = I - C

# Outside demand vector d
d = np.array([7900, 3950, 1975])

# Solve for the production vector x
try:
    x_production = np.linalg.solve(leontief_matrix, d)
    print("Leontief Matrix (I - C):\n", leontief_matrix)
    print("\nOutside Demand Vector (d):\n", d)
    print("\nProduction Vector (x):\n", x_production)
    print(f"\nTo meet demand, values must be:")
    print(f"Manufacturing: ${x_production[0]:.0f}")
    print(f"Agricultural: ${x_production[1]:.0f}")
    print(f"Utilities: ${x_production[2]:.0f}")

except np.linalg.LinAlgError:
    print("Error: Leontief matrix is singular, demand cannot be met uniquely.")
```

Solution: $\mathbf{x} = \left[ \begin{array}{l}27500\\ 33750\\ 24750 \end{array} \right]$

The economy can meet the demand by producing these amounts.

::: {.notes}
Using `numpy.linalg.solve`, we find the production vector $\mathbf{x}$. The result shows that the manufacturing sector needs to produce \$27,500, agriculture \$33,750, and utilities \$24,750. These are the gross output values needed to cover all intermediate consumption within the economy and to satisfy the specified external demand. This exact solution and the non-negative values indicate that the economy can indeed meet the demand.
:::

---

## Productive Open Economies

For $\mathbf{x}$ to be a valid production vector, its entries must be nonnegative.
An economy is **productive** if $(I-C)^{-1}$ exists and has nonnegative entries for every demand vector $\mathbf{d}$.

**THEOREM 1.10.1:** If $C$ is the consumption matrix for an open economy, and if **all of the column sums are less than 1**, then the matrix $I - C$ is invertible, the entries of $(I - C)^{-1}$ are nonnegative, and the economy is productive.

*   A sector is **profitable** if its column sum in $C$ is less than 1 (it needs less than \$1 of input to produce \$1 of output).
*   Thus, if all product-producing sectors are profitable, the economy is productive. (Or if all row sums are less than 1, also productive.)

::: {.notes}
A crucial aspect of Leontief models is whether an economy is "productive"—meaning it can actually meet any reasonable outside demand. This hinges on two conditions: the Leontief matrix $(I-C)$ must be invertible, and its inverse $(I-C)^{-1}$ must have all nonnegative entries (because you can't have negative production). Theorem 1.10.1 provides a simple test: if the sum of inputs required for each dollar of output (i.e., column sums of C) is less than \$1, then the economy is productive. This means each sector is profitable, in a gross sense, leading to stable economic conditions.
:::

---

## Example 2 (Leontief): Confirming Productive Economy

Recall $C = \left[ \begin{array}{lll}0.5 & 0.1 & 0.1\\ 0.2 & 0.5 & 0.3\\ 0.1 & 0.3 & 0.4 \end{array} \right]$
Column sums:

*   Mfg: $0.5 + 0.2 + 0.1 = 0.8 < 1$
*   Ag: $0.1 + 0.5 + 0.3 = 0.9 < 1$
*   Util: $0.1 + 0.3 + 0.4 = 0.8 < 1$

All column sums are less than 1, so by Theorem 1.10.1, the economy is productive!
$(I-C)^{-1}$ should exist and have nonnegative entries.

```{.pyodide}
#| max-lines: 10
import numpy as np

I = np.identity(3)
C = np.array([
    [0.5, 0.1, 0.1],
    [0.2, 0.5, 0.3],
    [0.1, 0.3, 0.4]
])
leontief_matrix = I - C

# Invert (I - C)
try:
    inv_leontief = np.linalg.inv(leontief_matrix)
    print("Inverse of Leontief Matrix (I - C)^-1:\n", inv_leontief)

    if np.all(inv_leontief >= 0):
        print("\nAll entries are nonnegative. Economy is productive.")
    else:
        print("\nSome entries are negative. Economy is not productive.")

    # Re-calculate x using the inverse
    d = np.array([7900, 3950, 1975])
    x_recalc = inv_leontief @ d
    print("\nProduction Vector (x) calculated via inverse:\n", x_recalc)

except np.linalg.LinAlgError:
    print("Error: Leontief matrix (I-C) is singular and cannot be inverted.")
```

The entries of $(I-C)^{-1}$ are indeed nonnegative, confirming the economy's productivity.
The production vector matches the previous calculation.

::: {.notes}
Let's confirm the theorem for our example. We calculate the column sums of the consumption matrix C. All are less than 1, so the theorem guarantees productivity. This means $(I-C)^{-1}$ should exist and have only non-negative entries. Using `numpy.linalg.inv`, we compute the inverse. As shown, all entries are positive, verifying the theorem. We can then use this inverse to quickly calculate the production vector for any demand, showing the strength of this model for economic planning. This integration of linear algebra into economics highlights its broad applicability beyond traditional engineering fields.
:::

---

## ECE Applications & Summary

**Key Areas for ECE where Linear Systems are Applied:**

*   **Network Analysis:**
    *   **Electrical Circuits:** Solving currents and voltages using Kirchhoff's Laws (KCL, KVL) – fundamental to circuit design & diagnostics.
    *   **Traffic Management:** Optimizing flow, designing road networks to prevent congestion.
    *   **Data Networks:** Analyzing data packet flow, optimizing routing.
*   **Signal & Image Processing:**
    *   **Polynomial Interpolation:** Reconstructing signals, approximating complex functions, noise reduction, image scaling.
    *   **Filter Design:** Many digital filters are based on linear relationships.
*   **Control Systems:**
    *   **System Identification:** Using input/output data to model a system as a set of linear equations.
    *   **State-Space Models:** Describing system dynamics as linear systems.
*   **Optimization:** Many engineering optimization problems are linear or can be linearized.

---

## ECE Applications & Summary

**Today We Covered:**

*   Systematic methods to solve real-world problems using linear systems.
*   **Network Analysis:** Flow conservation in general networks and specific electrical circuits (Ohm's, KCL, KVL).
*   **Balancing Chemical Equations:** Stoichiometry via homogeneous systems.
*   **Polynomial Interpolation:** Fitting curves to data points leading to unique solutions.
*   **Leontief Input-Output Models:** Economic interdependencies and production planning.

::: {.notes}
To summarize, what we've seen today is just a glimpse of the vast applicability of linear systems in ECE. From optimizing traffic in Philadelphia to designing complex electrical circuits, accurately balancing chemical reactions, interpolating data points for smooth functions, and even analyzing economic interdependencies, linear algebra provides the universal language and tools. The ability to formulate these real-world challenges as systems of linear equations and solve them is a critical skill for any aspiring engineer. Linear systems are truly the workhorses of quantitative analysis across virtually all engineering disciplines.
:::