<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.8.27">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>johnson_pcit_chapter_3 – Instrumentation</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="../../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../../site_libs/quarto-search/fuse.min.js"></script>
<script src="../../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../../">
<script src="../../site_libs/quarto-html/quarto.js" type="module"></script>
<script src="../../site_libs/quarto-html/tabsets/tabsets.js" type="module"></script>
<script src="../../site_libs/quarto-html/axe/axe-check.js" type="module"></script>
<script src="../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../site_libs/quarto-html/quarto-syntax-highlighting-ed96de9b727972fe78a7b5d16c58bf87.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../site_libs/bootstrap/bootstrap-e31584831b205ffbb2d98406f31c2a5b.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>

  <script src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN" && texText && texText.data) {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

<link rel="stylesheet" href="../../styles.css">
</head>

<body class="nav-fixed quarto-light">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a class="navbar-brand" href="../../index.html">
    <span class="navbar-title">Instrumentation</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" role="menu" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll me-auto">
  <li class="nav-item">
    <a class="nav-link" href="../../index.html"> 
<span class="menu-text">Home</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../about.html"> 
<span class="menu-text">About</span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
            <div class="quarto-navbar-tools">
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">On this page</h2>
   
  <ul>
  <li><a href="#digital-signal-conditioning" id="toc-digital-signal-conditioning" class="nav-link active" data-scroll-target="#digital-signal-conditioning">Digital Signal Conditioning</a></li>
  <li><a href="#instructional-objectives" id="toc-instructional-objectives" class="nav-link" data-scroll-target="#instructional-objectives">INSTRUCTIONAL OBJECTIVES</a></li>
  <li><a href="#introduction" id="toc-introduction" class="nav-link" data-scroll-target="#introduction">1 INTRODUCTION</a></li>
  <li><a href="#review-of-digital-fundamentals" id="toc-review-of-digital-fundamentals" class="nav-link" data-scroll-target="#review-of-digital-fundamentals">2 REVIEW OF DIGITAL FUNDAMENTALS</a></li>
  <li><a href="#digital-information" id="toc-digital-information" class="nav-link" data-scroll-target="#digital-information">2.1 Digital Information</a></li>
  <li><a href="#solution" id="toc-solution" class="nav-link" data-scroll-target="#solution">Solution</a></li>
  <li><a href="#solution-1" id="toc-solution-1" class="nav-link" data-scroll-target="#solution-1">Solution</a></li>
  <li><a href="#fractional-binary-numbers" id="toc-fractional-binary-numbers" class="nav-link" data-scroll-target="#fractional-binary-numbers">2.2 Fractional Binary Numbers</a></li>
  <li><a href="#boolean-algebra" id="toc-boolean-algebra" class="nav-link" data-scroll-target="#boolean-algebra">2.3 Boolean Algebra</a></li>
  <li><a href="#digital-electronics" id="toc-digital-electronics" class="nav-link" data-scroll-target="#digital-electronics">2.4 Digital Electronics</a></li>
  <li><a href="#example-5" id="toc-example-5" class="nav-link" data-scroll-target="#example-5">EXAMPLE 5</a></li>
  <li><a href="#solution-2" id="toc-solution-2" class="nav-link" data-scroll-target="#solution-2">Solution</a></li>
  <li><a href="#example-6" id="toc-example-6" class="nav-link" data-scroll-target="#example-6">EXAMPLE 6</a></li>
  <li><a href="#solution-3" id="toc-solution-3" class="nav-link" data-scroll-target="#solution-3">Solution</a></li>
  <li><a href="#programmable-logic-controllers" id="toc-programmable-logic-controllers" class="nav-link" data-scroll-target="#programmable-logic-controllers">2.5 Programmable Logic Controllers</a></li>
  <li><a href="#computer-interface" id="toc-computer-interface" class="nav-link" data-scroll-target="#computer-interface">2.6 Computer Interface</a></li>
  <li><a href="#converters" id="toc-converters" class="nav-link" data-scroll-target="#converters">3 CONVERTERS</a></li>
  <li><a href="#comparators" id="toc-comparators" class="nav-link" data-scroll-target="#comparators">3.1 Comparators</a></li>
  <li><a href="#example-7" id="toc-example-7" class="nav-link" data-scroll-target="#example-7">EXAMPLE 7</a></li>
  <li><a href="#solution-4" id="toc-solution-4" class="nav-link" data-scroll-target="#solution-4">Solution</a></li>
  <li><a href="#solution-5" id="toc-solution-5" class="nav-link" data-scroll-target="#solution-5">Solution</a></li>
  <li><a href="#digital-to-analog-converters-dacs" id="toc-digital-to-analog-converters-dacs" class="nav-link" data-scroll-target="#digital-to-analog-converters-dacs">3.2 Digital-to-Analog Converters (DACs)</a></li>
  <li><a href="#example-9" id="toc-example-9" class="nav-link" data-scroll-target="#example-9">EXAMPLE 9</a></li>
  <li><a href="#solution-6" id="toc-solution-6" class="nav-link" data-scroll-target="#solution-6">Solution</a></li>
  <li><a href="#example-10" id="toc-example-10" class="nav-link" data-scroll-target="#example-10">EXAMPLE 10</a></li>
  <li><a href="#solution-7" id="toc-solution-7" class="nav-link" data-scroll-target="#solution-7">Solution</a></li>
  <li><a href="#solution-8" id="toc-solution-8" class="nav-link" data-scroll-target="#solution-8">Solution</a></li>
  <li><a href="#example-12" id="toc-example-12" class="nav-link" data-scroll-target="#example-12">EXAMPLE 12</a></li>
  <li><a href="#solution-9" id="toc-solution-9" class="nav-link" data-scroll-target="#solution-9">Solution</a></li>
  <li><a href="#analog-to-digital-converters-adcs" id="toc-analog-to-digital-converters-adcs" class="nav-link" data-scroll-target="#analog-to-digital-converters-adcs">3.3 Analog-to-Digital Converters (ADCs)</a></li>
  <li><a href="#solution-10" id="toc-solution-10" class="nav-link" data-scroll-target="#solution-10">Solution</a></li>
  <li><a href="#example-14" id="toc-example-14" class="nav-link" data-scroll-target="#example-14">EXAMPLE 14</a></li>
  <li><a href="#solution-11" id="toc-solution-11" class="nav-link" data-scroll-target="#solution-11">Solution</a></li>
  <li><a href="#example-15" id="toc-example-15" class="nav-link" data-scroll-target="#example-15">EXAMPLE 15</a></li>
  <li><a href="#solution-12" id="toc-solution-12" class="nav-link" data-scroll-target="#solution-12">Solution</a></li>
  <li><a href="#example-17" id="toc-example-17" class="nav-link" data-scroll-target="#example-17">EXAMPLE 17</a></li>
  <li><a href="#solution-13" id="toc-solution-13" class="nav-link" data-scroll-target="#solution-13">Solution</a></li>
  <li><a href="#solution-14" id="toc-solution-14" class="nav-link" data-scroll-target="#solution-14">Solution</a></li>
  <li><a href="#solution-15" id="toc-solution-15" class="nav-link" data-scroll-target="#solution-15">Solution</a></li>
  <li><a href="#solution-16" id="toc-solution-16" class="nav-link" data-scroll-target="#solution-16">Solution</a></li>
  <li><a href="#solution-17" id="toc-solution-17" class="nav-link" data-scroll-target="#solution-17">Solution</a></li>
  <li><a href="#solution-18" id="toc-solution-18" class="nav-link" data-scroll-target="#solution-18">Solution</a></li>
  <li><a href="#frequency-based-converters" id="toc-frequency-based-converters" class="nav-link" data-scroll-target="#frequency-based-converters">3.4 Frequency-Based Converters</a></li>
  <li><a href="#example-23" id="toc-example-23" class="nav-link" data-scroll-target="#example-23">EXAMPLE 23</a></li>
  <li><a href="#solution-19" id="toc-solution-19" class="nav-link" data-scroll-target="#solution-19">Solution</a></li>
  <li><a href="#example-24" id="toc-example-24" class="nav-link" data-scroll-target="#example-24">EXAMPLE 24</a></li>
  <li><a href="#solution-20" id="toc-solution-20" class="nav-link" data-scroll-target="#solution-20">Solution</a></li>
  <li><a href="#data-acquisition-systems" id="toc-data-acquisition-systems" class="nav-link" data-scroll-target="#data-acquisition-systems">4 DATA-ACQUISITION SYSTEMS</a></li>
  <li><a href="#das-hardware" id="toc-das-hardware" class="nav-link" data-scroll-target="#das-hardware">4.1 DAS Hardware</a></li>
  <li><a href="#das-software" id="toc-das-software" class="nav-link" data-scroll-target="#das-software">4.2 DAS Software</a></li>
  <li><a href="#example-25" id="toc-example-25" class="nav-link" data-scroll-target="#example-25">EXAMPLE 25</a></li>
  <li><a href="#solution-21" id="toc-solution-21" class="nav-link" data-scroll-target="#solution-21">Solution</a></li>
  <li><a href="#characteristics-of-digital-data" id="toc-characteristics-of-digital-data" class="nav-link" data-scroll-target="#characteristics-of-digital-data">5 CHARACTERISTICS OF DIGITAL DATA</a></li>
  <li><a href="#digitized-value" id="toc-digitized-value" class="nav-link" data-scroll-target="#digitized-value">5.1 Digitized Value</a></li>
  <li><a href="#example-26" id="toc-example-26" class="nav-link" data-scroll-target="#example-26">EXAMPLE 26</a></li>
  <li><a href="#solution-22" id="toc-solution-22" class="nav-link" data-scroll-target="#solution-22">Solution</a></li>
  <li><a href="#sampled-data-systems" id="toc-sampled-data-systems" class="nav-link" data-scroll-target="#sampled-data-systems">5.2 Sampled Data Systems</a></li>
  <li><a href="#example-27" id="toc-example-27" class="nav-link" data-scroll-target="#example-27">EXAMPLE 27</a></li>
  <li><a href="#solution-23" id="toc-solution-23" class="nav-link" data-scroll-target="#solution-23">Solution</a></li>
  <li><a href="#example-28" id="toc-example-28" class="nav-link" data-scroll-target="#example-28">EXAMPLE 28</a></li>
  <li><a href="#solution-24" id="toc-solution-24" class="nav-link" data-scroll-target="#solution-24">Solution</a></li>
  <li><a href="#linearization" id="toc-linearization" class="nav-link" data-scroll-target="#linearization">5.3 Linearization</a></li>
  <li><a href="#solution-25" id="toc-solution-25" class="nav-link" data-scroll-target="#solution-25">Solution</a></li>
  <li><a href="#summary" id="toc-summary" class="nav-link" data-scroll-target="#summary">SUMMARY</a></li>
  <li><a href="#problems" id="toc-problems" class="nav-link" data-scroll-target="#problems">PROBLEMS</a></li>
  <li><a href="#section-2" id="toc-section-2" class="nav-link" data-scroll-target="#section-2">Section 2</a></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content" id="quarto-document-content"><header id="title-block-header" class="quarto-title-block"></header>




<section id="digital-signal-conditioning" class="level2">
<h2 class="anchored" data-anchor-id="digital-signal-conditioning">Digital Signal Conditioning</h2>
</section>
<section id="instructional-objectives" class="level2">
<h2 class="anchored" data-anchor-id="instructional-objectives">INSTRUCTIONAL OBJECTIVES</h2>
<p>In this chapter the basic principles of digital signal processing will be studied. This includes digital-to-analog converters (DAC) and analog-to-digital converters (ADC), as well as the characteristics of digital data. After reading this chapter and working through the examples and problems at the end of the chapter you will be able to:</p>
<ul>
<li>Develop Boolean equations for multivariable alarms.</li>
<li>Design an application using a comparator with hysteresis.</li>
<li>Calculate the expected output of a biopolar DAC for a given input.</li>
<li>Explain how a successive approximation ADC operates.</li>
<li>Describe how a sample-and-hold circuit operates.</li>
<li>Explain the operation of a frequency-based ADC.</li>
<li>Describe the consequence of sampling rate on data acquisition.</li>
</ul>
</section>
<section id="introduction" class="level2">
<h2 class="anchored" data-anchor-id="introduction">1 INTRODUCTION</h2>
<p>Why digital signal conditioning? And what is digital signal conditioning, anyway?</p>
<p>The answer to the first question is found in the recognition that digital electronics and digital computers have taken a major role in nearly every aspect of life in our modern world. Of course digital electronics is at the heart of computers, but there are lots of direct applications of digital electronics in our world. Everyday things like automatic door openers in stores, motion sensors in security systems, and seat-belt warning systems are implemented with digital electronics. All these digital electronic systems require data to be presented to them in a digital format (i.e., the data have to be digitally conditioned).</p>
<p>When most people think of a computer, they visualize the common home and office personal computer, or PC. In fact, however, one of the most common applications of computers is for controlling something, and we seldom ever even see the computer. When we learn that our microwave oven has a microprocessor-based computer inside, it is there for the purpose of controlling the operation of the oven. So it is with the use of computers in automobiles, washing machines, airplanes, and a vast host of other examples.</p>
<p>Computers are digital electronic devices and so all the information they work with has to be digitally formatted. Therefore, if they are used to control a variable such as temperature, then the temperature has to be represented digitally. So that’s why we need digital signal conditioning—to condition process-control signals to be in an appropriate digital format.</p>
<p>The second question is the topic of this chapter. Digital signal conditioning in process control means finding a way to represent analog process information in a digital format. We will review some common digital electronics principles and then study how analog signals are converted into a digital format.</p>
<p>You should realize that there is no greater accuracy in using digital techniques to represent data; in fact, accuracy is usually lost. But digital data are much more immune from spurious influences that would cause subsequent inaccuracy, such as noise, amplifier gain changes, power supply drifts, and so on.</p>
<p>Use of computers in control systems is particularly valuable for a number of other reasons, however:</p>
<ol type="1">
<li>A computer can control multivariable process-control systems.</li>
<li>Nonlinearities in sensor output can be linearized by the computer.</li>
<li>Complicated control equations can be solved quickly and modified as needed.</li>
<li>Networking of control computers allows a large process-control complex to operate in a fully integrated fashion.</li>
</ol>
</section>
<section id="review-of-digital-fundamentals" class="level2">
<h2 class="anchored" data-anchor-id="review-of-digital-fundamentals">2 REVIEW OF DIGITAL FUNDAMENTALS</h2>
<p>A working understanding of the application of digital techniques to process control requires a foundation in basic digital electronics. The design and implementation of control logic systems and microcomputer control systems require a depth of understanding that can be obtained only by taking several courses devoted to the subject. In this text, we assume a sufficient background that the reader can appreciate the essential features of digital electronic design and its application to process control.</p>
</section>
<section id="digital-information" class="level2">
<h2 class="anchored" data-anchor-id="digital-information">2.1 Digital Information</h2>
<p>The use of digital techniques in process control requires that process variable measurements and control information be encoded into a digital form. Digital signals themselves are simply two-state (binary) levels. These levels may be represented in many ways (e.g.,</p>
<p>two voltages, two currents, two frequencies, or two phases). We speak, then, of the digital information as a high state (H, or 1) or a low state (L, or 0) on a wire that carries the digital signal.</p>
<p>Digital Words Given the simple binary information that is carried by a single digital signal, it is clear that multiple signals must be used to describe analog information. Generally, this is done by using an assemblage of digital levels to construct a binary number, often called a word. The individual digital levels are referred to as bits of the word. Thus, for example, a 6-bit word consists of six independent digital levels, such as <span class="math inline">\(101011_{2}\)</span> , which can be thought of as a six-digit base 2 number. An important consideration, then, is how the analog information is encoded into this digital word.</p>
<p>Decimal Whole Numbers One of the most common schemes for encoding analog data into a digital word is to use the straight counting of decimal (or base 10) and binary number representations. The principles of this process are reviewed in Appendix: Digital Review, together with octal and hexadecimal representations.</p>
<p>EXAMPLE Find the base 10 equivalent of the binary whole number <span class="math inline">\(\mathbf{00100111}_{2}\)</span> .</p>
<p>1</p>
</section>
<section id="solution" class="level2">
<h2 class="anchored" data-anchor-id="solution">Solution</h2>
<p>As in the base 10 system, zeros preceding the first significant digit do not contribute. Thus, the binary number is actually <span class="math inline">\(\mathbf{100111}_2\)</span> , and <span class="math inline">\(n = 5\)</span> . To find the decimal equivalent, we use Appendix: Digital Review and compute as follows:</p>
<p><span class="math display">\[
N _ {1 0} = a _ {5} 2 ^ {5} + a _ {4} 2 ^ {4} + \dots + a _ {1} 2 ^ {1} + a _ {0} 2 ^ {0}
\]</span></p>
<p><span class="math display">\[
N _ {1 0} = (1) 2 ^ {5} + (0) 2 ^ {4} + (0) 2 ^ {3} + (1) 2 ^ {2} + (1) 2 ^ {1} + (1) 2 ^ {0} \tag {A.2}
\]</span></p>
<p><span class="math display">\[
N _ {1 0} = 3 2 + 4 + 2 + 1
\]</span></p>
<p><span class="math display">\[
N _ {1 0} = 3 9
\]</span></p>
<p>EXAMPLE Find the binary equivalent of the base 10 number 47.</p>
<p>2</p>
</section>
<section id="solution-1" class="level2">
<h2 class="anchored" data-anchor-id="solution-1">Solution</h2>
<p>Starting the successive division, we get</p>
<p><span class="math display">\[
\frac {4 7}{2} = 2 3 \text {w i t h a r e m a i n d e r o f} \frac {1}{2} \text {s o t h a t} a _ {0} = 1
\]</span></p>
<p>then</p>
<p><span class="math display">\[
\frac {2 3}{2} = 1 1 \text {w i t h a r e m a i n d e r o f} \frac {1}{2} \text {s o t h a t} a _ {1} = 1
\]</span></p>
<p>then</p>
<p><span class="math display">\[
\frac {1 1}{2} = 5 + \frac {1}{2} \therefore a _ {2} = 1
\]</span></p>
<p><span class="math display">\[
\frac {5}{2} = 2 + \frac {1}{2} \therefore a _ {3} = 1
\]</span></p>
<p><span class="math display">\[
\frac {2}{2} = 1 + 0 \quad \therefore a _ {4} = 0
\]</span></p>
<p><span class="math display">\[
\frac {1}{2} = 0 + \frac {1}{2} \quad \therefore a _ {5} = 1
\]</span></p>
<p>We find that base 10 number 47 becomes binary number <span class="math inline">\(\mathbf{101111}_{2}\)</span> .</p>
<p>The representation of negative numbers in binary format takes on several forms.</p>
<p>Octal and Hex Numbers It is cumbersome for humans to work with digital words expressed as numbers in the binary representation. For this reason, it has become common to use either the octal (base 8) or hexadecimal (base 16, called hex) representations. Octal numbers are conveniently formed from groupings of three binary digits; that is, <span class="math inline">\(\mathbf{000}_2\)</span> is <span class="math inline">\(0_8\)</span> and <span class="math inline">\(111_2\)</span> is <span class="math inline">\(7_8\)</span> . Thus, a binary number like <span class="math inline">\(101011_2\)</span> is equivalent to <span class="math inline">\(53_8\)</span> . Hex numbers are formed easily from groupings of four binary digits; that is, <span class="math inline">\(\mathbf{0000}_2\)</span> is <span class="math inline">\(0\mathrm{H}\)</span> and <span class="math inline">\(1111_2\)</span> is <span class="math inline">\(\mathrm{FH}\)</span> . The letter <span class="math inline">\(\mathrm{H}\)</span> (or <span class="math inline">\(\mathrm{h}\)</span> ) is used to designate a hex number instead of a subscript <span class="math inline">\(16\)</span> . Also recall that the hex counting sequence is <span class="math inline">\(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, \mathrm{A}, \mathrm{B}, \mathrm{C}, \mathrm{D}, \mathrm{E},\)</span> and <span class="math inline">\(\mathrm{F}\)</span> to cover the possible states. Because micro-computers must frequently use either 4-bit, 8-bit, or 16-bit words, the hex notation is commonly used with these machines. In hex, a binary number like <span class="math inline">\(10110110_2\)</span> would be written <span class="math inline">\(\mathrm{B6H}\)</span> .</p>
</section>
<section id="fractional-binary-numbers" class="level2">
<h2 class="anchored" data-anchor-id="fractional-binary-numbers">2.2 Fractional Binary Numbers</h2>
<p>Although not as commonly used, it is possible to define a fractional binary number in the same manner as whole numbers, using only the 1 and 0 of this counting system. Such numbers, just as in the decimal framework, represent divisions of the counting system to values less than unity.</p>
<p><span class="math display">\[
N _ {1 0} = b _ {1} 2 ^ {- 1} + b _ {2} 2 ^ {- 2} + \dots + b _ {m} 2 ^ {- m} \tag {1}
\]</span></p>
<p>where <span class="math inline">\(N_{10} =\)</span> base 10 number less than 1</p>
<p><span class="math inline">\(b_{1}b_{2}\ldots b_{m - 1}b_{m} = \mathrm{base~2~number~less~than~1}\)</span></p>
<p><span class="math inline">\(m =\)</span> number of digits in base 2 number</p>
<p>EXAMPLE Find the base 10 equivalent of the binary number <span class="math inline">\(\mathbf{0.11010}_{2}\)</span> .</p>
<p>3</p>
<p>Solution</p>
<p>This can be found most easily by using</p>
<p><span class="math display">\[
N _ {1 0} = b _ {1} 2 ^ {- 1} + b _ {2} 2 ^ {- 2} + \dots + b _ {m} 2 ^ {- m} \tag {1}
\]</span></p>
<p>with</p>
<p><span class="math display">\[
m = 5
\]</span></p>
<p><span class="math display">\[
N _ {1 0} = (1) 2 ^ {- 1} + (1) 2 ^ {- 2} + (0) 2 ^ {- 3} + (1) 2 ^ {- 4} + (0) 2 ^ {- 5}
\]</span></p>
<p><span class="math display">\[
N _ {1 0} = \frac {1}{2} + \frac {1}{4} + \frac {1}{1 6}
\]</span></p>
<p><span class="math display">\[
N _ {1 0} = 0. 8 1 2 5 _ {1 0}
\]</span></p>
<p>Converting a base 10 number that is less than 1 to a binary equivalent requires repeated multiplication by 2. The result of each multiplication is a fractional part and either a 0 or 1 whole-number part, which determines whether that digit is a 0 or a 1. The first multiplication gives the most significant bit, <span class="math inline">\(b_{1}\)</span> , and the last gives either a 0 or a 1 for the least significant bit, <span class="math inline">\(b_{m}\)</span> .</p>
<p>EXAMPLE Find the binary, octal, and hex equivalents of <span class="math inline">\(0.3125_{10}\)</span> .</p>
<p>4</p>
<p>Solution</p>
<p>Using successive multiplication, we find</p>
<p><span class="math display">\[
2 (0. 3 1 2 5) = 0. 6 2 5 0 \quad \text {s o} b _ {1} = 0
\]</span></p>
<p><span class="math display">\[
2 (0. 6 2 5) = 1. 2 5 0 \quad \text {s o} b _ {2} = 1
\]</span></p>
<p><span class="math display">\[
2 (0. 2 5) = 0. 5 \quad \text {s o} b _ {3} = 0
\]</span></p>
<p><span class="math display">\[
2 (0. 5) = 1. 0 \quad \text {s o} b _ {4} = 1
\]</span></p>
<p>Thus, we find that <span class="math inline">\(0.3125_{10}\)</span> is equivalent to <span class="math inline">\(\mathbf{0.0101}_{2}\)</span> . It can be represented as <span class="math inline">\(\mathbf{0.010100}_{2}\)</span> , because trailing zeros are not significant in a number less than 1, and thus as 0.24 octal, because <span class="math inline">\(\mathbf{010}_{2} = 2_{8}\)</span> and <span class="math inline">\(\mathbf{100}_{2} = 4_{8}\)</span> . Similarly, this is <span class="math inline">\(0.50\mathrm{H}\)</span> .</p>
</section>
<section id="boolean-algebra" class="level2">
<h2 class="anchored" data-anchor-id="boolean-algebra">2.3 Boolean Algebra</h2>
<p>In process control, as well as in many other technical disciplines, action is taken on the basis of an evaluation of observations made in the environment. In driving an automobile, for example, we are constantly observing such external factors as traffic, lights, speed limits, pedestrians, street conditions, low-flying aircraft, and such internal factors as how fast we wish to go, where we are going, and many others. We evaluate these factors and take actions predicated on the evaluations. We may see that a light is green, streets are dry, speed</p>
<p>is low, there are no pedestrians or aircraft, we are late, and thus conclude that an action of pressing on the accelerator is required. Then we may observe a parked police radar unit with all other factors the same, negate the aforementioned conclusion, and apply the brake. Many of these parameters can be represented by a true or not true observation; in fact, with enough definition, all the observations could be reduced to simple true or false conditions. When we learn to drive, we are actually setting up internal responses to a set of such true/false observations in the environment.</p>
<p>In the industrial world, an analogous condition exists relative to the external and internal influences on a manufacturing process, and when we control a process, we are in effect teaching a control system response to a set of true/false observations. This teaching may consist of designing electronic circuits that can logically evaluate the set of true/false conditions and initiate some appropriate action. To design such an electronic system, we must first be able to mathematically express the inputs, the logical evaluation, and the corresponding outputs. Boolean algebra is a mathematical procedure that allows the combinations of true/false conditions in various logical operations by equations so that conclusions can be drawn. We do not require expertise in Boolean technique, but only an operational familiarity with it that can be applied to a process-control environment.</p>
<p>Before a particular problem in industry can be addressed using digital electronics, it must be analyzed in terms that are amenable to the binary nature of digital techniques. Generally, this is accomplished by stating the problem in the form of a set of true/false-type conditions that must be applied to derive some desired result. These sets of conditions are then stated in the form of one or more Boolean equations. We will see in Section 2.4 that a Boolean equation is in a form that is readily implemented with existing digital circuits. The mathematical approach of Boolean algebra allows us to write an analytical expression to represent these stipulations.</p>
<p>Let us consider a simple example of how a Boolean equation may result from a practical problem. Consider a mixing tank for which there are three variables of interest: liquid level, pressure, and temperature. The problem is that we must signal an alarm when certain combinations of conditions occur among these variables. Referring to Figure 1, we denote level by <span class="math inline">\(A\)</span> , pressure by <span class="math inline">\(B\)</span> , and temperature by <span class="math inline">\(C\)</span> , and assume that setpoint values have been assigned for each variable so that the Boolean variables are either 1 or 0 as the physical quantities are above or below the setpoint values. The alarm will be triggered when the Boolean variable <span class="math inline">\(D\)</span> goes to the logic true state. The alarm conditions are</p>
<ol type="1">
<li>Low level with high pressure</li>
<li>High level with high temperature</li>
<li>High level with low temperature and high pressure</li>
</ol>
<p>We now define a Boolean expression with AND operations that will give a <span class="math inline">\(D = 1\)</span> for each condition:</p>
<ol type="1">
<li><span class="math inline">\(D = \overline{A} \cdot B\)</span> will give <span class="math inline">\(D = 1\)</span> for condition 1.</li>
<li><span class="math inline">\(D = A\cdot C\)</span> will give <span class="math inline">\(D = 1\)</span> for condition 2.</li>
<li><span class="math inline">\(D = A\cdot \overline{C}\cdot B\)</span> will give <span class="math inline">\(D = 1\)</span> for condition 3.</li>
</ol>
<p><img src="Books/Johnson_PCIT/chapter_3/268c1da519ea02d987e6652db413d65c_MD5.jpg" class="img-fluid"></p>
<p>FIGURE 1 System for illustrating Boolean applications to control.</p>
<p>The final logic equation results from combining all three conditions so that if any is true, the alarm will sound <span class="math inline">\((D = 1)\)</span> . This is accomplished with the OR operation</p>
<p><span class="math display">\[
D = \bar {A} \cdot B + A \cdot C + A \cdot \bar {C} \cdot B \tag {2}
\]</span></p>
<p>This equation would now form the starting point for a design of electronic digital circuitry that would perform the indicated operations.</p>
</section>
<section id="digital-electronics" class="level2">
<h2 class="anchored" data-anchor-id="digital-electronics">2.4 Digital Electronics</h2>
<p>The electronic building blocks of digital electronics are designed to operate on the binary levels present on digital signal lines. These building blocks are based on families of types of electronic circuits that have their specific stipulations of power supplies and voltage levels of the 1 and 0 states. The basic structure involves the use of AND/OR logic and NAND/NOR logic to implement Boolean equations.</p>
</section>
<section id="example-5" class="level2">
<h2 class="anchored" data-anchor-id="example-5">EXAMPLE 5</h2>
<p>Develop a digital circuit using AND/OR gates that implements Equation (2).</p>
</section>
<section id="solution-2" class="level2">
<h2 class="anchored" data-anchor-id="solution-2">Solution</h2>
<p>The problem posed in Section 2.3 (with Figure 1) has a Boolean equation solution of</p>
<p><span class="math display">\[
D = \bar {A} \cdot B + A \cdot C + A \cdot \bar {C} \cdot B \tag {2}
\]</span></p>
<p><img src="Books/Johnson_PCIT/chapter_3/cef47cf9122e0ee8fd3222b68ca898a7_MD5.jpg" class="img-fluid"></p>
<p>FIGURE 2 Solution for Example 5.</p>
<p>The implementation of this equation using AND/OR gates is shown in Figure 2. The AND, OR, and inverter are used in a straightforward implementation of the equation. It should be noted that Equation (2) can be greatly reduced by someone skilled in the art of digital logic to: <span class="math inline">\(D = A \cdot C + B\)</span> . The reader can show that this can be implemented by one AND gate and one OR gate!</p>
</section>
<section id="example-6" class="level2">
<h2 class="anchored" data-anchor-id="example-6">EXAMPLE 6</h2>
<p>Repeat Example 5 using NAND/NOR gates.</p>
</section>
<section id="solution-3" class="level2">
<h2 class="anchored" data-anchor-id="solution-3">Solution</h2>
<p>One way to implement the equation in NAND/NOR would be to provide inverters after every gate, in effect, to convert the devices back to AND/OR gates. In this case, the circuit developed would look like Figure 2 but with an inverter after every gate. A second approach is to use the Boolean theorems to reformulate the equation for better implementation using NAND/NOR logic. For example, if we are to get the desired equation for <span class="math inline">\(D\)</span> as output from a NAND gate, the inputs must have been</p>
<p><span class="math display">\[
\overline {{\overline {{A}} \cdot B}} + \overline {{A \cdot C}}
\]</span></p>
<p>and</p>
<p><span class="math display">\[
\overline {{A \cdot B \cdot \overline {{C}}}}
\]</span></p>
<p>because NAND between these produces</p>
<p><span class="math display">\[
\overline {{(\bar {A} \cdot B + A \cdot C)}} \cdot (\bar {A} \cdot B \cdot \bar {C})
\]</span></p>
<p>which, by DeMorgan’s theorem, becomes</p>
<p><span class="math display">\[
\bar {A} \cdot B + A \cdot C + A \cdot B \cdot \bar {C}
\]</span></p>
<p>that is, the desired output. Working backward from this result allows the circuit to be realized, as shown in Figure 3. However, using the simplified version given in Example 5, we can use DeMorgan’s theorem to write</p>
<p><span class="math display">\[
D = A \cdot C + B = \overline {{(A \cdot C)}} \cdot \overline {{B}}
\]</span></p>
<p>The reader can now show that this can be provided by two NAND gates and one inverter.</p>
<p><img src="Books/Johnson_PCIT/chapter_3/b17b91d3e142f05c3a385d23187362da_MD5.jpg" class="img-fluid"></p>
<p>FIGURE 3 Solution for Example 6.</p>
</section>
<section id="programmable-logic-controllers" class="level2">
<h2 class="anchored" data-anchor-id="programmable-logic-controllers">2.5 Programmable Logic Controllers</h2>
<p>The move toward digital logic techniques and computers in industrial control paralleled the development of special controllers called programmable logic controllers (PLCs), or simply programmable controllers (PCs). These devices are particularly suited to the solution control problems associated with Boolean equations and binary logic problems in general. They are a computer-based outgrowth of relay sequence controllers.</p>
</section>
<section id="computer-interface" class="level2">
<h2 class="anchored" data-anchor-id="computer-interface">2.6 Computer Interface</h2>
<p>Figure 4 shows a simple model of a computer system. The processor is connected to external equipment via three parallel sets of digital lines. The data lines carry data to and from the processor. The address lines allow the computer to select external locations for input and output. The control lines carry information to and from the computer related to operations, such as reading, writing, interrupts, and so on. This collection of lines is called the bus of the computer.</p>
<p><img src="Books/Johnson_PCIT/chapter_3/4362158b354327d4ac4d0b6245ee5e0a_MD5.jpg" class="img-fluid"></p>
<p>FIGURE 4 Generic model of a computer bus system.</p>
<p>The term interface refers to the hardware connections and software operations necessary to input and output data using connections to the bus. All of the equipment connected to the computer must share the bus lines.</p>
<p>It is an important consideration for interface hardware that a bus line not be compromised by some external connection. This means that the external equipment must not hold a bus line in a logic state when that equipment is not using the bus. If a data line is held at 0 by some equipment even when it is not performing data transfer, then no other equipment could raise that line to the 1 state during its data transfer operations. This problem is prevented by the use of tri-state buffers.</p>
<p>Tri-State Buffers Isolation of a bus line is accomplished by making all connections via a special digital device called a tri-state buffer. This device acts like a simple switch. When the switch is closed, the logic level on its input is impressed upon the output. When open, the output is placed in a high-impedance state—that is, an open circuit.</p>
<p>Figure 5 shows how two digital signals can both be connected to a single data line through tri-state buffers. Normally, both tri-states are disabled—that is, in the high-impedance state. When the computer needs to input signal <span class="math inline">\(A\)</span> , an enable signal, <span class="math inline">\(E_{1}\)</span> , is sent to tri-state 1 so that the state of <span class="math inline">\(A\)</span> is placed on the data line. After the computer reads the line, tri-state 1 is disabled again. Similarly, when the computer needs the state of signal <span class="math inline">\(B\)</span> , an enable, <span class="math inline">\(E_{2}\)</span> , is sent to tri-state 2 to place <span class="math inline">\(B\)</span> on the line.</p>
<p><img src="Books/Johnson_PCIT/chapter_3/e1378b1b86b4331a1ef4566054b0b73e_MD5.jpg" class="img-fluid"></p>
<p>FIGURE 5 Tri-state buffers allow multiple signals to share a single digital line in the bus.</p>
</section>
<section id="converters" class="level2">
<h2 class="anchored" data-anchor-id="converters">3 CONVERTERS</h2>
<p>The most important digital tool for the process-control technologist is one that translates digital information to analog and vice versa. Most measurements of process variables are performed by devices that translate information about the variable to an analog electrical signal. To interface this signal with a computer or digital logic circuit, it is necessary first to perform an analog-to-digital (A/D) conversion. The specifics of this conversion must be well known so that a unique, known relationship exists between the analog and digital signals. Often, the reverse situation occurs, where a digital signal is required to drive an analog device. In this case, a digital-to-analog (D/A) converter is required.</p>
</section>
<section id="comparators" class="level2">
<h2 class="anchored" data-anchor-id="comparators">3.1 Comparators</h2>
<p>The most elementary form of communication between the analog and digital is a device (usually an IC) called a comparator. This device, which is shown schematically in Figure 6, simply compares two analog voltages on its input terminals. Depending on which voltage is larger, the output will be a 1 (high) or a 0 (low) digital signal. The comparator is extensively used for alarm signals to computers or digital processing systems. This element is also an integral part of the analog-to-digital and digital-to-analog converter, to be discussed in Section 3.2.</p>
<p>One of the voltages on the comparator inputs, <span class="math inline">\(V_{a}\)</span> or <span class="math inline">\(V_{b}\)</span> in Figure 6, will be the variable input, and the other a fixed value called a trip, trigger, or reference voltage. The reference value is computed from the specifications of the problem and then applied to the appropriate comparator input terminal, as illustrated in Example 7. The reference voltage may be provided from a divider using available power supplies.</p>
<p>FIGURE 6 A basic comparator compares voltages and produces a digital output.</p>
<p><img src="Books/Johnson_PCIT/chapter_3/48861a2b1d79888aef10d0a124268c92_MD5.jpg" class="img-fluid"></p>
<p><img src="Books/Johnson_PCIT/chapter_3/965b2dcbf1182c81feec0d81b3d196cc_MD5.jpg" class="img-fluid"></p>
<p>FIGURE 7 Diagram of a solution to Example 7.</p>
</section>
<section id="example-7" class="level2">
<h2 class="anchored" data-anchor-id="example-7">EXAMPLE 7</h2>
<p>A process-control system specifies that temperature should never exceed <span class="math inline">\(160^{\circ}\mathrm{C}\)</span> if the pressure also exceeds <span class="math inline">\(10\mathrm{kPa}\)</span> . Design an alarm system to detect this condition, using temperature and pressure transducers with transfer functions of <span class="math inline">\(2.2\mathrm{mV} / {}^{\circ}\mathrm{C}\)</span> and <span class="math inline">\(0.2\mathrm{V} / \mathrm{kPa}\)</span> , respectively.</p>
</section>
<section id="solution-4" class="level2">
<h2 class="anchored" data-anchor-id="solution-4">Solution</h2>
<p>The alarm conditions will be a temperature signal of <span class="math inline">\((2.2\mathrm{mV} / {}^{\circ}\mathrm{C})\)</span> <span class="math inline">\((160^{\circ}\mathrm{C}) = 0.352\mathrm{V}\)</span> coincident with a pressure signal of <span class="math inline">\((0.2\mathrm{V} / \mathrm{kPa})\)</span> <span class="math inline">\((10\mathrm{kPa}) = 2\mathrm{V}\)</span> . The circuit in Figure 7 shows how this alarm can be implemented with comparators and one AND gate. The reference voltages could be provided from dividers.</p>
<p>Open-Collector Comparators Some comparator models have a special method of providing the digital output signal. Figure 8a shows that the output terminal of the comparator is connected internally to the collector of a transistor in the comparator and nowhere else! This is called an open-collector output because it is just that. Of course, even if there is base-emitter current in the transistor, no voltage will show up on the collector until it is connected to a supply through some collector resistor. In fact, this is exactly what is done in an application. Figure 8b shows that an external resistor is connected from the output to an appropriate power supply. This is called a collector pull-up resistor. Now the output terminal will show either a <span class="math inline">\(\mathbf{0}(0\mathrm{V})\)</span> if the internal transistor is ON or <span class="math inline">\(\mathbf{1}(V_s)\)</span> if the internal transistor is OFF.</p>
<p>There are a number of advantages to using the open-collector output:</p>
<ol type="1">
<li>It is possible to use a different power source for the output. For example, suppose you want to activate a <span class="math inline">\(+12\mathrm{-V}\)</span> relay with the output of a comparator that operates on <span class="math inline">\(+5\mathrm{V}\)</span> . By using an open-collector model, you can connect the pull-up resistor to a <span class="math inline">\(+12\mathrm{-V}\)</span> supply and power the relay directly from the output.</li>
<li>It is possible to OR together several comparators’ outputs by connecting all open-collector outputs together and then using a common pull-up resistor. If any one of the comparator’s output transistors is turned ON, the common output will go low.</li>
</ol>
<p>FIGURE 8 Many comparators use an open-collector output.</p>
<p><img src="Books/Johnson_PCIT/chapter_3/dd963c303d14fdbdaf9845f26f1be04b_MD5.jpg" class="img-fluid"></p>
<ol type="a">
<li></li>
</ol>
<p><img src="Books/Johnson_PCIT/chapter_3/8c30d36e21ae0175b0041d82117af92d_MD5.jpg" class="img-fluid"></p>
<ol start="2" type="a">
<li></li>
</ol>
<p>Hysteresis Comparator When using comparators, there is often a problem if the signal voltage has noise or approaches the reference value too slowly. The comparator output may “jiggle” back and forth between high and low as the reference level is reached. This effect is shown in Figure 9. Such fluctuation of output may cause problems with the equipment designed to interpret the comparator output signal.</p>
<p><img src="Books/Johnson_PCIT/chapter_3/a81ca534683dc70393b9386d04424cbb_MD5.jpg" class="img-fluid"></p>
<p><img src="Books/Johnson_PCIT/chapter_3/401866b14e516bcc7c6fed0b0e66e64e_MD5.jpg" class="img-fluid"></p>
<p>FIGURE 9 A comparator output will “jiggle” when a noisy signal passes through the reference voltage level.</p>
<p><img src="Books/Johnson_PCIT/chapter_3/35b571c3c9d1e8affa248086561b38b5_MD5.jpg" class="img-fluid"></p>
<ol type="a">
<li>Hysteresis comparator circuit</li>
</ol>
<p><img src="Books/Johnson_PCIT/chapter_3/d8b20bc393fae827104939569298f8bc_MD5.jpg" class="img-fluid"></p>
<p><span class="math display">\[
V _ {L} = V _ {\text {r e f}} - \frac {R}{R _ {f}} V _ {0} \quad V _ {H} = V _ {\text {r e f}}
\]</span></p>
<ol start="2" type="a">
<li>Hysteresis comparator input-output relationship and equations</li>
</ol>
<p>FIGURE 10 A generic DAC diagram, showing typical input and output signals.</p>
<p>This problem can often be solved by providing a deadband or hysteresis window to the reference level around which output changes occur. Once the comparator has been triggered high, the reference level is automatically reduced so that the signal must fall to some value below the old reference before the comparator goes to the low state.</p>
<p>There are many ways this hysteresis can be provided, but Figure 10 a shows one common technique. Feedback resistor <span class="math inline">\(R_{f}\)</span> is provided between the output and one of the inputs of the comparator, and that input is separated from the signal by another resistor, <span class="math inline">\(R\)</span> . Under the condition that <span class="math inline">\(R_{f} \gg R\)</span> , the response of the comparator is shown in Figure 10b.</p>
<p>The condition for which the output will go high <span class="math inline">\((V_0)\)</span> is defined by the condition</p>
<p><span class="math display">\[
V _ {\mathrm {i n}} \geq V _ {\mathrm {r e f}} \tag {3}
\]</span></p>
<p>Once having been driven high, the condition for the output to drop back to the low (0 V) state is given by the relation</p>
<p><span class="math display">\[
V _ {\text {i n}} \leq V _ {\text {r e f}} - (R / R _ {f}) V _ {0} \tag {4}
\]</span></p>
<p>The deadband or hysteresis is given by <span class="math inline">\((R / R_{f})V_{0}\)</span> , and is thus selectable by choice of the resistors, as long as this relation is satisfied. The response of this comparator is shown by the graph in Figure 10b. The arrows indicate increasing or decreasing input voltage.</p>
<p>A sensor converts the liquid level in a tank to voltage according to the transfer function <span class="math inline">\((20\mathrm{mV / cm})\)</span> . A comparator is supposed to go high (5 V) whenever the level becomes <span class="math inline">\(50~\mathrm{cm}\)</span> . Splashing causes the level to fluctuate by <span class="math inline">\(\pm 3\mathrm{cm}\)</span> . Develop a hysteresis comparator to protect against the effects of splashing.</p>
</section>
<section id="solution-5" class="level2">
<h2 class="anchored" data-anchor-id="solution-5">Solution</h2>
<p>The nominal reference for the comparator occurs at <span class="math inline">\(50~\mathrm{cm}\)</span> , which is <span class="math inline">\(V_{\mathrm{ref}} = (20\mathrm{mV / cm})(50\mathrm{cm}) = 1\mathrm{V}\)</span> . The splashing, however, causes a “noise” of <span class="math inline">\((20\mathrm{mV / cm}) \cdot (\pm 3\mathrm{cm}) = \pm 60\mathrm{mV}\)</span> . This is a total range of <span class="math inline">\(120\mathrm{mV}\)</span> . We need a deadband of at least <span class="math inline">\(120\mathrm{mV}\)</span> , but let us make it <span class="math inline">\(150\mathrm{mV}\)</span> for security. Thus, we have</p>
<p><span class="math display">\[
\begin{array}{l} (R / R _ {f}) (5 \mathrm {V}) = 1 5 0 \mathrm {m V} \\ (R / R _ {f}) = 0. 0 3 \\ \end{array}
\]</span></p>
<p>If we make <span class="math inline">\(R_{f} = 100\mathrm{k}\Omega\)</span> , then <span class="math inline">\(R = 3\mathrm{k}\Omega\)</span> . Thus, use of these resistors, as shown in Figure 10, with a reference of <span class="math inline">\(1\mathrm{V}\)</span> will meet the requirement.</p>
</section>
<section id="digital-to-analog-converters-dacs" class="level2">
<h2 class="anchored" data-anchor-id="digital-to-analog-converters-dacs">3.2 Digital-to-Analog Converters (DACs)</h2>
<p>A DAC accepts digital information and transforms it into an analog voltage. The digital information is in the form of a binary number with some fixed number of digits. Especially when used in connection with a computer, this binary number is called a binary word or computer word. The digits are called bits of the word. Thus, an 8-bit word would be a binary number having eight digits, such as <span class="math inline">\(10110110_{2}\)</span> . A unipolar DAC converts a digital word into an analog voltage by scaling the analog output to be zero when all bits are zero and some maximum value when all bits are one. This can be mathematically represented by treating the binary number that the word represents as a fractional number. In this context, the output of the DAC can be defined using Equation (1) as a scaling of some reference voltage:</p>
<p><span class="math display">\[
V _ {\text {o u t}} = V _ {R} \left[ b _ {1} 2 ^ {- 1} + b _ {2} 2 ^ {- 2} + \dots + b _ {n} 2 ^ {- n} \right] \tag {5}
\]</span></p>
<p>where <span class="math inline">\(V_{\mathrm{out}} = \mathrm{analog}\)</span> voltage output</p>
<p><span class="math display">\[
V _ {R} = \text {r e f e r e n c e v o l t a g e}
\]</span></p>
<p><span class="math display">\[
b _ {1} b _ {2} \dots b _ {n} = n \text {- b i t b i n a r y w o r d}
\]</span></p>
<p>The minimum <span class="math inline">\(V_{\mathrm{out}}\)</span> is zero, and the maximum is determined by the size of the binary word because, with all bits set to one, the decimal equivalent approaches <span class="math inline">\(V_{R}\)</span> as the number of bits increases. Thus, a 4-bit word has a maximum of</p>
<p><span class="math display">\[
V _ {\max } = V _ {R} \left[ 2 ^ {- 1} + 2 ^ {- 2} + 2 ^ {- 3} + 2 ^ {- 4} \right] = 0. 9 3 7 5 V _ {R}
\]</span></p>
<p>and an 8-bit word has a maximum of</p>
<p><span class="math display">\[
V _ {\max } = V _ {R} \left[ 2 ^ {- 1} + 2 ^ {- 2} + 2 ^ {- 3} + 2 ^ {- 4} + 2 ^ {- 5} + 2 ^ {- 6} + 2 ^ {- 7} + 2 ^ {- 8} \right] = 0. 9 9 6 1 V _ {R}
\]</span></p>
<p>An alternative equation to Equation (5) is often easier to use. This is based on noting that the expression in brackets in Equation (5) is really just the fraction of total counting states possible with the <span class="math inline">\(n\)</span> bits being used. With this recognition, we can write</p>
<p><span class="math display">\[
V _ {\text {o u t}} = \frac {N}{2 ^ {n}} V _ {R} \tag {6}
\]</span></p>
<p>where <span class="math inline">\(N =\)</span> base 10 whole-number equivalent of DAC input</p>
<p>Suppose an 8-bit converter with a <span class="math inline">\(5.0\mathrm{-V}\)</span> reference has an input of <span class="math inline">\(\mathbf{10100111}_2\)</span> or A7H. If this input is converted to base 10, we get <span class="math inline">\(N = 167_{10}\)</span> and <span class="math inline">\(2^{8} = 256\)</span> . From Equation (6), the output of the ADC will be</p>
<p><span class="math display">\[
V _ {\text {o u t}} = \frac {1 6 7}{2 5 6} 5. 0 = 3. 2 6 1 7 \text {v o l t s}
\]</span></p>
</section>
<section id="example-9" class="level2">
<h2 class="anchored" data-anchor-id="example-9">EXAMPLE 9</h2>
<p>What is the output voltage of a 10-bit DAC with a 10.0-V reference if the input is (a) <span class="math inline">\(\mathbf{0010110101}_{2} = 0\mathrm{B5H}\)</span> , (b) <span class="math inline">\(20\mathrm{FH}\)</span> ? What input is needed to get a 6.5-V output?</p>
</section>
<section id="solution-6" class="level2">
<h2 class="anchored" data-anchor-id="solution-6">Solution</h2>
<p>Let’s use Equation (5) for part (a) and Equation (6) for part (b). Thus, for the 0B5H input, we have</p>
<p><span class="math display">\[
V _ {\text {o u t}} = 1 0. 0 \left[ 2 ^ {- 3} + 2 ^ {- 5} + 2 ^ {- 6} + 2 ^ {- 8} + 2 ^ {- 1 0} \right]
\]</span></p>
<p><span class="math display">\[
V _ {\text {o u t}} = 1 0. 0 [ 0. 1 7 6 7 5 7 8 ]
\]</span></p>
<p><span class="math display">\[
V _ {\text {o u t}} = 1. 7 6 7 5 7 8 \mathrm {V}
\]</span></p>
<p>For (b), we have <span class="math inline">\(20\mathrm{FH} = 527_{10}\)</span> and <span class="math inline">\(2^{10} = 1024\)</span> , so</p>
<p><span class="math display">\[
V _ {\text {o u t}} = (5 2 7 / 1 0 2 4) 1 0. 0
\]</span></p>
<p><span class="math display">\[
V _ {\text {o u t}} = (0. 5 1 4 6 4 8) 1 0. 0
\]</span></p>
<p><span class="math display">\[
V _ {\text {o u t}} = 5. 1 4 6 4 8 \mathrm {V}
\]</span></p>
<p>We can use Equation (6) to determine the input needed to get a 6.5-V output by solving for <span class="math inline">\(N\)</span> ,</p>
<p><span class="math display">\[
N = 2 ^ {n} \left(V _ {\text {o u t}} / V _ {R}\right)
\]</span></p>
<p><span class="math display">\[
N = 1 0 2 4 (6. 5 / 1 0)
\]</span></p>
<p><span class="math display">\[
N = 6 6 5. 6
\]</span></p>
<p>The fact that there is a fractional remainder tells us that we cannot get exactly <span class="math inline">\(6.5\mathrm{V}\)</span> from the converter. The best we can do is get an output for <span class="math inline">\(N = 665 = 299\mathrm{H}\)</span> or <span class="math inline">\(666 = 29\mathrm{AH}\)</span> . The outputs for these two inputs are <span class="math inline">\(6.494\mathrm{V}\)</span> and <span class="math inline">\(6.504\mathrm{V}\)</span> , respectively. The only way to get exactly <span class="math inline">\(6.5\mathrm{V}\)</span> of output would be to change the value of the reference slightly.</p>
<p>Bipolar DAC Some DACs are designed to output a voltage that ranges from plus to minus some maximum when the input binary ranges over the counting states. Although computers frequently use 2s complement to represent negative numbers, this is not common with DACs. Instead, a simple offset-binary is frequently used, wherein the output is simply biased by half the reference voltage of Equation (6). The bipolar DAC relationship is then given by</p>
<p><span class="math display">\[
V _ {\text {o u t}} = \frac {N}{2 ^ {n}} V _ {R} - \frac {1}{2} V _ {R} \tag {7}
\]</span></p>
<p>Notice that if <span class="math inline">\(N = 0\)</span> , the output voltage will be given by the minimum value, <span class="math inline">\(V_{\mathrm{out}}(\mathrm{min}) = -V_R / 2\)</span> . However, the maximum value for <span class="math inline">\(N\)</span> is equal to <span class="math inline">\((2^n - 1)\)</span> , so that the maximum value of output voltage will be</p>
<p><span class="math display">\[
V _ {\text {o u t}} (\max ) = \frac {(2 ^ {n} - 1)}{2 ^ {n}} V _ {R} - \frac {1}{2} V _ {R} = \frac {1}{2} V _ {R} - \frac {V _ {R}}{2 ^ {n}}
\]</span></p>
</section>
<section id="example-10" class="level2">
<h2 class="anchored" data-anchor-id="example-10">EXAMPLE 10</h2>
<p>A bipolar DAC has 10 bits and a reference of <span class="math inline">\(5\mathrm{V}\)</span> . What outputs will result from inputs of 04FH and 2A4H? What digital input gives a zero output voltage?</p>
</section>
<section id="solution-7" class="level2">
<h2 class="anchored" data-anchor-id="solution-7">Solution</h2>
<p>The inputs of 04FH and 2A4H can easily be converted to base 10 numbers <span class="math inline">\(79_{10}\)</span> and <span class="math inline">\(676_{10}\)</span> . Then, from Equation (7), we find</p>
<p><span class="math display">\[
V _ {\text {o u t}} = \frac {7 9}{1 0 2 4} (5) - \frac {(5)}{2} = - 2. 1 1 4 2 5 7 8 \mathrm {V}
\]</span></p>
<p><span class="math display">\[
V _ {\text {o u t}} = \frac {6 7 6}{1 0 2 4} (5) - \frac {(5)}{2} = 0. 8 0 0 7 8 \mathrm {V}
\]</span></p>
<p>The zero occurs when Equation (7) equals zero. Solving for <span class="math inline">\(N\)</span> gives</p>
<p><span class="math display">\[
0 = \frac {N}{1 0 2 4} (5) - \frac {(5)}{2}
\]</span></p>
<p>or <span class="math inline">\(N = 512_{10} = 200\mathrm{H} = \mathbf{1000000000}_{2}\)</span></p>
<p>Conversion Resolution The conversion resolution is a function of the reference voltage and the number of bits in the word. The more bits, the smaller the change in analog output for a 1-bit change in binary word, and hence the better the resolution. The smallest possible change is simply given by</p>
<p><span class="math display">\[
\Delta V _ {\text {o u t}} = V _ {R} 2 ^ {- n} \tag {8}
\]</span></p>
<p>where <span class="math inline">\(\Delta V_{\mathrm{out}} =\)</span> smallest output change</p>
<p><span class="math display">\[
V _ {R} = \text {r e f e r e n c e v o l t a g e}
\]</span></p>
<p><span class="math inline">\(n =\)</span> number of bits in the word</p>
<p>Thus, a 5-bit word D/A converter with a <span class="math inline">\(10\mathrm{-V}\)</span> reference will provide changes of <span class="math inline">\(\Delta V_{\mathrm{out}} = (10)(2^{-5}) = 0.3125\mathrm{V}\)</span> per bit.</p>
<p>EXAMPLE Determine how many bits a D/A converter must have to provide output increments of 11 0.04 V or less. The reference is <span class="math inline">\(10\mathrm{V}\)</span></p>
</section>
<section id="solution-8" class="level2">
<h2 class="anchored" data-anchor-id="solution-8">Solution</h2>
<p>One way to find the solution is to continually try word sizes until the resolution falls below <span class="math inline">\(0.04\mathrm{V}\)</span> per bit. A more analytical procedure is to use Equation (8):</p>
<p><span class="math display">\[
\Delta V = 0. 0 4 = (1 0) \left(2 ^ {- y}\right)
\]</span></p>
<p>Any <span class="math inline">\(n\)</span> larger than the integer part of the exponent of two in this equation will satisfy the requirement. Taking logarithms</p>
<p><span class="math display">\[
\log (0. 0 4) = \log [ (1 0) (2 ^ {- y}) ]
\]</span></p>
<p><span class="math display">\[
\log (0. 0 4) = \log (1 0) - y \log 2
\]</span></p>
<p><span class="math display">\[
y = \frac {\log (1 0) - \log (0 . 0 4)}{\log 2}
\]</span></p>
<p><span class="math display">\[
y = 7. 9 6 6
\]</span></p>
<p><img src="Books/Johnson_PCIT/chapter_3/f2758152bd65b03b55515dd9e8aac1ec_MD5.jpg" class="img-fluid"></p>
<p>FIGURE 11 A generic DAC diagram, showing typical input and output signals.</p>
<p>Thus, a <span class="math inline">\(n = 8\)</span> will be satisfactory. This can be proved by Equation (8):</p>
<p><span class="math display">\[
\begin{array}{l} \Delta V _ {\text {o u t}} = (1 0) (2 ^ {- 8}) \\ \Delta V _ {\text {o u t}} = 0. 0 3 9 0 6 2 5 \mathrm {V} \\ \end{array}
\]</span></p>
<p>DAC Characteristics For modern applications, most DACs are integrated circuit (IC) assemblies, viewed as a black box having certain input and output characteristics. In Figure 11, we see the essential elements of the DAC in terms of required input and output. The associated characteristics can be summarized as follows by referring to this figure:</p>
<ol type="1">
<li>Digital input Typically, digital input is a parallel binary word composed of a number of bits specified by the device specification sheet. TTL logic levels are usually required, unless otherwise noted.</li>
<li>Power supply The power supply is bipolar at a level of <span class="math inline">\(\pm 12\)</span> to <span class="math inline">\(\pm 18\mathrm{V}\)</span> as required for internal amplifiers. Some DACs operate from a single supply.</li>
<li>Reference supply A reference supply is required to establish the range of output voltage and resolution of the converter. This must be a stable, low-ripple source. In some units, an internal reference is provided.</li>
<li>Output The output is a voltage representing the digital input. This voltage changes in steps as the digital input changes by bits, with the step determined by Equation (8). The actual output may be bipolar if the converter is designed to interpret negative digital inputs.</li>
<li>Offset Because the DAC is usually implemented with op amps, there may be the typical output offset voltage with a zero input. Typically, connections will be provided to facilitate a zeroing of the DAC output with a zero word input.</li>
<li>Data latch Many DACs have a data latch built into their inputs. When a logic command is given to latch data, whatever data are on the input bus will be latched into the DAC, and the analog output will be updated for that input data. The output will stay at that value until new digital data are latched into the input. In this way, the input of the DAC can be connected directly onto the data bus of a computer, but it will be updated only when a latch command is given by the computer.</li>
<li>Conversion time A DAC performs the conversion of digital input to analog output virtually instantaneously. From the moment that the digital signal is placed on the inputs to the presence of the analog output voltage is simply the propagation time of the signal through internal amplifiers. Typically, settling time of the internal amplifiers will be a few microseconds.</li>
</ol>
<p>DAC Structure Generally speaking, a DAC is used as a black box, and no knowledge of the internal workings is required. There is some value, however, in briefly showing how such conversion can be implemented. The simplest conversion uses a series of op amps for input for which the gains have been selected to provide an output as given by Equation (5). The most common variety, however, uses a resistive ladder network to provide the transfer function. This is shown in Figure 12 for the case of a 4-bit converter. With the <span class="math inline">\(R - 2R\)</span> choice of resistors, it can be shown through network analysis that the output voltage is given by Equations (5) or (6). The switches are analog electronic switches.</p>
</section>
<section id="example-12" class="level2">
<h2 class="anchored" data-anchor-id="example-12">EXAMPLE 12</h2>
<p>A control valve has a linear variation of opening as the input voltage varies from 0 to <span class="math inline">\(10\mathrm{V}\)</span> . A microcomputer outputs an 8-bit word to control the valve opening using an 8-bit DAC to generate the valve voltage.</p>
<ol type="a">
<li><p>Find the reference voltage required to obtain a full open valve <span class="math inline">\((10\mathrm{V})\)</span></p></li>
<li><p>Find the percentage of valve opening for a 1-bit change in the input word.</p></li>
</ol>
</section>
<section id="solution-9" class="level2">
<h2 class="anchored" data-anchor-id="solution-9">Solution</h2>
<p><img src="Books/Johnson_PCIT/chapter_3/fc7e112f35e9eccbf5ceb0a7ab2a586f_MD5.jpg" class="img-fluid"></p>
<p>FIGURE 12 A typical DAC is often implemented using a ladder network of resistors.</p>
<ol type="a">
<li>The full open-valve condition occurs with a 10-V input. If a 10-V reference is used, a full digital word <span class="math inline">\(\mathbf{1111111}_{2}\)</span> will not quite give <span class="math inline">\(10\mathrm{V}\)</span> , so we use a larger reference. Thus, we have</li>
</ol>
<p><span class="math display">\[
V _ {\text {o u t}} = V _ {R} \left(b _ {1} 2 ^ {- 1} + b _ {2} 2 ^ {- 2} + \dots + b _ {8} 2 ^ {- 8}\right)
\]</span></p>
<p><span class="math display">\[
1 0 = V _ {R} \left(\frac {1}{2} + \frac {1}{4} + \dots + \frac {1}{2 5 6}\right)
\]</span></p>
<p><span class="math display">\[
V _ {R} = \frac {1 0}{0 . 9 9 6 1} = 1 0. 0 3 9 \mathrm {V}
\]</span></p>
<ol start="2" type="a">
<li>The percentage of valve change per step is found first from</li>
</ol>
<p><span class="math display">\[
\Delta V _ {\text {o u t}} = V _ {R} 2 ^ {- 8}
\]</span></p>
<p><span class="math display">\[
\Delta V _ {\text {o u t}} = (1 0. 0 3 9) \frac {1}{2 5 6}
\]</span></p>
<p><span class="math display">\[
\Delta V _ {\text {o u t}} = 0. 0 3 9 2 \mathrm {V}
\]</span></p>
<p>Thus,</p>
<p><span class="math display">\[
\mathrm{percent} = \frac{(0.0392)(100)}{10} = 0.392 \%
\]</span></p>
<p>Data Output Boards It is now common and convenient to obtain a printed circuit board that plugs into a personal computer expansion slot and is a complete data output system. The board has all necessary DACs, address decoding, and bus interface. In most cases, the supplier of the board also provides elementary software—often written in C, BASIC, or assembly language—as necessary to use the board for data output.</p>
</section>
<section id="analog-to-digital-converters-adcs" class="level2">
<h2 class="anchored" data-anchor-id="analog-to-digital-converters-adcs">3.3 Analog-to-Digital Converters (ADCs)</h2>
<p>Although there are sensors that provide a direct digital signal output and more are being developed, most still convert the measured variable into an analog electrical signal. With the growing use of digital logic and computers in process control, it is necessary to employ an ADC to provide a digitally encoded signal for the computer. The transfer function of the ADC can be expressed in a similar way to that of the DAC as given in Equation (5). In this case, however, the interpretation is reversed. The ADC will find a fractional binary number that gives the closest approximation to the fraction formed by the input voltage and reference.</p>
<p><span class="math display">\[
b _ {1} 2 ^ {- 1} + b _ {2} 2 ^ {- 2} + \dots + b _ {n} 2 ^ {- n} \leq \frac {V _ {\text {i n}}}{V _ {R}} \tag {9}
\]</span></p>
<p>where <span class="math inline">\(b_{1}b_{2}\ldots b_{n} = n\)</span> -bit digital output</p>
<p><span class="math display">\[
V _ {\text {i n}} = \text {a n a l o g i n p u t v o l t a g e}
\]</span></p>
<p><span class="math display">\[
V _ {R} = \text {a n a l o g r e f e r e n c e v o l t a g e}
\]</span></p>
<p>We use an inequality in this equation because the fraction on the right can change continuously over all values, but the fraction derived from the binary number on the left can change only in fixed increments of <span class="math inline">\(\Delta N = 2^{-n}\)</span> . In other words, the only way the left side can change is if the LSB changes from 1 to 0 or from 0 to 1. In either case, the fraction changes by only <span class="math inline">\(2^{-n}\)</span> and nothing in between. Therefore, there is an inherent uncertainty in the input voltage producing a given ADC output, and that uncertainty is given by</p>
<p><span class="math display">\[
\Delta V = V _ {R} 2 ^ {- n} \tag {10}
\]</span></p>
<p>Minimum and Maximum Voltages Equation (9) shows that if the ratio of input voltage to reference is less than <span class="math inline">\(\Delta V\)</span> , then the digital output will be all 0s, (i.e., <span class="math inline">\(\mathbf{0000}\ldots \mathbf{000}_2\)</span> ). The LSB will not change until the input voltage becomes at least equal to <span class="math inline">\(\Delta V\)</span> , and then the output will be <span class="math inline">\(\mathbf{0000}\ldots \mathbf{001}_2\)</span> . Therefore, if the ADC output is all zeros, you know only that <span class="math inline">\(V_{\mathrm{in}}\)</span> is less than <span class="math inline">\(V_{R}2^{-n}\)</span> , so it could even be a negative voltage, for example.</p>
<p>Now notice that the MSB changes from <span class="math inline">\(\mathbf{0}\)</span> to <span class="math inline">\(\mathbf{1}\)</span> when the input voltage becomes equal to or greater than <span class="math inline">\(V_{R} - \Delta V\)</span> . Therefore, if the ADC output is all 1s (i.e., 1111… 1111) then you know only that <span class="math inline">\(V_{\mathrm{in}}\)</span> is greater than <span class="math inline">\(V_{R}(1 - 2^{-n})\)</span> .</p>
<p>This uncertainty must be taken into account in design applications. If the problem under consideration specifies a certain resolution in analog voltage, then the word size and reference must be selected to provide this in the converted digital number.</p>
<p>EXAMPLE 13</p>
<p>Temperature is measured by a sensor with an output of <span class="math inline">\(0.02\mathrm{V} / {}^{\circ}\mathrm{C}\)</span> . Determine the required ADC reference and word size to measure <span class="math inline">\(0^{\circ}\)</span> to <span class="math inline">\(100^{\circ}\mathrm{C}\)</span> with <span class="math inline">\(0.1^{\circ}\mathrm{C}\)</span> resolution.</p>
</section>
<section id="solution-10" class="level2">
<h2 class="anchored" data-anchor-id="solution-10">Solution</h2>
<p>At the maximum temperature of <span class="math inline">\(100^{\circ}\mathrm{C}\)</span> , the voltage output is</p>
<p><span class="math display">\[
(0. 0 2 \mathrm {V} / ^ {\circ} \mathrm {C}) (1 0 0 ^ {\circ} \mathrm {C}) = 2 \mathrm {V}
\]</span></p>
<p>so a 2-V reference is used.</p>
<p>A change of <span class="math inline">\(0.1^{\circ}\mathrm{C}\)</span> results in a voltage change of</p>
<p><span class="math display">\[
\left(0. 1 ^ {\circ} \mathrm {C}\right) \left(0. 0 2 \mathrm {V} / ^ {\circ} \mathrm {C}\right) = 2 \mathrm {m V}
\]</span></p>
<p>so we need a word size where</p>
<p><span class="math display">\[
0. 0 0 2 \mathrm {V} = (2) (2 ^ {- y})
\]</span></p>
<p>Choose a size <span class="math inline">\(n\)</span> that is the integer part of <span class="math inline">\(y\)</span> plus 1. Thus, solving with logarithms, we find</p>
<p><span class="math display">\[
y = \frac {\log (2) - \log (0 . 0 0 2)}{\log 2}
\]</span></p>
<p><span class="math display">\[
y = 9. 9 9 6 \approx 1 0
\]</span></p>
<p>so a 10-bit word is required for this resolution. A 10-bit word has a resolution of</p>
<p><span class="math display">\[
V = (2) \left(2 ^ {- 1 0}\right)
\]</span></p>
<p><span class="math display">\[
V = 0. 0 0 1 9 5 \mathrm {V}
\]</span></p>
<p>which is better than the minimum required resolution of <span class="math inline">\(2\mathrm{mV}\)</span> .</p>
<p>Notice that the output actually changes from <span class="math inline">\(111111110_{2}\)</span> to <span class="math inline">\(1111111111_{2}\)</span> at a voltage of</p>
<p><span class="math display">\[
V _ {R} (1 - 2 ^ {- n}) = (2 \mathrm {V}) (1 - 2 ^ {- 1 0}) = 1. 9 9 8 0 \mathrm {V}
\]</span></p>
<p>which corresponds to a temperature of <span class="math inline">\((1.9980\mathrm{V}) / (0.02\mathrm{V} / {}^{\circ}\mathrm{C}) = 99.90^{\circ}\mathrm{C}\)</span> . This means we are actually measuring temperature between <span class="math inline">\(0.1^{\circ}\mathrm{C}\)</span> and <span class="math inline">\(99.9^{\circ}\mathrm{C}\)</span> .</p>
</section>
<section id="example-14" class="level2">
<h2 class="anchored" data-anchor-id="example-14">EXAMPLE 14</h2>
<p>Find the digital word that results from a 3.127-V input to a 5-bit ADC with a 5-V reference.</p>
</section>
<section id="solution-11" class="level2">
<h2 class="anchored" data-anchor-id="solution-11">Solution</h2>
<p>The relationship between input and output is given by Equation (9). Thus, we are to encode a fractional number of <span class="math inline">\(V_{\mathrm{in}} / V_R\)</span> , or</p>
<p><span class="math display">\[
b _ {1} 2 ^ {- 1} + b _ {2} 2 ^ {- 2} + \dots + b _ {5} 2 ^ {- 5} = \frac {3 . 1 2 7}{5} = 0. 6 2 5 4
\]</span></p>
<p>Using the method of successive multiplication defined in Section 2.2, we find</p>
<p><span class="math display">\[
0. 6 2 5 4 (2) = 1. 2 5 0 8 \quad \therefore b _ {1} = 1
\]</span></p>
<p><span class="math display">\[
0. 2 5 0 8 (2) = 0. 5 0 1 6 \quad \therefore b _ {2} = 0
\]</span></p>
<p><span class="math display">\[
0. 5 0 1 6 (2) = 1. 0 0 3 2 \quad \therefore b _ {3} = 1
\]</span></p>
<p><span class="math display">\[
0. 0 0 3 2 (2) = 0. 0 0 6 4 \quad \therefore b _ {4} = 0
\]</span></p>
<p><span class="math display">\[
0. 0 0 6 4 (2) = 0. 0 1 2 8 \quad \therefore b _ {5} = 0
\]</span></p>
<p>so that the output is <span class="math inline">\(\mathbf{10100}_2\)</span></p>
<p>Equation (9) can be written in a simpler fashion by expressing the fractional binary number as the fraction of counting states, as was done for the DAC. In this case, the base 10 value of the digital output can be expressed as</p>
<p><span class="math display">\[
N = \operatorname {I N T} \left(\frac {V _ {\text {i n}}}{V _ {R}} 2 ^ {n}\right) \tag {11}
\]</span></p>
<p>where <span class="math inline">\(\mathrm{INT}()\)</span> means to take the integer part of the quantity in brackets. This is not a roundoff, but rather a truncation, so that <span class="math inline">\(\mathrm{INT}(3.3) = 3\)</span> and <span class="math inline">\(\mathrm{INT}(3.99) = 3\)</span> also. The value of <span class="math inline">\(N\)</span> is then converted to hex and/or binary to demonstrate the ADC output. In the previous example, we would have</p>
<p><span class="math display">\[
N = \operatorname {I N T} \left(\frac {3 . 1 2 7}{5} 2 ^ {5}\right) = \operatorname {I N T} (2 0. 0 1 2 8) = 2 0 _ {1 0}
\]</span></p>
<p>or <span class="math inline">\(14\mathrm{H} = \mathbf{10100}_{2}\)</span> , as already found.</p>
</section>
<section id="example-15" class="level2">
<h2 class="anchored" data-anchor-id="example-15">EXAMPLE 15</h2>
<p>The input to a 10-bit ADC with a 2.500-V reference is <span class="math inline">\(1.45\mathrm{V}\)</span> . What is the hex output? Suppose the output was found to be 1B4H. What is the voltage input?</p>
</section>
<section id="solution-12" class="level2">
<h2 class="anchored" data-anchor-id="solution-12">Solution</h2>
<p>We will use Equation (11) to find the solution to these questions. For the first part, we can form the expression</p>
<p><span class="math display">\[
\begin{array}{l} N = \operatorname {I N T} ((1. 4 5 / 2. 5) 2 ^ {1 0}) \\ N = \operatorname {I N T} (5 9 3. 9 2) \\ N = 5 9 3 \\ N = 2 5 1 \mathrm {H} \\ \end{array}
\]</span></p>
<p>So the output of the ADC is 251H for a 1.45-V input. To get the voltage input for a 1B4H-output, we solve Equation (11) for the voltage:</p>
<p><span class="math display">\[
V _ {\text {i n}} = \frac {N}{2 ^ {n}} V _ {R}
\]</span></p>
<p>A conversion yields <span class="math inline">\(1\mathrm{B4H} = 436_{10}\)</span> .</p>
<p><span class="math display">\[
\begin{array}{l} V _ {\text {i n}} = (4 3 6 / 1 0 2 4) 2. 5 0 \\ V _ {\mathrm {i n}} = 1. 0 6 4 4 5 \mathrm {V} \\ \end{array}
\]</span></p>
<p>However, it is important to realize that any voltage from this to <span class="math inline">\(1.06445 + 2.5 / 1024 = 1.06689\)</span> will give the same output, 1B4H. So the correct answer to the question is that the input voltage lies in the range 1.06445 to 1.06689 V.</p>
<p>Bipolar Operation A bipolar ADC is one that accepts bipolar input voltage for conversion into an appropriate digital output. The most common bipolar ADCs provide an output called offset-binary. This simply means that the normal output is shifted by half the</p>
<p>scale so that all-zeros corresponds to the negative maximum input voltage instead of zero. In equation form, the relation would be written as</p>
<p><span class="math display">\[
N = \operatorname {I N T} \left[ \left(\frac {V _ {\text {i n}}}{V _ {R}} + \frac {1}{2}\right) 2 ^ {n} \right] \tag {12}
\]</span></p>
<p>From this equation, you can see that if <span class="math inline">\(V_{\mathrm{in}} = -V_R / 2\)</span> , the output is zero, <span class="math inline">\(N = 0\)</span> . If <span class="math inline">\(V_{\mathrm{in}} = 0\)</span> , the output is half of <span class="math inline">\(2^n\)</span> . The output will be the maximum count when the input is <span class="math inline">\(V_R / 2 - V_R 2^n\)</span> . For example, for 8 bits with a 10.0-V reference, the step size is <span class="math inline">\(\Delta V_{\mathrm{in}} = (10) 2^8 \approx 0.039 \, \mathrm{V}\)</span> . Looking at the possible states, we would have</p>
<p><span class="math display">\[
V _ {\mathrm {i n}} = - 5. 0 0 0 \quad N = \mathbf {0 0 0 0 0 0 0 0} _ {2}
\]</span></p>
<p><span class="math display">\[
V _ {\text {i n}} = - 4. 9 6 1 \quad N = \mathbf {0 0 0 0 0 0 0 1} _ {2}
\]</span></p>
<p><span class="math display">\[
\mathrm {e t c .}
\]</span></p>
<p><span class="math display">\[
V _ {\text {i n}} = - 0. 0 3 9 \quad N = \mathbf {0 1 1 1 1 1 1} _ {2}
\]</span></p>
<p><span class="math display">\[
V _ {\mathrm {i n}} = 0. 0 0 0 \quad N = \mathbf {1 0 0 0 0 0 0 0} _ {2}
\]</span></p>
<p><span class="math display">\[
V _ {\text {i n}} = + 0. 0 3 9 \quad N = \mathbf {1 0 0 0 0 0 0 1} _ {2}
\]</span></p>
<p><span class="math display">\[
\mathrm {e t c .}
\]</span></p>
<p><span class="math display">\[
V _ {\text {i n}} = + 4. 9 6 1 \quad N = \mathbf {1 1 1 1 1 1 1} _ {2}
\]</span></p>
<p>There is an asymmetry to the result so that the converter cannot represent the full range from minus to plus <span class="math inline">\(V_{R} / 2\)</span> .</p>
<p>EXAMPLE What are the hex and binary output of a bipolar 8-bit ADC with a <span class="math inline">\(5.00\mathrm{-V}\)</span> reference for inputs of <span class="math inline">\(-0.85\mathrm{V}\)</span> and <span class="math inline">\(+1.5\mathrm{V}\)</span> ? What input voltage would cause an output of <span class="math inline">\(72\mathrm{H}\)</span> ?</p>
<p>Solution</p>
<p>Using Equation (12), we get</p>
<p><span class="math display">\[
N = \operatorname {I N T} ((1 / 5. 0 0) [ - 0. 8 5 + 2. 5 0 ] ^ {2 ^ {8}})
\]</span></p>
<p><span class="math display">\[
N = \operatorname {I N T} (8 4. 4 8)
\]</span></p>
<p><span class="math display">\[
N = 8 4 _ {1 0}
\]</span></p>
<p><span class="math display">\[
N = 5 4 \mathrm {H} = \mathbf {0 1 0 1 0 1 0 0} _ {2}
\]</span></p>
<p>and</p>
<p><span class="math display">\[
N = \operatorname {I N T} ((1 / 5. 0 0) [ 1. 5 + 2. 5 0 ] 2 5 6)
\]</span></p>
<p><span class="math display">\[
N = \operatorname {I N T} (2 0 4. 8)
\]</span></p>
<p><span class="math display">\[
N = 2 0 4 _ {1 0}
\]</span></p>
<p><span class="math display">\[
N = \mathrm {C C H} = 1 1 0 0 1 1 0 0 _ {2}
\]</span></p>
<p>To get an output of <span class="math inline">\(72\mathrm{H}\)</span> we solve Equation (12) for <span class="math inline">\(V_{\mathrm{in}}\)</span></p>
<p><span class="math display">\[
V _ {\mathrm {i n}} = (N / 2 ^ {n}) V _ {R} - V _ {R} / 2
\]</span></p>
<p><span class="math display">\[
V _ {\text {i n}} = (1 1 4 / 2 5 6) 5. 0 0 - 2. 5 0
\]</span></p>
<p><span class="math display">\[
V _ {\mathrm {i n}} = - 0. 2 7 3 4 \mathrm {V}
\]</span></p>
<p>But of course the actual answer is any voltage between <span class="math inline">\(-0.2734\mathrm{V}\)</span> and <span class="math inline">\((-0.2734 + 5 / 256) = -0.2539\mathrm{V}\)</span> .</p>
<p>FIGURE 13 A generic ADC diagram, showing typical input and output signals and noting the conversion time.</p>
<p><img src="Books/Johnson_PCIT/chapter_3/a161645ed90fbddeea8e08f9d2d4b7f3_MD5.jpg" class="img-fluid"></p>
<p>ADC Characteristics Figure 13 shows a generic ADC with all the typical connections. It is quite possible, and even appropriate in many cases, to regard the ADC as simply a black box with certain input and output characteristics. The following list summarizes the important characteristics of the ADC:</p>
<ol type="1">
<li>Analog voltage input This is for connection of the voltage to be converted. As will be explained later, it is important that this voltage be constant during the conversion process.</li>
<li>Power supplies Generally, an ADC requires bipolar supply voltages for internal op amps and a digital logic supply connection.</li>
<li>Reference voltage The reference voltage must be from a stable, well-regulated source. Special, integrated circuit reference-source voltages are available for this purpose.</li>
<li>Digital outputs The converter will have <span class="math inline">\(n\)</span> output lines for connection to digital interface circuitry. Generally, the levels are typical TTL values for definition of the high and low states. It is common for the output lines to be tri-state outputs so that the ADC can be connected directly to a bus.</li>
<li>Control lines The ADC has a number of control lines that are single-bit digital inputs and outputs designed to control operation of the ADC and allow for interface to a computer. The most common lines are:</li>
</ol>
<ol type="a">
<li><p>SC (Start-convert) This is a digital input to the ADC that starts the converter on the process of finding the correct digital outputs for the given analog voltage input. Typically, conversion starts on a falling edge.</p></li>
<li><p>EOC (End-of-convert) This is a digital output from the ADC to receiving equipment, such as a computer. Typically, this line will be high during the conversion process. When the conversion is complete, the line will go low. Thus, the falling edge indicates that the conversion is complete.</p></li>
<li><p>RD (Read) Since the output is typically buffered with tri-states, even though the conversion is complete, the correct digital results do not appear on the</p></li>
</ol>
<p>output lines. The receiving equipment must take the RD line low to enable the tri-states and place the data on the output lines.</p>
<ol type="1">
<li>Conversion time This is not an input or an output, but a very important characteristic of ADCs. A typical ADC does not produce the digital output instantaneously when the analog voltage is applied to its input terminal. The ADC must sequence through a process to find the appropriate digital output, and this process takes time. This is one of the reasons that handshaking lines are required. Figure 14 shows a typical timing diagram for taking a sample of data via an ADC.</li>
</ol>
<p>The existence of a finite conversion time complicates the use of ADCs in data acquisition. The computer cannot have a data input at any time; rather, it must request an input, wait for the ADC to perform a conversion, and then input the data.</p>
<p>ADC Structure Most ADCs are available in the form of integrated circuit (IC) assemblies that can be used as a black box in applications. To fully appreciate the characteristics of these devices, however, it is valuable to examine the standard techniques employed to perform the conversions. There are two methods in use that represent very different approaches to the conversion problem.</p>
<p>Parallel-Feedback ADC The parallel-feedback A/D converter employs a feedback system to perform the conversion, as shown in Figure 15. Essentially, a comparator is used to compare the input voltage, <span class="math inline">\(V_{x}\)</span> , to a feedback voltage, <span class="math inline">\(V_{F}\)</span> , that comes from a DAC as shown. The comparator output signal drives a logic network that steps the digital output (and hence DAC input) until the comparator indicates the two signals are the same within the resolution of the converter. The most popular parallel-feedback converter is the successive approximation device. The logic circuitry is such that it successively sets and tests each bit, starting with the most significant bit of the word. We start with all bits zero. Thus, the first operation will be to set <span class="math inline">\(b_{1} = 1\)</span> and test <span class="math inline">\(V_{F} = V_{R}2^{-1}\)</span> against <span class="math inline">\(V_{x}\)</span> through the comparator.</p>
<p>If <span class="math inline">\(V_{x}\)</span> is greater, then <span class="math inline">\(b_{1}\)</span> will be <span class="math inline">\(\mathbf{1}\)</span> , <span class="math inline">\(b_{2}\)</span> is set to <span class="math inline">\(\mathbf{1}\)</span> , and a test is made of <span class="math inline">\(V_{x}\)</span> versus <span class="math inline">\(V_{V} = V_{R}(2^{-1} + 2^{-2})\)</span> , and so on.</p>
<p>If <span class="math inline">\(V_{x}\)</span> is less than <span class="math inline">\(V_{R}2^{-1}\)</span> , then <span class="math inline">\(b_{1}\)</span> is reset to zero, <span class="math inline">\(b_{2}\)</span> is set to 1, and a test is made for <span class="math inline">\(V_{x}\)</span> versus <span class="math inline">\(V_{R}2^{-2}\)</span> . This process is repeated to the least significant bit of the word. The operation can be illustrated best through an example.</p>
<p>FIGURE 14 A typical data-acquisition timing diagram using an ADC. The read operation may occur at any time after the end-of-convert has been issued by the ADC.</p>
<p><img src="Books/Johnson_PCIT/chapter_3/5842a3e1601af4ca331db02fb8a9ab55_MD5.jpg" class="img-fluid"></p>
<p><img src="Books/Johnson_PCIT/chapter_3/87872e3df9ff17a4e5fa5f45245415e4_MD5.jpg" class="img-fluid"></p>
<p>FIGURE 15 One common method of implementing an ADC is the successive approximation of parallel feedback system using an internal DAC.</p>
</section>
<section id="example-17" class="level2">
<h2 class="anchored" data-anchor-id="example-17">EXAMPLE 17</h2>
<p>Find the successive approximation ADC output for a 4-bit converter to a 3.217-V input if the reference is <span class="math inline">\(5\mathrm{V}\)</span> .</p>
</section>
<section id="solution-13" class="level2">
<h2 class="anchored" data-anchor-id="solution-13">Solution</h2>
<p>Following the procedure outlined, we have the following operations: Let <span class="math inline">\(V_{x} = 3.217\)</span> ; then</p>
<ol type="1">
<li>Set <span class="math inline">\(b_{1} = 1\)</span> <span class="math inline">\(V_{F} = 5(2^{-1}) = 2.5\mathrm{V}\)</span></li>
</ol>
<p><span class="math inline">\(V_{x} &gt; 2.5\)</span> （204 leave <span class="math inline">\(b_{1} = \mathbf{1}\)</span></p>
<ol start="2" type="1">
<li>Set <span class="math inline">\(b_{2} = 1\)</span> <span class="math inline">\(V_{F} = 2.5 + 5(2^{-2}) = 3.75\)</span></li>
</ol>
<p><span class="math inline">\(V_{x} &lt;   3.75\)</span> reset <span class="math inline">\(b_{2} = \mathbf{0}\)</span></p>
<ol start="3" type="1">
<li>Set <span class="math inline">\(b_{3} = 1\)</span> <span class="math inline">\(V_{F} = 2.5 + 5(2^{-3}) = 3.125\)</span></li>
</ol>
<p><span class="math inline">\(V_{x} &gt; 3.125\)</span> （204 leave <span class="math inline">\(b_{3} = \mathbf{1}\)</span></p>
<ol start="4" type="1">
<li>Set <span class="math inline">\(b_{4} = 1\)</span> <span class="math inline">\(V_{F} = 3.125 + 5(2^{-4})\)</span></li>
</ol>
<p><span class="math inline">\(V_{x} &lt;   3.4375\)</span> reset <span class="math inline">\(b_{4} = \mathbf{0}\)</span></p>
<p>By this procedure, we find the output is a binary word of <span class="math inline">\(\mathbf{1010}_2\)</span> .</p>
<p><img src="Books/Johnson_PCIT/chapter_3/5c4d155f711ae45a6ea057017c88ddf4_MD5.jpg" class="img-fluid"></p>
<p>FIGURE 16 The dual-slope ADC uses an op amp integrator, comparator, and counter. This is commonly used in digital voltmeters.</p>
<p>The conversion time of successive approximation-type ADCs is on the order of 1 to <span class="math inline">\(5\mu \mathrm{s}\)</span> per bit. Thus, a low-priced 8-bit ADC might require <span class="math inline">\(5\mu \mathrm{s} / \mathrm{bit}\)</span> for a total conversion time of about <span class="math inline">\(40~\mu \mathrm{s}\)</span> . A higher-quality (and price) 12-bit might be able to perform the full conversion in only <span class="math inline">\(15~\mu \mathrm{s}\)</span> .</p>
<p>These conversion times depend on a clock that is internal to the ADC and not crystal controlled. Thus, there will be variation of the conversion time from unit to unit.</p>
<p>Ramp ADC The ramp-type A/D converters essentially compare the input voltage against a linearly increasing ramp voltage. A binary counter is activated that counts ramp steps until the ramp voltage equals the input. The output of the counter is then the digital word representing conversion of the analog input. The ramp itself is typically generated by an op amp integrator circuit.</p>
<p>Dual-Slope Ramp ADC This ADC is the most common type of ramp converter. A simplified diagram of this device is shown in Figure 16. The principle of operation is based on allowing the input signal to drive the integrator for a fixed time, <span class="math inline">\(T_{1}\)</span> , thus generating an output of</p>
<p><span class="math display">\[
V _ {1} = \frac {1}{R C} \int V _ {x} d t \tag {13}
\]</span></p>
<p>or, because <span class="math inline">\(V_{x}\)</span> is constant,</p>
<p><span class="math display">\[
V _ {1} = \frac {1}{R C} = T _ {1} V _ {x} \tag {14}
\]</span></p>
<p>FIGURE 17 A typical timing diagram of a dual-slope ADC. Since both slopes depend upon <span class="math inline">\(R\)</span> and <span class="math inline">\(C\)</span> , the ADC output is independent of the values of these components.</p>
<p><img src="Books/Johnson_PCIT/chapter_3/5343a1e0f309c29fe26c8c58639ace55_MD5.jpg" class="img-fluid"></p>
<p>After time <span class="math inline">\(T_{1}\)</span> , the input of the integrator is electronically switched to the reference supply. The comparator then sees an input voltage that decreases from <span class="math inline">\(V_{1}\)</span> as</p>
<p><span class="math display">\[
V _ {2} = V _ {1} - \frac {1}{R C} \int V _ {R} d t \tag {15}
\]</span></p>
<p>or, because <span class="math inline">\(V_{R}\)</span> is constant and <span class="math inline">\(V_{1}\)</span> is given from Equation (14),</p>
<p><span class="math display">\[
V _ {2} = \frac {1}{R C} T _ {1} V _ {x} - \frac {1}{R C} t V _ {R} \tag {16}
\]</span></p>
<p>A counter is activated at time <span class="math inline">\(T_{1}\)</span> and counts until the comparator indicates <span class="math inline">\(V_{2} = 0\)</span> , at which time <span class="math inline">\(t_{x}\)</span> [Equation (16)] indicates that <span class="math inline">\(V_{x}\)</span> will be</p>
<p><span class="math display">\[
V _ {x} = \frac {t _ {x}}{T _ {1}} V _ {R} \tag {17}
\]</span></p>
<p>Thus, the counter time, <span class="math inline">\(t_x\)</span> , is linearly related to <span class="math inline">\(V_x\)</span> and is independent of the integrator characteristics—that is, <span class="math inline">\(R\)</span> and <span class="math inline">\(C\)</span> . This procedure is shown in the timing diagram in Figure 17. Conversion start and stop digital signals are also used in these devices, and (in many cases) internal or external references may be used.</p>
<p>EXAMPLE 18</p>
<p>A dual-slope ADC as shown in Figure 16 has <span class="math inline">\(R = 100\mathrm{k}\Omega\)</span> and <span class="math inline">\(C = 0.01\mu \mathrm{F}\)</span> . The reference is <span class="math inline">\(10\mathrm{V}\)</span> , and the fixed integration time is <span class="math inline">\(10\mathrm{ms}\)</span> . Find the conversion time for a 6.8-V input.</p>
</section>
<section id="solution-14" class="level2">
<h2 class="anchored" data-anchor-id="solution-14">Solution</h2>
<p>We find the voltage after an integration time of <span class="math inline">\(10\mathrm{ms}\)</span> as</p>
<p><span class="math display">\[
V _ {1} = \frac {1}{R C} T _ {1} V _ {x}
\]</span></p>
<p><span class="math display">\[
V _ {1} = \frac {(1 0 \mathrm {m s}) (6 . 8 \mathrm {V})}{(1 0 0 \mathrm {k} \Omega) (0 . 1 \mu \mathrm {F})}
\]</span></p>
<p><span class="math display">\[
V _ {1} = 6. 8 \mathrm {V}
\]</span></p>
<p>Then we find the time required to integrate this to zero as <span class="math inline">\(V_{2} = 0\)</span> in</p>
<p><span class="math display">\[
V _ {2} = \frac {T _ {1} V _ {x}}{R C} - \frac {t _ {x}}{R C} V _ {R}
\]</span></p>
<p>Thus,</p>
<p><span class="math display">\[
t _ {x} = \frac {T _ {1} V _ {x}}{V _ {R}}
\]</span></p>
<p><span class="math display">\[
t _ {x} = \frac {(1 0 \mathrm {m s}) (6 . 8 \mathrm {V})}{1 0 \mathrm {V}}
\]</span></p>
<p><span class="math display">\[
t _ {x} = 6. 8 \mathrm {m s}
\]</span></p>
<p>The total conversion time is then <span class="math inline">\(10\mathrm{ms} + 6.8\mathrm{ms} = 16.8\mathrm{ms}\)</span></p>
<p>Example 18 illustrates an important characteristic of the dual-slope ADC. It has a much longer conversion time than a successive approximation type. In fact, the conversion time for the dual-slope is frequently from tens to several hundreds of milliseconds.</p>
<p>One of the most common applications of the dual-slope ADCs is in digital multi-meters. Here, input circuitry converts the input voltage into an appropriate range for the ADC. The ADC performs conversions continuously; that is, when one conversion is finished, the output is latched into a display register and another conversion is started. In applications such as this, a few hundred milliseconds’ conversion time is plenty fast and allows for the display to be updated several times per second.</p>
<p>EXAMPLE 19</p>
<p>A measurement of temperature using a sensor that outputs <span class="math inline">\(6.5\mathrm{mV} / {}^{\circ}\mathrm{C}\)</span> must measure to <span class="math inline">\(100^{\circ}\mathrm{C}\)</span> . A 6-bit ADC with a 10-V reference is used. (a) Develop a circuit to interface the sensor and the ADC. (b) Find the temperature resolution.</p>
</section>
<section id="solution-15" class="level2">
<h2 class="anchored" data-anchor-id="solution-15">Solution</h2>
<p>To measure to <span class="math inline">\(100^{\circ}\mathrm{C}\)</span> means the sensor output at <span class="math inline">\(100^{\circ}\mathrm{C}\)</span> will be</p>
<p><span class="math display">\[
(6. 5 \mathrm {m V} / ^ {\circ} \mathrm {C}) (1 0 0 ^ {\circ} \mathrm {C}) = 0. 6 5 \mathrm {V}
\]</span></p>
<ol type="a">
<li>The interface circuit must provide a gain so that at <span class="math inline">\(100^{\circ}\mathrm{C}\)</span> the ADC output is 111111. The input voltage that will provide this output is found from</li>
</ol>
<p><span class="math display">\[
V _ {x} = V _ {R} \left(a _ {1} 2 ^ {- 1} + a _ {2} 2 ^ {- 2} + \dots + a _ {6} 2 ^ {- 6}\right)
\]</span></p>
<p><span class="math display">\[
V _ {x} = 1 0 \left(\frac {1}{2} + \frac {1}{4} + \dots + \frac {1}{6 4}\right)
\]</span></p>
<p><span class="math display">\[
V _ {x} = 9. 8 4 3 7 5 \mathrm {V}
\]</span></p>
<p>Thus, the required gain must provide this voltage when the temperature is <span class="math inline">\(100^{\circ}\mathrm{C}\)</span> .</p>
<p><span class="math display">\[
\mathrm {g a i n} = \frac {9 . 8 4 3 7 5}{0 . 6 5}
\]</span></p>
<p><span class="math display">\[
\mathrm {g a i n} = 1 5. 1 4
\]</span></p>
<p>The op amp circuit of Figure 18 will provide this gain.</p>
<ol start="2" type="a">
<li>The temperature resolution can be found by working backward from the least significant bit (LSB) voltage change of the ADC:</li>
</ol>
<p><span class="math display">\[
\Delta V = V _ {R} 2 ^ {- n}
\]</span></p>
<p><span class="math display">\[
\Delta V = (1 0) \left(2 ^ {- 6}\right) = 0. 1 5 6 2 5 \mathrm {V}
\]</span></p>
<p>Working back through the amplifier, this corresponds to a sensor change of</p>
<p><span class="math display">\[
\Delta V _ {T} = \frac {0 . 1 5 6 2 5}{1 5 . 1 4} = 0. 0 1 0 3 2 \mathrm {V}
\]</span></p>
<p>or a temperature of</p>
<p><span class="math display">\[
\Delta T = \frac {0 . 0 1 0 3 2 \mathrm {V}}{0 . 0 0 6 5 \mathrm {V} / ^ {\circ} \mathrm {C}} = 1. 5 9 ^ {\circ} \mathrm {C}
\]</span></p>
<p><img src="Books/Johnson_PCIT/chapter_3/ab855c16ccc79a2fba593ca39420d29c_MD5.jpg" class="img-fluid"></p>
<p>FIGURE 18 Analog circuit for Example 19.</p>
<p>Conversion-Time Consequences The finite conversion time of the ADC has serious consequences on the rate of change of signals presented for conversion. An ADC performs the conversion process by referring back to the input signal while the conversion is taking place. Obviously, if the input is changing while this process is taking place, errors will occur.</p>
<p>Consequently, the ADC output will be in error if the magnitude of the input voltage changes by more than one LSB voltage, <span class="math inline">\(\Delta V\)</span> , during the time of conversion, <span class="math inline">\(\tau_{c}\)</span> . This is a serious limitation. Since the change in time of the input voltage is just the derivative, this condition can be written in the form</p>
<p><span class="math display">\[
\frac {d V _ {\text {i n}}}{d t} \leq \frac {\Delta V}{\tau_ {c}} = \frac {V _ {R}}{2 ^ {n} \tau_ {c}} \tag {18}
\]</span></p>
<p>Consider, for example, a 10-bit ADC with a 5.0-V reference and a <span class="math inline">\(20 - \mu s\)</span> conversion time. According to Equation (18), the maximum rate of change of the input voltage for this converter would be</p>
<p><span class="math display">\[
\frac {d V _ {\mathrm {i n}}}{d t} \leq \frac {5 . 0}{2 ^ {1 0} (2 0 \times 1 0 ^ {- 6})} \approx 2 4 4 \mathrm {V / s}
\]</span></p>
<p>This result, <span class="math inline">\(244\mathrm{V / s}\)</span> , doesn’t seem so bad. Let’s put this in perspective by asking what frequency it would correspond to if the input were a sinusoidal voltage,</p>
<p><span class="math display">\[
V _ {\mathrm {i n}} = V _ {0} \sin (\omega t)
\]</span></p>
<p>Taking the derivative and using Equation (18) gives the result</p>
<p><span class="math display">\[
\omega V _ {0} \cos (\omega t) \leq \frac {V _ {R}}{2 ^ {n} \tau_ {c}}
\]</span></p>
<p>or, since the maximum value of the cosine function is unity, we get the condition</p>
<p><span class="math display">\[
\omega \leq \frac {V _ {R}}{2 ^ {n} \tau_ {c} V _ {0}} \tag {19}
\]</span></p>
<p>or, in terms of frequency where <span class="math inline">\(\omega = 2\pi f\)</span></p>
<p><span class="math display">\[
f \leq \frac {V _ {R}}{2 ^ {n + 1} \pi \tau_ {c} V _ {0}} \tag {20}
\]</span></p>
<p>Returning to the <span class="math inline">\(244\mathrm{V / s}\)</span> , let’s assume that the full range is in use, <span class="math inline">\(V_{0} = V_{R}\)</span> . Then we find that the maximum angular frequency is</p>
<p><span class="math display">\[
\omega \leq \frac {1}{2 ^ {1 0} (2 0 \times 1 0 ^ {- 6})} \approx 4 8. 8 \mathrm {r a d / s}
\]</span></p>
<p>or, in terms of frequency,</p>
<p><span class="math display">\[
f \leq \frac {\omega}{2 \pi} \approx 7. 8 \mathrm {H z}
\]</span></p>
<p>This is a remarkable result! It says that this <span class="math inline">\(20 - \mu s\)</span> converter cannot find a 10-bit representation of an oscillating signal greater than <span class="math inline">\(7.8\mathrm{Hz}\)</span> . Yet it is true, and means that if the frequency is greater than this, there will be errors in the lower-order bits; that is, it is no longer converting to 10 bits.</p>
<p>EXAMPLE 20</p>
<p>An 8-bit, bipolar ADC with a 5-V reference will be used to take samples of a triangular wave as shown in Figure 19. What is the maximum frequency of the wave if the ADC conversion time is <span class="math inline">\(12\mu \mathrm{s}\)</span> ?</p>
<p>FIGURE 19 Input signal for Example 20.</p>
<p><img src="Books/Johnson_PCIT/chapter_3/e49f7acfc88643f2c3b377e7c664453f_MD5.jpg" class="img-fluid"></p>
</section>
<section id="solution-16" class="level2">
<h2 class="anchored" data-anchor-id="solution-16">Solution</h2>
<p>The solution is found from the condition expressed by Equation (18). From Figure 19 it is clear that the derivative of the input signal is simply the slope of the triangular wave,</p>
<p><span class="math display">\[
\frac {d V _ {\mathrm {i n}}}{d t} = \frac {2}{T / 4} = \frac {8}{T} = 8 f
\]</span></p>
<p>where <span class="math inline">\(T\)</span> is the period and <span class="math inline">\(f\)</span> is the frequency. Then, from Equation (18),</p>
<p><span class="math display">\[
8 f \leq \frac {5}{2 ^ {8} (1 2 \times 1 0 ^ {- 6})} = 1 6 2 7. 6 \mathrm {H z}
\]</span></p>
<p>or <span class="math inline">\(f\leq 203.5\mathrm{Hz}\)</span></p>
<p>Obviously, the limitations on frequency described previously severely limit the application of ADCs and computer data-acquisition systems. There is a solution, however. What is needed is simply that the signal not change during the conversion process. Therefore, the answer is to hold the value constant during that process. This is accomplished with a sample-and-hold (S/H) circuit.</p>
<p>Sample-and-Hold The basic concept of the sample-and-hold circuit is shown in Figure 20, where the S/H is connected to the input of an ADC. When the electronic switch is closed, the capacitor voltage will “track” the input voltage, <span class="math inline">\(V_{c}(t) = V_{\mathrm{in}}(t)\)</span> . At some time, <span class="math inline">\(t_s\)</span> , when a conversion of the input voltage is desired, the electronic switch is opened, isolating the capacitor from the input. Thus, the capacitor will hold (stay charged) to the voltage when the switch opened, <span class="math inline">\(V_{c} = V_{\mathrm{in}}(t_{s})\)</span> .</p>
<p>The voltage follower allows this voltage to be impressed upon the ADC input, but the capacitor does not discharge because of the very high input impedance of the follower. The start-convert is then issued, and the conversion proceeds with the input voltage remaining constant, so the problem of Equation (18) does not arise.</p>
<p>When the conversion is complete, the electronic switch is reclosed, and tracking continues until another conversion is needed. Figure 21 shows how <span class="math inline">\(V_{\mathrm{in}}(t)\)</span> and <span class="math inline">\(V_{c}(t)\)</span> would appear during a sample collection sequence of a sinusoidal signal.</p>
<p><img src="Books/Johnson_PCIT/chapter_3/c20c3f9515d84c4ca266cdeedfe65434_MD5.jpg" class="img-fluid"></p>
<p>FIGURE 20 The basic concept of a sample-and-hold circuit for use with the ADC.</p>
<p>FIGURE 21 The sampled signal is literally “held” during the ADC conversion process.</p>
<p><img src="Books/Johnson_PCIT/chapter_3/f4f58cbd10e14810c903e033f62c8dac_MD5.jpg" class="img-fluid"></p>
<p><img src="Books/Johnson_PCIT/chapter_3/46ee93eb9d3b2ede5d1e354db7e9badb_MD5.jpg" class="img-fluid"></p>
<p>Practical S/H Issues Because of the severe limitations of Equation (18), ADC systems virtually always use S/H circuits on the input. Whenever an SC is issued to the ADC, a “hold” is also issued to the S/H circuit. When the EOC is issued by the ADC, this usually automatically switches the S/H back to the “sample” mode. Figure 22 shows how IC S/H circuits are often implemented using FETs as the electronic switches.</p>
<p>There are several practical issues associated with the nonideal electrical characteristics of the elements involved in S/H circuits.</p>
<ul>
<li>There is a nonzero resistance path from the input voltage to the capacitor. This resistance consists of the output resistance of the source of <span class="math inline">\(V_{\mathrm{in}}\)</span> and the finite “ON” resistance of the electronic switch (the FET, for example).</li>
</ul>
<p>Figure 23a shows a model of the sample mode of the S/H. You can see that this constitutes a low-pass filter with <span class="math inline">\(R = R_{s} + R_{\mathrm{ON}}\)</span> and the capacitor. Therefore, there will be a limitation on the frequency that the system can track. The capacitor voltage will be down 3 dB (0.707) at the critical frequency given by</p>
<p><span class="math display">\[
f _ {c} = \frac {1}{2 \pi \left(R _ {s} + R _ {\mathrm {O N}}\right) C} \tag {21}
\]</span></p>
<p>Most commercial S/H circuits reduce this limitation by using a voltage follower before the switch, since it has very low output resistance.</p>
<p>FIGURE 22 A S/H often uses a FET as an electronic switch.</p>
<p><img src="Books/Johnson_PCIT/chapter_3/8a4854ff55cf409e9479cea58b81f6d0_MD5.jpg" class="img-fluid"></p>
<p><img src="Books/Johnson_PCIT/chapter_3/71e60772c7e4e1e4c3f5f339e5a4a8fc_MD5.jpg" class="img-fluid"></p>
<ol type="a">
<li>Sampling</li>
</ol>
<p><img src="Books/Johnson_PCIT/chapter_3/463338ee3bfddc90943fc4221663e74f_MD5.jpg" class="img-fluid"></p>
<ol start="2" type="a">
<li>Holding</li>
</ol>
<p>FIGURE 23 During (a) sampling and (b) holding, equivalent circuit resistance creates nonideal effects.</p>
<ul>
<li>During the hold mode, the capacitor is shunted by the parallel combination of the “OFF” resistance of the switch and the input resistance of the voltage follower, as shown in Figure 23b. In this case, there will be a gradual discharge, or “droop,” of the capacitor voltage. The droop time constant for this discharge is simply</li>
</ul>
<p><span class="math display">\[
\tau_ {D} = \frac {R _ {\mathrm {O F F}} R _ {V F}}{R _ {\mathrm {O F F}} + R _ {V F}} C \tag {22}
\]</span></p>
<p>The condition here is that the droop of the capacitor voltage cannot have a slope larger than that given by Equation (18). For the exponential decay of the capacitor voltage, this leads to the condition</p>
<p><span class="math display">\[
\frac {V _ {C}}{\tau_ {D}} \leq \frac {V _ {R}}{2 ^ {n} \tau_ {c}} \tag {23}
\]</span></p>
<p>or</p>
<p><span class="math display">\[
\tau_ {D} \geq 2 ^ {n} \tau_ {c} \frac {V _ {C}}{V _ {R}} \tag {24}
\]</span></p>
<p>Equation (24) shows how the value of capacitor <span class="math inline">\(C\)</span> can be selected to ensure that droop will not exceed the limitation imposed by Equation (18). Usually, the equation is evaluated for <span class="math inline">\(V_{C} = V_{R}\)</span> as a worst-case condition.</p>
<p>EXAMPLE 21</p>
<p>A S/H will be used with a 12-bit, unipolar ADC with a <span class="math inline">\(30 - \mu s\)</span> conversion time. The S/H switch ON resistance is <span class="math inline">\(10\Omega\)</span> , and its OFF resistance is <span class="math inline">\(10\mathrm{M}\Omega\)</span> . The voltage follower input resistance is also <span class="math inline">\(10\mathrm{M}\Omega\)</span> , while the signal source output resistance is <span class="math inline">\(50\Omega\)</span> .</p>
<ol type="a">
<li><p>What value of capacitor should be used?</p></li>
<li><p>Determine the sampling cutoff frequency.</p></li>
</ol>
</section>
<section id="solution-17" class="level2">
<h2 class="anchored" data-anchor-id="solution-17">Solution</h2>
<ol type="a">
<li>Equation (24), under the worst-case condition that <span class="math inline">\(V_{C} = V_{R}\)</span> will determine the minimum droop time, <span class="math inline">\(\tau_{D} \geq 2^{12}(30 \times 10^{-6}) = 0.12288\)</span> s. Now Equation (22) will allow determination of <span class="math inline">\(C\)</span> ,</li>
</ol>
<p><span class="math display">\[
\frac {(1 0 ^ {7}) (1 0 ^ {7})}{(1 0 ^ {7} + 1 0 ^ {7})} C \geq 0. 1 2 2 8 8
\]</span></p>
<p>which gives <span class="math inline">\(C \geq 0.025\mu \mathrm{F}\)</span> .</p>
<ol start="2" type="a">
<li>From this result and Equation (22), the critical frequency during sampling is found to be</li>
</ol>
<p><span class="math display">\[
f _ {c} = \frac {1}{(2 \pi) (5 0 + 1 0) (0 . 0 2 5 \times 1 0 ^ {- 6})} = 1 0 8 \mathrm {k H z}
\]</span></p>
<ul>
<li>Other important characteristics of the S/H circuit are the acquisition time <span class="math inline">\((\tau_{\mathrm{acq}})\)</span> and the aperture time <span class="math inline">\((\tau_{\mathrm{ap}})\)</span> . The acquisition time is the time required for the S/H to acquire the signal when changing from the hold to the sample mode. Typical times are on the order of microseconds. This places limits on the frequency with which samples can be taken.</li>
</ul>
<p>The aperture time is the time between when a command to hold is given and the actual signal level is held. This delay means that the value presented to the ADC is not exactly the value at the time the sample was requested. This time is typically less than <span class="math inline">\(1\mu \mathrm{s}\)</span> .</p>
<p>In general, the minimum time between samples taken from a S/H and ADC system is given by the sum</p>
<p><span class="math display">\[
T = \tau_ {c} + \tau_ {\mathrm {a c q}} + \tau_ {\mathrm {a p}} \tag {25}
\]</span></p>
<p>or, if expressed in terms of the maximum throughput frequency, <span class="math inline">\(f_{\mathrm{max}} = 1 / T\)</span> .</p>
<p>EXAMPLE A S/H has a 50-ns aperture time and a <span class="math inline">\(4 - \mu s\)</span> acquisition time, and the ADC has a <span class="math inline">\(40 - \mu s\)</span> conversion time. What is the maximum throughput frequency?</p>
</section>
<section id="solution-18" class="level2">
<h2 class="anchored" data-anchor-id="solution-18">Solution</h2>
<p>The frequency is given by the inverse of the time between samples, given by Equation (25):</p>
<p><span class="math display">\[
T = 4 0 \mu \mathrm {s} + 0. 0 5 \mu \mathrm {s} + 4 \mu \mathrm {s} = 4 4. 0 5 \mu \mathrm {s}
\]</span></p>
<p>Thus, the frequency is <span class="math inline">\(f_{\mathrm{max}} = 22.7 \mathrm{kHz}\)</span> .</p>
<p>Microprocessor-Compatible ADCs Just as with DACs, a whole line of ADCs have been developed that interface easily with microprocessor-based computers. The ADCs have built-in tri-state outputs so that they can be connected directly to the data bus of the computer. Data from the ADC are placed on the data bus lines only when the computer issues an appropriate enable command (often called a READ). Figure 24 shows how the ADC appears when connected to the environment of the microprocessor-based computer. The ADC appears much the same as memory. In some cases, an ADC input is actually taken by the computer using a memory-read instruction.</p>
<p>The decoding circuitry is necessary to provide the start-convert command, to input the convert-complete response from the ADC, and to issue the tri-state enable back to the ADC.</p>
</section>
<section id="frequency-based-converters" class="level2">
<h2 class="anchored" data-anchor-id="frequency-based-converters">3.4 Frequency-Based Converters</h2>
<p>There is another important method by which an analog sensor signal can be converted into a digital signal. This is based upon converting the sensor signal into a variable frequency and then using this frequency as input to a counter for a fixed interval of time. The output of the counter is then a measure of the frequency and thus the sensor signal.</p>
<p><img src="Books/Johnson_PCIT/chapter_3/57b20b778796fe0e6a729ea1de792a5b_MD5.jpg" class="img-fluid"></p>
<p>FIGURE 24 An ADC can be interfaced directly to the computer bus if it has tri-state outputs. Address decoding is required so the ADC can be operated by computer software.</p>
<p>Figure 25 shows a diagram that describes the essential elements of this type of analog-to-digital converter. An as yet not identified device converts the sensor signal into a proportional frequency, <span class="math inline">\(f_{s}\)</span> . This frequency signal is typically a square wave, as suggested in the figure. The square wave is fed to an <span class="math inline">\(n\)</span> -bit counter, which counts every rising (or falling) edge of the wave and hence every cycle. The counter often has a latch on the output that allows the counter to be accumulating a new count of input frequency while still maintaining the previous output.</p>
<p>A conversion cycle starts with a start-convert (SC) signal from the computer. This clears the counter and triggers a one-shot convert multivibrator (MV), which controls the operation. The MV is a simple digital IC that, when triggered, outputs a single pulse of some desired time duration. The count MV outputs a pulse of duration <span class="math inline">\(T_{c}\)</span> when triggered by the SC. This pulse acts as a start/stop signal to the counter and so defines the time over which the frequency signal will be counted. If the input frequency is high, the count will be high; if the frequency is low, the count will be low. The latch MV issues a short pulse to latch the latest count into the output latches when the count time, <span class="math inline">\(T_{c}\)</span> , is finished. The falling edge of <span class="math inline">\(T_{c}\)</span> also signals the computer that a conversion is complete (EOC). The computer can then read the count by enabling the tri-state output of the counter latch with the RD signal taken low.</p>
<p>A typical design starts from the range of frequency of the converted sensor signal, <span class="math inline">\(f_{\mathrm{min}}\)</span> to <span class="math inline">\(f_{\mathrm{max}}\)</span> . For maximum resolution, we then make the count time, <span class="math inline">\(T_{c}\)</span> , such that if the sensor signal produces the maximum frequency, the count will also be at its maximum. For an <span class="math inline">\(n\)</span> -bit binary counter, the maximum count is <span class="math inline">\(2^{n} - 1\)</span> , so the relation we need is</p>
<p><span class="math display">\[
T _ {c} = \frac {2 ^ {n} - 1}{f _ {\max }} \tag {26}
\]</span></p>
<p>The counter output for any other frequency is simply <span class="math inline">\(N = fT_{c}\)</span> .</p>
<p>Example 23 illustrates this concept.</p>
<p><img src="Books/Johnson_PCIT/chapter_3/403628967df0f99ac7549e3b9feca162_MD5.jpg" class="img-fluid"></p>
<p>FIGURE 25 General diagram of a frequency-based analog-to-digital converter.</p>
</section>
<section id="example-23" class="level2">
<h2 class="anchored" data-anchor-id="example-23">EXAMPLE 23</h2>
<p>A sensor signal is converted to a frequency that varies from 2.0 to <span class="math inline">\(20\mathrm{kHz}\)</span> . This signal is to be converted into an 8-bit digital signal. Specify the count time, <span class="math inline">\(T_{c}\)</span> . What is the range of count output for the sensor signal’s frequency range?</p>
</section>
<section id="solution-19" class="level2">
<h2 class="anchored" data-anchor-id="solution-19">Solution</h2>
<p>An 8-bit counter has a maximum output of <span class="math inline">\(255_{10}(11111111_2)\)</span> . Therefore, when the frequency is at its maximum, the count time must allow the counter to reach a full 255. From Equation (26),</p>
<p><span class="math display">\[
T _ {c} = \frac {2 ^ {8} - 1}{2 0 , 0 0 0 \mathrm {H z}} = 0. 0 1 2 7 5 \mathrm {s}
\]</span></p>
<p>So the one-shot multivibrator is configured to provide a 12.75-ms pulse. When the frequency is at the minimum of <span class="math inline">\(2.0\mathrm{kHz}\)</span> , the count will be</p>
<p><span class="math display">\[
N = (2 0 0 0 \mathrm {H z}) (0. 0 1 2 7 5 \mathrm {s}) = 2 5. 5
\]</span></p>
<p>or simply <span class="math inline">\(25_{10} = \mathbf{00011001}_2\)</span> , since the counter can count only in integers.</p>
<p>Sensor-to-Frequency Conversion Of course, this technique of analog-to-digital conversion depends upon converting the measured variable information into a variable frequency. In fact, this is not so hard to do. Common ICs exist that readily convert voltage or current to frequency. An example is the LM331 voltage-to-frequency IC. Figure 26 shows a generic LM331 circuit for controlling output frequency with an input voltage. For this circuit, the output frequency is determined by the relation</p>
<p><span class="math display">\[
f _ {\text {o u t}} = \frac {R _ {S}}{R _ {L}} \frac {1}{R _ {t} C _ {t}} \frac {V _ {\text {i n}}}{2 . 0 9} \tag {27}
\]</span></p>
<p>where the components are defined in the schematic. Actually, the frequency cannot really be zero even when <span class="math inline">\(V_{\mathrm{in}}\)</span> is zero. It is typically small, perhaps <span class="math inline">\(10\mathrm{Hz}\)</span> . Generally <span class="math inline">\(R_{S}\)</span> is in the range of 10 to <span class="math inline">\(20\mathrm{k}\Omega\)</span> and is adjustable to allow fine-tuning of the frequency-to-voltage scale factor. <span class="math inline">\(R_{L}\)</span> is used to provide a discharge path for the <span class="math inline">\(1 - \mu \mathrm{F}\)</span> capacitor. It typically has a value of about <span class="math inline">\(100\mathrm{k}\Omega\)</span> . The supply voltage can be up to <span class="math inline">\(40\mathrm{V}\)</span> . The output is open collector (OC), so a pull-up resistor is required to the logic supply voltage (for example, <span class="math inline">\(+5\mathrm{V}\)</span> for TTL).</p>
<p>As an example, suppose we want an input voltage of 0 to <span class="math inline">\(5.0\mathrm{V}\)</span> to generate a frequency from <span class="math inline">\(\approx 0\)</span> to <span class="math inline">\(10\mathrm{kHz}\)</span> . If we use typical values of <span class="math inline">\(R_{S} = 15\mathrm{k}\Omega\)</span> and <span class="math inline">\(R_{L} = 100\mathrm{k}\Omega\)</span> , Equation (27) provides</p>
<p><span class="math display">\[
1 0, 0 0 0 = \frac {1 5 \mathrm {k} \Omega}{1 0 0 \mathrm {k} \Omega} \frac {5 . 0}{2 . 0 9} \frac {1}{R _ {t} C _ {t}}
\]</span></p>
<p>so we get <span class="math inline">\(R_{t}C_{t} = 3.59 \times 10^{-5}\mathrm{s}\)</span> . Thus, picking <span class="math inline">\(C_t = 0.01\mu \mathrm{F}\)</span> means <span class="math inline">\(R_{t} = 3.59\mathrm{k}\Omega\)</span></p>
<p>The value of output frequency also depends upon resistors and a capacitor, so by fixing the control voltage, the frequency can also be made to depend upon these values. Therefore, if the sensor is a varying resistance or capacitance, it can often be used directly in the circuit to provide a frequency that varies with the sensed quantity. You must remember, however, that the variation of frequency with either resistance or capacitance is often nonlinear.</p>
<p>FIGURE 26 The LM331 is a common voltage-to-frequency converter useful in frequency-based ADCs.</p>
<p><img src="Books/Johnson_PCIT/chapter_3/7a6bd0d0b2156a64caafabd45ae8ef1f_MD5.jpg" class="img-fluid"></p>
<p>FIGURE 27 The 555 timer is useful for generation of a frequency that depends upon resistance or capacity.</p>
<p><img src="Books/Johnson_PCIT/chapter_3/25a6248164652fdc910f7e0bf2fe75b9_MD5.jpg" class="img-fluid"></p>
<p>Another common IC that can be used for converting resistance or capacity to a frequency is the 555 timer. This IC has an output frequency that depends upon an external resistor and capacitor. Figure 27 shows a standard 555 timer circuit that produces a steady, nonsymmetrical rectangular wave with frequency</p>
<p><span class="math display">\[
f = \frac {1}{0 . 6 9 3 \left(R _ {A} + 2 R _ {B}\right) C} \tag {28}
\]</span></p>
<p>The following example illustrates how the 555 can be used to produce a varying frequency and analog-to-digital conversion.</p>
</section>
<section id="example-24" class="level2">
<h2 class="anchored" data-anchor-id="example-24">EXAMPLE 24</h2>
<p>A resistor varies from 36 to <span class="math inline">\(4\mathrm{k}\Omega\)</span> as light intensity varies from 1.5 to <span class="math inline">\(10\mathrm{W / m^2}\)</span> . Devise a frequency-based 10-bit ADC of this signal. What are the frequencies at 1.5 and <span class="math inline">\(10\mathrm{W / m^2}\)</span> ? Plot the counter output versus light intensity. Notice the nonlinearity.</p>
</section>
<section id="solution-20" class="level2">
<h2 class="anchored" data-anchor-id="solution-20">Solution</h2>
<p>We want the maximum frequency to produce a count of <span class="math inline">\(2^{10} - 1 = 1023\)</span> , but maximum frequency is unspecified, so we cannot determine the count time. We get to pick one, so let us pick the count time to be, say, <span class="math inline">\(10 \mathrm{~ms}\)</span> . Then we get the maximum frequency as <span class="math inline">\(f_{\max} = (1023 / 10 \mathrm{~ms}) = 102,300 \mathrm{~Hz}\)</span> . This frequency will occur when the sensor is at <span class="math inline">\(4 \mathrm{k} \Omega\)</span> :</p>
<p><span class="math display">\[
1 0 2, 3 0 0 \mathrm {H z} = \frac {1}{0 . 6 9 3 (4 \mathrm {k} \Omega + 2 R _ {B}) C}
\]</span></p>
<p>This leaves another value we can pick. Let’s make <span class="math inline">\(R_{B} = 2\mathrm{k}\Omega\)</span> ; then we get</p>
<p><span class="math display">\[
C = \frac {1}{0 . 6 9 3 (4 \mathrm {k} \Omega + 4 \mathrm {k} \Omega) (1 0 2 , 3 0 0 \mathrm {H z})} = 0. 0 0 1 8 \mu \mathrm {F}
\]</span></p>
<p>We get the frequency at <span class="math inline">\(1.5\mathrm{W / m}^2\)</span> by using <span class="math inline">\(36\mathrm{k}\Omega\)</span> for <span class="math inline">\(R_{A}\)</span></p>
<p><span class="math display">\[
f _ {\min } = \frac {1}{0 . 6 9 3 (3 6 \mathrm {k} \Omega + 4 \mathrm {k} \Omega) (0 . 0 0 1 8 \mu \mathrm {F})} = 2 0, 0 4 2 \mathrm {H z}
\]</span></p>
<p>So the count is <span class="math inline">\(N = (20,042\mathrm{Hz})(0.01\mathrm{s}) = 200.42\)</span> , or simply 200. A plot of the count versus light intensity is shown in Figure 28. You can see the nonlinearity, which results from the resistor being in the denominator of the frequency equation.</p>
<p>In general, it is important for you to realize that there are simple IC circuits that allow conversion of the sensed quantity directly to frequency. If this frequency is counted using a simple system, as shown in Figure 26, then analog-to-digital conversion has resulted. The conversion time of these circuits is determined by <span class="math inline">\(T_{c}\)</span> and the maximum sensor frequency. Most of the IC circuits can have a maximum frequency of around <span class="math inline">\(100\mathrm{kHz}\)</span> . This means, for example, that an 8-bit converter would need a count time of about <span class="math inline">\(2.55\mathrm{ms}\)</span> . So you can see that conversion times are long compared with successive approximation types of ADCs. For most process-control applications, the slower conversion time is not a limitation.</p>
<p><img src="Books/Johnson_PCIT/chapter_3/3f44fea713a211c29138d89db4c94681_MD5.jpg" class="img-fluid"></p>
<p>FIGURE 28 Response from Example 24.</p>
</section>
<section id="data-acquisition-systems" class="level2">
<h2 class="anchored" data-anchor-id="data-acquisition-systems">4 DATA-ACQUISITION SYSTEMS</h2>
<p>Microprocessor-based personal computers (PCs) are used extensively to implement direct digital control in the process industries. These familiar desktop computers are designed much like the system shown in Figure 24, using a bus that consists of the data lines, address lines, and control lines. All communication with the processor is via these bus lines. This includes essential equipment such as RAM, ROM, disk, and CD-ROM.</p>
<p>The PC also connects the bus lines to a number of printed circuit board (PCB) sockets, using an industry standard configuration of how the bus lines are connected to the socket. These sockets are referred to as expansion slots. Many special types of peripheral equipment such as fax/modem boards, game boards, and network connection boards are designed on PCBs that plug into these expansion slots.</p>
<p>Special PCBs called data-acquisition systems (DASs) have been developed for the purpose of providing for input and output of analog data. These are used when the PC is to be used in a control system. The following paragraphs provide general information about the hardware and software of data-acquisition systems.</p>
</section>
<section id="das-hardware" class="level2">
<h2 class="anchored" data-anchor-id="das-hardware">4.1 DAS Hardware</h2>
<p>The hardware features of a general data-acquisition system are shown in Figure 29. Although there is variation from manufacturer to manufacturer, the system shown in this figure and described herein demonstrates the essential features of DASs.</p>
<p><img src="Books/Johnson_PCIT/chapter_3/6ce899a5a54d9cfb804d66e32998e2de_MD5.jpg" class="img-fluid"></p>
<p>FIGURE 29 Typical layout of a data-acquisition board for use in a personal computer expansion slot.</p>
<p>ADC and S/H The DAS typically has a high-speed, successive approximation-type ADC and a fast S/H circuit. Whenever the DAS is requested to obtain a data sample, the S/H is automatically incorporated into the process. The ADC conversion time constitutes the major part of the data sample acquisition time, but the S/H acquisition time must also be considered to establish maximum throughput.</p>
<p>Analog Multiplexer The analog multiplexer (MUX) allows the DAS to select data from a number of different sources. The MUX has a number of input channels, each of which is connected to a different analog input voltage source. The MUX acts like a multiple set of switches, as illustrated in Figure 30, arranged in such a fashion that any one of the input channels can be selected to provide its voltage to the S/H and ADC. In some cases, the DAS can be programmed to take channel samples sequentially.</p>
<p>Address Decoder/Command Processor The computer can select to input a sample from a given channel by sending an appropriate selection on the address lines and control lines of the computer bus. These are decoded to initiate the proper sequence of commands to the MUX, ADC, and S/H. Another common feature is the ability to program the DAS to take a number of samples from a channel with a specified time between samples. In this case, the computer is notified by interrupt when a sample is ready for input.</p>
<p>DAC and Latch For output purposes, the DAS often includes a latch and DAC. The address decoder/command processor is used to latch data written to the DAS, which is then converted to an appropriate analog signal by the DAC.</p>
</section>
<section id="das-software" class="level2">
<h2 class="anchored" data-anchor-id="das-software">4.2 DAS Software</h2>
<p>The process of selecting a channel and initiating a data input from that channel involves some interface between the computer and the DAS. This interface is facilitated by software that the computer executes. The software can be written by the user, but is often also provided by the DAS manufacturer in the form of programs on disk.</p>
<p><img src="Books/Johnson_PCIT/chapter_3/1f059fbb6b5d5a126f02f495bd25dc28_MD5.jpg" class="img-fluid"></p>
<p>FIGURE 30 An analog multiplexer acts as a multiposition switch for selecting particular inputs to the ADC.</p>
<p>Figure 31 is a flowchart of the basic sequence of operations that must occur when a sample is required from the DAS. The following paragraphs describe each element of the sequence.</p>
<p>Generally, the DAS is mapped into a base port address location in the PC system. In the PC, this address can be from 000H to FFFH, but many addresses are reserved for use by the processor and other peripherals. A common address for input/output (I/O) systems such as the DAS is port 300H.</p>
<p>The sequence starts with selection of a channel for input. This is accomplished by a write to the DAS decoder that identifies the required channel. The MUX then places that channel input voltage at the S/H input.</p>
<p>The software then issues a start-convert (SC) command according to the specifications of the DAS. This is often accomplished by a write to some base + offset address. The DAS internally activates the hold mode of the S/H and starts the converter.</p>
<p>The end-of-convert (EOC) is provided in a status register in the DAS. The contents of this status register can be read by the processor by a port input of a base + offset address. The appropriate bit is then tested by the software to deduce whether the EOC has been issued.</p>
<p>Once the EOC has been issued, the software can input the data itself by a read of an appropriate address, again a base + offset, which enables tri-states, placing the ADC output on the data bus.</p>
<p>There is one problem with the operations described, shown in Figure 31. If the DAS fails, the computer will be locked in the loop waiting for the EOC to be issued. One way to resolve this is to add an additional timer loop for a time greater than the conversion time of the ADC. If the EOC is not detected prior to time-out, an error is announced, and the computer is returned to an error-handling routine.</p>
<p>FIGURE 31 Software for data acquisition involves operations to start the ADC, test the EOC, and input the data.</p>
<p><img src="Books/Johnson_PCIT/chapter_3/321cc346a7291f5833ef2d5cbc1db8a7_MD5.jpg" class="img-fluid"></p>
<p>In some cases, the EOC detection is handled by an interrupt service routine. In this way, the computer is free to execute other software until the interrupt occurs. Then the data is input. Again, there needs to be a system to detect that an EOC was not provided to protect against DAS failure.</p>
</section>
<section id="example-25" class="level2">
<h2 class="anchored" data-anchor-id="example-25">EXAMPLE 25</h2>
<p>A DAS has the following specifications:</p>
<ol type="1">
<li>8 channels</li>
<li>8-bit, bipolar ADC with a 5.0-V reference and a <span class="math inline">\(25 - \mu s\)</span> conversion time</li>
<li>S/H with a <span class="math inline">\(10 - \mu s\)</span> acquisition time</li>
<li>8-bit unipolar DAC with a 10.0-V reference.</li>
</ol>
<pre class="assembly"><code>ADDRESSING: BASE $= 000\mathrm{H}$ to FFFH by switches

BASE + 0: READ inputs data sample

WRITE selects input channel:

$b_{0}$ set selects channel 0, and so forth, to

$b_{7}$ set selects channel 7

BASE + 1: READ inputs ADC status with EOC indicated by $b_{7}$ going low

WRITE initializes the DAS if $b_{7}$ is high, issues SC by taking $b_{0}$ low when $b_{7}$ is low

BASE + 2: READ has no action

WRITE sends data to DAC</code></pre>
<p>Prepare a flowchart showing how a program would take a sample from channel 3. Include a time-out routine that jumps to ERROR (some unspecified routine) if the EOC is not issued after <span class="math inline">\(100\mu \mathrm{s}\)</span> . Use port 300H as the base address.</p>
<p>FIGURE 32 Solution to Example 25.</p>
<p><img src="Books/Johnson_PCIT/chapter_3/aca1cdcb0536c186432dd28238ce5008_MD5.jpg" class="img-fluid"></p>
</section>
<section id="solution-21" class="level2">
<h2 class="anchored" data-anchor-id="solution-21">Solution</h2>
<p>Figure 32 shows a flowchart indicating how the software would provide for an input from channel 3. It would be necessary to discover the value <span class="math inline">\(N\)</span> to provide the <span class="math inline">\(100 - \mu \mathrm{s}\)</span> delay</p>
<p>by determining the time to sequence through the EOC testing loop. Such a flowchart could be implemented in assembly language or a higher-level language such as C, BASIC, or FORTRAN.</p>
</section>
<section id="characteristics-of-digital-data" class="level2">
<h2 class="anchored" data-anchor-id="characteristics-of-digital-data">5 CHARACTERISTICS OF DIGITAL DATA</h2>
<p>There are many advantages to using computers for the controller function. For example, one computer can handle many loops, interaction between loops can be accounted for in the software, data are less susceptible to noise-induced errors, and linearization can be easily provided by software. Other advantages include self-tuning, error correction, and automatic failure recovery.</p>
<p>It seems there should be a price for these advantages, and indeed, there are some disadvantages to the use of computers in controller operations. A serious disadvantage is that conversion of analog data into digital data results in a loss of knowledge about the value of the variable. The nature and consequences of this will be considered.</p>
</section>
<section id="digitized-value" class="level2">
<h2 class="anchored" data-anchor-id="digitized-value">5.1 Digitized Value</h2>
<p>Consider first analog-to-digital conversion (ADC) of analog data into a digital format. The format of the ADC output is an <span class="math inline">\(n\)</span> -bit binary representation of the data. With <span class="math inline">\(n\)</span> -bits it is possible to represent <span class="math inline">\(2^{n}\)</span> values, including zero. There is a finite resolution of the physical data being represented of one part in <span class="math inline">\(2^{n}\)</span> , and that means we now are ignorant about the value of the variable after it has been converted into the binary representation.</p>
<p>In equation form, we can write the relation between a physical variable and its <span class="math inline">\(n\)</span> -bit digital representation as</p>
<p><span class="math display">\[
N = \frac {\left(V - V _ {\min}\right)}{\left(V _ {\max} - V _ {\min}\right)} 2 ^ {n} \tag {29}
\]</span></p>
<p>where <span class="math inline">\(N =\)</span> base 10 equivalent of binary representation</p>
<p><span class="math inline">\(V =\)</span> input value</p>
<p><span class="math inline">\(V_{\mathrm{max}} =\)</span> maximum input value</p>
<p><span class="math inline">\(V_{\mathrm{min}} =\)</span> minimum input value</p>
<p>Only the integer part of the right side of Equation (29) is used to determine <span class="math inline">\(N\)</span> . Equation (29) assumes that the measurement system and ADC have been designed so that the binary output switches from the equivalent of <span class="math inline">\(2^{n} - 1\)</span> to <span class="math inline">\(2^{n}\)</span> just at <span class="math inline">\(V_{\mathrm{max}}\)</span> . The resolution of the measurement can be found by noting what change in <span class="math inline">\(V\)</span> will produce a single-integer (bit) change of <span class="math inline">\(N\)</span> . This is easily seen to be</p>
<p><span class="math display">\[
\Delta V = \left(V _ {\max } - V _ {\min }\right) / 2 ^ {n} \tag {30}
\]</span></p>
<p>The following example illustrates some of the consequences of the digital conversion of data. A careful study of this example will help you understand the limitations of digital representation.</p>
</section>
<section id="example-26" class="level2">
<h2 class="anchored" data-anchor-id="example-26">EXAMPLE 26</h2>
<p>A temperature between <span class="math inline">\(100^{\circ}\mathrm{C}\)</span> and <span class="math inline">\(300^{\circ}\mathrm{C}\)</span> is converted into a 0to 5.0-V signal. This signal is fed to an 8-bit ADC with a 5.0-V reference. What is the actual measurement range of the system?</p>
<ol type="a">
<li><p>What is the resolution?</p></li>
<li><p>What hex output results from <span class="math inline">\(169^{\circ}\mathrm{C}\)</span> ?</p></li>
<li><p>What temperature does a hex output of C5H represent?</p></li>
</ol>
</section>
<section id="solution-22" class="level2">
<h2 class="anchored" data-anchor-id="solution-22">Solution</h2>
<p>The nature of the ADC is that the output will change to FFH at a voltage of <span class="math inline">\(5.0 - 5 / 256 = 4.98\mathrm{V}\)</span> <span class="math inline">\((299.22^{\circ}\mathrm{C})\)</span> and would change to <span class="math inline">\(100\mathrm{H}\)</span> at exactly <span class="math inline">\(5.0\mathrm{V}\)</span> <span class="math inline">\((300^{\circ}\mathrm{C})\)</span> . Thus, FFH would seem to mean any temperature between <span class="math inline">\(299.22^{\circ}\mathrm{C}\)</span> and <span class="math inline">\(300^{\circ}\mathrm{C}\)</span> . Because there is no <span class="math inline">\(100\mathrm{H}\)</span> or higher (only 8 bits), FFH actually means any temperature greater than <span class="math inline">\(299.22^{\circ}\mathrm{C}\)</span> . Similarly, the output will be <span class="math inline">\(00\mathrm{H}\)</span> for any voltage less than <span class="math inline">\(5 / 256 = 0.0195\mathrm{V}\)</span> , which is a temperature of <span class="math inline">\(100.78^{\circ}\mathrm{C}\)</span> , so <span class="math inline">\(00\mathrm{H}\)</span> is output for any temperature less than <span class="math inline">\(100.78^{\circ}\mathrm{C}\)</span> . Thus, the actual measurement range is from <span class="math inline">\(100.78^{\circ}\mathrm{C}\)</span> to <span class="math inline">\(299.22^{\circ}\mathrm{C}\)</span> .</p>
<ol type="a">
<li>The temperature span of <span class="math inline">\((300^{\circ}\mathrm{C} - 100^{\circ}\mathrm{C}) = 200^{\circ}\mathrm{C}\)</span> is divided into <span class="math inline">\(2^{8} = 256\)</span> values. Therefore, the resolution is given by Equation (30).</li>
</ol>
<p><span class="math display">\[
\Delta T = 2 0 0 ^ {\circ} \mathrm {C} / 2 5 6 = 0. 7 8 ^ {\circ} \mathrm {C} / \mathrm {b i t}
\]</span></p>
<p>Let us make sure we understand what this means. If the temperature is <span class="math inline">\(100^{\circ}\mathrm{C}\)</span> , the output will be 00H. It will stay at this value until the temperature reaches <span class="math inline">\(100.78^{\circ}\mathrm{C}\)</span> ; then it will change to 01H. Thus, the resolution of <span class="math inline">\(0.78^{\circ}\mathrm{C}\)</span> means that we are ignorant about the value of the temperature by this amount with any reading.</p>
<ol start="2" type="a">
<li>For every temperature within the range, there is one specific output value. Thus, for a temperature of <span class="math inline">\(169^{\circ}\mathrm{C}\)</span> , we can find that value by Equation (29). We find the fraction of the measurement range <span class="math inline">\(169^{\circ}\mathrm{C}\)</span> represented by</li>
</ol>
<p><span class="math display">\[
N = \frac {(1 6 9 - 1 0 0)}{(3 0 0 - 1 0 0)} 2 ^ {8} = \frac {6 9}{2 0 0} 2 5 6 = (0. 3 4 5) (2 5 6)
\]</span></p>
<p><span class="math display">\[
N = 8 8. 3 2
\]</span></p>
<p>But only the integer part is used, so <span class="math inline">\(88_{10} \rightarrow 58\mathrm{H}\)</span> and, therefore, <span class="math inline">\(169^{\circ}\mathrm{C} \rightarrow 58\mathrm{H}\)</span> . Another way to get this result is to divide the quantity <span class="math inline">\((169 - 100)\)</span> by the resolution to find the fraction of the binary number, <span class="math inline">\(69 / 0.78 = 88.46 \rightarrow 58\mathrm{H}\)</span> (round-off error accounts for the difference).</p>
<ol start="3" type="a">
<li>Now our ignorance of value really shows up. What temperature does C5H represent? The procedure is quite straightforward. We simply solve Equation (29) for <span class="math inline">\(T\)</span> knowing that <span class="math inline">\(\mathrm{C}5\mathrm{H} \rightarrow 197_{10}\)</span></li>
</ol>
<p><span class="math display">\[
1 9 7 = \frac {(T - 1 0 0)}{(3 0 0 - 1 0 0)} 2 5 6
\]</span></p>
<p><span class="math display">\[
T = (1 9 7) (2 0 0) / 2 5 6 + 1 0 0
\]</span></p>
<p><span class="math display">\[
T = 2 5 3. 9 ^ {\circ} \mathrm {C}
\]</span></p>
<p>One of the consequences of the digitizing resolution is that we cannot be expected to control a value any more closely than this resolution. If we were supposed to control temperature to within <span class="math inline">\(\pm 0.2^{\circ}\mathrm{C}\)</span> using the measurement system of Example 26, it would be impossible, because we do not know its value within that tolerance.</p>
<p>Problems of resolution are reduced by using more bits in the digital word. With 16 bits, for example, the resolution is one part in 65,536. With a 16-bit ADC using a <span class="math inline">\(5.0\mathrm{-V}\)</span> reference, the least significant bit is toggled for voltage changes of only <span class="math inline">\(5.0\mathrm{V} / 65,536 = 76.3\mu \mathrm{V}!\)</span> Thus, noise becomes a severe problem in a typical industrial environment.</p>
</section>
<section id="sampled-data-systems" class="level2">
<h2 class="anchored" data-anchor-id="sampled-data-systems">5.2 Sampled Data Systems</h2>
<p>The previous section dealt with the consequences of having only discrete knowledge of the value of the physical variable. Consider also that we have only discrete knowledge of the value in time. That is, the computer control system takes only periodic samples of the variable value. Thus, we are ignorant of the value or variation of the variable between samples. For the control system to function correctly, certain conditions must be assumed about variations between samples. That is what sampled data systems are all about. In the following section, we will consider the nature and consequences of having only periodic samples of the physical variable.</p>
<p>Sampling Rate The key issue with respect to sampling in a computer-based controller is the rate at which samples must be taken. The sample rate is expressed either through <span class="math inline">\(t_s\)</span> , the time between samples, or <span class="math inline">\(f_s = 1 / t_s\)</span> , the sampling frequency.</p>
<p>There is a maximum sampling rate in any system—that is, the time required to take a sample (ADC conversion time) plus the time required to solve the controller equations to determine the appropriate output (program execution time).</p>
<p>There is a minimum sampling rate in any system that depends on the nature of the time variation of the sampled variable. Simply put, samples must be taken at a high enough rate so that the signal can be reconstructed from the samples. There are serious consequences to sampling at too small a rate. For example, the control system will not be able to correct variations of the controlled variable that are missed because too few samples were taken.</p>
<p>Figure 33 illustrates the consequences of sampling rate on knowledge of signal variation. The actual signal is shown in Figure 33a. Figures 33b, 33c, and 33d illustrate knowledge about signal variation deduced from various sample rates. Reconstructed versions of the original signal are indicated by the dashed lines between samples.</p>
<p>The sampling rate of Figure 33b is much too slow, because little information about the actual signal variation is contained in the reconstruction from the samples.</p>
<p>For Figure 33c, the signal seems to possess a frequency of variation that is not in fact present in the actual signal. This is called aliasing, and it is one consequence of too small a sampling rate.</p>
<p><img src="Books/Johnson_PCIT/chapter_3/18c5dee1d769c51994640921d8b12efa_MD5.jpg" class="img-fluid"></p>
<ol type="a">
<li></li>
</ol>
<p><img src="Books/Johnson_PCIT/chapter_3/d3db36ddbff8964c884aeb80d0456e59_MD5.jpg" class="img-fluid"></p>
<ol start="2" type="a">
<li></li>
</ol>
<p><img src="Books/Johnson_PCIT/chapter_3/35a35024f3890766791587aa3b90eb0a_MD5.jpg" class="img-fluid"></p>
<ol start="3" type="a">
<li></li>
</ol>
<p><img src="Books/Johnson_PCIT/chapter_3/53937eb023c0196e9264979a2c91a039_MD5.jpg" class="img-fluid"></p>
<ol start="4" type="a">
<li></li>
</ol>
<p>FIGURE 33 The sampling rate can disguise actual signal details.</p>
<p>The sampling rate of Figure 33d shows that the essential features of the signal can be reconstructed from the samples. A general rule for the minimum sampling rate can be deduced from the maximum frequency of the signal. The rule is that for adequate reconstruction of the signal from samples, the samples must be taken at a frequency that is about 10 times the maximum frequency of the signal.</p>
<p><span class="math display">\[
f _ {s} = 1 0 f _ {\max } \tag {31}
\]</span></p>
<p>where <span class="math inline">\(f_{s} =\)</span> sampling frequency</p>
<p><span class="math inline">\(f_{\mathrm{max}} =\)</span> maximum signal frequency</p>
<p>This is, of course, equivalent to taking 10 samples within the shortest period of the signal.</p>
<p>To determine the minimum sampling rate, an estimate must be made of the highest possible frequency (shortest possible period) of the signal. The sampling frequency will be 10 times that value. For Figure 33d, 6 samples are taken instead of 10 in one basic period of the data. The reconstruction from samples is somewhat crude, but the basic structure is present.</p>
</section>
<section id="example-27" class="level2">
<h2 class="anchored" data-anchor-id="example-27">EXAMPLE 27</h2>
<p>The plot of Figure 34 shows typical data taken from pressure variations in a reaction vessel. Determine the maximum time between samples for a computer control system to be used with this system.</p>
</section>
<section id="solution-23" class="level2">
<h2 class="anchored" data-anchor-id="solution-23">Solution</h2>
<p>An examination of the signal of Figure 34 shows that the shortest time between any two peaks is <span class="math inline">\(0.15\mathrm{s}\)</span> . This gives a maximum signal frequency of <span class="math inline">\(f_{\mathrm{max}} = 1 / 0.15 = 6.7\mathrm{Hz}\)</span> . From Equation (31), the minimum sampling frequency is given by <span class="math inline">\(f_{s} = 10f_{\mathrm{max}} = (10)(6.7\mathrm{Hz}) = 67\mathrm{Hz}\)</span> . The maximum time between samples is <span class="math inline">\(t_s = 1 / f_s = 15\)</span> ms.</p>
<p>It is important to understand the connection between the suggested sampling frequency of Equation (31) and that suggested by the Nyquist sampling frequency. The Nyquist sampling theorem presents a result that, if a signal is bandlimited to a frequency, <span class="math inline">\(f_{\mathrm{max}}\)</span> , then the signal can be reconstructed if sampled at a rate of twice this maximum—that is, <span class="math inline">\(f_{\mathrm{sample}} = 2f_{\mathrm{max}}\)</span> . This is an apparent contradiction to Equation (31).</p>
<p>This contradiction is resolved by two observations. First, practical signals in industry are not bandlimited, which would mean the maximum frequency was infinite. This can be alleviated by filtering the signal to block frequencies beyond some value <span class="math inline">\(f_{\mathrm{max}}\)</span> , effectively providing an artificial band limit, but beyond that which presents real, practical data.</p>
<p>Second, the Nyquist criterion does not specify how many samples must be taken to reconstruct the signal. Indeed, in the limit of sampling at <span class="math inline">\(2f_{\mathrm{max}}\)</span> , an infinite number of samples must be taken. In the practical world, the signal is not regular and periodic. Equation (31) represents a compromise that has been found to provide sufficient samples for practical signal reconstruction.</p>
<p>The cycle time of a process-control fieldbus can also impact the issue of the maximum signal frequency. If the fieldbus is used to take measurement data from a sensor and send the response back to the final control element, the potential delays because of bus traffic limit the controllable maximum frequency.</p>
<p>FIGURE 34 Pressure data for Example 27.</p>
<p><img src="Books/Johnson_PCIT/chapter_3/ea05b9ac5f7a6edb4fcca9cc568338c0_MD5.jpg" class="img-fluid"></p>
</section>
<section id="example-28" class="level2">
<h2 class="anchored" data-anchor-id="example-28">EXAMPLE 28</h2>
<p>A network application is used with a control system that limits cycle time to <span class="math inline">\(450~\mathrm{ms}\)</span> because of heavy bus usage. One of the control systems is to regulate periodic variations of temperature in a reaction chamber. Assuming the computer processing time is negligible, what is the maximum temperature variation frequency that can be controlled?</p>
</section>
<section id="solution-24" class="level2">
<h2 class="anchored" data-anchor-id="solution-24">Solution</h2>
<p>The 450 ms corresponds to the time for requesting a sample from the sensor and then receiving this sample. The total reaction time of the control system should include the time to get a signal back to the final control element. Thus, we add another <span class="math inline">\(225\mathrm{ms}\)</span> to the total processing time. In this case, the sampling frequency is given by</p>
<p><span class="math display">\[
f _ {\mathrm {s}} = 1 / (0. 4 5 + 0. 2 2 5) = 1. 4 8 \mathrm {H z}
\]</span></p>
<p>The maximum frequency of the temperature variation is found from Equation (31):</p>
<p><span class="math display">\[
f _ {\max } = f _ {s} / 1 0 = 0. 1 4 8 \mathrm {H z},
\]</span></p>
<p>or a period of about 6.8 seconds.</p>
</section>
<section id="linearization" class="level2">
<h2 class="anchored" data-anchor-id="linearization">5.3 Linearization</h2>
<p>In many cases, the input binary number and the controlled variable are not linearly related. In such cases, it is necessary to execute a program that will linearize the binary number so that it is proportional to the controlled variable value. There are two common approaches: equation inversion and table look-up.</p>
<p>Linearization by Equation When an equation is known that relates the value of the controlled variable and the binary number in the computer, an equation can be developed to determine the linearized value of the variable. For example, suppose that a transducer outputs a voltage related to pressure by</p>
<p><span class="math display">\[
V = K [ p ] ^ {1 / 2} \tag {32}
\]</span></p>
<p>This voltage is converted to a binary number, <span class="math inline">\(DV\)</span> , by an ADC. Then it is also true that the binary number and pressure are still related by the square root:</p>
<p><span class="math display">\[
D V \text {v a r i e s} [ p ] ^ {1 / 2} \tag {33}
\]</span></p>
<p>What we want is a binary number that is linearly related to pressure. The way to get this is to square <span class="math inline">\(DV\)</span> :</p>
<p><span class="math display">\[
D P = D V * D V \text {v a r i e s} p \tag {34}
\]</span></p>
<p>Thus, the program would input a sample <span class="math inline">\(DV\)</span> and multiply it by itself. The resulting number would be linearly related to the pressure. Of course, there may have to be scale shifts and offsets before we have a number equal to the pressure, as the following example shows.</p>
<p>EXAMPLE Pressure from 50 to <span class="math inline">\(400\mathrm{psi}\)</span> is converted to voltage by the relation</p>
<p>29</p>
<p><span class="math display">\[
V = 0. 3 8 5 [ p ] ^ {1 / 2} - 2. 7 2 2
\]</span></p>
<p>This is input to an ADC with a 5.0-V reference, which provides 00H to FFH over the pressure range. A program uses an instruction <span class="math inline">\(DV = UDF(1)\)</span> to input the data from the ADC as a base 10 number <span class="math inline">\(DV\)</span> that varies from 0 to 255 over the pressure range. Develop a linearization equation to give a quantity, <span class="math inline">\(p\)</span> , in the program that is equal to the actual pressure.</p>
</section>
<section id="solution-25" class="level2">
<h2 class="anchored" data-anchor-id="solution-25">Solution</h2>
<p>We have enough information to work backward through the ADC, signal conditioning, and measurement. Thus, we know the voltage is related to <span class="math inline">\(DV\)</span> by the ADC transformation</p>
<p><span class="math display">\[
D V = (V / V _ {\text {r e f}}) 2 5 6 = (V / 5) 2 5 6
\]</span></p>
<p>or</p>
<p><span class="math display">\[
V = (5 / 2 5 6) D V
\]</span></p>
<p>Then, using the known relation for <span class="math inline">\(V\)</span> in terms of <span class="math inline">\(p\)</span> ,</p>
<p><span class="math display">\[
0. 3 8 5 [ p ] ^ {1 / 2} - 2. 7 2 2 = (5 / 2 5 6) D V
\]</span></p>
<p>and solving for <span class="math inline">\(p\)</span></p>
<p><span class="math display">\[
p = (0. 0 5 0 7 D V + 7. 0 7 1) ^ {2}
\]</span></p>
<p>This number <span class="math inline">\(p\)</span> in the program is equal to the actual pressure value, 50 to 400 psi.</p>
<p>Linearization by Table Look-up There are many measurement processes where it is impossible to find a simple equation such as Equation (32) to relate the controlled variable and the binary number. Also, when the program must be written in assembly language, it may be difficult to evaluate even simple equations such as that of Example 29. In these cases, it becomes much easier to use the look-up table approach.</p>
<p>This is really just what we humans do when we use thermocouple tables, for example. We measure the voltage, go to a table and look up the temperature, and sometimes interpolate. It is the exact same thing with the software approach. The table of input values and corresponding physical variable values are stored in a table in memory. Following a measurement, the input value is looked up in the table and the correct measured value found.</p>
<p>Figure 35 shows a software approach for table look-up in flowchart format. It is assumed that the input values are stored in ascending value in <span class="math inline">\(N\)</span> memory locations and the corresponding physical variable values are stored in the following <span class="math inline">\(N\)</span> locations. Thus, if the input is found at the <span class="math inline">\(I\)</span> th memory location from the start of the table, then the actual variable value is found at the <span class="math inline">\(N + I\)</span> location.</p>
<p>Of course, there are many other methods of table construction and search. In many cases, it is necessary to write interpolation routines by programming equations to refine the values between table values.</p>
<p>FIGURE 35 Linearization by table look-up can be accomplished by the operations in this flowchart.</p>
<p><img src="Books/Johnson_PCIT/chapter_3/a4f08619f79fd919fa2bc21e8ea4f152_MD5.jpg" class="img-fluid"></p>
</section>
<section id="summary" class="level2">
<h2 class="anchored" data-anchor-id="summary">SUMMARY</h2>
<p>This chapter provides a digital electronics background to make the reader conversant with the elements of digital signal conditioning and able to perform simple analysis and design as associated with process control.</p>
<ol type="1">
<li>The use of digital words enables the encoding of analog information into a digital format.</li>
<li>It is possible to encode fractional decimal numbers as binary, and vice versa, using</li>
</ol>
<p><span class="math display">\[
N _ {1 0} = b _ {1} 2 ^ {- 1} + b _ {2} 2 ^ {- 2} + \dots + b _ {m} 2 ^ {- m} \tag {1}
\]</span></p>
<ol type="1">
<li>Boolean algebraic techniques can be applied to the development of process alarms and elementary control functions.</li>
<li>Digital electronic gates and comparators allow the implementation of process Boolean equations.</li>
<li>DACs are used to convert digital words into analog numbers using a fractional-number representative. The resolution is</li>
</ol>
<p><span class="math display">\[
\Delta V = V _ {R} 2 ^ {- n} \tag {8}
\]</span></p>
<ol type="1">
<li>An ADC of the successive approximations type determines an output digital word for an input analog voltage in as many steps as bits to the word.</li>
<li>The dual-slope ADC converts analog to digital information by a combination of integration and time counting.</li>
<li>The data-acquisition system (DAS) is a modular device that interfaces many analog signals to a computer. Signal address decoding, multiplexing, and ADC operations are included in the device.</li>
<li>The sampling rate of a signal must be high enough to assure the signal can be reconstructed from the samples. Generally we must sample about 10 times the maximum signal frequency.</li>
<li>One of the great advantages of digitizing data and feeding it into a computer is that nonlinearities can then be removed by software. This is done by either an equation or by a table look-up process.</li>
</ol>
</section>
<section id="problems" class="level2">
<h2 class="anchored" data-anchor-id="problems">PROBLEMS</h2>
</section>
<section id="section-2" class="level2">
<h2 class="anchored" data-anchor-id="section-2">Section 2</h2>
<p>1 Convert the following binary numbers into decimal, octal, and hex:</p>
<ol type="a">
<li><p><span class="math inline">\(1010_{2}\)</span></p></li>
<li><p>111011</p></li>
<li><p><span class="math inline">\(010110_{2}\)</span></p></li>
</ol>
<p>2 Convert the following binary numbers into decimal, octal, and hex:</p>
<ol type="a">
<li><p><span class="math inline">\(1011010_{2}\)</span></p></li>
<li><p><span class="math inline">\(0.1101_{2}\)</span></p></li>
<li><p>1011.0110</p></li>
</ol>
<p>3 Convert the following decimal numbers into binary, octal, and hex:</p>
<ol type="a">
<li><p><span class="math inline">\(21_{10}\)</span></p></li>
<li><p><span class="math inline">\(630_{10}\)</span></p></li>
<li><p>42710</p></li>
</ol>
<p>4 Convert <span class="math inline">\(27.156_{10}\)</span> into a binary number with the fractional binary part expressed in 6 bits. What actual decimal does this binary fraction equal?</p>
<p>5 Find the 2s complement of</p>
<ol type="a">
<li><p>1011,</p></li>
<li><p>10101100</p></li>
</ol>
<p>6 Prove by a table of values that <span class="math inline">\(\overline{A\cdot B} = \overline{A} +\overline{B}\)</span> (DeMorgan’s theorem).</p>
<p>7 Show that the Boolean equation <span class="math inline">\(A\cdot B + A\cdot \overline{A\cdot B}\)</span> reduces to <span class="math inline">\(A\)</span></p>
<p>A process involves moving speed, load weight, and rate of loading in a conveyor system. The variables are provided as high (1) and low (0) levels for digital control. An alarm should be initiated whenever any of the following occur:</p>
<ol type="a">
<li><p>Speed is low; both weight and loading rate are high.</p></li>
<li><p>Speed is high; loading rate is low.</p></li>
</ol>
<p>Find a Boolean equation describing the required alarm output. Let the variables be <span class="math inline">\(S\)</span> for speed, <span class="math inline">\(W\)</span> for weight, and <span class="math inline">\(R\)</span> for loading rate.</p>
<p>9 Implement Problem 8 with</p>
<ol type="a">
<li><p>AND/OR logic and</p></li>
<li><p>NAND/NOR logic</p></li>
</ol>


</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
  window.document.addEventListener("DOMContentLoaded", function (event) {
    const icon = "";
    const anchorJS = new window.AnchorJS();
    anchorJS.options = {
      placement: 'right',
      icon: icon
    };
    anchorJS.add('.anchored');
    const isCodeAnnotation = (el) => {
      for (const clz of el.classList) {
        if (clz.startsWith('code-annotation-')) {                     
          return true;
        }
      }
      return false;
    }
    const onCopySuccess = function(e) {
      // button target
      const button = e.trigger;
      // don't keep focus
      button.blur();
      // flash "checked"
      button.classList.add('code-copy-button-checked');
      var currentTitle = button.getAttribute("title");
      button.setAttribute("title", "Copied!");
      let tooltip;
      if (window.bootstrap) {
        button.setAttribute("data-bs-toggle", "tooltip");
        button.setAttribute("data-bs-placement", "left");
        button.setAttribute("data-bs-title", "Copied!");
        tooltip = new bootstrap.Tooltip(button, 
          { trigger: "manual", 
            customClass: "code-copy-button-tooltip",
            offset: [0, -8]});
        tooltip.show();    
      }
      setTimeout(function() {
        if (tooltip) {
          tooltip.hide();
          button.removeAttribute("data-bs-title");
          button.removeAttribute("data-bs-toggle");
          button.removeAttribute("data-bs-placement");
        }
        button.setAttribute("title", currentTitle);
        button.classList.remove('code-copy-button-checked');
      }, 1000);
      // clear code selection
      e.clearSelection();
    }
    const getTextToCopy = function(trigger) {
      const outerScaffold = trigger.parentElement.cloneNode(true);
      const codeEl = outerScaffold.querySelector('code');
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
    const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
      text: getTextToCopy
    });
    clipboard.on('success', onCopySuccess);
    if (window.document.getElementById('quarto-embedded-source-code-modal')) {
      const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
        text: getTextToCopy,
        container: window.document.getElementById('quarto-embedded-source-code-modal')
      });
      clipboardModal.on('success', onCopySuccess);
    }
      var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
      var mailtoRegex = new RegExp(/^mailto:/);
        var filterRegex = new RegExp('/' + window.location.host + '/');
      var isInternal = (href) => {
          return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
      }
      // Inspect non-navigation links and adorn them if external
     var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
      for (var i=0; i<links.length; i++) {
        const link = links[i];
        if (!isInternal(link.href)) {
          // undo the damage that might have been done by quarto-nav.js in the case of
          // links that we want to consider external
          if (link.dataset.originalHref !== undefined) {
            link.href = link.dataset.originalHref;
          }
        }
      }
    function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
      const config = {
        allowHTML: true,
        maxWidth: 500,
        delay: 100,
        arrow: false,
        appendTo: function(el) {
            return el.parentElement;
        },
        interactive: true,
        interactiveBorder: 10,
        theme: 'quarto',
        placement: 'bottom-start',
      };
      if (contentFn) {
        config.content = contentFn;
      }
      if (onTriggerFn) {
        config.onTrigger = onTriggerFn;
      }
      if (onUntriggerFn) {
        config.onUntrigger = onUntriggerFn;
      }
      window.tippy(el, config); 
    }
    const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
    for (var i=0; i<noterefs.length; i++) {
      const ref = noterefs[i];
      tippyHover(ref, function() {
        // use id or data attribute instead here
        let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
        try { href = new URL(href).hash; } catch {}
        const id = href.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note) {
          return note.innerHTML;
        } else {
          return "";
        }
      });
    }
    const xrefs = window.document.querySelectorAll('a.quarto-xref');
    const processXRef = (id, note) => {
      // Strip column container classes
      const stripColumnClz = (el) => {
        el.classList.remove("page-full", "page-columns");
        if (el.children) {
          for (const child of el.children) {
            stripColumnClz(child);
          }
        }
      }
      stripColumnClz(note)
      if (id === null || id.startsWith('sec-')) {
        // Special case sections, only their first couple elements
        const container = document.createElement("div");
        if (note.children && note.children.length > 2) {
          container.appendChild(note.children[0].cloneNode(true));
          for (let i = 1; i < note.children.length; i++) {
            const child = note.children[i];
            if (child.tagName === "P" && child.innerText === "") {
              continue;
            } else {
              container.appendChild(child.cloneNode(true));
              break;
            }
          }
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(container);
          }
          return container.innerHTML
        } else {
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(note);
          }
          return note.innerHTML;
        }
      } else {
        // Remove any anchor links if they are present
        const anchorLink = note.querySelector('a.anchorjs-link');
        if (anchorLink) {
          anchorLink.remove();
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        if (note.classList.contains("callout")) {
          return note.outerHTML;
        } else {
          return note.innerHTML;
        }
      }
    }
    for (var i=0; i<xrefs.length; i++) {
      const xref = xrefs[i];
      tippyHover(xref, undefined, function(instance) {
        instance.disable();
        let url = xref.getAttribute('href');
        let hash = undefined; 
        if (url.startsWith('#')) {
          hash = url;
        } else {
          try { hash = new URL(url).hash; } catch {}
        }
        if (hash) {
          const id = hash.replace(/^#\/?/, "");
          const note = window.document.getElementById(id);
          if (note !== null) {
            try {
              const html = processXRef(id, note.cloneNode(true));
              instance.setContent(html);
            } finally {
              instance.enable();
              instance.show();
            }
          } else {
            // See if we can fetch this
            fetch(url.split('#')[0])
            .then(res => res.text())
            .then(html => {
              const parser = new DOMParser();
              const htmlDoc = parser.parseFromString(html, "text/html");
              const note = htmlDoc.getElementById(id);
              if (note !== null) {
                const html = processXRef(id, note);
                instance.setContent(html);
              } 
            }).finally(() => {
              instance.enable();
              instance.show();
            });
          }
        } else {
          // See if we can fetch a full url (with no hash to target)
          // This is a special case and we should probably do some content thinning / targeting
          fetch(url)
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.querySelector('main.content');
            if (note !== null) {
              // This should only happen for chapter cross references
              // (since there is no id in the URL)
              // remove the first header
              if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
                note.children[0].remove();
              }
              const html = processXRef(null, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      }, function(instance) {
      });
    }
        let selectedAnnoteEl;
        const selectorForAnnotation = ( cell, annotation) => {
          let cellAttr = 'data-code-cell="' + cell + '"';
          let lineAttr = 'data-code-annotation="' +  annotation + '"';
          const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
          return selector;
        }
        const selectCodeLines = (annoteEl) => {
          const doc = window.document;
          const targetCell = annoteEl.getAttribute("data-target-cell");
          const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
          const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
          const lines = annoteSpan.getAttribute("data-code-lines").split(",");
          const lineIds = lines.map((line) => {
            return targetCell + "-" + line;
          })
          let top = null;
          let height = null;
          let parent = null;
          if (lineIds.length > 0) {
              //compute the position of the single el (top and bottom and make a div)
              const el = window.document.getElementById(lineIds[0]);
              top = el.offsetTop;
              height = el.offsetHeight;
              parent = el.parentElement.parentElement;
            if (lineIds.length > 1) {
              const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
              const bottom = lastEl.offsetTop + lastEl.offsetHeight;
              height = bottom - top;
            }
            if (top !== null && height !== null && parent !== null) {
              // cook up a div (if necessary) and position it 
              let div = window.document.getElementById("code-annotation-line-highlight");
              if (div === null) {
                div = window.document.createElement("div");
                div.setAttribute("id", "code-annotation-line-highlight");
                div.style.position = 'absolute';
                parent.appendChild(div);
              }
              div.style.top = top - 2 + "px";
              div.style.height = height + 4 + "px";
              div.style.left = 0;
              let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
              if (gutterDiv === null) {
                gutterDiv = window.document.createElement("div");
                gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
                gutterDiv.style.position = 'absolute';
                const codeCell = window.document.getElementById(targetCell);
                const gutter = codeCell.querySelector('.code-annotation-gutter');
                gutter.appendChild(gutterDiv);
              }
              gutterDiv.style.top = top - 2 + "px";
              gutterDiv.style.height = height + 4 + "px";
            }
            selectedAnnoteEl = annoteEl;
          }
        };
        const unselectCodeLines = () => {
          const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
          elementsIds.forEach((elId) => {
            const div = window.document.getElementById(elId);
            if (div) {
              div.remove();
            }
          });
          selectedAnnoteEl = undefined;
        };
          // Handle positioning of the toggle
      window.addEventListener(
        "resize",
        throttle(() => {
          elRect = undefined;
          if (selectedAnnoteEl) {
            selectCodeLines(selectedAnnoteEl);
          }
        }, 10)
      );
      function throttle(fn, ms) {
      let throttle = false;
      let timer;
        return (...args) => {
          if(!throttle) { // first call gets through
              fn.apply(this, args);
              throttle = true;
          } else { // all the others get throttled
              if(timer) clearTimeout(timer); // cancel #2
              timer = setTimeout(() => {
                fn.apply(this, args);
                timer = throttle = false;
              }, ms);
          }
        };
      }
        // Attach click handler to the DT
        const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
        for (const annoteDlNode of annoteDls) {
          annoteDlNode.addEventListener('click', (event) => {
            const clickedEl = event.target;
            if (clickedEl !== selectedAnnoteEl) {
              unselectCodeLines();
              const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
              if (activeEl) {
                activeEl.classList.remove('code-annotation-active');
              }
              selectCodeLines(clickedEl);
              clickedEl.classList.add('code-annotation-active');
            } else {
              // Unselect the line
              unselectCodeLines();
              clickedEl.classList.remove('code-annotation-active');
            }
          });
        }
    const findCites = (el) => {
      const parentEl = el.parentElement;
      if (parentEl) {
        const cites = parentEl.dataset.cites;
        if (cites) {
          return {
            el,
            cites: cites.split(' ')
          };
        } else {
          return findCites(el.parentElement)
        }
      } else {
        return undefined;
      }
    };
    var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
    for (var i=0; i<bibliorefs.length; i++) {
      const ref = bibliorefs[i];
      const citeInfo = findCites(ref);
      if (citeInfo) {
        tippyHover(citeInfo.el, function() {
          var popup = window.document.createElement('div');
          citeInfo.cites.forEach(function(cite) {
            var citeDiv = window.document.createElement('div');
            citeDiv.classList.add('hanging-indent');
            citeDiv.classList.add('csl-entry');
            var biblioDiv = window.document.getElementById('ref-' + cite);
            if (biblioDiv) {
              citeDiv.innerHTML = biblioDiv.innerHTML;
            }
            popup.appendChild(citeDiv);
          });
          return popup.innerHTML;
        });
      }
    }
  });
  </script>
</div> <!-- /content -->




</body></html>