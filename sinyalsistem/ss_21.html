<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.8.25">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="Imron Rosyadi">

<title>Signal and Systems</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
html { -webkit-text-size-adjust: 100%; }
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
</style>


<script src="site_libs/quarto-nav/quarto-nav.js"></script>
<script src="site_libs/quarto-nav/headroom.min.js"></script>
<script src="site_libs/clipboard/clipboard.min.js"></script>
<script src="site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="site_libs/quarto-search/fuse.min.js"></script>
<script src="site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="./">
<script src="site_libs/quarto-html/quarto.js" type="module"></script>
<script src="site_libs/quarto-html/tabsets/tabsets.js" type="module"></script>
<script src="site_libs/quarto-html/axe/axe-check.js" type="module"></script>
<script src="site_libs/quarto-html/popper.min.js"></script>
<script src="site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="site_libs/quarto-html/anchor.min.js"></script>
<link href="site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="site_libs/quarto-html/quarto-syntax-highlighting-7b89279ff1a6dce999919e0e67d4d9ec.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="site_libs/bootstrap/bootstrap.min.js"></script>
<link href="site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="site_libs/bootstrap/bootstrap-e31584831b205ffbb2d98406f31c2a5b.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>
<script type="module" src="site_libs/quarto-ojs/quarto-ojs-runtime.js"></script>
<link href="site_libs/quarto-ojs/quarto-ojs.css" rel="stylesheet">
<script src="site_libs/quarto-diagram/mermaid.min.js"></script>
<script src="site_libs/quarto-diagram/mermaid-init.js"></script>
<link href="site_libs/quarto-diagram/mermaid.css" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN" && texText && texText.data) {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

<link rel="stylesheet" href="styles.css">
</head>

<body class="nav-fixed quarto-light">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a href="./index.html" class="navbar-brand navbar-brand-logo">
    </a>
    <a class="navbar-brand" href="./index.html">
    <span class="navbar-title">Signal and Systems</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" role="menu" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll me-auto">
  <li class="nav-item">
    <a class="nav-link" href="./index.html"> 
<span class="menu-text">Home</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="./about.html"> 
<span class="menu-text">About</span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
            <div class="quarto-navbar-tools">
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">On this page</h2>
   
  <ul>
  <li><a href="#signals-and-systems" id="toc-signals-and-systems" class="nav-link active" data-scroll-target="#signals-and-systems">Signals and Systems</a>
  <ul class="collapse">
  <li><a href="#discrete-time-lti-systems-the-convolution-sum" id="toc-discrete-time-lti-systems-the-convolution-sum" class="nav-link" data-scroll-target="#discrete-time-lti-systems-the-convolution-sum">DISCRETE-TIME LTI SYSTEMS: THE CONVOLUTION SUM</a></li>
  <li><a href="#moment-of-silence" id="toc-moment-of-silence" class="nav-link" data-scroll-target="#moment-of-silence">Moment of Silence</a></li>
  <li><a href="#what-is-a-system" id="toc-what-is-a-system" class="nav-link" data-scroll-target="#what-is-a-system">What is a System?</a></li>
  <li><a href="#signal-decomposition-with-impulses" id="toc-signal-decomposition-with-impulses" class="nav-link" data-scroll-target="#signal-decomposition-with-impulses">Signal Decomposition with Impulses</a>
  <ul class="collapse">
  <li><a href="#the-sifting-property" id="toc-the-sifting-property" class="nav-link" data-scroll-target="#the-sifting-property">The “Sifting Property”</a></li>
  </ul></li>
  <li><a href="#signal-decomposition-with-impulses-1" id="toc-signal-decomposition-with-impulses-1" class="nav-link" data-scroll-target="#signal-decomposition-with-impulses-1">Signal Decomposition with Impulses</a></li>
  <li><a href="#visualizing-decomposition" id="toc-visualizing-decomposition" class="nav-link" data-scroll-target="#visualizing-decomposition">Visualizing Decomposition</a></li>
  <li><a href="#lti-systems-the-convolution-sum" id="toc-lti-systems-the-convolution-sum" class="nav-link" data-scroll-target="#lti-systems-the-convolution-sum">LTI Systems &amp; The Convolution Sum</a></li>
  <li><a href="#the-flip-and-slide-method" id="toc-the-flip-and-slide-method" class="nav-link" data-scroll-target="#the-flip-and-slide-method">The “Flip-and-Slide” Method</a></li>
  <li><a href="#interactive-demo-flip-and-slide" id="toc-interactive-demo-flip-and-slide" class="nav-link" data-scroll-target="#interactive-demo-flip-and-slide">Interactive Demo: Flip-and-Slide</a></li>
  <li><a href="#example-accumulator-system" id="toc-example-accumulator-system" class="nav-link" data-scroll-target="#example-accumulator-system">Example: Accumulator System</a></li>
  <li><a href="#example-accumulator-system-1" id="toc-example-accumulator-system-1" class="nav-link" data-scroll-target="#example-accumulator-system-1">Example: Accumulator System</a></li>
  <li><a href="#example-convolving-two-pulses" id="toc-example-convolving-two-pulses" class="nav-link" data-scroll-target="#example-convolving-two-pulses">Example: Convolving Two Pulses</a></li>
  <li><a href="#application-digital-audio-reverb" id="toc-application-digital-audio-reverb" class="nav-link" data-scroll-target="#application-digital-audio-reverb">Application: Digital Audio Reverb</a></li>
  <li><a href="#application-digital-audio-reverb-1" id="toc-application-digital-audio-reverb-1" class="nav-link" data-scroll-target="#application-digital-audio-reverb-1">Application: Digital Audio Reverb</a></li>
  <li><a href="#summary" id="toc-summary" class="nav-link" data-scroll-target="#summary">Summary</a></li>
  </ul></li>
  </ul>
<div class="quarto-alternate-formats"><h2>Other Formats</h2><ul><li><a href="ss_21.html"><i class="bi bi-file-slides"></i>RevealJS (live)</a></li></ul></div></nav>
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">Signal and Systems</h1>
<p class="subtitle lead">2.1 The Convolution Sum</p>
</div>



<div class="quarto-title-meta">

    <div>
    <div class="quarto-title-meta-heading">Author</div>
    <div class="quarto-title-meta-contents">
             <p>Imron Rosyadi </p>
          </div>
  </div>
    
  
    
  </div>
  


</header>


<section id="signals-and-systems" class="level1">
<h1>Signals and Systems</h1>
<section id="discrete-time-lti-systems-the-convolution-sum" class="level2">
<h2 class="anchored" data-anchor-id="discrete-time-lti-systems-the-convolution-sum">DISCRETE-TIME LTI SYSTEMS: THE CONVOLUTION SUM</h2>
<p><strong>ECE Undergraduate Course</strong></p>
<p>Imron Rosyadi</p>
<div class="notes">
<p>Welcome everyone. Today, we’re diving into one of the most fundamental concepts in Signals and Systems: The Convolution Sum. This operation is the key to understanding how Linear Time-Invariant, or LTI, systems work. By the end of this lecture, you’ll be able to represent any discrete-time signal in a new way and use that representation to find the output of any LTI system for any given input.</p>
</div>
<hr>
</section>
<section id="moment-of-silence" class="level2" data-background-color="black">
<h2 data-background-color="black" class="anchored" data-anchor-id="moment-of-silence">Moment of Silence</h2>
<hr>
</section>
<section id="what-is-a-system" class="level2">
<h2 class="anchored" data-anchor-id="what-is-a-system">What is a System?</h2>
<p>A <strong>system</strong> is a process by which <strong>input signals</strong> are <code>transformed</code> to produce <strong>output signals</strong>.</p>
<div class="cell" data-layout-align="default">
<div class="cell-output-display">
<div>
<p></p><figure class="figure"><p></p>
<div>
<pre class="mermaid mermaid-js">graph LR
    A[Input Signal] --&gt; B(System);
    B --&gt; C[Output Signal];
</pre>
</div>
<p></p></figure><p></p>
</div>
</div>
</div>
<hr>
</section>
<section id="signal-decomposition-with-impulses" class="level2">
<h2 class="anchored" data-anchor-id="signal-decomposition-with-impulses">Signal Decomposition with Impulses</h2>
<p>Any discrete-time signal <span class="math inline">\(x[n]\)</span> can be represented as a sum of scaled and shifted unit impulses.</p>
<p>Think of it as breaking down a signal into its most basic building blocks.</p>
<section id="the-sifting-property" class="level3">
<h3 class="anchored" data-anchor-id="the-sifting-property">The “Sifting Property”</h3>
<p>This decomposition is also known as the <strong><em>sifting property</em></strong> of the unit impulse:</p>
<p><span class="math display">\[
x[n] = \sum_{k=-\infty}^{\infty} x[k] \delta[n-k]
\]</span></p>
<p>For any given <span class="math inline">\(n\)</span>, the summation “sifts” through all values of <span class="math inline">\(x[k]\)</span> and picks out only the one where <span class="math inline">\(k=n\)</span>.</p>
<hr>
</section>
</section>
<section id="signal-decomposition-with-impulses-1" class="level2">
<h2 class="anchored" data-anchor-id="signal-decomposition-with-impulses-1">Signal Decomposition with Impulses</h2>
<div class="cell" data-layout-align="default">
<div class="cell-output-display">
<div>
<p></p><figure class="figure"><p></p>
<div>
<pre class="mermaid mermaid-js">graph TD
    subgraph Decomposing x[n]
        XN("x[n]") --&gt; IMP1("x[-1]δ[n+1]")
        XN --&gt; IMP0("x[0]δ[n]")
        XN --&gt; IMP2("x[1]δ[n-1]")
        XN --&gt; ETC(...)
    end
    subgraph Reconstructing x[n]
        IMP1 --&gt; SUM("(&amp;Sigma;)")
        IMP0 --&gt; SUM
        IMP2 --&gt; SUM
        ETC --&gt; SUM
        SUM --&gt; XN_OUT("x[n]")
    end
</pre>
</div>
<p></p></figure><p></p>
</div>
</div>
</div>
<div class="notes">
<p>The core idea here is incredibly powerful. We take a complex signal, <span class="math inline">\(x[n]\)</span>, and express it as a linear combination of the simplest possible signal: the unit impulse, <span class="math inline">\(\delta[n]\)</span>. Each term in the sum, <span class="math inline">\(x[k]\delta[n-k]\)</span>, isolates a single point from the original signal. The weight of each impulse is simply the value of the signal at that point in time. This representation is the foundation for everything that follows.</p>
</div>
<hr>
</section>
<section id="visualizing-decomposition" class="level2">
<h2 class="anchored" data-anchor-id="visualizing-decomposition">Visualizing Decomposition</h2>
<p>Let’s see this in action. The signal <span class="math inline">\(x[n]\)</span> is built by summing its individual impulse components.</p>
<pre class="{pyodide}"><code>#| max-lines: 15
import numpy as np
import matplotlib.pyplot as plt

n_range = np.arange(-2, 3)
x_vals = { -2: 0.5, -1: -1.0, 0: 2.0, 1: 1.0, 2: -0.5 }
x = np.array([x_vals.get(i, 0) for i in n_range])

fig, axs = plt.subplots(3, 2, figsize=(7, 5), sharex=True, sharey=True)
fig.suptitle('Decomposition of x[n] into Scaled Impulses')

# Plot original signal
axs[0, 0].stem(n_range, x)
axs[0, 0].set_title('Original Signal $x[n]$')

# Plot individual components
components = [(-1, x_vals[-1]), (0, x_vals[0]), (1, x_vals[1]), (2, x_vals[2])]
ax_flat = axs.flat[1:]

for i, (k, val) in enumerate(components):
    if i &lt; len(ax_flat):
      impulse = np.zeros_like(n_range, dtype=float)
      impulse[n_range == k] = val
      ax_flat[i].stem(n_range, impulse)
      ax_flat[i].set_title(f'$x[{k}]\\delta[n-{k}]$')

# Sum subplot
axs[2, 1].stem(n_range, x)
axs[2, 1].set_title('Sum of Components = $x[n]$')

for ax in axs.flat: ax.grid(True)
plt.tight_layout(rect=[0, 0, 1, 0.96])
plt.show()</code></pre>
<div class="notes">
<p>Here you can see the process graphically, just like in Figure 2.1 from the textbook. The top-left plot shows our original signal, <span class="math inline">\(x[n]\)</span>. The next four plots each show a single, scaled impulse. For example, the plot titled <span class="math inline">\(x[0]\delta[n-0]\)</span> is a signal that’s zero everywhere except at <span class="math inline">\(n=0\)</span>, where its value is <span class="math inline">\(x[0]=2.0\)</span>. When we add all these simple impulse components together, as shown in the bottom-right plot, we perfectly reconstruct the original signal.</p>
</div>
<hr>
</section>
<section id="lti-systems-the-convolution-sum" class="level2">
<h2 class="anchored" data-anchor-id="lti-systems-the-convolution-sum">LTI Systems &amp; The Convolution Sum</h2>
<p>How does an <strong>LTI</strong> system respond to an input <span class="math inline">\(x[n]\)</span>?</p>
<ol type="1">
<li><strong>Linearity:</strong> The response to a sum of inputs is the sum of the individual responses.
<ul>
<li>Input: <span class="math inline">\(x[n] = \sum_k x[k] \delta[n-k]\)</span></li>
<li>Output: <span class="math inline">\(y[n] = \sum_k x[k] \cdot \{\text{Response to } \delta[n-k]\}\)</span></li>
</ul></li>
<li><strong>Time-Invariance:</strong> A shift in the input causes the same shift in the output.
<ul>
<li>Response to <span class="math inline">\(\delta[n]\)</span> is the <strong>impulse response</strong>, <span class="math inline">\(h[n]\)</span>.</li>
<li>Response to <span class="math inline">\(\delta[n-k]\)</span> is just a shifted impulse response, <span class="math inline">\(h[n-k]\)</span>.</li>
</ul></li>
</ol>
<p>Combining these gives the <strong>Convolution Sum</strong>:</p>
<p><span class="math display">\[
y[n] = \sum_{k=-\infty}^{\infty} x[k] h[n-k]
\]</span></p>
<p>We denote this operation with an asterisk: <span class="math inline">\(y[n] = x[n] * h[n]\)</span>.</p>
<div class="notes">
<p>This is the central result. Because the system is linear, we can find the output by summing the responses to all the simple impulse components of the input. And because the system is time-invariant, the response to a shifted impulse <span class="math inline">\(\delta[n-k]\)</span> is just a shifted version of the response to a non-shifted impulse <span class="math inline">\(\delta[n]\)</span>. We call the response to <span class="math inline">\(\delta[n]\)</span> the “impulse response” and denote it <span class="math inline">\(h[n]\)</span>. By putting these two properties together, we arrive at the convolution sum. It tells us that the output <span class="math inline">\(y[n]\)</span> is a weighted sum of shifted versions of the impulse response. The weights are the values of the input signal, <span class="math inline">\(x[k]\)</span>.</p>
</div>
<hr>
</section>
<section id="the-flip-and-slide-method" class="level2">
<h2 class="anchored" data-anchor-id="the-flip-and-slide-method">The “Flip-and-Slide” Method</h2>
<p>The convolution sum <span class="math inline">\(y[n]=\sum_{k=-\infty}^{\infty} x[k] h[n-k]\)</span> can be computed graphically for each output sample <code>n</code>.</p>
<p><strong>Procedure for a fixed <code>n</code>:</strong></p>
<ol type="1">
<li><strong>Plot signals vs.&nbsp;<code>k</code>:</strong> Plot the input <span class="math inline">\(x[k]\)</span> and the impulse response <span class="math inline">\(h[k]\)</span>.</li>
<li><strong>Flip:</strong> Time-reverse <span class="math inline">\(h[k]\)</span> to get <span class="math inline">\(h[-k]\)</span>.</li>
<li><strong>Slide:</strong> Shift <span class="math inline">\(h[-k]\)</span> by <span class="math inline">\(n\)</span> to get <span class="math inline">\(h[n-k]\)</span>.
<ul>
<li>Shift right for <span class="math inline">\(n &gt; 0\)</span>; left for <span class="math inline">\(n &lt; 0\)</span>.</li>
</ul></li>
<li><strong>Multiply:</strong> Point-wise multiply the sequences <span class="math inline">\(x[k]\)</span> and <span class="math inline">\(h[n-k]\)</span>.</li>
<li><strong>Sum:</strong> Sum all the values of the product sequence. The result is <span class="math inline">\(y[n]\)</span>.</li>
</ol>
<p>Repeat for all values of <code>n</code> to find the entire output signal <span class="math inline">\(y[n]\)</span>.</p>
<div class="notes">
<p>While the formula looks abstract, there’s a very mechanical, graphical way to compute it, which we call the “flip-and-slide” method. The key is to think of <code>n</code> as a fixed value for now. We are trying to compute a single output point, y[n]. The expression involves a sum over the dummy variable <code>k</code>. So, we plot both signals, x and h, as functions of <code>k</code>. The tricky part is the term <span class="math inline">\(h[n-k]\)</span>. As a function of <code>k</code>, it’s a flipped and shifted version of the original impulse response. Once you have <span class="math inline">\(x[k]\)</span> and <span class="math inline">\(h[n-k]\)</span> plotted, you just multiply them point by point and add up all the results. That sum gives you the single value <span class="math inline">\(y[n]\)</span>. Then you change <code>n</code> and do it all over again.</p>
</div>
<hr>
</section>
<section id="interactive-demo-flip-and-slide" class="level2">
<h2 class="anchored" data-anchor-id="interactive-demo-flip-and-slide">Interactive Demo: Flip-and-Slide</h2>
<ul>
<li><span class="math inline">\(x[n] = 0.5\delta[n] + 2\delta[n-1]\)</span></li>
<li><span class="math inline">\(h[n] = u[n] - u[n-3]\)</span></li>
</ul>
<p>Use the slider to change the value of <code>n</code> and observe the convolution process.</p>
<div class="cell">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb2" data-startfrom="196" data-source-offset="0"><pre class="sourceCode js code-with-copy"><code class="sourceCode javascript" style="counter-reset: source-line 195;"><span id="cb2-196"><a href="#cb2-196" aria-hidden="true" tabindex="-1"></a>viewof n <span class="op">=</span> Inputs<span class="op">.</span><span class="fu">range</span>([<span class="op">-</span><span class="dv">4</span><span class="op">,</span> <span class="dv">12</span>]<span class="op">,</span> {<span class="dt">value</span><span class="op">:</span> <span class="dv">2</span><span class="op">,</span> <span class="dt">step</span><span class="op">:</span> <span class="dv">1</span><span class="op">,</span> <span class="dt">label</span><span class="op">:</span> <span class="st">"Time shift (n)"</span>})<span class="op">;</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<div class="cell-output cell-output-display">
<div id="ojs-cell-1" data-nodetype="declaration">

</div>
</div>
</div>
<pre class="{pyodide}"><code>#| edit: false
#| echo: false
#| input:
#|   - n

import numpy as np
import matplotlib.pyplot as plt

# Define the signals
k_range = np.arange(-2, 7)
x = np.zeros_like(k_range, dtype=float)
x[k_range == 0] = 0.5
x[k_range == 1] = 2.0

h_base = np.zeros_like(k_range, dtype=float)
h_base[(k_range &gt;= 0) &amp; (k_range &lt;= 2)] = 1.0

# Pre-compute the full convolution result y[n]
y_full = np.convolve(x, h_base, 'full')
y_range = np.arange(k_range[0]*2, len(y_full) + k_range[0]*2)


def plot_convolution_step(n_val):
    fig, (ax1, ax2, ax3) = plt.subplots(3, 1, figsize=(8, 6), sharex=True)
    fig.tight_layout(pad=3.0)

    # 1. Flip &amp; Slide
    h_flipped_shifted = np.zeros_like(k_range, dtype=float)
    # Calculate the indices for the flipped and shifted h
    h_indices = n_val - k_range
    # Create a mask for the valid indices of h (0 to 2)
    mask = (h_indices &gt;= 0) &amp; (h_indices &lt;= 2)
    h_flipped_shifted[mask] = 1.0
    
    ax1.stem(k_range, x, label='$x[k]$', basefmt=" ")
    ax1.stem(k_range, h_flipped_shifted, label=f'$h[{n_val}-k]$', linefmt='r-', markerfmt='ro', basefmt=" ")
    ax1.set_title(f'1. Flip &amp; Slide (for n={n_val})')
    ax1.legend()
    ax1.grid(True)
    ax1.set_ylim(0, 3)

    # 2. Multiply
    product = x * h_flipped_shifted
    ax2.stem(k_range, product, linefmt='g-', markerfmt='go', basefmt=" ")
    ax2.set_title(f'2. Multiply: $x[k]h[{n_val}-k]$')
    ax2.grid(True)
    ax2.set_ylim(0, 3)
  
    # 3. Sum
    y_val = np.sum(product)
    ax3.stem(y_range, y_full, linefmt='k-', markerfmt='ko', basefmt=' ')
    ax3.stem([n_val], [y_val], 'c^', label=f'$y[{n_val}] = \\Sigma = {y_val:.1f}$', basefmt=' ', markerfmt='c^', linefmt='c-')
    ax3.set_title('3. Sum to get Output $y[n]$')
    ax3.legend()
    ax3.grid(True)
    ax3.set_xlabel('n (time)')
    ax3.set_xlim(y_range[0], y_range[-1])
    ax3.set_ylim(0, 3)
  
    plt.show()

# Call the function with the value from the slider
plot_convolution_step(n)</code></pre>
<div class="notes">
<p>This interactive demo brings the flip-and-slide method to life. The top plot shows the stationary input signal <span class="math inline">\(x[k]\)</span> in blue and the <em>flipped and shifted</em> impulse response, <span class="math inline">\(h[n-k]\)</span>, in red. As you move the slider for <code>n</code>, you can see the red signal slide. The middle plot shows the point-wise product. The bottom plot shows the final output signal <span class="math inline">\(y[n]\)</span>. The cyan triangle shows the value of <span class="math inline">\(y[n]\)</span> for the <em>current</em> <code>n</code>, which is calculated by summing the green stems in the middle plot.</p>
</div>
<hr>
</section>
<section id="example-accumulator-system" class="level2">
<h2 class="anchored" data-anchor-id="example-accumulator-system">Example: Accumulator System</h2>
<p>Let’s convolve an exponential signal with a unit step. This models a system called an <strong>accumulator</strong>.</p>
<p><strong>Problem</strong></p>
<ul>
<li>Input: <span class="math inline">\(x[n] = \alpha^n u[n]\)</span>, for <span class="math inline">\(0 &lt; \alpha &lt; 1\)</span>.</li>
<li>Impulse Response: <span class="math inline">\(h[n] = u[n]\)</span>.</li>
</ul>
<p><strong>Analysis</strong></p>
<ul>
<li>For <span class="math inline">\(n &lt; 0\)</span>, there’s no overlap between <span class="math inline">\(x[k]\)</span> and <span class="math inline">\(h[n-k]\)</span>. So, <span class="math inline">\(y[n] = 0\)</span>.</li>
<li>For <span class="math inline">\(n \ge 0\)</span>, the overlap is for <span class="math inline">\(0 \le k \le n\)</span>. <span class="math display">\[
y[n] = \sum_{k=0}^{n} \alpha^k = \frac{1 - \alpha^{n+1}}{1 - \alpha}
\]</span> <strong>Result:</strong> <span class="math inline">\(y[n] = \left(\frac{1 - \alpha^{n+1}}{1 - \alpha}\right) u[n]\)</span>.</li>
</ul>
<hr>
</section>
<section id="example-accumulator-system-1" class="level2">
<h2 class="anchored" data-anchor-id="example-accumulator-system-1">Example: Accumulator System</h2>
<pre class="{pyodide}"><code>#| max-lines: 10
import numpy as np
import matplotlib.pyplot as plt

alpha = 0.8; n = np.arange(-2, 21)
x = (alpha**n) * (n &gt;= 0)
h = (n &gt;= 0).astype(float)
y = ((1 - alpha**(n + 1)) / (1 - alpha)) * (n &gt;= 0)

fig, (ax1, ax2) = plt.subplots(1, 2, figsize=(7, 3.5))

ax1.stem(n, x, 'b', markerfmt='bo', label='$x[n]$')
ax1.stem(n, h, 'r', markerfmt='ro', label='$h[n]$')
ax1.set_title('Input &amp; Impulse Response'); ax1.legend(); ax1.grid(True)

ax2.stem(n, y, 'g', markerfmt='go')
ax2.set_title('Output $y[n]=x[n]*h[n]$'); ax2.grid(True)

fig.supxlabel('n'); plt.tight_layout(); plt.show()</code></pre>
<div class="notes">
<p>This is a classic example. The impulse response, <span class="math inline">\(h[n]=u[n]\)</span>, defines an accumulator. We feed in a decaying exponential signal. As seen in the derivation, the output is zero for <span class="math inline">\(n&lt;0\)</span> because there is no overlap. For <span class="math inline">\(n \ge 0\)</span>, the sum is a finite geometric series. The plot on the right shows the output starting at <span class="math inline">\(y[0]=1\)</span> and rising to a final value of <span class="math inline">\(1/(1-\alpha)\)</span>.</p>
</div>
<hr>
</section>
<section id="example-convolving-two-pulses" class="level2">
<h2 class="anchored" data-anchor-id="example-convolving-two-pulses">Example: Convolving Two Pulses</h2>
<p>Let’s convolve two finite-length pulses. The output shape and length depend on the inputs.</p>
<ul>
<li><span class="math inline">\(x[n] = 1\)</span> for <span class="math inline">\(0 \le n \le 4\)</span>.</li>
<li><span class="math inline">\(h[n] = \alpha^n\)</span> for <span class="math inline">\(0 \le n \le 6\)</span> (with <span class="math inline">\(\alpha &gt; 1\)</span>).</li>
</ul>
<p>The convolution <span class="math inline">\(y[n]\)</span> is non-zero for <span class="math inline">\(0 \le n \le 10\)</span>, with a trapezoidal shape due to changing overlap.</p>
<pre class="{pyodide}"><code>#| max-lines: 15
import numpy as np
import matplotlib.pyplot as plt

alpha = 1.1; N_x = 5; N_h = 7
n_x = np.arange(0, N_x); x = np.ones_like(n_x)
n_h = np.arange(0, N_h); h = alpha**n_h
y = np.convolve(x, h); n_y = np.arange(0, len(y))

fig, (ax1, ax2) = plt.subplots(1, 2, figsize=(7, 3.5))

ax1.stem(n_x, x, 'b', markerfmt='bo', label='$x[n]$')
ax1.stem(n_h, h, 'r', markerfmt='ro', label='$h[n]$')
ax1.set_title('Input Pulses'); ax1.legend(); ax1.grid(True)

ax2.stem(n_y, y, 'g', markerfmt='go')
ax2.set_title('Output $y[n]=x[n]*h[n]$'); ax2.grid(True)
fig.supxlabel('n'); plt.tight_layout(); plt.show()</code></pre>
<div class="notes">
<p>Here we convolve two pulses of finite length. The key to solving this analytically is to break it down into five regions for <code>n</code> based on the overlap: no overlap, partial increasing overlap, full overlap, partial decreasing overlap, and no overlap again. The result has a trapezoidal shape and its length is <span class="math inline">\(N_x + N_h - 1 = 5 + 7 - 1 = 11\)</span> samples. This length property is general for the convolution of two finite-length sequences.</p>
</div>
<hr>
</section>
<section id="application-digital-audio-reverb" class="level2">
<h2 class="anchored" data-anchor-id="application-digital-audio-reverb">Application: Digital Audio Reverb</h2>
<p>Convolution is used in audio engineering to create effects like reverberation (reverb).</p>
<ul>
<li><strong>Input Signal <span class="math inline">\(x[n]\)</span>:</strong> A “dry” audio signal (e.g., a single clap).</li>
<li><strong>Impulse Response <span class="math inline">\(h[n]\)</span>:</strong> The “room response.” This is what you would record if you made a perfect impulse (like a starter pistol shot) in a concert hall. It captures all the echoes.</li>
<li><strong>Output Signal <span class="math inline">\(y[n]\)</span>:</strong> The “wet” audio signal, with reverb. <span class="math display">\[y[n] = x[n] * h[n]\]</span></li>
</ul>
<p>By convolving any dry sound with the impulse response of a space, we can make it sound like it was recorded there!</p>
<hr>
</section>
<section id="application-digital-audio-reverb-1" class="level2">
<h2 class="anchored" data-anchor-id="application-digital-audio-reverb-1">Application: Digital Audio Reverb</h2>
<div class="cell" data-layout-align="default">
<div class="cell-output-display">
<div>
<p></p><figure class="figure"><p></p>
<div>
<pre class="mermaid mermaid-js">graph TD
    A["Dry Audio&lt;br&gt;x[n]"] --&gt; C{"Convolution&lt;br&gt;y[n] = x[n]*h[n]"};
    B["Room Impulse Response&lt;br&gt;h[n]"] --&gt; C;
    C --&gt; D["Audio with Reverb&lt;br&gt;y[n]"];
</pre>
</div>
<p></p></figure><p></p>
</div>
</div>
</div>
<div class="notes">
<p>Let’s talk about a fun, real-world application: creating artificial reverb for music and movies. Imagine you record a singer in a perfectly “dead” room with no echoes. This is your dry input signal, <span class="math inline">\(x[n]\)</span>. Now, you go to a large cathedral and pop a balloon. The sound you record—a series of echoes that die out—is the impulse response, <span class="math inline">\(h[n]\)</span>, of the cathedral. If you convolve the singer’s dry vocal track with the cathedral’s impulse response, the output will sound exactly as if the singer was performing there! This is the principle behind most digital reverb plugins.</p>
</div>
<hr>
</section>
<section id="summary" class="level2">
<h2 class="anchored" data-anchor-id="summary">Summary</h2>
<ul>
<li><p><strong>Signal Decomposition:</strong> Any discrete signal <span class="math inline">\(x[n]\)</span> can be written as a sum of scaled, shifted impulses: <span class="math inline">\(x[n] = \sum_k x[k]\delta[n-k]\)</span>.</p></li>
<li><p><strong>LTI System Response:</strong> The output <span class="math inline">\(y[n]\)</span> of an LTI system is the input <span class="math inline">\(x[n]\)</span> convolved with the system’s <strong>impulse response</strong> <span class="math inline">\(h[n]\)</span>.</p></li>
<li><p><strong>The Convolution Sum:</strong> This fundamental operation is defined as: <span class="math display">\[ y[n] = x[n] * h[n] = \sum_{k=-\infty}^{\infty} x[k]h[n-k] \]</span></p></li>
<li><p><strong>Calculation:</strong> We can compute this using the graphical <strong>“flip-and-slide”</strong> method.</p></li>
<li><p><strong>Key Insight:</strong> The impulse response <span class="math inline">\(h[n]\)</span> is a complete characterization of an LTI system. If you know <span class="math inline">\(h[n]\)</span>, you know how the system will react to <em>any</em> input.</p></li>
</ul>
<div class="notes">
<p>Let’s recap. We started with the idea that any signal can be broken down into impulses. This allowed us to derive the convolution sum, which is the mathematical tool for finding the output of any LTI system. We learned the practical “flip-and-slide” method for computing it. And most importantly, we established that the impulse response, <span class="math inline">\(h[n]\)</span>, is the ultimate fingerprint of an LTI system. It tells you everything you need to know about its behavior.</p>
</div>


</section>
</section>

</main> <!-- /main -->
<script type="ojs-module-contents">
eyJjb250ZW50cyI6W3sibWV0aG9kTmFtZSI6ImludGVycHJldCIsImNlbGxOYW1lIjoib2pzLWNlbGwtMSIsImlubGluZSI6ZmFsc2UsInNvdXJjZSI6InZpZXdvZiBuID0gSW5wdXRzLnJhbmdlKFstNCwgMTJdLCB7dmFsdWU6IDIsIHN0ZXA6IDEsIGxhYmVsOiBcIlRpbWUgc2hpZnQgKG4pXCJ9KTtcbiJ9LHsibWV0aG9kTmFtZSI6ImludGVycHJldFF1aWV0Iiwic291cmNlIjoic2hpbnlJbnB1dCgnbicpIn1dfQ==
</script>
<script type="module">
if (window.location.protocol === "file:") { alert("The OJS runtime does not work with file:// URLs. Please use a web server to view this document."); }
window._ojs.paths.runtimeToDoc = "../..";
window._ojs.paths.runtimeToRoot = "../..";
window._ojs.paths.docToRoot = "";
window._ojs.selfContained = false;
window._ojs.runtime.interpretFromScriptTags();
</script>
<script id="quarto-html-after-body" type="application/javascript">
  window.document.addEventListener("DOMContentLoaded", function (event) {
    const icon = "";
    const anchorJS = new window.AnchorJS();
    anchorJS.options = {
      placement: 'right',
      icon: icon
    };
    anchorJS.add('.anchored');
    const isCodeAnnotation = (el) => {
      for (const clz of el.classList) {
        if (clz.startsWith('code-annotation-')) {                     
          return true;
        }
      }
      return false;
    }
    const onCopySuccess = function(e) {
      // button target
      const button = e.trigger;
      // don't keep focus
      button.blur();
      // flash "checked"
      button.classList.add('code-copy-button-checked');
      var currentTitle = button.getAttribute("title");
      button.setAttribute("title", "Copied!");
      let tooltip;
      if (window.bootstrap) {
        button.setAttribute("data-bs-toggle", "tooltip");
        button.setAttribute("data-bs-placement", "left");
        button.setAttribute("data-bs-title", "Copied!");
        tooltip = new bootstrap.Tooltip(button, 
          { trigger: "manual", 
            customClass: "code-copy-button-tooltip",
            offset: [0, -8]});
        tooltip.show();    
      }
      setTimeout(function() {
        if (tooltip) {
          tooltip.hide();
          button.removeAttribute("data-bs-title");
          button.removeAttribute("data-bs-toggle");
          button.removeAttribute("data-bs-placement");
        }
        button.setAttribute("title", currentTitle);
        button.classList.remove('code-copy-button-checked');
      }, 1000);
      // clear code selection
      e.clearSelection();
    }
    const getTextToCopy = function(trigger) {
      const outerScaffold = trigger.parentElement.cloneNode(true);
      const codeEl = outerScaffold.querySelector('code');
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
    const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
      text: getTextToCopy
    });
    clipboard.on('success', onCopySuccess);
    if (window.document.getElementById('quarto-embedded-source-code-modal')) {
      const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
        text: getTextToCopy,
        container: window.document.getElementById('quarto-embedded-source-code-modal')
      });
      clipboardModal.on('success', onCopySuccess);
    }
      var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
      var mailtoRegex = new RegExp(/^mailto:/);
        var filterRegex = new RegExp('/' + window.location.host + '/');
      var isInternal = (href) => {
          return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
      }
      // Inspect non-navigation links and adorn them if external
     var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
      for (var i=0; i<links.length; i++) {
        const link = links[i];
        if (!isInternal(link.href)) {
          // undo the damage that might have been done by quarto-nav.js in the case of
          // links that we want to consider external
          if (link.dataset.originalHref !== undefined) {
            link.href = link.dataset.originalHref;
          }
        }
      }
    function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
      const config = {
        allowHTML: true,
        maxWidth: 500,
        delay: 100,
        arrow: false,
        appendTo: function(el) {
            return el.parentElement;
        },
        interactive: true,
        interactiveBorder: 10,
        theme: 'quarto',
        placement: 'bottom-start',
      };
      if (contentFn) {
        config.content = contentFn;
      }
      if (onTriggerFn) {
        config.onTrigger = onTriggerFn;
      }
      if (onUntriggerFn) {
        config.onUntrigger = onUntriggerFn;
      }
      window.tippy(el, config); 
    }
    const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
    for (var i=0; i<noterefs.length; i++) {
      const ref = noterefs[i];
      tippyHover(ref, function() {
        // use id or data attribute instead here
        let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
        try { href = new URL(href).hash; } catch {}
        const id = href.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note) {
          return note.innerHTML;
        } else {
          return "";
        }
      });
    }
    const xrefs = window.document.querySelectorAll('a.quarto-xref');
    const processXRef = (id, note) => {
      // Strip column container classes
      const stripColumnClz = (el) => {
        el.classList.remove("page-full", "page-columns");
        if (el.children) {
          for (const child of el.children) {
            stripColumnClz(child);
          }
        }
      }
      stripColumnClz(note)
      if (id === null || id.startsWith('sec-')) {
        // Special case sections, only their first couple elements
        const container = document.createElement("div");
        if (note.children && note.children.length > 2) {
          container.appendChild(note.children[0].cloneNode(true));
          for (let i = 1; i < note.children.length; i++) {
            const child = note.children[i];
            if (child.tagName === "P" && child.innerText === "") {
              continue;
            } else {
              container.appendChild(child.cloneNode(true));
              break;
            }
          }
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(container);
          }
          return container.innerHTML
        } else {
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(note);
          }
          return note.innerHTML;
        }
      } else {
        // Remove any anchor links if they are present
        const anchorLink = note.querySelector('a.anchorjs-link');
        if (anchorLink) {
          anchorLink.remove();
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        if (note.classList.contains("callout")) {
          return note.outerHTML;
        } else {
          return note.innerHTML;
        }
      }
    }
    for (var i=0; i<xrefs.length; i++) {
      const xref = xrefs[i];
      tippyHover(xref, undefined, function(instance) {
        instance.disable();
        let url = xref.getAttribute('href');
        let hash = undefined; 
        if (url.startsWith('#')) {
          hash = url;
        } else {
          try { hash = new URL(url).hash; } catch {}
        }
        if (hash) {
          const id = hash.replace(/^#\/?/, "");
          const note = window.document.getElementById(id);
          if (note !== null) {
            try {
              const html = processXRef(id, note.cloneNode(true));
              instance.setContent(html);
            } finally {
              instance.enable();
              instance.show();
            }
          } else {
            // See if we can fetch this
            fetch(url.split('#')[0])
            .then(res => res.text())
            .then(html => {
              const parser = new DOMParser();
              const htmlDoc = parser.parseFromString(html, "text/html");
              const note = htmlDoc.getElementById(id);
              if (note !== null) {
                const html = processXRef(id, note);
                instance.setContent(html);
              } 
            }).finally(() => {
              instance.enable();
              instance.show();
            });
          }
        } else {
          // See if we can fetch a full url (with no hash to target)
          // This is a special case and we should probably do some content thinning / targeting
          fetch(url)
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.querySelector('main.content');
            if (note !== null) {
              // This should only happen for chapter cross references
              // (since there is no id in the URL)
              // remove the first header
              if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
                note.children[0].remove();
              }
              const html = processXRef(null, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      }, function(instance) {
      });
    }
        let selectedAnnoteEl;
        const selectorForAnnotation = ( cell, annotation) => {
          let cellAttr = 'data-code-cell="' + cell + '"';
          let lineAttr = 'data-code-annotation="' +  annotation + '"';
          const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
          return selector;
        }
        const selectCodeLines = (annoteEl) => {
          const doc = window.document;
          const targetCell = annoteEl.getAttribute("data-target-cell");
          const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
          const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
          const lines = annoteSpan.getAttribute("data-code-lines").split(",");
          const lineIds = lines.map((line) => {
            return targetCell + "-" + line;
          })
          let top = null;
          let height = null;
          let parent = null;
          if (lineIds.length > 0) {
              //compute the position of the single el (top and bottom and make a div)
              const el = window.document.getElementById(lineIds[0]);
              top = el.offsetTop;
              height = el.offsetHeight;
              parent = el.parentElement.parentElement;
            if (lineIds.length > 1) {
              const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
              const bottom = lastEl.offsetTop + lastEl.offsetHeight;
              height = bottom - top;
            }
            if (top !== null && height !== null && parent !== null) {
              // cook up a div (if necessary) and position it 
              let div = window.document.getElementById("code-annotation-line-highlight");
              if (div === null) {
                div = window.document.createElement("div");
                div.setAttribute("id", "code-annotation-line-highlight");
                div.style.position = 'absolute';
                parent.appendChild(div);
              }
              div.style.top = top - 2 + "px";
              div.style.height = height + 4 + "px";
              div.style.left = 0;
              let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
              if (gutterDiv === null) {
                gutterDiv = window.document.createElement("div");
                gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
                gutterDiv.style.position = 'absolute';
                const codeCell = window.document.getElementById(targetCell);
                const gutter = codeCell.querySelector('.code-annotation-gutter');
                gutter.appendChild(gutterDiv);
              }
              gutterDiv.style.top = top - 2 + "px";
              gutterDiv.style.height = height + 4 + "px";
            }
            selectedAnnoteEl = annoteEl;
          }
        };
        const unselectCodeLines = () => {
          const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
          elementsIds.forEach((elId) => {
            const div = window.document.getElementById(elId);
            if (div) {
              div.remove();
            }
          });
          selectedAnnoteEl = undefined;
        };
          // Handle positioning of the toggle
      window.addEventListener(
        "resize",
        throttle(() => {
          elRect = undefined;
          if (selectedAnnoteEl) {
            selectCodeLines(selectedAnnoteEl);
          }
        }, 10)
      );
      function throttle(fn, ms) {
      let throttle = false;
      let timer;
        return (...args) => {
          if(!throttle) { // first call gets through
              fn.apply(this, args);
              throttle = true;
          } else { // all the others get throttled
              if(timer) clearTimeout(timer); // cancel #2
              timer = setTimeout(() => {
                fn.apply(this, args);
                timer = throttle = false;
              }, ms);
          }
        };
      }
        // Attach click handler to the DT
        const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
        for (const annoteDlNode of annoteDls) {
          annoteDlNode.addEventListener('click', (event) => {
            const clickedEl = event.target;
            if (clickedEl !== selectedAnnoteEl) {
              unselectCodeLines();
              const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
              if (activeEl) {
                activeEl.classList.remove('code-annotation-active');
              }
              selectCodeLines(clickedEl);
              clickedEl.classList.add('code-annotation-active');
            } else {
              // Unselect the line
              unselectCodeLines();
              clickedEl.classList.remove('code-annotation-active');
            }
          });
        }
    const findCites = (el) => {
      const parentEl = el.parentElement;
      if (parentEl) {
        const cites = parentEl.dataset.cites;
        if (cites) {
          return {
            el,
            cites: cites.split(' ')
          };
        } else {
          return findCites(el.parentElement)
        }
      } else {
        return undefined;
      }
    };
    var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
    for (var i=0; i<bibliorefs.length; i++) {
      const ref = bibliorefs[i];
      const citeInfo = findCites(ref);
      if (citeInfo) {
        tippyHover(citeInfo.el, function() {
          var popup = window.document.createElement('div');
          citeInfo.cites.forEach(function(cite) {
            var citeDiv = window.document.createElement('div');
            citeDiv.classList.add('hanging-indent');
            citeDiv.classList.add('csl-entry');
            var biblioDiv = window.document.getElementById('ref-' + cite);
            if (biblioDiv) {
              citeDiv.innerHTML = biblioDiv.innerHTML;
            }
            popup.appendChild(citeDiv);
          });
          return popup.innerHTML;
        });
      }
    }
  });
  </script>
</div> <!-- /content -->




</body></html>