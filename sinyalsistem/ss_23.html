<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.8.25">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="Imron Rosyadi">

<title>Signal and Systems</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="site_libs/quarto-nav/quarto-nav.js"></script>
<script src="site_libs/quarto-nav/headroom.min.js"></script>
<script src="site_libs/clipboard/clipboard.min.js"></script>
<script src="site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="site_libs/quarto-search/fuse.min.js"></script>
<script src="site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="./">
<script src="site_libs/quarto-html/quarto.js" type="module"></script>
<script src="site_libs/quarto-html/tabsets/tabsets.js" type="module"></script>
<script src="site_libs/quarto-html/axe/axe-check.js" type="module"></script>
<script src="site_libs/quarto-html/popper.min.js"></script>
<script src="site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="site_libs/quarto-html/anchor.min.js"></script>
<link href="site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="site_libs/quarto-html/quarto-syntax-highlighting-7b89279ff1a6dce999919e0e67d4d9ec.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="site_libs/bootstrap/bootstrap.min.js"></script>
<link href="site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="site_libs/bootstrap/bootstrap-e31584831b205ffbb2d98406f31c2a5b.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>
<script src="site_libs/quarto-diagram/mermaid.min.js"></script>
<script src="site_libs/quarto-diagram/mermaid-init.js"></script>
<link href="site_libs/quarto-diagram/mermaid.css" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN" && texText && texText.data) {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

<link rel="stylesheet" href="styles.css">
</head>

<body class="nav-fixed quarto-light">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a href="./index.html" class="navbar-brand navbar-brand-logo">
    </a>
    <a class="navbar-brand" href="./index.html">
    <span class="navbar-title">Signal and Systems</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" role="menu" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll me-auto">
  <li class="nav-item">
    <a class="nav-link" href="./index.html"> 
<span class="menu-text">Home</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="./about.html"> 
<span class="menu-text">About</span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
            <div class="quarto-navbar-tools">
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">On this page</h2>
   
  <ul>
  <li><a href="#signals-and-systems" id="toc-signals-and-systems" class="nav-link active" data-scroll-target="#signals-and-systems">Signals and Systems</a>
  <ul class="collapse">
  <li><a href="#properties-of-linear-time-invariant-systems" id="toc-properties-of-linear-time-invariant-systems" class="nav-link" data-scroll-target="#properties-of-linear-time-invariant-systems">PROPERTIES OF LINEAR TIME-INVARIANT SYSTEMS</a></li>
  <li><a href="#the-power-of-the-impulse-response" id="toc-the-power-of-the-impulse-response" class="nav-link" data-scroll-target="#the-power-of-the-impulse-response">The Power of the Impulse Response</a></li>
  <li><a href="#the-commutative-property" id="toc-the-commutative-property" class="nav-link" data-scroll-target="#the-commutative-property">The Commutative Property</a></li>
  <li><a href="#the-commutative-property-1" id="toc-the-commutative-property-1" class="nav-link" data-scroll-target="#the-commutative-property-1">The Commutative Property</a></li>
  <li><a href="#the-distributive-property" id="toc-the-distributive-property" class="nav-link" data-scroll-target="#the-distributive-property">The Distributive Property</a></li>
  <li><a href="#the-distributive-property-1" id="toc-the-distributive-property-1" class="nav-link" data-scroll-target="#the-distributive-property-1">The Distributive Property</a></li>
  <li><a href="#distributive-property-in-action" id="toc-distributive-property-in-action" class="nav-link" data-scroll-target="#distributive-property-in-action">Distributive Property in Action</a></li>
  <li><a href="#the-associative-property" id="toc-the-associative-property" class="nav-link" data-scroll-target="#the-associative-property">The Associative Property</a></li>
  <li><a href="#order-doesnt-matter-for-lti-systems" id="toc-order-doesnt-matter-for-lti-systems" class="nav-link" data-scroll-target="#order-doesnt-matter-for-lti-systems">Order Doesn’t Matter… for LTI systems!</a></li>
  <li><a href="#system-properties-via-impulse-response" id="toc-system-properties-via-impulse-response" class="nav-link" data-scroll-target="#system-properties-via-impulse-response">System Properties via Impulse Response</a></li>
  <li><a href="#invertibility-of-lti-systems" id="toc-invertibility-of-lti-systems" class="nav-link" data-scroll-target="#invertibility-of-lti-systems">Invertibility of LTI Systems</a></li>
  <li><a href="#example-inverting-the-accumulator" id="toc-example-inverting-the-accumulator" class="nav-link" data-scroll-target="#example-inverting-the-accumulator">Example: Inverting the Accumulator</a></li>
  <li><a href="#causality-and-stability" id="toc-causality-and-stability" class="nav-link" data-scroll-target="#causality-and-stability">Causality and Stability</a></li>
  <li><a href="#the-unit-step-response" id="toc-the-unit-step-response" class="nav-link" data-scroll-target="#the-unit-step-response">The Unit Step Response</a></li>
  </ul></li>
  </ul>
<div class="quarto-alternate-formats"><h2>Other Formats</h2><ul><li><a href="ss_23.html"><i class="bi bi-file-slides"></i>RevealJS (live)</a></li></ul></div></nav>
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">Signal and Systems</h1>
<p class="subtitle lead">2.3 Properties of LTI Systems</p>
</div>



<div class="quarto-title-meta">

    <div>
    <div class="quarto-title-meta-heading">Author</div>
    <div class="quarto-title-meta-contents">
             <p>Imron Rosyadi </p>
          </div>
  </div>
    
  
    
  </div>
  


</header>


<section id="signals-and-systems" class="level1">
<h1>Signals and Systems</h1>
<section id="properties-of-linear-time-invariant-systems" class="level2">
<h2 class="anchored" data-anchor-id="properties-of-linear-time-invariant-systems">PROPERTIES OF LINEAR TIME-INVARIANT SYSTEMS</h2>
<p><strong>ECE Undergraduate Course</strong></p>
<p>Imron Rosyadi</p>
<div class="notes">
<p>In our last sessions, we derived the convolution sum and integral. These are powerful tools because they show that an LTI system is completely defined by its impulse response. Today, we’ll explore the profound implications of this fact by examining the key properties of LTI systems, such as commutativity, associativity, stability, and causality, all through the lens of the impulse response.</p>
</div>
<hr>
</section>
<section id="the-power-of-the-impulse-response" class="level2">
<h2 class="anchored" data-anchor-id="the-power-of-the-impulse-response">The Power of the Impulse Response</h2>
<p>The convolution representation shows that an <strong>LTI</strong> system is completely characterized by its impulse response, <span class="math inline">\(h[n]\)</span> or <span class="math inline">\(h(t)\)</span>.</p>
<ul>
<li><strong>Discrete-Time:</strong> <span class="math inline">\(y[n] = x[n] * h[n] = \sum_{k=-\infty}^{\infty} x[k]h[n-k]\)</span></li>
<li><strong>Continuous-Time:</strong> <span class="math inline">\(y(t) = x(t) * h(t) = \int_{-\infty}^{\infty} x(\tau)h(t-\tau)d\tau\)</span></li>
</ul>
<p>This is a unique feature of LTI systems. For <strong>non-linear</strong> systems, the impulse response is <em>not</em> a complete characterization.</p>
<p>For example, an LTI system with <span class="math inline">\(h[n] = \delta[n] + \delta[n-1]\)</span> is uniquely defined as <span class="math inline">\(y[n] = x[n] + x[n-1]\)</span>.</p>
<p>But non-linear systems like <span class="math inline">\(y[n] = (x[n]+x[n-1])^2\)</span> or <span class="math inline">\(y[n]=\max(x[n], x[n-1])\)</span> have the same impulse response, yet behave differently for other inputs.</p>
<div class="notes">
<p>It’s crucial to grasp this distinction. For an LTI system, if I give you its impulse response, I’ve told you everything. You can predict its output for any input. This is not true for a non-linear system. Multiple different non-linear systems can share the same impulse response. This is why the properties we’re about to discuss are so special to the LTI world.</p>
</div>
<hr>
</section>
<section id="the-commutative-property" class="level2">
<h2 class="anchored" data-anchor-id="the-commutative-property">The Commutative Property</h2>
<p>Convolution is a commutative operation. The order doesn’t matter.</p>
<p><span class="math display">\[
x[n] * h[n] = h[n] * x[n]
\]</span> <span class="math display">\[
x(t) * h(t) = h(t) * x(t)
\]</span></p>
<p>This means we can swap the roles of the input and the impulse response.</p>
<hr>
</section>
<section id="the-commutative-property-1" class="level2">
<h2 class="anchored" data-anchor-id="the-commutative-property-1">The Commutative Property</h2>
<div class="cell" data-layout-align="default">
<div class="cell-output-display">
<div>
<p></p><figure class="figure"><p></p>
<div>
<pre class="mermaid mermaid-js">graph TD
    subgraph "Standard View"
        A[Input: x] --&gt; S1[System: h]
        S1 --&gt; O1[Output: y]
    end
</pre>
</div>
<p></p></figure><p></p>
</div>
</div>
</div>
<div class="cell" data-layout-align="default">
<div class="cell-output-display">
<div>
<p></p><figure class="figure"><p></p>
<div>
<pre class="mermaid mermaid-js">graph TD
    subgraph "Equivalent View"
        B[Input: h] --&gt; S2[System: x]
        S2 --&gt; O2[Output: y]
    end
</pre>
</div>
<p></p></figure><p></p>
</div>
</div>
</div>
<p><strong>Why is this useful?</strong> Sometimes flipping and sliding one signal is much easier than the other. Commutativity lets us choose the easier path.</p>
<div class="notes">
<p>The commutative property is more than just a mathematical curiosity. It has a practical benefit. When you’re faced with a convolution problem, you have a choice: you can either flip and slide ‘h’ or you can flip and slide ‘x’. Often, one of the signals is much simpler (like a rectangle or an impulse), making the “flip and slide” operation on that signal significantly easier. Commutativity gives you the freedom to choose the simpler calculation.</p>
</div>
<hr>
</section>
<section id="the-distributive-property" class="level2">
<h2 class="anchored" data-anchor-id="the-distributive-property">The Distributive Property</h2>
<p>Convolution distributes over addition.</p>
<p><span class="math display">\[
x(t) * [h_1(t) + h_2(t)] = x(t) * h_1(t) + x(t) * h_2(t)
\]</span></p>
<p>This means a <strong>parallel combination</strong> of LTI systems is equivalent to a single system whose impulse response is the <strong>sum</strong> of the individual impulse responses.</p>
<hr>
</section>
<section id="the-distributive-property-1" class="level2">
<h2 class="anchored" data-anchor-id="the-distributive-property-1">The Distributive Property</h2>
<div class="cell" data-layout-align="default">
<div class="cell-output-display">
<div>
<p></p><figure class="figure"><p></p>
<div>
<pre class="mermaid mermaid-js">graph TD
    subgraph "Parallel Systems"
        X(x) --&gt; H1(h1);
        X --&gt; H2(h2);
        H1 --&gt; A("(+)");
        H2 --&gt; A;
        A --&gt; Y(y);
    end

    subgraph "is equivalent to"
       X2(x) --&gt; H_EQ(h1 + h2);
       H_EQ --&gt; Y2(y);
    end
</pre>
</div>
<p></p></figure><p></p>
</div>
</div>
</div>
<p>This property can simplify complex convolutions by breaking them into simpler parts.</p>
<div class="notes">
<p>The distributive property provides the rule for handling parallel systems. If you have an input that feeds into two different LTI systems and their outputs are added together, you can replace that entire parallel structure with a single LTI system. The impulse response of this new equivalent system is simply the sum of the two original impulse responses. We can also use this property in reverse to break down a complicated convolution problem into several simpler ones.</p>
</div>
<hr>
</section>
<section id="distributive-property-in-action" class="level2">
<h2 class="anchored" data-anchor-id="distributive-property-in-action">Distributive Property in Action</h2>
<p>Let’s convolve <span class="math inline">\(x[n] = (\frac{1}{2})^n u[n] + 2^n u[-n]\)</span> with the accumulator <span class="math inline">\(h[n]=u[n]\)</span>.</p>
<p>We can break <span class="math inline">\(x[n]\)</span> into two parts: a right-sided part <span class="math inline">\(x_1[n]\)</span> and a left-sided part <span class="math inline">\(x_2[n]\)</span>.</p>
<p><span class="math inline">\(y[n] = (x_1[n] + x_2[n]) * h[n] = (x_1[n]*h[n]) + (x_2[n]*h[n])\)</span></p>
<pre class="{pyodide}"><code>#| max-lines: 10
import numpy as np
import matplotlib.pyplot as plt

n = np.arange(-10, 11)
x1 = (0.5**n) * (n &gt;= 0)
x2 = (2.0**n) * (n &lt;= 0)
x = x1 + x2
x[n==0] = 1 # Correct for double counting at n=0

# From Example 2.3 and 2.5
y1 = (2 * (1 - 0.5**(n+1))) * (n &gt;= 0)
y2 = np.where(n &lt; 0, 2.0**(n+1), 2)
y = y1 + y2

fig, (ax1, ax2) = plt.subplots(1, 2, figsize=(7, 4))
ax1.stem(n, x1, linefmt='b-', markerfmt='bo', basefmt=' ', label='$x_1[n]$')
ax1.stem(n, x2, linefmt='r-', markerfmt='ro', basefmt=' ', label='$x_2[n]$')
ax1.set_title('Input Components')
ax1.legend()

ax2.stem(n, y, 'g', markerfmt='go')
ax2.set_title('Final Output $y[n]=y_1+y_2$')
fig.tight_layout()
plt.show()
</code></pre>
<div class="notes">
<p>Here’s a concrete example of using the distributive property. The input signal <span class="math inline">\(x[n]\)</span> is “two-sided,” which makes direct convolution tedious. By splitting <span class="math inline">\(x[n]\)</span> into a right-sided exponential <span class="math inline">\(x_1\)</span> and a left-sided exponential <span class="math inline">\(x_2\)</span>, we create two simpler problems. We already solved these two separate convolutions in previous examples! The final result is just the sum of those two simpler results, as shown in the green plot on the right.</p>
</div>
<hr>
</section>
<section id="the-associative-property" class="level2">
<h2 class="anchored" data-anchor-id="the-associative-property">The Associative Property</h2>
<p>Convolution is also an associative operation.</p>
<p><span class="math display">\[
[x(t) * h_1(t)] * h_2(t) = x(t) * [h_1(t) * h_2(t)]
\]</span></p>
<p>This means for a <strong>cascade (series)</strong> of LTI systems, the overall impulse response is the <strong>convolution</strong> of the individual impulse responses.</p>
<div class="cell" data-layout-align="default">
<div class="cell-output-display">
<div>
<p></p><figure class="figure"><p></p>
<div>
<pre class="mermaid mermaid-js">graph LR
    subgraph "Cascade of Systems"
        X(x) --&gt; H1(h1) --&gt; W(w) --&gt; H2(h2) --&gt; Y(y);
    end

    subgraph "is equivalent to"
        X2(x) --&gt; H_EQ(h1 * h2) --&gt; Y2(y);
    end
</pre>
</div>
<p></p></figure><p></p>
</div>
</div>
</div>
<div class="notes">
<p>Associativity gives us the rule for systems in series. When the output of one LTI system becomes the input to another, this is a cascade. The entire cascade can be replaced by a single equivalent LTI system. The impulse response of this new system is found by convolving the impulse responses of the individual systems in the cascade.</p>
</div>
<hr>
</section>
<section id="order-doesnt-matter-for-lti-systems" class="level2">
<h2 class="anchored" data-anchor-id="order-doesnt-matter-for-lti-systems">Order Doesn’t Matter… for LTI systems!</h2>
<p>Combining the <strong>associative</strong> and <strong>commutative</strong> properties leads to a powerful conclusion:</p>
<p><strong>The order of LTI systems in a cascade can be interchanged without changing the overall system response.</strong></p>
<p><span class="math inline">\(h_1 * h_2 = h_2 * h_1\)</span></p>
<p>This is a very special characteristic of LTI systems. It does <strong>NOT</strong> hold for non-linear systems.</p>
<div class="columns">
<div class="column" style="width:50%;">
<section id="lti-systems" class="level4">
<h4 class="anchored" data-anchor-id="lti-systems">LTI Systems</h4>
<div class="cell" data-layout-align="default">
<div class="cell-output-display">
<div>
<p></p><figure class="figure"><p></p>
<div>
<pre class="mermaid mermaid-js">graph TD
    X1(x) --&gt; H1(h1) --&gt; H2(h2) --&gt; Y1(y)
    Y1 -- yields same y --&gt; Y2
    X2(x) --&gt; H2b(h2) --&gt; H1b(h1) --&gt; Y2(y)
</pre>
</div>
<p></p></figure><p></p>
</div>
</div>
</div>
</section>
</div><div class="column" style="width:50%;">
<section id="non-linear-counterexample" class="level4">
<h4 class="anchored" data-anchor-id="non-linear-counterexample">Non-Linear Counterexample</h4>
<ul>
<li>Let System 1 be <code>squaring</code></li>
<li>Let System 2 be <code>multiply by 2</code></li>
</ul>
<p><span class="math inline">\(x \rightarrow [\text{Square}] \rightarrow \times 2 \rightarrow y = 2x^2\)</span></p>
<p><span class="math inline">\(x \rightarrow \times 2 \rightarrow [\text{Square}] \rightarrow y = (2x)^2 = 4x^2\)</span></p>
<p>The results are different! (<span class="math inline">\(2x^2 \ne 4x^2\)</span>)</p>
</section>
</div>
</div>
<div class="notes">
<p>This is one of the most important results. Because convolution is both associative and commutative, we can swap the order of LTI systems in a series connection and the final output remains exactly the same. The counterexample on the right shows how quickly this breaks down for non-linear systems. Simply changing the order of a squaring operation and a gain of 2 completely changes the final result. This flexibility is a privilege we only enjoy with LTI systems.</p>
</div>
<hr>
</section>
<section id="system-properties-via-impulse-response" class="level2">
<h2 class="anchored" data-anchor-id="system-properties-via-impulse-response">System Properties via Impulse Response</h2>
<p>We can determine key system properties directly from <span class="math inline">\(h\)</span>.</p>
<table class="caption-top table">
<colgroup>
<col style="width: 50%">
<col style="width: 50%">
</colgroup>
<thead>
<tr class="header">
<th style="text-align: left;">Property</th>
<th style="text-align: left;">Condition on Impulse Response <span class="math inline">\(h\)</span></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><strong>Memoryless</strong></td>
<td style="text-align: left;"><span class="math inline">\(h[n]=K\delta[n]\)</span> or <span class="math inline">\(h(t)=K\delta(t)\)</span>. Non-zero only at the origin.</td>
</tr>
<tr class="even">
<td style="text-align: left;"><strong>Causal</strong></td>
<td style="text-align: left;"><span class="math inline">\(h[n]=0\)</span> for <span class="math inline">\(n&lt;0\)</span> or <span class="math inline">\(h(t)=0\)</span> for <span class="math inline">\(t&lt;0\)</span>. Response can’t precede the impulse.</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><strong>Stable (BIBO)</strong></td>
<td style="text-align: left;">Impulse response must be absolutely summable/integrable. <span class="math inline">\(\sum \|h[k]\| &lt; \infty\)</span> or <span class="math inline">\(\int \|h(\tau)\|d\tau &lt; \infty\)</span>.</td>
</tr>
<tr class="even">
<td style="text-align: left;"><strong>Invertible</strong></td>
<td style="text-align: left;">An inverse system <span class="math inline">\(h_{inv}\)</span> exists such that <span class="math inline">\(h * h_{inv} = \delta\)</span>.</td>
</tr>
</tbody>
</table>
<div class="notes">
<p>This summary table is your cheat sheet. It connects the high-level system properties we’ve discussed—memory, causality, stability, and invertibility—to concrete, testable conditions on the impulse response. By simply inspecting <span class="math inline">\(h\)</span>, we can immediately determine these fundamental characteristics of an LTI system.</p>
</div>
<hr>
</section>
<section id="invertibility-of-lti-systems" class="level2">
<h2 class="anchored" data-anchor-id="invertibility-of-lti-systems">Invertibility of LTI Systems</h2>
<p>An LTI system is invertible if we can find an inverse system, <span class="math inline">\(h_{inv}\)</span>, that perfectly undoes its effect.</p>
<p>In a cascade, they form an identity system.</p>
<div class="cell" data-layout-align="default">
<div class="cell-output-display">
<div>
<p></p><figure class="figure"><p></p>
<div>
<pre class="mermaid mermaid-js">graph LR
    X("x(t)") --&gt; H("h(t)") --&gt; W("w(t)") --&gt; H_INV("h_inv(t)") --&gt; Y("y(t) = x(t)");

    subgraph "is equivalent to"
        X2("x(t)") --&gt; ID("δ(t)") --&gt; Y2("y(t)=x(t)");
    end
</pre>
</div>
<p></p></figure><p></p>
</div>
</div>
</div>
<p>The condition for invertibility is:</p>
<p><span class="math display">\[
h(t) * h_{inv}(t) = \delta(t) \quad \text{or} \quad h[n] * h_{inv}[n] = \delta[n]
\]</span></p>
<div class="notes">
<p>The concept of an inverse is intuitive: it’s a system that gets you back your original input. For LTI systems, this concept has a precise mathematical form. The inverse system, when convolved with the original system, must produce a unit impulse. The unit impulse acts as the “identity element” for convolution, just like the number 1 is the identity for multiplication.</p>
</div>
<hr>
</section>
<section id="example-inverting-the-accumulator" class="level2">
<h2 class="anchored" data-anchor-id="example-inverting-the-accumulator">Example: Inverting the Accumulator</h2>
<ul>
<li><strong>System:</strong> The discrete-time accumulator. Its impulse response is the unit step, <span class="math inline">\(h[n] = u[n]\)</span>.
<ul>
<li><span class="math inline">\(y[n] = \sum_{k=-\infty}^{n} x[k]\)</span></li>
</ul></li>
<li><strong>Inverse System:</strong> The first-difference system.
<ul>
<li><span class="math inline">\(w[n] = y[n] - y[n-1]\)</span></li>
<li>Its impulse response is <span class="math inline">\(h_{inv}[n] = \delta[n] - \delta[n-1]\)</span>.</li>
</ul></li>
</ul>
<p>Let’s verify: <span class="math inline">\(h[n] * h_{inv}[n] = u[n] * (\delta[n] - \delta[n-1]) = u[n] - u[n-1] = \delta[n]\)</span> ✔️</p>
<pre class="{pyodide}"><code>#| max-lines: 10
import numpy as np
import matplotlib.pyplot as plt

n = np.arange(-2, 6)
h = (n &gt;= 0).astype(int)
h_inv = (n == 0).astype(int) - (n == 1).astype(int)
y = np.convolve(h, h_inv, 'same')

fig, (ax1, ax2) = plt.subplots(1, 2, figsize=(7, 4))
ax1.stem(n, h, 'b', markerfmt='bo', label='$h[n]=u[n]$')
ax1.stem(n, h_inv, 'r', markerfmt='ro', label='$h_{inv}[n]$')
ax1.set_title('System and Its Inverse'); ax1.legend()

ax2.stem(n, y, 'g', markerfmt='go')
ax2.set_title('Result: $h[n]*h_{inv}[n]=\delta[n]$')
fig.tight_layout(); plt.show()</code></pre>
<div class="notes">
<p>The accumulator and the first-difference system are a perfect pair of inverse systems. The accumulator sums up values over time. The first-difference looks at the change from one sample to the next. It makes intuitive sense that differencing undoes summation. The plot confirms this mathematically: convolving the impulse response of the accumulator (a step function) with the impulse response of the first-difference system gives us a single unit impulse.</p>
</div>
<hr>
</section>
<section id="causality-and-stability" class="level2">
<h2 class="anchored" data-anchor-id="causality-and-stability">Causality and Stability</h2>
<ul>
<li><strong>Causality:</strong> An LTI system is causal if its output at time <code>n</code> only depends on inputs up to time <code>n</code> (present and past).
<ul>
<li><strong>Condition:</strong> <span class="math inline">\(h[n] = 0\)</span> for <span class="math inline">\(n&lt;0\)</span> or <span class="math inline">\(h(t)=0\)</span> for <span class="math inline">\(t&lt;0\)</span>.</li>
<li><em>Intuition: The system can’t react to an impulse before it happens.</em></li>
</ul></li>
<li><strong>Stability (BIBO):</strong> A system is stable if every bounded input produces a bounded output.
<ul>
<li><strong>Condition:</strong> The impulse response must be <strong>absolutely summable/integrable</strong>.</li>
<li><span class="math inline">\(\sum_{k=-\infty}^{\infty} |h[k]| &lt; \infty\)</span> or <span class="math inline">\(\int_{-\infty}^{\infty} |h(\tau)| d\tau &lt; \infty\)</span></li>
<li><em>Intuition: The system’s “memory” or “echoes” must eventually die out.</em></li>
</ul></li>
</ul>
<p><strong>Example:</strong> The accumulator, <span class="math inline">\(h[n]=u[n]\)</span>, is causal but <strong>unstable</strong> because <span class="math inline">\(\sum_{n=0}^\infty |u[n]| = \infty\)</span>.</p>
<div class="notes">
<p>Causality is a simple check: is the impulse response zero for all negative time? If yes, it’s causal. Stability is a bit more involved. The condition means that the total “energy” of the impulse response, ignoring sign, must be finite. If the impulse response doesn’t decay to zero fast enough, like the unit step, a bounded input (like a constant value of 1) can cause the output to grow infinitely.</p>
</div>
<hr>
</section>
<section id="the-unit-step-response" class="level2">
<h2 class="anchored" data-anchor-id="the-unit-step-response">The Unit Step Response</h2>
<p>Besides the impulse response <span class="math inline">\(h(t)\)</span>, the <strong>unit step response</strong> <span class="math inline">\(s(t)\)</span> is also used to characterize an LTI system. It’s the output when the input is a unit step, <span class="math inline">\(u(t)\)</span>.</p>
<p>The two are directly related:</p>
<div class="columns">
<div class="column" style="width:50%;">
<section id="discrete-time" class="level4">
<h4 class="anchored" data-anchor-id="discrete-time">Discrete-Time</h4>
<p>The step response is the running sum of the impulse response. <span class="math display">\[s[n] = \sum_{k=-\infty}^{n} h[k]\]</span> The impulse response is the first difference of the step response. <span class="math display">\[h[n] = s[n] - s[n-1]\]</span></p>
</section>
</div><div class="column" style="width:50%;">
<section id="continuous-time" class="level4">
<h4 class="anchored" data-anchor-id="continuous-time">Continuous-Time</h4>
<p>The step response is the running integral of the impulse response. <span class="math display">\[s(t) = \int_{-\infty}^{t} h(\tau)d\tau\]</span> The impulse response is the derivative of the step response. <span class="math display">\[h(t) = \frac{ds(t)}{dt}\]</span></p>
</section>
</div>
</div>
<p>Knowing either <span class="math inline">\(h(t)\)</span> or <span class="math inline">\(s(t)\)</span> allows you to fully describe the LTI system.</p>
<div class="notes">
<p>The impulse response is the fundamental theoretical tool, but in a real-world lab, creating a perfect impulse is impossible. Creating a good step input (like flipping a switch) is much easier. The step response is therefore a common practical way to measure and characterize a system. These equations show that the impulse response and step response are two sides of the same coin. They contain the same information about the system, just presented in different ways.</p>
</div>


</section>
</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
  window.document.addEventListener("DOMContentLoaded", function (event) {
    const icon = "";
    const anchorJS = new window.AnchorJS();
    anchorJS.options = {
      placement: 'right',
      icon: icon
    };
    anchorJS.add('.anchored');
    const isCodeAnnotation = (el) => {
      for (const clz of el.classList) {
        if (clz.startsWith('code-annotation-')) {                     
          return true;
        }
      }
      return false;
    }
    const onCopySuccess = function(e) {
      // button target
      const button = e.trigger;
      // don't keep focus
      button.blur();
      // flash "checked"
      button.classList.add('code-copy-button-checked');
      var currentTitle = button.getAttribute("title");
      button.setAttribute("title", "Copied!");
      let tooltip;
      if (window.bootstrap) {
        button.setAttribute("data-bs-toggle", "tooltip");
        button.setAttribute("data-bs-placement", "left");
        button.setAttribute("data-bs-title", "Copied!");
        tooltip = new bootstrap.Tooltip(button, 
          { trigger: "manual", 
            customClass: "code-copy-button-tooltip",
            offset: [0, -8]});
        tooltip.show();    
      }
      setTimeout(function() {
        if (tooltip) {
          tooltip.hide();
          button.removeAttribute("data-bs-title");
          button.removeAttribute("data-bs-toggle");
          button.removeAttribute("data-bs-placement");
        }
        button.setAttribute("title", currentTitle);
        button.classList.remove('code-copy-button-checked');
      }, 1000);
      // clear code selection
      e.clearSelection();
    }
    const getTextToCopy = function(trigger) {
      const outerScaffold = trigger.parentElement.cloneNode(true);
      const codeEl = outerScaffold.querySelector('code');
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
    const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
      text: getTextToCopy
    });
    clipboard.on('success', onCopySuccess);
    if (window.document.getElementById('quarto-embedded-source-code-modal')) {
      const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
        text: getTextToCopy,
        container: window.document.getElementById('quarto-embedded-source-code-modal')
      });
      clipboardModal.on('success', onCopySuccess);
    }
      var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
      var mailtoRegex = new RegExp(/^mailto:/);
        var filterRegex = new RegExp('/' + window.location.host + '/');
      var isInternal = (href) => {
          return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
      }
      // Inspect non-navigation links and adorn them if external
     var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
      for (var i=0; i<links.length; i++) {
        const link = links[i];
        if (!isInternal(link.href)) {
          // undo the damage that might have been done by quarto-nav.js in the case of
          // links that we want to consider external
          if (link.dataset.originalHref !== undefined) {
            link.href = link.dataset.originalHref;
          }
        }
      }
    function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
      const config = {
        allowHTML: true,
        maxWidth: 500,
        delay: 100,
        arrow: false,
        appendTo: function(el) {
            return el.parentElement;
        },
        interactive: true,
        interactiveBorder: 10,
        theme: 'quarto',
        placement: 'bottom-start',
      };
      if (contentFn) {
        config.content = contentFn;
      }
      if (onTriggerFn) {
        config.onTrigger = onTriggerFn;
      }
      if (onUntriggerFn) {
        config.onUntrigger = onUntriggerFn;
      }
      window.tippy(el, config); 
    }
    const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
    for (var i=0; i<noterefs.length; i++) {
      const ref = noterefs[i];
      tippyHover(ref, function() {
        // use id or data attribute instead here
        let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
        try { href = new URL(href).hash; } catch {}
        const id = href.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note) {
          return note.innerHTML;
        } else {
          return "";
        }
      });
    }
    const xrefs = window.document.querySelectorAll('a.quarto-xref');
    const processXRef = (id, note) => {
      // Strip column container classes
      const stripColumnClz = (el) => {
        el.classList.remove("page-full", "page-columns");
        if (el.children) {
          for (const child of el.children) {
            stripColumnClz(child);
          }
        }
      }
      stripColumnClz(note)
      if (id === null || id.startsWith('sec-')) {
        // Special case sections, only their first couple elements
        const container = document.createElement("div");
        if (note.children && note.children.length > 2) {
          container.appendChild(note.children[0].cloneNode(true));
          for (let i = 1; i < note.children.length; i++) {
            const child = note.children[i];
            if (child.tagName === "P" && child.innerText === "") {
              continue;
            } else {
              container.appendChild(child.cloneNode(true));
              break;
            }
          }
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(container);
          }
          return container.innerHTML
        } else {
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(note);
          }
          return note.innerHTML;
        }
      } else {
        // Remove any anchor links if they are present
        const anchorLink = note.querySelector('a.anchorjs-link');
        if (anchorLink) {
          anchorLink.remove();
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        if (note.classList.contains("callout")) {
          return note.outerHTML;
        } else {
          return note.innerHTML;
        }
      }
    }
    for (var i=0; i<xrefs.length; i++) {
      const xref = xrefs[i];
      tippyHover(xref, undefined, function(instance) {
        instance.disable();
        let url = xref.getAttribute('href');
        let hash = undefined; 
        if (url.startsWith('#')) {
          hash = url;
        } else {
          try { hash = new URL(url).hash; } catch {}
        }
        if (hash) {
          const id = hash.replace(/^#\/?/, "");
          const note = window.document.getElementById(id);
          if (note !== null) {
            try {
              const html = processXRef(id, note.cloneNode(true));
              instance.setContent(html);
            } finally {
              instance.enable();
              instance.show();
            }
          } else {
            // See if we can fetch this
            fetch(url.split('#')[0])
            .then(res => res.text())
            .then(html => {
              const parser = new DOMParser();
              const htmlDoc = parser.parseFromString(html, "text/html");
              const note = htmlDoc.getElementById(id);
              if (note !== null) {
                const html = processXRef(id, note);
                instance.setContent(html);
              } 
            }).finally(() => {
              instance.enable();
              instance.show();
            });
          }
        } else {
          // See if we can fetch a full url (with no hash to target)
          // This is a special case and we should probably do some content thinning / targeting
          fetch(url)
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.querySelector('main.content');
            if (note !== null) {
              // This should only happen for chapter cross references
              // (since there is no id in the URL)
              // remove the first header
              if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
                note.children[0].remove();
              }
              const html = processXRef(null, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      }, function(instance) {
      });
    }
        let selectedAnnoteEl;
        const selectorForAnnotation = ( cell, annotation) => {
          let cellAttr = 'data-code-cell="' + cell + '"';
          let lineAttr = 'data-code-annotation="' +  annotation + '"';
          const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
          return selector;
        }
        const selectCodeLines = (annoteEl) => {
          const doc = window.document;
          const targetCell = annoteEl.getAttribute("data-target-cell");
          const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
          const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
          const lines = annoteSpan.getAttribute("data-code-lines").split(",");
          const lineIds = lines.map((line) => {
            return targetCell + "-" + line;
          })
          let top = null;
          let height = null;
          let parent = null;
          if (lineIds.length > 0) {
              //compute the position of the single el (top and bottom and make a div)
              const el = window.document.getElementById(lineIds[0]);
              top = el.offsetTop;
              height = el.offsetHeight;
              parent = el.parentElement.parentElement;
            if (lineIds.length > 1) {
              const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
              const bottom = lastEl.offsetTop + lastEl.offsetHeight;
              height = bottom - top;
            }
            if (top !== null && height !== null && parent !== null) {
              // cook up a div (if necessary) and position it 
              let div = window.document.getElementById("code-annotation-line-highlight");
              if (div === null) {
                div = window.document.createElement("div");
                div.setAttribute("id", "code-annotation-line-highlight");
                div.style.position = 'absolute';
                parent.appendChild(div);
              }
              div.style.top = top - 2 + "px";
              div.style.height = height + 4 + "px";
              div.style.left = 0;
              let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
              if (gutterDiv === null) {
                gutterDiv = window.document.createElement("div");
                gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
                gutterDiv.style.position = 'absolute';
                const codeCell = window.document.getElementById(targetCell);
                const gutter = codeCell.querySelector('.code-annotation-gutter');
                gutter.appendChild(gutterDiv);
              }
              gutterDiv.style.top = top - 2 + "px";
              gutterDiv.style.height = height + 4 + "px";
            }
            selectedAnnoteEl = annoteEl;
          }
        };
        const unselectCodeLines = () => {
          const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
          elementsIds.forEach((elId) => {
            const div = window.document.getElementById(elId);
            if (div) {
              div.remove();
            }
          });
          selectedAnnoteEl = undefined;
        };
          // Handle positioning of the toggle
      window.addEventListener(
        "resize",
        throttle(() => {
          elRect = undefined;
          if (selectedAnnoteEl) {
            selectCodeLines(selectedAnnoteEl);
          }
        }, 10)
      );
      function throttle(fn, ms) {
      let throttle = false;
      let timer;
        return (...args) => {
          if(!throttle) { // first call gets through
              fn.apply(this, args);
              throttle = true;
          } else { // all the others get throttled
              if(timer) clearTimeout(timer); // cancel #2
              timer = setTimeout(() => {
                fn.apply(this, args);
                timer = throttle = false;
              }, ms);
          }
        };
      }
        // Attach click handler to the DT
        const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
        for (const annoteDlNode of annoteDls) {
          annoteDlNode.addEventListener('click', (event) => {
            const clickedEl = event.target;
            if (clickedEl !== selectedAnnoteEl) {
              unselectCodeLines();
              const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
              if (activeEl) {
                activeEl.classList.remove('code-annotation-active');
              }
              selectCodeLines(clickedEl);
              clickedEl.classList.add('code-annotation-active');
            } else {
              // Unselect the line
              unselectCodeLines();
              clickedEl.classList.remove('code-annotation-active');
            }
          });
        }
    const findCites = (el) => {
      const parentEl = el.parentElement;
      if (parentEl) {
        const cites = parentEl.dataset.cites;
        if (cites) {
          return {
            el,
            cites: cites.split(' ')
          };
        } else {
          return findCites(el.parentElement)
        }
      } else {
        return undefined;
      }
    };
    var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
    for (var i=0; i<bibliorefs.length; i++) {
      const ref = bibliorefs[i];
      const citeInfo = findCites(ref);
      if (citeInfo) {
        tippyHover(citeInfo.el, function() {
          var popup = window.document.createElement('div');
          citeInfo.cites.forEach(function(cite) {
            var citeDiv = window.document.createElement('div');
            citeDiv.classList.add('hanging-indent');
            citeDiv.classList.add('csl-entry');
            var biblioDiv = window.document.getElementById('ref-' + cite);
            if (biblioDiv) {
              citeDiv.innerHTML = biblioDiv.innerHTML;
            }
            popup.appendChild(citeDiv);
          });
          return popup.innerHTML;
        });
      }
    }
  });
  </script>
</div> <!-- /content -->




</body></html>