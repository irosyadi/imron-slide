---
title: "Signal and Systems"
subtitle: "2.3 Properties of LTI Systems"
author: "Imron Rosyadi"
format:
  live-revealjs:
    logo: "qrjs_assets/unsoed_logo.png"
    footer: "[irosyadi-2025](https://imron-slide.vercel.app)"
    slide-number: true
    chalkboard: true
    scrollable: true
    controls: true
    progress: true
    preview-links: true
    transition: fade
    incremental: false
    theme: [default, qrjs_assets/ir_style.scss]
    mermaid:
        theme: forest
pyodide:
  packages:
    - numpy
    - plotly
    - nbformat
---

# Signals and Systems
## PROPERTIES OF LINEAR TIME-INVARIANT SYSTEMS

**ECE Undergraduate Course**

Imron Rosyadi

::: {.notes}
In our last sessions, we derived the convolution sum and integral. These are powerful tools because they show that an LTI system is completely defined by its impulse response. Today, we'll explore the profound implications of this fact by examining the key properties of LTI systems, such as commutativity, associativity, stability, and causality, all through the lens of the impulse response.
:::

---

## The Power of the Impulse Response

The convolution representation shows that an **LTI** system is completely characterized by its impulse response, $h[n]$ or $h(t)$.

-   **Discrete-Time:** $y[n] = x[n] * h[n] = \sum_{k=-\infty}^{\infty} x[k]h[n-k]$
-   **Continuous-Time:** $y(t) = x(t) * h(t) = \int_{-\infty}^{\infty} x(\tau)h(t-\tau)d\tau$

This is a unique feature of LTI systems. For **non-linear** systems, the impulse response is *not* a complete characterization.

For example, an LTI system with $h[n] = \delta[n] + \delta[n-1]$ is uniquely defined as $y[n] = x[n] + x[n-1]$.

But non-linear systems like $y[n] = (x[n]+x[n-1])^2$ or $y[n]=\max(x[n], x[n-1])$ have the same impulse response, yet behave differently for other inputs.

::: {.notes}
It's crucial to grasp this distinction. For an LTI system, if I give you its impulse response, I've told you everything. You can predict its output for any input. This is not true for a non-linear system. Multiple different non-linear systems can share the same impulse response. This is why the properties we're about to discuss are so special to the LTI world.
:::

---

## The Commutative Property

Convolution is a commutative operation. The order doesn't matter.

$$
x[n] * h[n] = h[n] * x[n]
$$
$$
x(t) * h(t) = h(t) * x(t)
$$

This means we can swap the roles of the input and the impulse response.

---

## The Commutative Property
```{mermaid}
graph TD
    subgraph "Standard View"
        A[Input: x] --> S1[System: h]
        S1 --> O1[Output: y]
    end
```

```{mermaid}
graph TD
    subgraph "Equivalent View"
        B[Input: h] --> S2[System: x]
        S2 --> O2[Output: y]
    end
```

**Why is this useful?** Sometimes flipping and sliding one signal is much easier than the other. Commutativity lets us choose the easier path.

::: {.notes}
The commutative property is more than just a mathematical curiosity. It has a practical benefit. When you're faced with a convolution problem, you have a choice: you can either flip and slide 'h' or you can flip and slide 'x'. Often, one of the signals is much simpler (like a rectangle or an impulse), making the "flip and slide" operation on that signal significantly easier. Commutativity gives you the freedom to choose the simpler calculation.
:::

---

## The Distributive Property

Convolution distributes over addition.

$$
x(t) * [h_1(t) + h_2(t)] = x(t) * h_1(t) + x(t) * h_2(t)
$$

This means a **parallel combination** of LTI systems is equivalent to a single system whose impulse response is the **sum** of the individual impulse responses.

---

## The Distributive Property

```{mermaid}
graph TD
    subgraph "Parallel Systems"
        X(x) --> H1(h1);
        X --> H2(h2);
        H1 --> A("(+)");
        H2 --> A;
        A --> Y(y);
    end

    subgraph "is equivalent to"
       X2(x) --> H_EQ(h1 + h2);
       H_EQ --> Y2(y);
    end
```

This property can simplify complex convolutions by breaking them into simpler parts.

::: {.notes}
The distributive property provides the rule for handling parallel systems. If you have an input that feeds into two different LTI systems and their outputs are added together, you can replace that entire parallel structure with a single LTI system. The impulse response of this new equivalent system is simply the sum of the two original impulse responses. We can also use this property in reverse to break down a complicated convolution problem into several simpler ones.
:::

---

## Distributive Property in Action

Let's convolve $x[n] = (\frac{1}{2})^n u[n] + 2^n u[-n]$ with the accumulator $h[n]=u[n]$.

We can break $x[n]$ into two parts: a right-sided part $x_1[n]$ and a left-sided part $x_2[n]$.

$y[n] = (x_1[n] + x_2[n]) * h[n] = (x_1[n]*h[n]) + (x_2[n]*h[n])$

```{pyodide}
#| max-lines: 10
import numpy as np
import matplotlib.pyplot as plt

n = np.arange(-10, 11)
x1 = (0.5**n) * (n >= 0)
x2 = (2.0**n) * (n <= 0)
x = x1 + x2
x[n==0] = 1 # Correct for double counting at n=0

# From Example 2.3 and 2.5
y1 = (2 * (1 - 0.5**(n+1))) * (n >= 0)
y2 = np.where(n < 0, 2.0**(n+1), 2)
y = y1 + y2

fig, (ax1, ax2) = plt.subplots(1, 2, figsize=(7, 4))
ax1.stem(n, x1, linefmt='b-', markerfmt='bo', basefmt=' ', label='$x_1[n]$')
ax1.stem(n, x2, linefmt='r-', markerfmt='ro', basefmt=' ', label='$x_2[n]$')
ax1.set_title('Input Components')
ax1.legend()

ax2.stem(n, y, 'g', markerfmt='go')
ax2.set_title('Final Output $y[n]=y_1+y_2$')
fig.tight_layout()
plt.show()

```

::: {.notes}
Here's a concrete example of using the distributive property. The input signal $x[n]$ is "two-sided," which makes direct convolution tedious. By splitting $x[n]$ into a right-sided exponential $x_1$ and a left-sided exponential $x_2$, we create two simpler problems. We already solved these two separate convolutions in previous examples! The final result is just the sum of those two simpler results, as shown in the green plot on the right.
:::

---

## The Associative Property

Convolution is also an associative operation.

$$
[x(t) * h_1(t)] * h_2(t) = x(t) * [h_1(t) * h_2(t)]
$$

This means for a **cascade (series)** of LTI systems, the overall impulse response is the **convolution** of the individual impulse responses.

```{mermaid}
graph LR
    subgraph "Cascade of Systems"
        X(x) --> H1(h1) --> W(w) --> H2(h2) --> Y(y);
    end

    subgraph "is equivalent to"
        X2(x) --> H_EQ(h1 * h2) --> Y2(y);
    end
```

::: {.notes}
Associativity gives us the rule for systems in series. When the output of one LTI system becomes the input to another, this is a cascade. The entire cascade can be replaced by a single equivalent LTI system. The impulse response of this new system is found by convolving the impulse responses of the individual systems in the cascade.
:::

---

## Order Doesn't Matter... for LTI systems!

Combining the **associative** and **commutative** properties leads to a powerful conclusion:

**The order of LTI systems in a cascade can be interchanged without changing the overall system response.**

$h_1 * h_2 = h_2 * h_1$

This is a very special characteristic of LTI systems. It does **NOT** hold for non-linear systems.

:::: {.columns}
::: {.column width="50%"}
#### LTI Systems
```{mermaid}
graph TD
    X1(x) --> H1(h1) --> H2(h2) --> Y1(y)
    Y1 -- yields same y --> Y2
    X2(x) --> H2b(h2) --> H1b(h1) --> Y2(y)
```
:::
::: {.column width="50%"}
#### Non-Linear Counterexample

- Let System 1 be `squaring`
- Let System 2 be `multiply by 2`

$x \rightarrow [\text{Square}] \rightarrow \times 2 \rightarrow y = 2x^2$

$x \rightarrow \times 2 \rightarrow [\text{Square}] \rightarrow y = (2x)^2 = 4x^2$

The results are different! ($2x^2 \ne 4x^2$)
:::
::::

::: {.notes}
This is one of the most important results. Because convolution is both associative and commutative, we can swap the order of LTI systems in a series connection and the final output remains exactly the same. The counterexample on the right shows how quickly this breaks down for non-linear systems. Simply changing the order of a squaring operation and a gain of 2 completely changes the final result. This flexibility is a privilege we only enjoy with LTI systems.
:::

---

## System Properties via Impulse Response

We can determine key system properties directly from $h$.

| Property | Condition on Impulse Response $h$ |
| :--- | :--- |
| **Memoryless** | $h[n]=K\delta[n]$ or $h(t)=K\delta(t)$. Non-zero only at the origin. |
| **Causal** | $h[n]=0$ for $n<0$ or $h(t)=0$ for $t<0$. Response can't precede the impulse. |
| **Stable (BIBO)** | Impulse response must be absolutely summable/integrable. $\sum \|h[k]\| < \infty$ or $\int \|h(\tau)\|d\tau < \infty$. |
| **Invertible** | An inverse system $h_{inv}$ exists such that $h * h_{inv} = \delta$. |


::: {.notes}
This summary table is your cheat sheet. It connects the high-level system properties we've discussed—memory, causality, stability, and invertibility—to concrete, testable conditions on the impulse response. By simply inspecting $h$, we can immediately determine these fundamental characteristics of an LTI system.
:::

---

## Invertibility of LTI Systems

An LTI system is invertible if we can find an inverse system, $h_{inv}$, that perfectly undoes its effect.

In a cascade, they form an identity system.

```{mermaid}
graph LR
    X("x(t)") --> H("h(t)") --> W("w(t)") --> H_INV("h_inv(t)") --> Y("y(t) = x(t)");

    subgraph "is equivalent to"
        X2("x(t)") --> ID("δ(t)") --> Y2("y(t)=x(t)");
    end
```

The condition for invertibility is:

$$
h(t) * h_{inv}(t) = \delta(t) \quad \text{or} \quad h[n] * h_{inv}[n] = \delta[n]
$$

::: {.notes}
The concept of an inverse is intuitive: it's a system that gets you back your original input. For LTI systems, this concept has a precise mathematical form. The inverse system, when convolved with the original system, must produce a unit impulse. The unit impulse acts as the "identity element" for convolution, just like the number 1 is the identity for multiplication.
:::

---

## Example: Inverting the Accumulator

-   **System:** The discrete-time accumulator. Its impulse response is the unit step, $h[n] = u[n]$.
    -   $y[n] = \sum_{k=-\infty}^{n} x[k]$

-   **Inverse System:** The first-difference system.
    -   $w[n] = y[n] - y[n-1]$
    -   Its impulse response is $h_{inv}[n] = \delta[n] - \delta[n-1]$.

Let's verify: $h[n] * h_{inv}[n] = u[n] * (\delta[n] - \delta[n-1]) = u[n] - u[n-1] = \delta[n]$ ✔️

```{pyodide}
#| max-lines: 10
import numpy as np
import matplotlib.pyplot as plt

n = np.arange(-2, 6)
h = (n >= 0).astype(int)
h_inv = (n == 0).astype(int) - (n == 1).astype(int)
y = np.convolve(h, h_inv, 'same')

fig, (ax1, ax2) = plt.subplots(1, 2, figsize=(7, 4))
ax1.stem(n, h, 'b', markerfmt='bo', label='$h[n]=u[n]$')
ax1.stem(n, h_inv, 'r', markerfmt='ro', label='$h_{inv}[n]$')
ax1.set_title('System and Its Inverse'); ax1.legend()

ax2.stem(n, y, 'g', markerfmt='go')
ax2.set_title('Result: $h[n]*h_{inv}[n]=\delta[n]$')
fig.tight_layout(); plt.show()
```

::: {.notes}
The accumulator and the first-difference system are a perfect pair of inverse systems. The accumulator sums up values over time. The first-difference looks at the change from one sample to the next. It makes intuitive sense that differencing undoes summation. The plot confirms this mathematically: convolving the impulse response of the accumulator (a step function) with the impulse response of the first-difference system gives us a single unit impulse.
:::

---

## Causality and Stability

-   **Causality:** An LTI system is causal if its output at time `n` only depends on inputs up to time `n` (present and past).
    -   **Condition:** $h[n] = 0$ for $n<0$ or $h(t)=0$ for $t<0$.
    -   _Intuition: The system can't react to an impulse before it happens._

-   **Stability (BIBO):** A system is stable if every bounded input produces a bounded output.
    -   **Condition:** The impulse response must be **absolutely summable/integrable**.
    -   $\sum_{k=-\infty}^{\infty} |h[k]| < \infty$ or $\int_{-\infty}^{\infty} |h(\tau)| d\tau < \infty$
    -   _Intuition: The system's "memory" or "echoes" must eventually die out._

**Example:** The accumulator, $h[n]=u[n]$, is causal but **unstable** because $\sum_{n=0}^\infty |u[n]| = \infty$.

::: {.notes}
Causality is a simple check: is the impulse response zero for all negative time? If yes, it's causal.
Stability is a bit more involved. The condition means that the total "energy" of the impulse response, ignoring sign, must be finite. If the impulse response doesn't decay to zero fast enough, like the unit step, a bounded input (like a constant value of 1) can cause the output to grow infinitely.
:::

---

## The Unit Step Response

Besides the impulse response $h(t)$, the **unit step response** $s(t)$ is also used to characterize an LTI system. It's the output when the input is a unit step, $u(t)$.

The two are directly related:

::::{.columns}
::: {.column width="50%"}
#### Discrete-Time
The step response is the running sum of the impulse response.
$$s[n] = \sum_{k=-\infty}^{n} h[k]$$
The impulse response is the first difference of the step response.
$$h[n] = s[n] - s[n-1]$$
:::
::: {.column width="50%"}
#### Continuous-Time
The step response is the running integral of the impulse response.
$$s(t) = \int_{-\infty}^{t} h(\tau)d\tau$$
The impulse response is the derivative of the step response.
$$h(t) = \frac{ds(t)}{dt}$$
:::
::::

Knowing either $h(t)$ or $s(t)$ allows you to fully describe the LTI system.

::: {.notes}
The impulse response is the fundamental theoretical tool, but in a real-world lab, creating a perfect impulse is impossible. Creating a good step input (like flipping a switch) is much easier. The step response is therefore a common practical way to measure and characterize a system. These equations show that the impulse response and step response are two sides of the same coin. They contain the same information about the system, just presented in different ways.
:::
