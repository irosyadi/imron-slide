---
title: "Signals and Systems"
subtitle: "Fourier Analysis: Deconstructing Signals"
author: "Imron Rosyadi"
format:
  live-revealjs:
    logo: "qrjs_assets/unsoed_logo.png"
    footer: "[irosyadi-2025](https://imron-slide.vercel.app)"
    slide-number: true
    chalkboard: true
    scrollable: true
    controls: true
    progress: true
    transition: fade
    theme: [default, qrjs_assets/ir_style.scss]
    mermaid:
        theme: neutral
pyodide:
  packages:
    - numpy
    - plotly
    - nbformat
---

# Signals and Systems
## Fourier Analysis: Deconstructing Signals

### Imron Rosyadi

---

## 1. The Power of Complex Exponentials

Recall from our previous discussion that complex exponentials are **eigenfunctions** of LTI systems.

:::: {.columns}
::: {.column width="50%"}
**Continuous-Time**
$x(t) = e^{st} \quad \xrightarrow{\text{LTI System}} \quad y(t) = H(s) e^{st}$
:::
::: {.column width="50%"}
**Discrete-Time**
$x[n] = z^n \quad \xrightarrow{\text{LTI System}} \quad y[n] = H(z) z^n$
:::
::::

This means:

*   LTI systems only scale complex exponentials, they don't change their fundamental form.
*   The system's behavior is fully characterized by $H(s)$ or $H(z)$ at specific values of $s$ or $z$.

**The BIG Question:**
If we can represent *any* signal as a sum (or integral) of these simple complex exponentials, then analyzing complex LTI systems becomes a simple matter of multiplication.

This is exactly what **Fourier Analysis** enables!

::: {.notes}
Start by reminding students of the crucial eigenfunction property. This sets the stage for *why* Fourier analysis is so powerful. It's not just a mathematical curiosity; it's a direct consequence of how LTI systems behave. The fundamental insight is that if we can decompose any signal into these elementary complex exponential building blocks, then the analysis of complex signals through LTI systems transforms from difficult convolution operations in the time domain to simple algebraic multiplications in the frequency domain. This is the cornerstone of frequency-domain analysis in ECE.
:::

---

## 2. A Glimpse into History: Joseph Fourier

### Joseph Fourier (1768-1830)

:::: {.columns}
::: {.column width="40%"}
![](https://upload.wikimedia.org/wikipedia/commons/d/df/Fourier2_-_restoration1.jpg){fig-align="center" width="80%"}

*Mathematica, quae ad calorem deduxi, sunt mihi graviora.*
(The mathematics that I have derived concerning heat, are to me of greater importance.)
--- *Joseph Fourier*
:::
::: {.column width="60%"}
*   French mathematician and physicist.
*   Best known for initiating the investigation of Fourier series and their applications to problems of heat transfer and vibrations.
*   **Original Motivation:** Solving the one-dimensional heat equation (1807). He proposed that *any* continuous function could be represented as a **sum of sines and cosines**.
*   **Controversial Idea:** His assertion that *any* function could be represented as such was highly controversial among his peers (Lagrange, Laplace), as the concept of "function" was very narrow at the time.

**Impact:** Revolutionized mathematics and physics, enabling frequency-domain analysis.
:::
::::

::: {.notes}
It's important to provide historical context. Understanding that Fourier's ideas were revolutionary and even controversial helps students appreciate the depth and impact of his work. His motivation came from a practical physical problem (heat conduction), illustrating how theoretical breakthroughs often arise from engineering challenges. Emphasize that the general idea of decomposing a function into a sum of simple terms was not new, but Fourier's specific claim about trigonometric functions for *any* function was radical at the time.
:::

---

## 3. Fourier Series: Representing Periodic Signals

The Fourier Series allows us to represent a **periodic signal** $x(t)$ with period $T_0$ (and fundamental frequency $\omega_0 = 2\pi/T_0$) as a weighted sum of harmonically related complex exponentials.

### 3.1 Complex Exponential Fourier Series
$$
x(t) = \sum_{k=-\infty}^{\infty} c_k e^{jk\omega_0 t}
$$
where the coefficients $c_k$ are given by:
$$
c_k = \frac{1}{T_0} \int_{T_0} x(t) e^{-jk\omega_0 t} dt
$$
(The integral is over any single period $T_0$).

---

## 3. Fourier Series: Representing Periodic Signals

### 3.2 Trigonometric Fourier Series (Alternative Form)
$$
x(t) = a_0 + \sum_{k=1}^{\infty} (a_k \cos(k\omega_0 t) + b_k \sin(k\omega_0 t))
$$
where $a_0 = c_0 = \frac{1}{T_0} \int_{T_0} x(t) dt$ and $c_k = \frac{1}{2}(a_k - jb_k)$.
(For real signals: $a_k = 2 \text{Re}\{c_k\}$, $b_k = -2 \text{Im}\{c_k\}$).

**Key Idea:** Any periodic signal can be decomposed into a sum of a DC component, a fundamental frequency component, and components at integer multiples (harmonics) of the fundamental frequency.

::: {.notes}
Introduce both the complex exponential and trigonometric forms. Emphasize that the complex exponential form is often more mathematically convenient, especially when dealing with LTI systems due to the eigenfunction property. Explain the concept of "harmonics" – components at integer multiples of the fundamental frequency. The coefficients $c_k$, $a_k$, $b_k$ represent the "strength" or "amplitude" of each frequency component present in the signal. The integral formula for $c_k$ is essentially a correlation, telling us how much of $e^{jk\omega_0t}$ is "in" $x(t)$.
:::

---

## 4. Interactive Demo: Fourier Series Synthesis of a Square Wave

Let's synthesize a square wave by summing its Fourier Series components.
A square wave is rich in odd harmonics.

$$
x(t)_{\text{square}} = \frac{4}{\pi} \sum_{k \text{ odd}, k \ge 1} \frac{1}{k} \sin(k\omega_0 t)
$$

Adjust the number of `Harmonics` to see how well the approximation matches the ideal square wave.

```{python}
#| echo: false
import numpy as np
import plotly.graph_objects as go

def square_wave_fourier_synthesis(t, num_harmonics, T0=2*np.pi):
    omega0 = 2 * np.pi / T0
    y_approx = np.zeros_like(t, dtype=float)
    for k in range(1, num_harmonics + 1, 2):  # Only odd harmonics
        coeff = (4 / np.pi) * (1 / k)
        y_approx += coeff * np.sin(k * omega0 * t)
    return y_approx

# Time vector for plotting
T0 = 2 * np.pi
t_vals = np.linspace(0, T0, 500)

# Create the figure
fig = go.Figure()

# Add traces for each number of harmonics
harmonics_steps = range(1, 100, 2)
for num_harmonics in harmonics_steps:
    y_approx = square_wave_fourier_synthesis(t_vals, num_harmonics, T0)
    fig.add_trace(
        go.Scatter(
            visible=False,
            x=t_vals,
            y=y_approx,
            mode='lines',
            name=f'{num_harmonics} Harmonics'
        )
    )

# Make the first trace visible
if fig.data:
    fig.data[0].visible = True

# Ideal square wave (for comparison)
ideal_square_wave = np.where(t_vals < T0/2, 1.0, -1.0)
fig.add_trace(go.Scatter(x=t_vals, y=ideal_square_wave, mode='lines', name='Ideal Square Wave', line=dict(color='red', dash='dash', width=1)))

# Create and add slider
steps = []
num_approximation_traces = len(harmonics_steps)
for i, num_harmonics in enumerate(harmonics_steps):
    visibility = [False] * (num_approximation_traces + 1)
    visibility[i] = True
    visibility[-1] = True # Keep ideal wave visible
    
    step = dict(
        method="update",
        args=[{"visible": visibility},
              {"title": f"Fourier Series Synthesis ({num_harmonics} Harmonics)"}],
        label=str(num_harmonics)
    )
    steps.append(step)

sliders = [dict(
    active=0,
    currentvalue={"prefix": "Harmonics: "},
    pad={"t": 50},
    steps=steps
)]

fig.update_layout(
    sliders=sliders,
    title='Fourier Series Synthesis of a Square Wave (1 Harmonic)',
    xaxis_title='Time',
    yaxis_title='Amplitude',
    legend_title='Signal',
    height=500,
    margin=dict(l=40, r=40, b=40, t=80),
    hovermode="x unified"
)
fig.update_xaxes(range=[0, T0])
fig.update_yaxes(range=[-1.5, 1.5])

fig
```
::: {.notes}
This interactive demo is crucial for building intuition. Students can visually see how adding more harmonics progressively refines the approximation of the square wave. Point out the Gibbs phenomenon (overshoots at discontinuities) as an interesting artifact. Explain that signals with sharp transitions or discontinuities require many harmonics to be accurately represented, while smooth signals might require fewer. This provides a direct link between a signal's time-domain characteristics and its frequency-domain representation.
:::

---

## 5. Fourier Transform: For Aperiodic Signals

Fourier Series applies only to periodic signals. What about non-periodic, transient signals?
The **Fourier Transform (FT)** extends this concept to **aperiodic signals**.

### 5.1 From Fourier Series to Fourier Transform (Conceptual)

Imagine a periodic signal whose period $T_0$ approaches infinity ($T_0 \to \infty$).
As $T_0 \to \infty$:  

*   The fundamental frequency $\omega_0 = 2\pi/T_0 \to 0$.
*   The discrete sum over harmonics becomes a continuous integral over frequency.
*   The Fourier coefficients $c_k$ become a continuous function of frequency, $X(j\omega)$.

---

## 5. Fourier Transform: For Aperiodic Signals

### 5.2 The Fourier Transform Pair

**Forward Fourier Transform:** Transforms a time-domain signal $x(t)$ into its frequency-domain representation $X(j\omega)$.
$$
X(j\omega) = \int_{-\infty}^{\infty} x(t) e^{-j\omega t} dt
$$

**Inverse Fourier Transform:** Transforms a frequency-domain spectrum $X(j\omega)$ back into its time-domain signal $x(t)$.
$$
x(t) = \frac{1}{2\pi} \int_{-\infty}^{\infty} X(j\omega) e^{j\omega t} d\omega
$$

**Interpretation:** $X(j\omega)$ is the **spectrum** of the signal $x(t)$, showing how much of each frequency $\omega$ is present in the signal.

::: {.notes}
Transition from FS to FT by explaining the limiting process where the period goes to infinity. This helps students grasp the conceptual continuity. Emphasize the interpretation of $X(j\omega)$ as the "frequency spectrum" – it's crucial for understanding applications. $X(j\omega)$ is a complex-valued function and can be visualized by its magnitude $|X(j\omega)|$ (how much of that frequency is present) and its phase $\angle X(j\omega)$ (relative phase of that frequency component).
:::

---

## 6. Key Properties of the Fourier Transform in LTI Systems

The FT reveals powerful properties crucial for ECE:

1.  **Linearity:** If $\mathcal{F}\{x_1(t)\} = X_1(j\omega)$ and $\mathcal{F}\{x_2(t)\} = X_2(j\omega)$, then
    $\mathcal{F}\{ax_1(t) + bx_2(t)\} = aX_1(j\omega) + bX_2(j\omega)$

2.  **Time Shift:** If $\mathcal{F}\{x(t)\} = X(j\omega)$, then
    $\mathcal{F}\{x(t-t_0)\} = e^{-j\omega t_0} X(j\omega)$
    (A time shift in the time domain corresponds to a phase shift in the frequency domain).

3.  **Convolution Property (THE MOST IMPORTANT FOR LTI):**
    If $y(t) = x(t) * h(t)$ (convolution in time domain), then
    $\mathcal{F}\{y(t)\} = Y(j\omega) = X(j\omega) H(j\omega)$
    (Convolution in time domain becomes multiplication in frequency domain!)

    Here, $H(j\omega) = \mathcal{F}\{h(t)\}$ is the **frequency response** of the LTI system.

---

## 6. Key Properties of the Fourier Transform in LTI Systems

```{mermaid}
graph TD
    A[Time Domain] -- "Convolution: x(t) * h(t)" --> B["Time Domain Result: y(t)"]

    C[Frequency Domain] -- "FT: X(j&omega;), H(j&omega;)" --> D["Frequency Domain Result: Y(j&omega;)"]

    A -- FT --> C
    B -- FT --> D
  
    C -- Multiplication: X(j&omega;) * H(j&omega;) --> D

    style A fill:#a2c4c9,stroke:#333,stroke-width:2px;
    style B fill:#a2c4c9,stroke:#333,stroke-width:2px;
    style C fill:#fce5cd,stroke:#333,stroke-width:2px;
    style D fill:#fce5cd,stroke:#333,stroke-width:2px;

    linkStyle 0 stroke:#666,stroke-width:2px;
    linkStyle 1 stroke:#333,stroke-width:3px,color:red;
    linkStyle 2 stroke:#666,stroke-width:2px;
    linkStyle 3 stroke:#666,stroke-width:2px;
    linkStyle 4 stroke:#333,stroke-width:3px,color:blue;
```
::: {.notes}
Highlight these properties, especially the convolution property. This is the "AHA!" moment for LTI systems. Explain that calculating convolution in the time domain (an integral or sum) can be computationally intensive and conceptually opaque. Transforming to the frequency domain allows us to simply multiply the input spectrum by the system's frequency response, and then inverse transform the result. This transforms a complex operation into two transforms and a simple multiplication, providing immense analytical and computational benefits.
:::

---

## 7. Interactive Demo: Filtering in the Frequency Domain

Let's apply a simple Low-Pass Filter (LPF) to a signal composed of two sine waves with different frequencies.

Observe:

1.  The input signal's time-domain plot and its frequency spectrum.
2.  The filter's frequency response (magnitude).
3.  The output signal's time-domain plot and its frequency spectrum.

Adjust the `Cutoff Frequency` of the filter. See how the filter attenuates higher frequencies while passing lower frequencies.

```{python}
#| echo: false
import numpy as np
import plotly.graph_objects as go
from plotly.subplots import make_subplots
from numpy.fft import fft, ifft, fftfreq

# Parameters
fs = 50  # Sampling frequency
T = 10   # Duration
t = np.linspace(0, T, int(T * fs), endpoint=False)

# Input signal: sum of two sinusoids
f1 = 0.5  # Low frequency
f2 = 3.0  # High frequency
x_t = np.sin(2 * np.pi * f1 * t) + 0.5 * np.sin(2 * np.pi * f2 * t)

# Compute Fourier Transform of input signal
X_jw = fft(x_t)
frequencies = fftfreq(len(t), 1/fs) * 2 * np.pi  # Convert to angular frequency (rad/s)

# Create a simple Low-Pass Filter (LPF) in frequency domain
def lpf_response(freqs, cutoff):
    H_jw = np.zeros_like(freqs, dtype=complex)
    H_jw[np.abs(freqs) <= cutoff] = 1.0
    H_jw[np.abs(freqs) > 1.2 * cutoff] = 0.0
    return H_jw

# --- Plotting ---
fig = make_subplots(rows=2, cols=2,
                    subplot_titles=("Input Signal x(t)", "|X(jω)| - Input Spectrum",
                                    "|H(jω)| - Filter Response", "Output Signal y(t)"))

# Add static traces first
fig.add_trace(go.Scatter(x=t, y=x_t, mode='lines', name='Input Signal x(t)', line=dict(color='blue')), row=1, col=1)
fig.add_trace(go.Scatter(x=frequencies, y=np.abs(X_jw), mode='lines', name='|X(jω)|', line=dict(color='blue', dash='dot')), row=1, col=2)

cutoff_freq_steps = np.arange(0.1, 5.1, 0.1)

for cutoff_freq in cutoff_freq_steps:
    H_jw = lpf_response(frequencies, cutoff_freq)
    Y_jw = X_jw * H_jw
    y_t = np.real(ifft(Y_jw))

    fig.add_trace(
        go.Scatter(
            visible=False,
            x=frequencies, y=np.abs(H_jw), mode='lines', name='|H(jω)|', line=dict(color='green')
        ), row=2, col=1
    )
    fig.add_trace(
        go.Scatter(
            visible=False,
            x=t, y=y_t, mode='lines', name='Output Signal y(t)', line=dict(color='red')
        ), row=2, col=2
    )

# Make first step visible (corresponding to active slider position)
initial_active_slider_index = 9 # for 1.0 rad/s
fig.data[2 + initial_active_slider_index*2].visible = True
fig.data[3 + initial_active_slider_index*2].visible = True

steps = []
for i, cutoff_freq in enumerate(cutoff_freq_steps):
    visibility = [True, True] + ([False] * len(cutoff_freq_steps) * 2)
    visibility[2 + i*2] = True
    visibility[3 + i*2] = True
    step = dict(
        method="update",
        args=[{"visible": visibility},
              {"title": f"Signal Filtering in Frequency Domain (Cutoff: {cutoff_freq:.1f} rad/s)"}],
        label=f"{cutoff_freq:.1f}"
    )
    steps.append(step)

sliders = [dict(
    active=initial_active_slider_index,
    currentvalue={"prefix": "LPF Cutoff Frequency (ωc): "},
    pad={"t": 50},
    steps=steps
)]

fig.update_layout(
    sliders=sliders,
    title_text=f'Signal Filtering in Frequency Domain (Cutoff: {cutoff_freq_steps[initial_active_slider_index]:.1f} rad/s)',
    height=600,
    showlegend=False,
    margin=dict(l=40, r=40, b=40, t=90)
)
fig.update_xaxes(title_text='Time (s)', row=1, col=1)
fig.update_yaxes(title_text='Amplitude', row=1, col=1)
fig.update_xaxes(title_text='Angular Frequency (rad/s)', range=[-10, 10], row=1, col=2)
fig.update_yaxes(title_text='Magnitude', row=1, col=2)
fig.update_xaxes(title_text='Angular Frequency (rad/s)', range=[-10, 10], row=2, col=1)
fig.update_yaxes(title_text='Magnitude', row=2, col=1)
fig.update_xaxes(title_text='Time (s)', row=2, col=2)
fig.update_yaxes(title_text='Amplitude', row=2, col=2)
fig.update_yaxes(fixedrange=True)

fig
```
::: {.notes}
This is another critical interactive demo. It visually demonstrates the action of a filter directly in both the time and frequency domains. As students move the cutoff frequency, they should observe:
1. The input signal contains both low (0.5 Hz) and high (3.0 Hz) frequency components.
2. The filter's frequency response is a "gate" that passes frequencies below the cutoff and blocks those above.
3. The output signal's spectrum clearly shows which frequencies were passed and which were attenuated.
4. The output signal in the time domain visibly changes, retaining the lower frequency components and smoothing out the higher ones.
This directly illustrates the meaning of $Y(j\omega) = X(j\omega)H(j\omega)$ in a dynamic way.
:::



---

## 8. ECE Applications of Fourier Analysis

Fourier Analysis is fundamental to almost every area of Electrical and Computer Engineering.

**1. Communication Systems**

*   **Modulation/Demodulation:** Shifting a signal's spectrum to a different carrier frequency for transmission (radio, WiFi).
*   **Multiplexing:** Combining multiple signals into one channel by allocating different frequency bands.
*   **Spectrum Analysis:** Understanding bandwidth requirements, interference.

**2. Audio & Speech Processing**

*   **Equalizers:** Boosting or cutting specific frequency ranges.
*   **Noise Reduction:** Filtering out unwanted frequency components.
*   **Compression (e.g., MP3):** Discarding inaudible frequency components.

**3. Image & Video Processing**

*   **Filtering:** Sharpening (high-pass), blurring (low-pass), edge detection.
*   **Compression (e.g., JPEG):** Representing images efficiently in the frequency domain.

---

## 8. ECE Applications of Fourier Analysis 

**4. Circuit Analysis**


*   **AC Steady-State Analysis:** Transforming differential equations into algebraic equations in the frequency domain (phasors).
*   **Filter Design:** Designing circuits that pass or block specific frequencies (e.g., Butterworth, Chebyshev filters).

**5. Control Systems**

*   **Frequency Response Analysis:** Assessing system stability and performance by analyzing how different input frequencies are processed.
*   **System Identification:** Determining a system's characteristics by observing its response to various frequencies.

**6. Digital Signal Processing (DSP)**

*   **Discrete Fourier Transform (DFT) / Fast Fourier Transform (FFT):** Efficient algorithms for computing the FT on discrete (sampled) data, enabling real-time applications.

::: {.notes}
Dedicate a slide to the sheer breadth of applications. This motivates students and shows them how theoretical concepts translate directly into real-world technologies they encounter daily. Emphasize that Fourier analysis is not just a mathematical tool, but a core component of how these systems are designed, analyzed, and implemented. Mention the FFT as the computational backbone that made many of these applications practical.
:::

---

## 9. Conclusion: The Ubiquity of Fourier

*   **Decomposition:** Fourier analysis provides a powerful framework to decompose complex signals into simpler, understandable frequency components (complex exponentials).
*   **Simplification:** It transforms complex time-domain operations (like convolution) into simpler frequency-domain operations (like multiplication) for LTI systems.
*   **Insight:** It offers deep insights into phenomena related to frequency, resonance, filtering, and system behavior.

**In essence, Fourier Analysis is the lens through which engineers view and manipulate signals and systems in the frequency domain.**

It is a cornerstone of modern electrical and computer engineering, underpinning technologies from your smartphone to medical imaging, and from radar to robotics.

---

## 9. Conclusion: The Ubiquity of Fourier

```{mermaid}
graph TD
    A[Complex Time-Domain Signal] --> B{Fourier Transform}
    B --> C[Simple Frequency Components]
    C --> D["LTI System Analysis: Multiplication by H(j&omega;)"]
    D --> E[Output Frequency Components]
    E --> F{Inverse Fourier Transform}
    F --> G[System Output in Time-Domain]

    style A fill:#DDA0DD,stroke:#333,stroke-width:2px;
    style G fill:#DDA0DD,stroke:#333,stroke-width:2px;
    style C fill:#ADD8E6,stroke:#333,stroke-width:2px;
    style E fill:#ADD8E6,stroke:#333,stroke-width:2px;
    style B fill:#8FBC8F,stroke:#333,stroke-width:2px;
    style F fill:#8FBC8F,stroke:#333,stroke-width:2px;
    style D fill:#F4A460,stroke:#333,stroke-width:2px;
```
::: {.notes}
Summarize the key takeaways and reinforce why Fourier analysis is indispensable. Reiterate that it's a fundamental paradigm shift in how we approach signals and systems. The final Mermaid diagram provides a visual conceptual flow from time to frequency and back, showing where the 'magic' of simplification happens. End on an inspiring note connecting the theory back to everyday technology.
:::