---
title: "Interactive Sinusoidal Plot"
subtitle: "Using Pyodide and Observable JS in Quarto"
format:
  live-revealjs:
    logo: "qrjs_assets/unsoed_logo.png"
    footer: "[irosyadi-2025](https://imron-slide.vercel.app)"
    slide-number: true
    chalkboard: true
    scrollable: true
    controls: true
    progress: true
    preview-links: true
    transition: fade
    incremental: false
    theme: [default, qrjs_assets/ir_style.scss]
pyodide:
  packages:
    - numpy
    - plotly
    - nbformat
---

## Sinusoidal Wave

```{ojs}
viewof freqRange = Inputs.range([0.1, 10], {value: 1, step: 0.1, label: "Frequency (Hz)"});
viewof phaseRange = Inputs.range([0, 6.28], {value: 0, step: 0.1, label: "Phase Shift (radians)"});

frequency = debounce(viewof freqRange);
phase = debounce(viewof phaseRange);

// Debounce function to prevent rapid updates
function debounce(input, delay = 500) {
  return Generators.observe(notify => {
    let timer = null;
    let value;
    function inputted() {
      if (timer !== null) return;
      notify(value = input.value);
      timer = setTimeout(delayed, delay);
    }
    function delayed() {
      timer = null;
      if (value === input.value) return;
      notify(value = input.value);
    }
    input.addEventListener("input", inputted), inputted();
    return () => input.removeEventListener("input", inputted);
  });
}
```

```{pyodide}
#| edit: false
#| echo: false
#| input:
#|   - frequency
#|   - phase

import plotly.graph_objects as go
import numpy as np

# Generate time vector
t = np.linspace(0, 10, 500)

# Generate sinusoidal data
y = np.sin(frequency * t + phase)

# Create Plotly figure
fig = go.Figure()

# Add trace for the sinusoidal wave
fig.add_trace(
    go.Scatter(
        x=t,
        y=y,
        mode='lines',
        line=dict(width=4)
    )
)

# Update layout
fig.update_layout(
    xaxis_title="Time (s)",
    yaxis_title="Amplitude",
    yaxis=dict(range=[-1.1, 1.1]),
    width=800,
    margin=dict(l=0, r=0, b=0, t=0)
)

# Display the figure
fig
```

---

## Test


```{pyodide}
import numpy as np
import matplotlib.pyplot as plt

# Define the signals
k_range = np.arange(-2, 7)
x = np.zeros_like(k_range, dtype=float)
x[k_range == 0] = 0.5
x[k_range == 1] = 2.0

h_base = np.zeros_like(k_range, dtype=float)
h_base[(k_range >= 0) & (k_range <= 2)] = 1.0

# Pre-compute the full convolution result y[n]
y_full = np.convolve(x, h_base, 'full')
y_range = np.arange(k_range[0]*2, len(y_full) + k_range[0]*2)

def plot_convolution_step(n):
    fig, (ax1, ax2, ax3) = plt.subplots(3, 1, figsize=(7, 5), sharex=True)

    # 1. Flip & Slide
    h_flipped_shifted = np.zeros_like(k_range, dtype=float)
    h_indices = n - k_range
    mask = (h_indices >= 0) & (h_indices <= 2)
    h_flipped_shifted[mask] = 1.0
    ax1.stem(k_range, x, label='$x[k]$')
    ax1.stem(k_range, h_flipped_shifted, label=f'$h[{n}-k]$', linefmt='r-', markerfmt='ro')
    ax1.set_title(f'1. Flip & Slide (for n={n})'); ax1.legend(); ax1.grid(True)

    # 2. Multiply
    product = x * h_flipped_shifted
    ax2.stem(k_range, product, linefmt='g-', markerfmt='go')
    ax2.set_title(f'2. Multiply: $x[k]h[{n}-k]$'); ax2.grid(True)
  
    # 3. Sum
    y_val = np.sum(product)
    ax3.stem(y_range, y_full, linefmt='k-', markerfmt='ko', basefmt=' ')
    ax3.stem([n], [y_val], 'c^', label=f'$y[{n}] = \\Sigma = {y_val:.1f}$')
    ax3.set_title('3. Sum to get Output $y[n]$'); ax3.legend(); ax3.grid(True)
    ax3.set_xlabel('n (time)'); ax3.set_xlim(k_range[0], k_range[-1]);
  
    plt.tight_layout(); plt.show()

# In a static context, we can't use the interactive slider.
# We'll just call the function for a specific value of n, for example n=1.
plot_convolution_step(n=2)
```