---
title: "Signal and Systems"
subtitle: "2.2 The Convolution Integral"
author: "Imron Rosyadi"
format:
  live-revealjs:
    logo: "qrjs_assets/unsoed_logo.png"
    footer: "[irosyadi-2025](https://imron-slide.vercel.app)"
    slide-number: true
    chalkboard: true
    scrollable: true
    controls: true
    progress: true
    preview-links: true
    transition: fade
    incremental: false
    theme: [default, qrjs_assets/ir_style.scss]
    mermaid:
        theme: forest
pyodide:
  packages:
    - numpy
    - plotly
    - nbformat
---

# Signals and Systems
## CONTINUOUS-TIME LTI SYSTEMS: THE CONVOLUTION INTEGRAL

**ECE Undergraduate Course**

Imron Rosyadi

::: {.notes}
We've seen how the convolution sum governs discrete-time LTI systems. Now, we'll develop the parallel concept for continuous-time systems. Our goal is the same: to find a way to express any continuous-time signal in terms of impulses, which will then let us find a system's output for any input, just by knowing its impulse response.
:::

---

## Representing Continuous Signals with Impulses

We start by approximating a continuous signal $x(t)$ with a "staircase" of narrow pulses.

Each pulse has a width $\Delta$ and height $x(k\Delta)$.

The approximation, $\hat{x}(t)$, is a sum of scaled and shifted rectangular pulses:

$$
\hat{x}(t) = \sum_{k=-\infty}^{\infty} x(k\Delta) \delta_{\Delta}(t-k\Delta)\Delta
$$

where $\delta_{\Delta}(t)$ is a rectangular pulse of width $\Delta$ and height $1/\Delta$.

```{pyodide}
#| max-lines: 10
import numpy as np
import matplotlib.pyplot as plt

def x(t): return (np.sin(t) + np.sin(2.5*t)) * np.exp(-t*0.3)

t_cont = np.linspace(-1, 10, 400)
x_cont = x(t_cont)

delta = 1.0
t_stair = np.arange(-1, 10, delta)
x_stair = x(t_stair)

plt.figure(figsize=(7, 4))
plt.plot(t_cont, x_cont, label='$x(t)$')
plt.bar(t_stair, x_stair, width=delta, align='edge', alpha=0.5, label='$\\hat{x}(t)$')
plt.title('Staircase Approximation of $x(t)$')
plt.xlabel('t'); plt.legend(); plt.grid(True)
plt.show()
```

::: {.notes}
Look at the plot. The smooth blue line is our original signal, $x(t)$. The orange bars represent the staircase approximation, $\hat{x}(t)$. Each bar is a narrow pulse. As you can imagine, if we make the width $\Delta$ of these pulses smaller and smaller, the orange staircase will become a better and better approximation of the blue curve.
:::

---

## From Summation to Integration

As we shrink the pulse width, $\Delta \rightarrow 0$:

1.  The staircase approximation $\hat{x}(t)$ becomes the signal $x(t)$.
2.  The narrow pulse $\delta_{\Delta}(t)$ becomes the ideal impulse $\delta(t)$.
3.  The summation becomes an integral.

$$
\lim_{\Delta \to 0} \sum_{k=-\infty}^{\infty} x(k\Delta) \delta_{\Delta}(t-k\Delta)\Delta \quad \longrightarrow \quad \int_{-\infty}^{\infty} x(\tau) \delta(t-\tau) d\tau
$$

This gives us the **sifting property** for continuous-time signals:

$$
x(t) = \int_{-\infty}^{\infty} x(\tau) \delta(t-\tau) d\tau
$$

::: {.notes}
This limiting process is the heart of the transition from discrete to continuous. The sum, which works with discrete points, transforms into an integral, which works over a continuum. The result is the continuous-time sifting property. Just like its discrete counterpart, it says we can represent any signal $x(t)$ as a "continuous sum" (an integral) of weighted, shifted impulses. The weight for the impulse at time $\tau$ is the value of the signal at that time, $x(\tau)$.
:::

---

## The Convolution Integral

By applying linearity and time-invariance, we arrive at the system output $y(t)$:

-   **Input:** $x(t) = \int x(\tau) \delta(t-\tau) d\tau$ (An integral of weighted impulses)
-   **Linearity:** The output is the integral of the responses to those weighted impulses.
-   **Time-Invariance:** The response to a shifted impulse $\delta(t-\tau)$ is a shifted impulse response $h(t-\tau)$.

Combining these gives the **Convolution Integral**:

$$
y(t) = \int_{-\infty}^{+\infty} x(\tau) h(t-\tau) d\tau
$$

This is denoted as $y(t) = x(t) * h(t)$. Once again, an LTI system is completely characterized by its impulse response $h(t)$.

::: {.notes}
The logic is exactly the same as for the discrete-time case. Linearity means we can consider the response to each infinitesimal slice of the input, $x(\tau)d\tau$, and then integrate (sum) them all up. Time-invariance means the response to a slice at time $\tau$ is just a shifted and scaled version of the impulse response, specifically $x(\tau)h(t-\tau)d\tau$. Integrating over all $\tau$ gives us the total output at time $t$. The convolution integral is the cornerstone of continuous-time LTI system analysis.
:::

---

## The "Flip-and-Slide" Method (Continuous)

We evaluate $y(t) = \int x(\tau)h(t-\tau)d\tau$ for each output time `t`.

**Procedure for a fixed `t`:**

1.  **Plot vs. $\tau$**: Graph the input $x(\tau)$ and impulse response $h(\tau)$.
2.  **Flip**: Time-reverse $h(\tau)$ to get $h(-\tau)$.
3.  **Slide**: Shift $h(-\tau)$ by $t$ to get $h(t-\tau)$.
4.  **Multiply**: Form the product signal $x(\tau)h(t-\tau)$.
5.  **Integrate**: Compute the total area under the product signal. This area is the value of $y(t)$.

Repeat for all `t` to find the entire output signal $y(t)$.

::: {.notes}
The graphical method is also completely analogous. For any specific moment `t` where we want to find the output, we "flip" the impulse response and "slide" it into position. Then we multiply it by the input signal and calculate the area of the resulting shape. That area is our output value, $y(t)$. We then slide to the next value of `t` and repeat.
:::

---

## Example: RC Circuit (Integrator)

Let's find the response of a simple integrator to an exponential input.

**Problem**

- Input: $x(t) = e^{-at}u(t)$, for $a > 0$.
- Impulse Response: $h(t) = u(t)$ (This is an ideal integrator).

**Analysis**

- For $t < 0$, there's no overlap, so $y(t) = 0$.
- For $t \ge 0$, the overlap is for $0 < \tau < t$.
  $$
  y(t) = \int_{0}^{t} e^{-a\tau} d\tau = \frac{1}{a}(1 - e^{-at})
  $$

**Result:** $y(t) = \frac{1}{a}(1 - e^{-at})u(t)$. This is the classic charging curve of an RC circuit.

---

## Example: RC Circuit (Integrator)

```{pyodide}
#| max-lines: 15
import numpy as np
import matplotlib.pyplot as plt

a = 2.0; t = np.linspace(-0.5, 4, 400)
x = np.exp(-a*t) * (t >= 0)
h = (t >= 0).astype(float)
y = (1/a) * (1 - np.exp(-a*t)) * (t >= 0)

fig, (ax1, ax2) = plt.subplots(1, 2, figsize=(7, 3.5))

ax1.plot(t, x, 'b', label='$x(t)$'); ax1.plot(t, h, 'r', label='$h(t)$')
ax1.set_title('Input & Impulse Response'); ax1.legend(); ax1.grid(True)

ax2.plot(t, y, 'g')
ax2.set_title('Output $y(t)=x(t)*h(t)$'); ax2.grid(True)

fig.supxlabel('t'); plt.tight_layout(); plt.show()
```

::: {.notes}
This is the continuous-time version of the accumulator example we saw earlier. The impulse response $h(t)=u(t)$ corresponds to an integrator. When we feed an exponential input into an integrator, we get the output shown on the right. Engineers will recognize this immediately as the voltage across a capacitor in a series RC circuit when a DC voltage is applied. The convolution integral mathematically derives this well-known physical behavior.
:::

---

## Interactive Demo: Convolving Two Pulses

- $x(t)$ is a rectangle from $t=0$ to $t=1$.
- $h(t)$ is a ramp from $t=0$ to $t=2$.

Use the slider for `t` to see the "flip-and-slide" method in action.

```{ojs}
viewof t = Inputs.range([-0.5, 3.5], {label: "t", step: 0.1, value: 1.5});
```

```{pyodide}
#| input:
#|  - t
#| echo: false
import numpy as np
import plotly.graph_objects as go
from plotly.subplots import make_subplots

T = 1.0 # Width of x(t)
tau = np.linspace(-1, 4, 500)
x_tau = ((tau >= 0) & (tau <= T)).astype(float)

def h_func(t_val):
    result = np.zeros_like(t_val)
    mask = (t_val >= 0) & (t_val <= 2*T)
    result[mask] = t_val[mask] / T
    return result

h_tau = h_func(tau)

# Create figure with subplots
fig = make_subplots(
    rows=3, cols=1,
    shared_xaxes=True,
    vertical_spacing=0.1,
    subplot_titles=(
        f'1. Flip & Slide (for t={t:.1f})',
        '2. Multiply & Find Area',
        '3. Area gives Output y(t)'
    )
)

h_flipped_shifted = h_func(t - tau)

# 1. Flip & Slide
fig.add_trace(go.Scatter(x=tau, y=x_tau, name=r'$x(\tau)$'), row=1, col=1)
fig.add_trace(go.Scatter(x=tau, y=h_flipped_shifted, name=f'$h({t:.1f}-\\tau)$'), row=1, col=1)

# 2. Multiply
product = x_tau * h_flipped_shifted
fig.add_trace(go.Scatter(x=tau, y=product, name=r'$x(\tau)h(t-\tau)$', fill='tozeroy', line_color='green'), row=2, col=1)

# 3. Integrate
y_out = np.convolve(x_tau, h_tau, 'same') * (tau[1]-tau[0])
y_current = np.trapz(product, tau)

fig.add_trace(go.Scatter(x=tau, y=y_out, name='$y(t)$', line_color='black'), row=3, col=1)
fig.add_trace(go.Scatter(
    x=[t], y=[y_current],
    name=f'$y({t:.1f}) = \\int \\approx {y_current:.2f}$',
    mode='markers',
    marker=dict(symbol='triangle-up', size=12, color='cyan')
), row=3, col=1)

# Update layout
fig.update_layout(height=700, width=800, showlegend=True)
fig.update_yaxes(range=[-0.2, 2.2], row=1, col=1)
fig.update_xaxes(title_text=r't / $\tau$', range=[-1, 4], row=3, col=1)

fig
```

::: {.notes}
Let's see this in action. The top plot shows the fixed input $x(\tau)$ and the flipped, sliding impulse response $h(t-\tau)$. As you move the slider, you slide the red curve. The middle plot shows their product, and the green shaded region is the area we need to calculate. The bottom plot shows the full output signal $y(t)$ built up from these areas. The cyan triangle shows the output value for the current `t`, which is precisely the green area in the plot above it. Watch how the shape of the overlapping area changes, creating the different segments of the output signal.
:::

---

## Example: One-Sided Exponential

A left-sided exponential convolved with a shifted step function.

**Problem**

- $x(t) = e^{2t}u(-t)$ (left-sided)
- $h(t) = u(t-3)$ (right-sided)

**Analysis**

1.  **Case 1: $t-3 \le 0$ (i.e., $t \le 3$)**
    Overlap is for $\tau < t-3$.
    $y(t) = \int_{-\infty}^{t-3} e^{2\tau}d\tau = \frac{1}{2} e^{2(t-3)}$
2.  **Case 2: $t-3 > 0$ (i.e., $t > 3$)**
    Overlap is for $\tau < 0$.
    $y(t) = \int_{-\infty}^{0} e^{2\tau} d\tau = \frac{1}{2}$

---

## Example: One-Sided Exponential

```{pyodide}
#| max-lines: 15
import numpy as np
import matplotlib.pyplot as plt

t = np.linspace(-2, 6, 400)
x = np.exp(2*t) * (t <= 0)
h = (t >= 3).astype(float)
y = np.where(t <= 3, 0.5 * np.exp(2*(t-3)), 0.5)

fig, ax = plt.subplots(figsize=(7, 4))
ax.plot(t, x, label='$x(t)=e^{2t}u(-t)$')
ax.plot(t, h, label='$h(t)=u(t-3)$')
ax.plot(t, y, 'g--', lw=2, label='$y(t)=x(t)*h(t)$')
ax.set_title('Convolution with a Left-Sided Signal')
ax.set_xlabel('t'); ax.legend(); ax.grid(True)
plt.show()
```

::: {.notes}
This example is interesting because the input signal is non-zero only for negative time. The impulse response is a step that starts at t=3. When we convolve them, we analyze the overlap in two cases. When $t$ is less than 3, the overlap region depends on $t$, resulting in an exponential rise. But once $t$ moves past 3, the region of overlap becomes fixed (from minus infinity to zero), so the integral gives a constant value of 1/2.
:::

---

## Summary

- **Signal Representation:** Any continuous signal $x(t)$ can be represented by the sifting integral: $x(t) = \int x(\tau)\delta(t-\tau)d\tau$.

- **LTI System Response:** The output $y(t)$ of a continuous-time LTI system is the input $x(t)$ convolved with the system's **impulse response** $h(t)$.

- **The Convolution Integral:** The core operation for continuous-time LTI systems is:
  $$ y(t) = x(t) * h(t) = \int_{-\infty}^{\infty} x(\tau)h(t-\tau) d\tau $$

- **Calculation:** The **"flip-and-slide"** method provides a graphical way to compute the convolution integral by finding the area under the product of the input and the flipped, shifted impulse response.

- **Key Parallel:** The theory and methods for continuous-time systems directly mirror those we learned for discrete-time systems, with sums replaced by integrals.

::: {.notes}
To summarize, we've built a complete framework for analyzing continuous-time LTI systems that is perfectly analogous to the discrete-time framework. We represent signals using impulses, which leads to the convolution integral. This integral, calculated via the "flip-and-slide" method, gives us the system's output for any input, provided we know its unique "fingerprint"â€”the impulse response $h(t)$.
:::
