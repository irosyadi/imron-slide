<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.8.25">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="Imron Rosyadi">

<title>Signal and Systems</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="site_libs/quarto-nav/quarto-nav.js"></script>
<script src="site_libs/quarto-nav/headroom.min.js"></script>
<script src="site_libs/clipboard/clipboard.min.js"></script>
<script src="site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="site_libs/quarto-search/fuse.min.js"></script>
<script src="site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="./">
<script src="site_libs/quarto-html/quarto.js" type="module"></script>
<script src="site_libs/quarto-html/tabsets/tabsets.js" type="module"></script>
<script src="site_libs/quarto-html/axe/axe-check.js" type="module"></script>
<script src="site_libs/quarto-html/popper.min.js"></script>
<script src="site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="site_libs/quarto-html/anchor.min.js"></script>
<link href="site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="site_libs/quarto-html/quarto-syntax-highlighting-7b89279ff1a6dce999919e0e67d4d9ec.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="site_libs/bootstrap/bootstrap.min.js"></script>
<link href="site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="site_libs/bootstrap/bootstrap-e31584831b205ffbb2d98406f31c2a5b.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>
<script src="site_libs/quarto-diagram/mermaid.min.js"></script>
<script src="site_libs/quarto-diagram/mermaid-init.js"></script>
<link href="site_libs/quarto-diagram/mermaid.css" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN" && texText && texText.data) {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

<link rel="stylesheet" href="styles.css">
</head>

<body class="nav-fixed quarto-light">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a href="./index.html" class="navbar-brand navbar-brand-logo">
    </a>
    <a class="navbar-brand" href="./index.html">
    <span class="navbar-title">Signal and Systems</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" role="menu" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll me-auto">
  <li class="nav-item">
    <a class="nav-link" href="./index.html"> 
<span class="menu-text">Home</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="./about.html"> 
<span class="menu-text">About</span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
            <div class="quarto-navbar-tools">
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">On this page</h2>
   
  <ul>
  <li><a href="#basic-system-properties" id="toc-basic-system-properties" class="nav-link active" data-scroll-target="#basic-system-properties">Basic System Properties</a>
  <ul class="collapse">
  <li><a href="#introduction-to-system-properties" id="toc-introduction-to-system-properties" class="nav-link" data-scroll-target="#introduction-to-system-properties">Introduction to System Properties</a></li>
  <li><a href="#systems-with-and-without-memory" id="toc-systems-with-and-without-memory" class="nav-link" data-scroll-target="#systems-with-and-without-memory">1. Systems with and without Memory</a></li>
  <li><a href="#systems-with-and-without-memory-1" id="toc-systems-with-and-without-memory-1" class="nav-link" data-scroll-target="#systems-with-and-without-memory-1">1. Systems with and without Memory</a></li>
  <li><a href="#memory-interactive-demonstration" id="toc-memory-interactive-demonstration" class="nav-link" data-scroll-target="#memory-interactive-demonstration">Memory: Interactive Demonstration</a></li>
  <li><a href="#memory-interactive-demonstration-1" id="toc-memory-interactive-demonstration-1" class="nav-link" data-scroll-target="#memory-interactive-demonstration-1">Memory: Interactive Demonstration</a></li>
  <li><a href="#invertibility-and-inverse-systems" id="toc-invertibility-and-inverse-systems" class="nav-link" data-scroll-target="#invertibility-and-inverse-systems">2. Invertibility and Inverse Systems</a></li>
  <li><a href="#invertibility-and-inverse-systems-1" id="toc-invertibility-and-inverse-systems-1" class="nav-link" data-scroll-target="#invertibility-and-inverse-systems-1">2. Invertibility and Inverse Systems</a></li>
  <li><a href="#non-invertible-systems" id="toc-non-invertible-systems" class="nav-link" data-scroll-target="#non-invertible-systems">Non-Invertible Systems</a></li>
  <li><a href="#invertibility-interactive-demonstration" id="toc-invertibility-interactive-demonstration" class="nav-link" data-scroll-target="#invertibility-interactive-demonstration">Invertibility: Interactive Demonstration</a></li>
  <li><a href="#causality" id="toc-causality" class="nav-link" data-scroll-target="#causality">3. Causality</a></li>
  <li><a href="#causality-1" id="toc-causality-1" class="nav-link" data-scroll-target="#causality-1">3. Causality</a></li>
  <li><a href="#causality-interactive-demonstration" id="toc-causality-interactive-demonstration" class="nav-link" data-scroll-target="#causality-interactive-demonstration">Causality: Interactive Demonstration</a></li>
  <li><a href="#stability" id="toc-stability" class="nav-link" data-scroll-target="#stability">4. Stability</a></li>
  <li><a href="#stability-1" id="toc-stability-1" class="nav-link" data-scroll-target="#stability-1">4. Stability</a></li>
  <li><a href="#stability-interactive-demonstration-accumulator" id="toc-stability-interactive-demonstration-accumulator" class="nav-link" data-scroll-target="#stability-interactive-demonstration-accumulator">Stability: Interactive Demonstration (Accumulator)</a></li>
  <li><a href="#examples-of-stability-check" id="toc-examples-of-stability-check" class="nav-link" data-scroll-target="#examples-of-stability-check">Examples of Stability Check</a>
  <ul class="collapse">
  <li><a href="#time-invariance" id="toc-time-invariance" class="nav-link" data-scroll-target="#time-invariance">5. Time Invariance</a></li>
  <li><a href="#time-invariance-1" id="toc-time-invariance-1" class="nav-link" data-scroll-target="#time-invariance-1">5. Time Invariance</a></li>
  </ul></li>
  <li><a href="#time-invariance-interactive-demonstration-time-varying-gain" id="toc-time-invariance-interactive-demonstration-time-varying-gain" class="nav-link" data-scroll-target="#time-invariance-interactive-demonstration-time-varying-gain">Time Invariance: Interactive Demonstration (Time-Varying Gain)</a></li>
  <li><a href="#linearity" id="toc-linearity" class="nav-link" data-scroll-target="#linearity">6. Linearity</a></li>
  <li><a href="#linearity-examples" id="toc-linearity-examples" class="nav-link" data-scroll-target="#linearity-examples">Linearity: Examples</a></li>
  <li><a href="#linearity-interactive-demonstration-quadratic-system" id="toc-linearity-interactive-demonstration-quadratic-system" class="nav-link" data-scroll-target="#linearity-interactive-demonstration-quadratic-system">Linearity: Interactive Demonstration (Quadratic System)</a></li>
  <li><a href="#linearity-incrementally-linear-systems" id="toc-linearity-incrementally-linear-systems" class="nav-link" data-scroll-target="#linearity-incrementally-linear-systems">Linearity: Incrementally Linear Systems</a></li>
  <li><a href="#conclusion-summary" id="toc-conclusion-summary" class="nav-link" data-scroll-target="#conclusion-summary">Conclusion &amp; Summary</a></li>
  </ul></li>
  </ul>
<div class="quarto-alternate-formats"><h2>Other Formats</h2><ul><li><a href="ss_16.html"><i class="bi bi-file-slides"></i>RevealJS (live)</a></li></ul></div></nav>
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">Signal and Systems</h1>
<p class="subtitle lead">1.6 Basic System Properties</p>
</div>



<div class="quarto-title-meta">

    <div>
    <div class="quarto-title-meta-heading">Author</div>
    <div class="quarto-title-meta-contents">
             <p>Imron Rosyadi </p>
          </div>
  </div>
    
  
    
  </div>
  


</header>


<section id="basic-system-properties" class="level1">
<h1>Basic System Properties</h1>
<hr>
<section id="introduction-to-system-properties" class="level2">
<h2 class="anchored" data-anchor-id="introduction-to-system-properties">Introduction to System Properties</h2>
<ul>
<li><strong>Understanding System Behavior:</strong> Basic system properties help categorize and analyze how systems behave.</li>
<li>These properties are crucial for:
<ul>
<li>Simplifying system analysis and design.</li>
<li>Predicting system responses to various inputs.</li>
<li>Developing theoretical frameworks for signals and systems.</li>
</ul></li>
</ul>
<div class="notes">
<p>Welcome everyone to this session on Basic System Properties. In Signals and Systems, understanding how systems react to signals is fundamental. But to truly understand them, we first need to characterize them based on certain intrinsic properties. These properties act like fundamental rules that govern a system’s behavior, allowing us to predict, design, and even troubleshoot complex systems with greater ease. They’ll be central to all our subsequent discussions in this course.</p>
</div>
<hr>
</section>
<section id="systems-with-and-without-memory" class="level2">
<h2 class="anchored" data-anchor-id="systems-with-and-without-memory">1. Systems with and without Memory</h2>
<p>A system is <strong>memoryless</strong> if its output at any given time depends only on the input at that <em>same</em> time.</p>
<p><strong>Memoryless System Examples:</strong></p>
<ul>
<li><strong>Discrete-Time:</strong> <span class="math display">\[
y[n]=\left(2 x[n]-x^{2}[n]\right)^{2} \quad \text{(1.90)}
\]</span></li>
<li><strong>Continuous-Time (Resistor):</strong> <span class="math display">\[
y(t)=R x(t) \quad \text{(1.91)}
\]</span></li>
</ul>
<hr>
</section>
<section id="systems-with-and-without-memory-1" class="level2">
<h2 class="anchored" data-anchor-id="systems-with-and-without-memory-1">1. Systems with and without Memory</h2>
<p><strong>Systems with Memory:</strong> Output depends on past or future input values.</p>
<ul>
<li><strong>Discrete-Time Accumulator (Summer):</strong> <span class="math display">\[
y[n]=\sum_{k=-\infty}^{n} x[k] \quad \text{(1.92)}
\]</span> This can also be expressed as <span class="math inline">\(y[n]=y[n-1]+x[n]\)</span>.</li>
<li><strong>Discrete-Time Delay:</strong> <span class="math display">\[
y[n]=x[n-1] \quad \text{(1.93)}
\]</span></li>
<li><strong>Continuous-Time Capacitor:</strong> <span class="math display">\[
y(t)=\frac{1}{C} \int_{-\infty}^{t} x(\tau) d \tau \quad \text{(1.94)}
\]</span></li>
</ul>
<div class="notes">
<p>The first property we’ll discuss is memory. Think of it simply: does the system need to “remember” past (or anticipate future) inputs to produce its current output?</p>
<p>A memoryless system is like an instantaneous black box. The resistor is a classic example: the voltage across it at time ‘t’ only depends on the current flowing through it at that <em>exact</em> same time ‘t’. It doesn’t care what the current was five seconds ago, or what it will be in the future.</p>
<p>On the other hand, systems with memory hold onto information. An accumulator, for instance, needs to sum <em>all</em> past inputs up to the current moment. Similarly, a delay system needs to remember the previous input value to output it at the current time. In physical systems, memory is often associated with energy storage, such as in capacitors (storing charge related to past current) or inductors (storing magnetic energy related to past voltage). Digital systems store information in registers. While we usually think of memory as related to the past, dependency on future values also qualifies as memory, as we’ll see with causality.</p>
</div>
<hr>
</section>
<section id="memory-interactive-demonstration" class="level2">
<h2 class="anchored" data-anchor-id="memory-interactive-demonstration">Memory: Interactive Demonstration</h2>
<p>Let’s compare a memoryless system with a system with memory (an accumulator).</p>
<p><strong>Memoryless System:</strong> <span class="math inline">\(y[n] = x[n]^2\)</span></p>
<pre class="{pyodide}"><code>#| max-lines: 10
import numpy as np
import matplotlib.pyplot as plt

# Input signal
n = np.arange(-5, 6)
x = np.where((n &gt;= -2) &amp; (n &lt;= 2), 1, 0) # Simple pulse

# Memoryless system output
y_memoryless = x**2

plt.figure(figsize=(6, 2.5))
plt.stem(n, x, label='Input x[n]', basefmt=" ")
plt.stem(n, y_memoryless, linefmt='r-', markerfmt='ro', label='Output y[n]', basefmt=" ")
plt.title('Memoryless System: y[n] = x[n]^2')
plt.xlabel('n')
plt.ylabel('Amplitude')
plt.grid(True)
plt.legend()
plt.tight_layout()
plt.show()</code></pre>
<hr>
</section>
<section id="memory-interactive-demonstration-1" class="level2">
<h2 class="anchored" data-anchor-id="memory-interactive-demonstration-1">Memory: Interactive Demonstration</h2>
<p><strong>System with Memory (Accumulator):</strong> <span class="math inline">\(y[n] = \sum_{k=-\infty}^{n} x[k]\)</span></p>
<pre class="{pyodide}"><code>#| max-lines: 10
import numpy as np
import matplotlib.pyplot as plt

# Input signal
n = np.arange(-5, 6)
x = np.where((n == 0) | (n == 1), 1, 0) # Two impulses

# Accumulator output
y_accumulator = np.cumsum(x)

plt.figure(figsize=(6, 2.5))
plt.stem(n, x, label='Input x[n]', basefmt=" ")
plt.stem(n, y_accumulator, linefmt='g-', markerfmt='go', label='Output y[n]', basefmt=" ")
plt.title('Accumulator: y[n] = sum(x[k])')
plt.xlabel('n')
plt.ylabel('Amplitude')
plt.grid(True)
plt.legend()
plt.tight_layout()
plt.show()</code></pre>
<div class="notes">
<p>Here we have two interactive plots to illustrate the concept of memory.</p>
<p>On the first, for the memoryless system <code>y[n] = x[n]^2</code>, observe how <code>y[n]</code> at any point <code>n</code> (e.g., <code>n=0</code>) is simply the square of <code>x[n]</code> at that <em>same</em> <code>n</code>. There’s no dependency on <code>x[-1]</code> or <code>x[1]</code>. The output mirrors the input’s shape instantaneously.</p>
<p>On the second, we have an accumulator <code>y[n] = sum(x[k])</code>. If the input <code>x[n]</code> is an impulse at <code>n=0</code> and <code>n=1</code>, the output <code>y[n]</code> at, say, <code>n=2</code>, is the sum of <code>x[-infinity]</code> to <code>x[2]</code>. It “remembers” the past impulses. Notice how the output value at a given <code>n</code> is influenced by all the input values that came before it. This continuous build-up is a clear sign of memory.</p>
</div>
<hr>
</section>
<section id="invertibility-and-inverse-systems" class="level2">
<h2 class="anchored" data-anchor-id="invertibility-and-inverse-systems">2. Invertibility and Inverse Systems</h2>
<p>A system is <strong>invertible</strong> if distinct inputs always produce distinct outputs.</p>
<ul>
<li>If a system is invertible, an <strong>inverse system</strong> exists.</li>
<li>When cascaded with the original system, the inverse system yields an output identical to the original input.</li>
</ul>
<div class="cell" data-layout-align="default">
<div class="cell-output-display">
<div>
<p></p><figure class="figure"><p></p>
<div>
<pre class="mermaid mermaid-js">graph LR
    A["Input x[n]"] --&gt; S1["System S"]
    S1 --&gt; B["Output y[n]"]
    B --&gt; S2["Inverse System S⁻¹"]
    S2 --&gt; C["Output w[n] = x[n]"]
</pre>
</div>
<p></p></figure><p></p>
</div>
</div>
</div>
<p><em>(Figure 1.45(a) - Concept of an inverse system)</em></p>
<hr>
</section>
<section id="invertibility-and-inverse-systems-1" class="level2">
<h2 class="anchored" data-anchor-id="invertibility-and-inverse-systems-1">2. Invertibility and Inverse Systems</h2>
<p><strong>Invertible System Example (Continuous-Time):</strong></p>
<p><span class="math display">\[
y(t)=2 x(t) \quad \text{(1.97)}
\]</span> Inverse System: <span class="math display">\[
w(t)=\frac{1}{2} y(t) \quad \text{(1.98)}
\]</span></p>
<p><strong>Invertible System Example (Discrete-Time Accumulator):</strong></p>
<p>The accumulator: <span class="math inline">\(y[n]=\sum_{k=-\infty}^{n} x[k]\)</span> Inverse System: <span class="math display">\[
w[n]=y[n]-y[n-1] \quad \text{(1.99)}
\]</span></p>
<div class="notes">
<p>Next, we consider invertibility. An invertible system is one where you can uniquely determine the input signal if you know the output signal. Imagine a secret code: if you can decode the message perfectly back to its original form, the encoding process was invertible. If multiple different original messages could result in the same encoded message, then it’s not invertible and you can’t uniquely recover the original.</p>
<p>Mathematically, this means that if <span class="math inline">\(x_1(t) \neq x_2(t)\)</span>, then their corresponding outputs <span class="math inline">\(y_1(t) \neq y_2(t)\)</span>. If this condition holds, then an inverse system can be designed. The block diagram shows this concept: the original system followed by its inverse system effectively acts as an identity system, where the final output is just the original input.</p>
<p>Consider the simple scaling system <code>y(t) = 2x(t)</code>. If you know <code>y(t)</code>, you can always find <code>x(t)</code> by dividing <code>y(t)</code> by 2. It’s perfectly invertible. The accumulator is also invertible, its inverse is the first difference operator.</p>
</div>
<hr>
</section>
<section id="non-invertible-systems" class="level2">
<h2 class="anchored" data-anchor-id="non-invertible-systems">Non-Invertible Systems</h2>
<p><strong>Examples of Non-Invertible Systems:</strong></p>
<ul>
<li><strong>Zero System:</strong> <span class="math display">\[
y[n]=0 \quad \text{(1.100)}
\]</span> <em>Many different inputs (e.g., <span class="math inline">\(x[n]=u[n]\)</span> or <span class="math inline">\(x[n]=\delta[n]\)</span>) produce the same zero output.</em></li>
<li><strong>Squaring System:</strong> <span class="math display">\[
y(t)=x^{2}(t) \quad \text{(1.101)}
\]</span> <em>You cannot determine the sign of <span class="math inline">\(x(t)\)</span> from <span class="math inline">\(y(t)\)</span>. For example, <span class="math inline">\(x(t)=2\)</span> and <span class="math inline">\(x(t)=-2\)</span> both yield <span class="math inline">\(y(t)=4\)</span>.</em></li>
</ul>
<p><strong>Practical Application: Encoding Systems</strong> * In communications, encoders must be invertible for perfect signal recovery.</p>
<div class="notes">
<p>Now for non-invertible systems: these are systems where multiple distinct inputs can lead to the <em>same</em> output. If this happens, you can’t uniquely reconstruct the input from the output, as you don’t know which of the multiple input possibilities was the original one.</p>
<p>The ‘zero system’ is a trivial but clear example: no matter what you input, the output is always zero. If the output is zero, you have no way of knowing what the original input was. Similarly, for the squaring system <span class="math inline">\(y(t) = x^2(t)\)</span>, consider inputs <span class="math inline">\(x(t)=2\)</span> and <span class="math inline">\(x(t)=-2\)</span>. Both produce the output <span class="math inline">\(y(t)=4\)</span>. If you only see <span class="math inline">\(y(t)=4\)</span>, you can’t tell if the input was 2 or -2. Thus, the system is non-invertible.</p>
<p>This concept is vital in areas like data compression and encoding. For instance, lossless audio compression aims to be invertible, allowing you to perfectly reconstruct the original audio. Lossy compression, like MP3, is non-invertible because it discards information, making perfect reconstruction impossible, though often perceptually acceptable.</p>
</div>
<hr>
</section>
<section id="invertibility-interactive-demonstration" class="level2">
<h2 class="anchored" data-anchor-id="invertibility-interactive-demonstration">Invertibility: Interactive Demonstration</h2>
<p>Let’s demonstrate the inverse for an accumulator.</p>
<pre class="{pyodide}"><code>#| max-lines: 10
import numpy as np
import matplotlib.pyplot as plt

# Define input signal
n = np.arange(-5, 6)
x = np.array([0, 0, 0, 1, 2, -1, 0.5, 0, 0, 0, 0]) # A simple test signal

# System (Accumulator)
# y[n] = sum_{k=-inf}^{n} x[k]
y_system = np.cumsum(x)

# Inverse System (First Difference)
# w[n] = y[n] - y[n-1]
w_inverse = np.zeros_like(y_system, dtype=float)
w_inverse[0] = y_system[0] # Handle the first element
w_inverse[1:] = y_system[1:] - y_system[:-1]


plt.figure(figsize=(7, 6))

plt.subplot(3, 1, 1)
plt.stem(n, x, label='Input x[n]', basefmt=" ")
plt.title('Original Input x[n]')
plt.ylabel('Amplitude')
plt.grid(True)
plt.tight_layout()

plt.subplot(3, 1, 2)
plt.stem(n, y_system, linefmt='r-', markerfmt='ro', label='Output y[n]', basefmt=" ")
plt.title('System Output y[n] (Accumulator)')
plt.ylabel('Amplitude')
plt.grid(True)
plt.tight_layout()

plt.subplot(3, 1, 3)
plt.stem(n, w_inverse, linefmt='g-', markerfmt='go', label='Recovered w[n]', basefmt=" ")
plt.title('Recovered Signal w[n] (Inverse System)')
plt.xlabel('n')
plt.ylabel('Amplitude')
plt.grid(True)
plt.tight_layout()

plt.show()

# Verify if w_inverse is identical to x
print(f"Are recovered signal w[n] and original x[n] identical? {np.allclose(x, w_inverse)}")
</code></pre>
<div class="notes">
<p>This interactive plot helps us visualize the invertibility of the accumulator.</p>
<ol type="1">
<li><strong>Original Input <code>x[n]</code>:</strong> This is the signal we apply to our system.</li>
<li><strong>System Output <code>y[n]</code> (Accumulator):</strong> This shows <code>x[n]</code> after passing through the accumulator, where each <code>y[n]</code> is the running sum of <code>x[k]</code> up to <code>n</code>. Notice how the signal builds up or combines the past values.</li>
<li><strong>Recovered Signal <code>w[n]</code> (Inverse System):</strong> This is the output of the inverse system, which performs a “first difference” operation (<span class="math inline">\(w[n] = y[n] - y[n-1]\)</span>). Observe how this operation effectively “undoes” the accumulation and recovers the original shape of <code>x[n]</code>.</li>
</ol>
<p>The printout below the graph confirms numerically that the recovered signal <code>w[n]</code> is indeed identical to the original input <code>x[n]</code>. This provides a concrete example of an invertible system and its inverse.</p>
</div>
<hr>
</section>
<section id="causality" class="level2">
<h2 class="anchored" data-anchor-id="causality">3. Causality</h2>
<p>A system is <strong>causal</strong> if its output at any time depends <em>only</em> on values of the input at the present time and in the past.</p>
<ul>
<li>Often referred to as <strong>nonanticipative</strong>.</li>
<li>If <span class="math inline">\(x_1(t) = x_2(t)\)</span> for <span class="math inline">\(t \le t_0\)</span>, then <span class="math inline">\(y_1(t) = y_2(t)\)</span> for <span class="math inline">\(t \le t_0\)</span>.</li>
<li><strong>All memoryless systems are causal.</strong></li>
</ul>
<p><strong>Causal System Examples:</strong></p>
<ul>
<li><strong>RC Circuit:</strong> Capacitor voltage responds to present and past source voltage.</li>
<li><strong>Accumulator:</strong> <span class="math inline">\(y[n]=\sum_{k=-\infty}^{n} x[k]\)</span></li>
<li><strong>Delay:</strong> <span class="math inline">\(y[n]=x[n-1]\)</span></li>
</ul>
<hr>
</section>
<section id="causality-1" class="level2">
<h2 class="anchored" data-anchor-id="causality-1">3. Causality</h2>
<p><strong>Non-Causal System Examples:</strong></p>
<ul>
<li><strong>Future-Dependent:</strong> <span class="math display">\[
y[n]=x[n]-x[n+1] \quad \text{(1.102)}
\]</span> <span class="math display">\[
y(t)=x(t+1) \quad \text{(1.103)}
\]</span></li>
<li><strong>Time Reversal:</strong> <span class="math display">\[
y[n]=x[-n] \quad \text{(1.105)}
\]</span> <em>For <span class="math inline">\(n &lt; 0\)</span>, e.g., <span class="math inline">\(y[-4]=x[4]\)</span>, output depends on future input.</em></li>
<li><strong>Averaging System:</strong> <span class="math display">\[
y[n]=\frac{1}{2 M+1} \sum_{k=-M}^{+M} x[n-k] \quad \text{(1.104)}
\]</span> <em>Includes future values like <span class="math inline">\(x[n+M]\)</span>.</em></li>
</ul>
<div class="notes">
<p>Causality is a crucial property, especially for real-time systems. Simply put, a causal system cannot “look into the future.” Its current output can only be influenced by the current input or inputs that have already occurred (i.e., past inputs). Think of hitting a drum: the sound (output) can only happen after you hit it (input), not before.</p>
<p>An RC circuit is causal because the capacitor voltage builds up based on the history of the current, not what current will flow in the future. All memoryless systems are inherently causal because their output only depends on the present input, which by definition means no future dependency.</p>
<p>However, many systems are non-causal. For instance, a system that outputs <code>x[n+1]</code> outputs a future value of the input. This is impossible in real-time, but perfectly fine for processing recorded data, like in audio mastering or image processing, where the entire signal is available. The average system is an example, it takes inputs from a window that spans both past and future values relative to <code>n</code>. Another subtle non-causal system is <code>y[n] = x[-n]</code>. For <span class="math inline">\(n &lt; 0\)</span>, say <span class="math inline">\(n=-5\)</span>, <span class="math inline">\(y[-5]\)</span> becomes <span class="math inline">\(x[5]\)</span>, which is a future value.</p>
</div>
<hr>
</section>
<section id="causality-interactive-demonstration" class="level2">
<h2 class="anchored" data-anchor-id="causality-interactive-demonstration">Causality: Interactive Demonstration</h2>
<p>Compare a causal delay with a non-causal advance.</p>
<pre class="{pyodide}"><code>#| max-lines: 10
import numpy as np
import matplotlib.pyplot as plt

# Define input signal
n = np.arange(-5, 6)
x = np.cos(np.pi/2 * n) * np.exp(-0.2*np.abs(n))
x = np.where(n &gt;= -4, x, 0) # Make it start from a certain point for clarity

# Causal System: Delay
y_delay = np.zeros_like(x)
y_delay[1:] = x[:-1] # y[n] = x[n-1]

# Non-Causal System: Advance
y_advance = np.zeros_like(x)
y_advance[:-1] = x[1:] # y[n] = x[n+1]

plt.figure(figsize=(7, 6))

plt.subplot(3, 1, 1)
plt.stem(n, x, label='Input x[n]', basefmt=" ")
plt.title('Original Input x[n]')
plt.ylabel('Amplitude')
plt.grid(True)
plt.tight_layout()

plt.subplot(3, 1, 2)
plt.stem(n, y_delay, label='Output y[n]', basefmt=" ")
plt.stem(n, x, linefmt='k:', markerfmt='k.', label='Original x[n] (for ref)', basefmt=" ")
plt.title('Causal System: y[n] = x[n-1] (Delay)')
plt.ylabel('Amplitude')
plt.grid(True)
plt.legend()
plt.tight_layout()


plt.subplot(3, 1, 3)
plt.stem(n, y_advance, label='Output y[n]', basefmt=" ")
plt.stem(n, x, linefmt='k:', markerfmt='k.', label='Original x[n] (for ref)', basefmt=" ")
plt.title('Non-Causal System: y[n] = x[n+1] (Advance)')
plt.xlabel('n')
plt.ylabel('Amplitude')
plt.grid(True)
plt.legend()
plt.tight_layout()

plt.show()</code></pre>
<div class="notes">
<p>This interactive plot clearly demonstrates the difference between causal and non-causal systems using a delay and an advance.</p>
<ol type="1">
<li><strong>Original Input <code>x[n]</code>:</strong> Our reference signal.</li>
<li><strong>Causal System: <code>y[n] = x[n-1]</code> (Delay):</strong> Observe that the output <code>y[n]</code> is always the value of <code>x[n]</code> from the <em>previous</em> time step. For example, <code>y[0]</code> is <code>x[-1]</code>, <code>y[1]</code> is <code>x[0]</code>, and so on. The output signal is shifted to the right, appearing <em>after</em> the corresponding input values. This is how physical, real-time systems operate. For any given <code>n</code>, your output only depends on <code>x[n]</code> or <code>x[n-k]</code> where <code>k</code> is a positive integers.</li>
<li><strong>Non-Causal System: <code>y[n] = x[n+1]</code> (Advance):</strong> Notice how the output <code>y[n]</code> is the value of <code>x[n]</code> from the <em>next</em> time step. For example, <code>y[0]</code> is <code>x[1]</code>, <code>y[1]</code> is <code>x[2]</code>. The output signal appears shifted to the left, meaning it anticipates future input values. While impossible in real-time, such systems are useful for processing pre-recorded data when all future samples are available.</li>
</ol>
</div>
<hr>
</section>
<section id="stability" class="level2">
<h2 class="anchored" data-anchor-id="stability">4. Stability</h2>
<p>A system is <strong>stable</strong> if small (bounded) inputs lead to responses that do not diverge (are also bounded).</p>
<ul>
<li><strong>Bounded-Input, Bounded-Output (BIBO) Stability.</strong></li>
<li>Informally: A stable system eventually settles down or remains within limits, given a reasonable input.</li>
</ul>
<div class="columns">
<div class="column" style="width:50%;">
<p><strong>Stable System Analogy: Pendulum</strong></p>
<p><img src="https://cdn.mathpix.com/cropped/2024_02_14_ad5c48a840b9702e9410g-079.jpg?height=261&amp;width=387&amp;top_left_y=1472&amp;top_left_x=665" class="img-fluid"> <em>Gravity and friction provide restoring/dissipating forces.</em></p>
</div><div class="column" style="width:50%;">
<p><strong>Unstable System Analogy: Inverted Pendulum</strong> <img src="https://cdn.mathpix.com/cropped/2024_02_14_ad5c48a840b9702e9410g-079.jpg?height=306&amp;width=354&amp;top_left_y=1813&amp;top_left_x=703" class="img-fluid"> <em>Gravity increases deviation; small perturbation leads to tipping.</em></p>
</div>
</div>
<hr>
</section>
<section id="stability-1" class="level2">
<h2 class="anchored" data-anchor-id="stability-1">4. Stability</h2>
<p><strong>Unstable System Example: Accumulator for Unit Step Input</strong></p>
<p>If <span class="math inline">\(x[n]=u[n]\)</span> (unit step, bounded, equal to 1 for <span class="math inline">\(n \ge 0\)</span>), the accumulator output is: <span class="math display">\[
y[n]=\sum_{k=-\infty}^{n} u[k]=(n+1) u[n]
\]</span> * <span class="math inline">\(y[0]=1, y[1]=2, y[2]=3, \ldots\)</span> * <span class="math inline">\(y[n]\)</span> grows without bound, so the accumulator is unstable.</p>
<div class="notes">
<p>Stability is a critical property for practical systems. An unstable system, even with a small input, can produce an output that grows infinitely large, potentially leading to system failure or unwanted behavior. Think of a microphone feeding back into a speaker: a small sound can quickly escalate into a loud, ear-splitting screech. That’s instability.</p>
<p>The formal definition is <strong>BIBO stability</strong>: Bounded-Input, Bounded-Output. If you put a signal into the system whose amplitude never exceeds a certain finite maximum (it’s “bounded”), then the output signal must also have an amplitude that never exceeds some finite maximum. If the output grows without limit for <em>any</em> bounded input, the system is unstable.</p>
<p>The pendulum analogy is excellent. A normal pendulum is stable: give it a small push, and it oscillates for a while but eventually settles back to its equilibrium point due to damping (friction) and a restoring force (gravity). An inverted pendulum, however, is inherently unstable: a tiny push will cause it to fall over, with its deviation from vertical growing rapidly.</p>
<p>The accumulator, as we saw before, is an example of an unstable system. If you feed it a constant input like a unit step, its output just keeps growing indefinitely, accumulating the past values. This unbounded growth from a bounded input directly violates the BIBO stability criterion.</p>
</div>
<hr>
</section>
<section id="stability-interactive-demonstration-accumulator" class="level2">
<h2 class="anchored" data-anchor-id="stability-interactive-demonstration-accumulator">Stability: Interactive Demonstration (Accumulator)</h2>
<p>Let’s observe the accumulator’s response to a bounded input.</p>
<pre class="{pyodide}"><code>#| max-lines: 10
import numpy as np
import matplotlib.pyplot as plt

# Input signal: Bounded unit step
n = np.arange(-5, 10)
x = np.where(n &gt;= 0, 1, 0) # Unit step function, bounded by 1

# Accumulator output
y_accumulator = np.cumsum(x)

plt.figure(figsize=(8, 4))

plt.subplot(2, 1, 1)
plt.stem(n, x, label='Input x[n]', basefmt=" ")
plt.title('Bounded Input: x[n] = u[n]')
plt.ylabel('Amplitude')
plt.grid(True)
plt.tight_layout()

plt.subplot(2, 1, 2)
plt.stem(n, y_accumulator, linefmt='r-', markerfmt='ro', label='Output y[n]', basefmt=" ")
plt.title('System Output: Accumulator (Unbounded)')
plt.xlabel('n')
plt.ylabel('Amplitude')
plt.grid(True)
plt.tight_layout()

plt.show()

# Demonstrate some values
print(f"Input x[0]={x[n==0]}, x[5]={x[n==5]}, x[-1]={x[n==-1]}")
print(f"Output y[0]={y_accumulator[n==0]}, y[5]={y_accumulator[n==5]}")</code></pre>
<div class="notes">
<p>This interactive demonstration uses the accumulator system again, but specifically to show its instability.</p>
<ol type="1">
<li><strong>Bounded Input <code>x[n] = u[n]</code>:</strong> The top plot shows a unit step function. This signal is definitely bounded; its maximum value is 1, and its minimum is 0.</li>
<li><strong>System Output (Accumulator):</strong> The bottom plot shows the output of the accumulator when <code>u[n]</code> is the input. You can clearly see that <code>y[n]</code> grows linearly with <code>n</code> for <code>n &gt;= 0</code>. For example, <code>y[0]=1</code>, <code>y[1]=2</code>, <code>y[2]=3</code>, and so on.</li>
</ol>
<p>Since the output <code>y[n]</code> grows indefinitely as <code>n</code> increases, even though the input <code>x[n]</code> remains bounded, the accumulator is an <strong>unstable system</strong> according to the BIBO definition. This illustrates why the formal definition of stability is vital, as intuitive “slow growth” can still lead to unboundedness over time.</p>
</div>
<hr>
</section>
<section id="examples-of-stability-check" class="level2">
<h2 class="anchored" data-anchor-id="examples-of-stability-check">Examples of Stability Check</h2>
<div class="columns">
<div class="column" style="width:50%;">
<p><strong>System <span class="math inline">\(S_1\)</span>: <span class="math inline">\(y(t) = t x(t)\)</span></strong> (1.109)</p>
<ul>
<li><strong>Input:</strong> <span class="math inline">\(x(t) = 1\)</span> (A bounded input).</li>
<li><strong>Output:</strong> <span class="math inline">\(y(t) = t \cdot 1 = t\)</span>.</li>
<li>As <span class="math inline">\(t \to \infty\)</span>, <span class="math inline">\(y(t)\)</span> grows without bound.</li>
<li><strong>Conclusion:</strong> System <span class="math inline">\(S_1\)</span> is <strong>unstable</strong>.</li>
</ul>
</div><div class="column" style="width:50%;">
<p><strong>System <span class="math inline">\(S_2\)</span>: <span class="math inline">\(y(t) = e^{x(t)}\)</span></strong> (1.110)</p>
<ul>
<li>Consider any bounded input: For some <span class="math inline">\(B &gt; 0\)</span>, <span class="math inline">\(|x(t)| &lt; B\)</span>.
<ul>
<li>This means <span class="math inline">\(-B &lt; x(t) &lt; B\)</span>.</li>
</ul></li>
<li>Then for the output:
<ul>
<li><span class="math inline">\(e^{-B} &lt; y(t) &lt; e^{B}\)</span>.</li>
</ul></li>
<li>The output <span class="math inline">\(y(t)\)</span> is bounded by <span class="math inline">\(e^B\)</span>.</li>
<li><strong>Conclusion:</strong> System <span class="math inline">\(S_2\)</span> is <strong>stable</strong>.</li>
</ul>
</div>
</div>
<div class="notes">
<p>These two examples highlight how to formally check for stability.</p>
<p>For <span class="math inline">\(S_1\)</span>, the strategy for proving instability is to find just <em>one</em> counterexample. A simple constant input, like <span class="math inline">\(x(t)=1\)</span>, is bounded. But when passed through <span class="math inline">\(y(t)=tx(t)\)</span>, the output becomes <span class="math inline">\(y(t)=t\)</span>. This output clearly grows without limit as time progresses. Since we found a bounded input that yields an unbounded output, <span class="math inline">\(S_1\)</span> is unstable.</p>
<p>For <span class="math inline">\(S_2\)</span>, it’s not immediately obvious to find a counterexample if it’s stable. So, the strategy is to prove it for <em>any</em> bounded input. If an input <span class="math inline">\(x(t)\)</span> is bounded by <span class="math inline">\(B\)</span>, meaning its absolute value is always less than <span class="math inline">\(B\)</span>, then the exponential function <span class="math inline">\(e^{x(t)}\)</span> will also be bounded. Since <span class="math inline">\(e^x\)</span> is an monotonically increasing function, <span class="math inline">\(e^{-B} &lt; e^{x(t)} &lt; e^B\)</span>. This shows that if the input is bounded by <span class="math inline">\(B\)</span>, the output is guaranteed to be bounded by <span class="math inline">\(e^B\)</span>. Thus, <span class="math inline">\(S_2\)</span> is stable. Always remember to check for <em>all</em> bounded inputs, not just specific ones, when proving stability.</p>
</div>
<hr>
<section id="time-invariance" class="level3">
<h3 class="anchored" data-anchor-id="time-invariance">5. Time Invariance</h3>
<p>A system is <strong>time invariant</strong> if a time shift in the input signal results in an identical time shift in the output signal.</p>
<ul>
<li>The system’s characteristics and behavior are fixed over time.</li>
<li>If <span class="math inline">\(x(t) \to y(t)\)</span>, then <span class="math inline">\(x(t-t_0) \to y(t-t_0)\)</span> (Continuous Time).</li>
<li>If <span class="math inline">\(x[n] \to y[n]\)</span>, then <span class="math inline">\(x[n-n_0] \to y[n-n_0]\)</span> (Discrete Time).</li>
</ul>
<p><strong>Time-Invariant System Example:</strong></p>
<p><span class="math display">\[
y(t)=\sin [x(t)] \quad \text{(1.114)}
\]</span> If <span class="math inline">\(x_1(t) \to y_1(t)=\sin[x_1(t)]\)</span>, then for <span class="math inline">\(x_2(t)=x_1(t-t_0)\)</span>, <span class="math inline">\(y_2(t)=\sin[x_2(t)]=\sin[x_1(t-t_0)]\)</span>. Since <span class="math inline">\(y_1(t-t_0)=\sin[x_1(t-t_0)]\)</span>, we have <span class="math inline">\(y_2(t)=y_1(t-t_0)\)</span>. Thus, it’s time-invariant.</p>
<hr>
</section>
<section id="time-invariance-1" class="level3">
<h3 class="anchored" data-anchor-id="time-invariance-1">5. Time Invariance</h3>
<p><strong>Time-Varying System Examples:</strong></p>
<ul>
<li><strong>Time-Varying Gain:</strong> <span class="math display">\[
y[n]=n x[n] \quad \text{(1.119)}
\]</span> <em>The gain <code>n</code> changes with time.</em></li>
<li><strong>Time Scaling:</strong> <span class="math display">\[
y(t)=x(2 t) \quad \text{(1.120)}
\]</span> <em>A time shift in input is compressed in output.</em></li>
</ul>
<div class="notes">
<p>Time invariance means that the system’s “rules” don’t change over time. If you perform an experiment with a system today, and then repeat the <em>exact same experiment</em> tomorrow (with the same input applied at the same relative time), you should get the exact same output, just shifted in time. The system doesn’t “age” or change its internal parameters.</p>
<p>The mathematical definition perfectly captures this. If you shift the input signal by <span class="math inline">\(t_0\)</span> (or <span class="math inline">\(n_0\)</span>), the output signal should also just be shifted by the <em>same</em> amount.</p>
<p>The <span class="math inline">\(\sin[x(t)]\)</span> system is time-invariant because the sine function itself doesn’t change with time. It acts on the input value <em>regardless</em> of when that value occurs.</p>
<p>However, a system like <span class="math inline">\(y[n]=nx[n]\)</span> clearly depends on time <span class="math inline">\(n\)</span>. If you input an impulse at <span class="math inline">\(n=0\)</span>, <span class="math inline">\(y[0]=0 \cdot x[0] = 0\)</span>. If you input the <em>same</em> impulse (just shifted) at <span class="math inline">\(n=1\)</span>, <span class="math inline">\(y[1]=1 \cdot x[1] = 1\)</span>. The output is NOT just a shifted version of the first output. This means the system’s “gain” changes based on the time <code>n</code>, making it time-varying. Similarly, time-scaling like <span class="math inline">\(y(t)=x(2t)\)</span> is time-varying because a time shift in the input gets scaled by the system.</p>
</div>
<hr>
</section>
</section>
<section id="time-invariance-interactive-demonstration-time-varying-gain" class="level2">
<h2 class="anchored" data-anchor-id="time-invariance-interactive-demonstration-time-varying-gain">Time Invariance: Interactive Demonstration (Time-Varying Gain)</h2>
<p>Let’s illustrate that <span class="math inline">\(y[n]=nx[n]\)</span> is time-varying.</p>
<pre class="{pyodide}"><code>#| max-lines: 10
import numpy as np
import matplotlib.pyplot as plt

# Define input signal x1[n] (a single pulse at n=0)
n = np.arange(-5, 6)
x1 = np.where(n == 0, 1, 0)

# Output for x1[n]
y1 = n * x1

# Define shifted input signal x2[n] = x1[n-2] (pulse at n=2)
n0 = 2 # Time shift
x2 = np.where(n == n0, 1, 0) # This is x1[n-2]

# Output for x2[n]
y2 = n * x2

# Expected output if system were time-invariant: y1[n-n0]
y1_shifted = np.zeros_like(n, dtype=float)
# Find the indices corresponding to the shifted signal
mask = (n - n0 &gt;= n.min()) &amp; (n - n0 &lt;= n.max())
y1_shifted[mask] = y1[n[mask] - n0]

plt.figure(figsize=(7, 6))

plt.subplot(3, 1, 1)
plt.stem(n, x1, label='x1[n]', basefmt=" ")
plt.stem(n, y1, linefmt='r:', markerfmt='ro', label='y1[n]=n*x1[n]', basefmt=" ")
plt.title('Input $x_1[n]$ and Output $y_1[n]$')
plt.ylabel('Amplitude')
plt.grid(True)
plt.legend()
plt.tight_layout()

plt.subplot(3, 1, 2)
plt.stem(n, x2, label='x2[n] = x1[n-2]', basefmt=" ")
plt.stem(n, y2, linefmt='g:', markerfmt='go', label='y2[n]=n*x2[n]', basefmt=" ")
plt.title('Shifted Input $x_2[n]$ and Output $y_2[n]$')
plt.ylabel('Amplitude')
plt.grid(True)
plt.legend()
plt.tight_layout()

plt.subplot(3, 1, 3)
plt.stem(n, y2, linefmt='g:', markerfmt='go', label='y2[n]', basefmt=" ")
plt.stem(n, y1_shifted, linefmt='b--', markerfmt='bx', label='Expected $y_1[n-2]$ for Time Invariance', basefmt=" ")
plt.title('Comparison: $y_2[n]$ vs. $y_1[n-2]$')
plt.xlabel('n')
plt.ylabel('Amplitude')
plt.grid(True)
plt.legend()
plt.tight_layout()

plt.show()

# Verification
print(f"y1: {y1}")
print(f"y2: {y2}")
print(f"y1_shifted: {y1_shifted}")
print(f"Is y2[n] == y1[n-2]? {np.allclose(y2, y1_shifted)}")</code></pre>
<div class="notes">
<p>This demonstration visually proves that the system <span class="math inline">\(y[n]=nx[n]\)</span> is <em>not</em> time-invariant.</p>
<ol type="1">
<li><strong>Top Plot: <span class="math inline">\(x_1[n]\)</span> and <span class="math inline">\(y_1[n]\)</span>:</strong> We start with an input <span class="math inline">\(x_1[n]\)</span> which is an impulse at <span class="math inline">\(n=0\)</span>. The output <span class="math inline">\(y_1[n]\)</span> is calculated as <span class="math inline">\(n \cdot x_1[n]\)</span>, which for <span class="math inline">\(n=0\)</span> is <span class="math inline">\(0 \cdot 1 = 0\)</span>. So, <span class="math inline">\(y_1[n]\)</span> is zero everywhere.</li>
<li><strong>Middle Plot: <span class="math inline">\(x_2[n]\)</span> and <span class="math inline">\(y_2[n]\)</span>:</strong> Now, we shift the input <span class="math inline">\(x_1[n]\)</span> by 2 units to get <span class="math inline">\(x_2[n]\)</span> (an impulse at <span class="math inline">\(n=2\)</span>). The output <span class="math inline">\(y_2[n]\)</span> is then calculated as <span class="math inline">\(n \cdot x_2[n]\)</span>. For <span class="math inline">\(n=2\)</span>, this becomes <span class="math inline">\(2 \cdot 1 = 2\)</span>. So, <span class="math inline">\(y_2[n]\)</span> is an impulse of amplitude 2 at <span class="math inline">\(n=2\)</span>.</li>
<li><strong>Bottom Plot: Comparison (<span class="math inline">\(y_2[n]\)</span> vs.&nbsp;expected <span class="math inline">\(y_1[n-2]\)</span>):</strong> If the system were time-invariant, the output <span class="math inline">\(y_2[n]\)</span> (green stems) should simply be a shifted version of <span class="math inline">\(y_1[n]\)</span> (meaning still all zeros, but shifted, so still all zeros – represented by the dashed blue stems for expected <span class="math inline">\(y_1[n-2]\)</span>). However, <code>y2[n]</code> clearly has a non-zero value at <code>n=2</code>.</li>
</ol>
<p>Since <span class="math inline">\(y_2[n]\)</span> is not equal to <span class="math inline">\(y_1[n-2]\)</span>, the system is time-varying. The gain <code>n</code> changes based on time, so the response to the same input (just shifted) will be different.</p>
</div>
<hr>
</section>
<section id="linearity" class="level2">
<h2 class="anchored" data-anchor-id="linearity">6. Linearity</h2>
<p>A system is <strong>linear</strong> if it possesses the property of <strong>superposition</strong>. This means it satisfies two conditions:</p>
<ol type="1">
<li><strong>Additivity:</strong> If <span class="math inline">\(x_1(t) \to y_1(t)\)</span> and <span class="math inline">\(x_2(t) \to y_2(t)\)</span>, then <span class="math inline">\(x_1(t)+x_2(t) \to y_1(t)+y_2(t)\)</span>.</li>
<li><strong>Homogeneity (Scaling):</strong> If <span class="math inline">\(x_1(t) \to y_1(t)\)</span>, then <span class="math inline">\(a x_1(t) \to a y_1(t)\)</span> for any complex constant <span class="math inline">\(a\)</span>.</li>
</ol>
<p>These two properties can be combined: * <strong>Continuous Time:</strong> <span class="math display">\[
    a x_1(t)+b x_2(t) \rightarrow a y_1(t)+b y_2(t) \quad \text{(1.121)}
    \]</span> * <strong>Discrete Time:</strong> <span class="math display">\[
    a x_1[n]+b x_2[n] \rightarrow a y_1[n]+b y_2[n] \quad \text{(1.122)}
    \]</span></p>
<p><strong>Important Consequence:</strong> For linear systems, a zero input <span class="math inline">\(x[n]=0\)</span> for all <span class="math inline">\(n\)</span> must result in a zero output <span class="math inline">\(y[n]=0\)</span> for all <span class="math inline">\(n\)</span>.</p>
<div class="notes">
<p>Linearity is perhaps the most fundamental property in Signals and Systems, forming the basis for many powerful analysis techniques. A linear system obeys the principle of <strong>superposition</strong>.</p>
<p>This principle is broken down into two parts: 1. <strong>Additivity:</strong> If you have two different inputs, say <span class="math inline">\(x_1\)</span> and <span class="math inline">\(x_2\)</span>, and you know their individual outputs, <span class="math inline">\(y_1\)</span> and <span class="math inline">\(y_2\)</span>, then if you apply the sum of the inputs (<span class="math inline">\(x_1+x_2\)</span>), the output will simply be the sum of their individual outputs (<span class="math inline">\(y_1+y_2\)</span>). 2. <strong>Homogeneity/Scaling:</strong> If you scale an input by a factor ‘a’ (e.g., make it twice as strong), the output will also be scaled by the <em>exact same</em> factor ‘a’.</p>
<p>Both of these must hold for a system to be linear. If either one fails, the system is nonlinear. The combined statement is very powerful for checking linearity.</p>
<p>A crucial consequence of linearity is that a linear system with no input should produce no output. This “zero-in/zero-out” check is often the quickest way to spot a nonlinear system. If you apply zero input and get a non-zero output (like a constant offset), the system is definitely not linear. We’ll explore examples now.</p>
</div>
<hr>
</section>
<section id="linearity-examples" class="level2">
<h2 class="anchored" data-anchor-id="linearity-examples">Linearity: Examples</h2>
<p><strong>Example 1: System <span class="math inline">\(S_A: y(t) = t x(t)\)</span></strong> (Example 1.17)</p>
<ul>
<li>Let <span class="math inline">\(x_3(t) = a x_1(t) + b x_2(t)\)</span>.</li>
<li><span class="math inline">\(y_3(t) = t x_3(t) = t(a x_1(t) + b x_2(t)) = a (t x_1(t)) + b (t x_2(t)) = a y_1(t) + b y_2(t)\)</span>.</li>
<li><strong>Conclusion:</strong> System <span class="math inline">\(S_A\)</span> is <strong>linear</strong>. (It is also time-varying, as seen before!)</li>
</ul>
<p><strong>Example 2: System <span class="math inline">\(S_B: y(t) = x^2(t)\)</span></strong> (Example 1.18)</p>
<ul>
<li>Let <span class="math inline">\(x_3(t) = a x_1(t) + b x_2(t)\)</span>.</li>
<li><span class="math inline">\(y_3(t) = (a x_1(t) + b x_2(t))^2 = a^2 x_1^2(t) + b^2 x_2^2(t) + 2ab x_1(t) x_2(t)\)</span>.</li>
<li>This is <span class="math inline">\(a^2 y_1(t) + b^2 y_2(t) + 2ab x_1(t) x_2(t)\)</span> which is <strong>not</strong> <span class="math inline">\(a y_1(t) + b y_2(t)\)</span>.</li>
<li><strong>Conclusion:</strong> System <span class="math inline">\(S_B\)</span> is <strong>non-linear</strong>.</li>
</ul>
<p><strong>Example 3: System <span class="math inline">\(S_C: y[n] = \text{Re}\{x[n]\}\)</span></strong> (Example 1.19)</p>
<ul>
<li>Is additive, but fails homogeneity for complex scalars.</li>
<li>If <span class="math inline">\(x_1[n] = r[n]+js[n]\)</span>, then <span class="math inline">\(y_1[n] = r[n]\)</span>.</li>
<li>Let <span class="math inline">\(a=j\)</span>. The input <span class="math inline">\(x_2[n] = j x_1[n] = -s[n] + j r[n]\)</span>.</li>
<li><span class="math inline">\(y_2[n] = \text{Re}\{x_2[n]\} = -s[n]\)</span>.</li>
<li>Expected <span class="math inline">\(a y_1[n] = j r[n]\)</span>. Since <span class="math inline">\(-s[n] \ne j r[n]\)</span>, it fails homogeneity.</li>
<li><strong>Conclusion:</strong> System <span class="math inline">\(S_C\)</span> is <strong>non-linear</strong>.</li>
</ul>
<div class="notes">
<p>Let’s walk through these examples to solidify our understanding of linearity. For each, we apply the superposition test.</p>
<ol type="1">
<li><p><strong>System <span class="math inline">\(S_A: y(t) = t x(t)\)</span></strong>: This is a direct application of the definition. When we substitute the combined input <span class="math inline">\(ax_1(t)+bx_2(t)\)</span> into the system equation, we can factor out <span class="math inline">\(a\)</span> and <span class="math inline">\(b\)</span>, showing that the output is indeed the linear combination of individual outputs. So, it’s linear. Note that this system is linear but <em>not</em> time-invariant, as we discussed previously. Systems can have one property without the other.</p></li>
<li><p><strong>System <span class="math inline">\(S_B: y(t) = x^2(t)\)</span></strong>: Here, the squaring operation <span class="math inline">\(x^2(t)\)</span> immediately suggests non-linearity because of the cross-term <span class="math inline">\(2ab x_1(t) x_2(t)\)</span> that arises from expanding the square of <span class="math inline">\((ax_1+bx_2)\)</span>. This cross-term prevents the output from being a simple linear combination of <span class="math inline">\(y_1\)</span> and <span class="math inline">\(y_2\)</span>. Therefore, it’s non-linear.</p></li>
<li><p><strong>System <span class="math inline">\(S_C: y[n] = \text{Re}\{x[n]\}\)</span></strong>: This one is tricky and highlights the importance of considering <em>complex</em> scalars for homogeneity. It <em>is</em> additive, but it fails homogeneity when scaled by a complex constant like <span class="math inline">\(j\)</span>. The real part of <span class="math inline">\(j \cdot x_1[n]\)</span> is not <span class="math inline">\(j\)</span> times the real part of <span class="math inline">\(x_1[n]\)</span>. This demonstrates that both additivity AND homogeneity must hold for <em>any complex</em> scalar for a system to be linear.</p></li>
</ol>
</div>
<hr>
</section>
<section id="linearity-interactive-demonstration-quadratic-system" class="level2">
<h2 class="anchored" data-anchor-id="linearity-interactive-demonstration-quadratic-system">Linearity: Interactive Demonstration (Quadratic System)</h2>
<p>Let’s test <span class="math inline">\(y[n] = x^2[n]\)</span> for linearity.</p>
<pre class="{pyodide}"><code>#| max-lines: 10
import numpy as np
import matplotlib.pyplot as plt

# Input signals
n = np.arange(-5, 6)
x1 = np.where(n == 0, 2, 0) # Impulse at n=0, amplitude 2
x2 = np.where(n == 1, 1, 0) # Impulse at n=1, amplitude 1

# Scaling constants
a_val = 2
b_val = 3

# Individual outputs for y[n] = x^2[n]
y1 = x1**2
y2 = x2**2

# Expected linear combination: a*y1 + b*y2
y_expected_linear = a_val * y1 + b_val * y2

# Combined input
x_combined = a_val * x1 + b_val * x2

# Actual output for combined input
y_actual_combined = x_combined**2

plt.figure(figsize=(7, 6))

plt.subplot(3, 1, 1)
plt.stem(n, x1, label='x1[n]', linefmt='b-', markerfmt='bo', basefmt=" ")
plt.stem(n, x2, label='x2[n]', linefmt='g--', markerfmt='gx', basefmt=" ")
plt.title('Individual Inputs $x_1[n]$ and $x_2[n]$')
plt.ylabel('Amplitude')
plt.grid(True)
plt.legend()
plt.tight_layout()

plt.subplot(3, 1, 2)
plt.stem(n, y_actual_combined, linefmt='r-', markerfmt='ro', label='Actual output from $a x_1 + b x_2$', basefmt=" ")
plt.title('Actual Output $y[n]$ for $a x_1[n] + b x_2[n]$')
plt.ylabel('Amplitude')
plt.grid(True)
plt.legend()
plt.tight_layout()

plt.subplot(3, 1, 3)
plt.stem(n, y_expected_linear, linefmt='b:', markerfmt='bs', label='Expected $a y_1[n] + b y_2[n]$ (if linear)', basefmt=" ")
plt.stem(n, y_actual_combined, linefmt='r-', markerfmt='ro', label='Actual output (for comparison)', basefmt=" ")
plt.title('Comparison: Actual Output vs. Expected Linear Sum')
plt.xlabel('n')
plt.ylabel('Amplitude')
plt.grid(True)
plt.legend()
plt.tight_layout()

plt.show()

# Print values for specific 'n'
print(f"At n=0:")
print(f"x1[0]={x1[n==0]}, x2[0]={x2[n==0]}")
print(f"y_actual_combined[0]={y_actual_combined[n==0]}, y_expected_linear[0]={y_expected_linear[n==0]}")
print(f"Are they equal at n=0? {np.isclose(y_actual_combined[n==0], y_expected_linear[n==0])}")
print("\n")
print(f"At n=1:")
print(f"x1[1]={x1[n==1]}, x2[1]={x2[n==1]}")
print(f"y_actual_combined[1]={y_actual_combined[n==1]}, y_expected_linear[1]={y_expected_linear[n==1]}")
print(f"Are they equal at n=1? {np.isclose(y_actual_combined[n==1], y_expected_linear[n==1])}")

print(f"\nOverall: Are outputs equal? {np.allclose(y_actual_combined, y_expected_linear)}")</code></pre>
<div class="notes">
<p>This demonstration concretely shows why the system <span class="math inline">\(y[n]=x^2[n]\)</span> is nonlinear. We’re testing the superposition property by comparing two results:</p>
<ol type="1">
<li><strong>Expected Linear Sum (blue dashed stems):</strong> This is what the output <em>should</em> be if the system were linear: <span class="math inline">\(a \cdot y_1[n] + b \cdot y_2[n]\)</span>. We compute <span class="math inline">\(y_1[n]\)</span> from <span class="math inline">\(x_1[n]\)</span> and <span class="math inline">\(y_2[n]\)</span> from <span class="math inline">\(x_2[n]\)</span> separately, then combine them.</li>
<li><strong>Actual Output (red solid stems):</strong> This is the output we get when we first combine the inputs (<span class="math inline">\(a \cdot x_1[n] + b \cdot x_2[n]\)</span>) and <em>then</em> pass this combined signal through the system.</li>
</ol>
<p><strong>Observe:</strong> * <strong>At <code>n=0</code>:</strong> <code>x1[0]=2</code>, <code>x2[0]=0</code>. The combined input is <code>2*2 + 3*0 = 4</code>. The actual output is <code>4^2=16</code>. The expected linear sum is <code>2*(2^2) + 3*(0^2) = 2*4 + 0 = 8</code>. They are different! * <strong>At <code>n=1</code>:</strong> <code>x1[1]=0</code>, <code>x2[1]=1</code>. The combined input is <code>2*0 + 3*1 = 3</code>. The actual output is <code>3^2=9</code>. The expected linear sum is <code>2*(0^2) + 3*(1^2) = 0 + 3*1 = 3</code>. They are different!</p>
<p>The plots clearly show that the red solid stems (actual output) do <em>not</em> match the blue dashed stems (expected linear sum). The numerical checks at the bottom confirm this. This discrepancy, caused by the squaring operation, violates the superposition principle, proving the system is nonlinear.</p>
</div>
<hr>
</section>
<section id="linearity-incrementally-linear-systems" class="level2">
<h2 class="anchored" data-anchor-id="linearity-incrementally-linear-systems">Linearity: Incrementally Linear Systems</h2>
<p><strong>Example: System <span class="math inline">\(S_D: y[n] = 2x[n] + 3\)</span></strong> (1.132)</p>
<ul>
<li>This system often looks “linear” because it’s a linear equation.</li>
<li>However, it <strong>violates the zero-input, zero-output property</strong>:
<ul>
<li>If <span class="math inline">\(x[n]=0\)</span>, then <span class="math inline">\(y[n]=2(0)+3=3 \ne 0\)</span>.</li>
</ul></li>
<li>Therefore, System <span class="math inline">\(S_D\)</span> is <strong>non-linear</strong>.</li>
</ul>
<div class="cell" data-layout-align="default">
<div class="cell-output-display">
<div>
<p></p><figure class="figure"><p></p>
<div>
<pre class="mermaid mermaid-js">graph TD
    A["Input x[n]"] --&gt; S_linear["Linear System: $$y_L[n]=2x[n]$$"]
    S_linear --&gt; add[+]
    S_const[Constant Input: 3] --&gt; add
    add --&gt; B["Output y[n]"]
</pre>
</div>
<p></p></figure><p></p>
</div>
</div>
</div>
<p><em>(Figure 1.48 - Structure of an incrementally linear system)</em></p>
<p>This system is <strong>incrementally linear</strong>: * The <em>difference</em> between two outputs is a linear function of the <em>difference</em> between their inputs. <span class="math display">\[
y_1[n]-y_2[n] = (2x_1[n]+3) - (2x_2[n]+3) = 2(x_1[n]-x_2[n]) \quad \text{(1.136)}
\]</span> * This means it can be viewed as a linear system (<span class="math inline">\(2x[n]\)</span>) with a constant offset (3).</p>
<div class="notes">
<p>This final example for linearity, <span class="math inline">\(y[n]=2x[n]+3\)</span>, is a very common point of confusion. Many students, seeing a “linear equation”, assume it defines a linear system. However, this is not the case within the context of Signals and Systems.</p>
<p>The quickest way to check is the “zero-in, zero-out” property. If <span class="math inline">\(x[n]\)</span> is zero for all <span class="math inline">\(n\)</span>, a truly linear system must output zero for all <span class="math inline">\(n\)</span>. But for <span class="math inline">\(y[n]=2x[n]+3\)</span>, if <span class="math inline">\(x[n]=0\)</span>, then <span class="math inline">\(y[n]=3\)</span>. Since the output is non-zero, this system is <em>not</em> linear. It fails the homogeneity property (try scaling by zero!).</p>
<p>However, such systems are called “incrementally linear.” This means that while the system itself isn’t linear, <em>changes</em> in its output are linear with respect to <em>changes</em> in its input. The diagram illustrates this: the system can be seen as a linear part (<span class="math inline">\(2x[n]\)</span>) combined with a constant offset (3), which is essentially the system’s “zero-input response.” This distinction is important for understanding more complex systems later.</p>
</div>
<hr>
</section>
<section id="conclusion-summary" class="level2">
<h2 class="anchored" data-anchor-id="conclusion-summary">Conclusion &amp; Summary</h2>
<p>We’ve explored six fundamental properties of systems:</p>
<ul>
<li><strong>Memory / Memoryless:</strong> Does output depend only on the current input?</li>
<li><strong>Invertibility:</strong> Can the input be uniquely recovered from the output?</li>
<li><strong>Causality:</strong> Does output depend only on present and past inputs? (Non-anticipative)</li>
<li><strong>Stability:</strong> Do bounded inputs lead to bounded outputs? (BIBO)</li>
<li><strong>Time Invariance:</strong> Do a time shift in input cause an identical time shift in output?</li>
<li><strong>Linearity:</strong> Does the system satisfy superposition (additivity &amp; homogeneity)?</li>
</ul>
<p>These properties are essential tools for:</p>
<ul>
<li>Classifying systems.</li>
<li>Simplifying analysis (especially for linear, time-invariant systems).</li>
<li>Designing systems with desired behaviors.</li>
</ul>
<p>Understanding these basics lays the groundwork for advanced topics in Signals and Systems!</p>
<div class="notes">
<p>To wrap up, we’ve covered six critical properties that define the behavior of systems in Signals and Systems.</p>
<ul>
<li><strong>Memory</strong> speaks to whether a system “remembers” past inputs or predicts future ones.</li>
<li><strong>Invertibility</strong> is about whether we can uniquely reverse the system’s operation to deduce the original input.</li>
<li><strong>Causality</strong> is about real-time behavior - can the system react only to what has already happened, or does it anticipate?</li>
<li><strong>Stability</strong> is crucial for reliability, ensuring that small inputs don’t lead to out-of-control outputs.</li>
<li><strong>Time Invariance</strong> means the system’s behavior is consistent over time, regardless of when an input is applied.</li>
<li><strong>Linearity</strong> is the bedrock for many advanced analysis techniques, allowing us to break down complex inputs into simpler components and superimpose their responses.</li>
</ul>
<p>These definitions are not just academic. They directly influence how we design everything from audio filters to control systems, telecommunications networks, and medical imaging devices. Mastering these properties will significantly simplify your journey through the rest of this Signals and Systems course. Thank you!</p>
</div>


</section>
</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
  window.document.addEventListener("DOMContentLoaded", function (event) {
    const icon = "";
    const anchorJS = new window.AnchorJS();
    anchorJS.options = {
      placement: 'right',
      icon: icon
    };
    anchorJS.add('.anchored');
    const isCodeAnnotation = (el) => {
      for (const clz of el.classList) {
        if (clz.startsWith('code-annotation-')) {                     
          return true;
        }
      }
      return false;
    }
    const onCopySuccess = function(e) {
      // button target
      const button = e.trigger;
      // don't keep focus
      button.blur();
      // flash "checked"
      button.classList.add('code-copy-button-checked');
      var currentTitle = button.getAttribute("title");
      button.setAttribute("title", "Copied!");
      let tooltip;
      if (window.bootstrap) {
        button.setAttribute("data-bs-toggle", "tooltip");
        button.setAttribute("data-bs-placement", "left");
        button.setAttribute("data-bs-title", "Copied!");
        tooltip = new bootstrap.Tooltip(button, 
          { trigger: "manual", 
            customClass: "code-copy-button-tooltip",
            offset: [0, -8]});
        tooltip.show();    
      }
      setTimeout(function() {
        if (tooltip) {
          tooltip.hide();
          button.removeAttribute("data-bs-title");
          button.removeAttribute("data-bs-toggle");
          button.removeAttribute("data-bs-placement");
        }
        button.setAttribute("title", currentTitle);
        button.classList.remove('code-copy-button-checked');
      }, 1000);
      // clear code selection
      e.clearSelection();
    }
    const getTextToCopy = function(trigger) {
      const outerScaffold = trigger.parentElement.cloneNode(true);
      const codeEl = outerScaffold.querySelector('code');
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
    const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
      text: getTextToCopy
    });
    clipboard.on('success', onCopySuccess);
    if (window.document.getElementById('quarto-embedded-source-code-modal')) {
      const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
        text: getTextToCopy,
        container: window.document.getElementById('quarto-embedded-source-code-modal')
      });
      clipboardModal.on('success', onCopySuccess);
    }
      var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
      var mailtoRegex = new RegExp(/^mailto:/);
        var filterRegex = new RegExp('/' + window.location.host + '/');
      var isInternal = (href) => {
          return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
      }
      // Inspect non-navigation links and adorn them if external
     var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
      for (var i=0; i<links.length; i++) {
        const link = links[i];
        if (!isInternal(link.href)) {
          // undo the damage that might have been done by quarto-nav.js in the case of
          // links that we want to consider external
          if (link.dataset.originalHref !== undefined) {
            link.href = link.dataset.originalHref;
          }
        }
      }
    function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
      const config = {
        allowHTML: true,
        maxWidth: 500,
        delay: 100,
        arrow: false,
        appendTo: function(el) {
            return el.parentElement;
        },
        interactive: true,
        interactiveBorder: 10,
        theme: 'quarto',
        placement: 'bottom-start',
      };
      if (contentFn) {
        config.content = contentFn;
      }
      if (onTriggerFn) {
        config.onTrigger = onTriggerFn;
      }
      if (onUntriggerFn) {
        config.onUntrigger = onUntriggerFn;
      }
      window.tippy(el, config); 
    }
    const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
    for (var i=0; i<noterefs.length; i++) {
      const ref = noterefs[i];
      tippyHover(ref, function() {
        // use id or data attribute instead here
        let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
        try { href = new URL(href).hash; } catch {}
        const id = href.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note) {
          return note.innerHTML;
        } else {
          return "";
        }
      });
    }
    const xrefs = window.document.querySelectorAll('a.quarto-xref');
    const processXRef = (id, note) => {
      // Strip column container classes
      const stripColumnClz = (el) => {
        el.classList.remove("page-full", "page-columns");
        if (el.children) {
          for (const child of el.children) {
            stripColumnClz(child);
          }
        }
      }
      stripColumnClz(note)
      if (id === null || id.startsWith('sec-')) {
        // Special case sections, only their first couple elements
        const container = document.createElement("div");
        if (note.children && note.children.length > 2) {
          container.appendChild(note.children[0].cloneNode(true));
          for (let i = 1; i < note.children.length; i++) {
            const child = note.children[i];
            if (child.tagName === "P" && child.innerText === "") {
              continue;
            } else {
              container.appendChild(child.cloneNode(true));
              break;
            }
          }
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(container);
          }
          return container.innerHTML
        } else {
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(note);
          }
          return note.innerHTML;
        }
      } else {
        // Remove any anchor links if they are present
        const anchorLink = note.querySelector('a.anchorjs-link');
        if (anchorLink) {
          anchorLink.remove();
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        if (note.classList.contains("callout")) {
          return note.outerHTML;
        } else {
          return note.innerHTML;
        }
      }
    }
    for (var i=0; i<xrefs.length; i++) {
      const xref = xrefs[i];
      tippyHover(xref, undefined, function(instance) {
        instance.disable();
        let url = xref.getAttribute('href');
        let hash = undefined; 
        if (url.startsWith('#')) {
          hash = url;
        } else {
          try { hash = new URL(url).hash; } catch {}
        }
        if (hash) {
          const id = hash.replace(/^#\/?/, "");
          const note = window.document.getElementById(id);
          if (note !== null) {
            try {
              const html = processXRef(id, note.cloneNode(true));
              instance.setContent(html);
            } finally {
              instance.enable();
              instance.show();
            }
          } else {
            // See if we can fetch this
            fetch(url.split('#')[0])
            .then(res => res.text())
            .then(html => {
              const parser = new DOMParser();
              const htmlDoc = parser.parseFromString(html, "text/html");
              const note = htmlDoc.getElementById(id);
              if (note !== null) {
                const html = processXRef(id, note);
                instance.setContent(html);
              } 
            }).finally(() => {
              instance.enable();
              instance.show();
            });
          }
        } else {
          // See if we can fetch a full url (with no hash to target)
          // This is a special case and we should probably do some content thinning / targeting
          fetch(url)
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.querySelector('main.content');
            if (note !== null) {
              // This should only happen for chapter cross references
              // (since there is no id in the URL)
              // remove the first header
              if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
                note.children[0].remove();
              }
              const html = processXRef(null, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      }, function(instance) {
      });
    }
        let selectedAnnoteEl;
        const selectorForAnnotation = ( cell, annotation) => {
          let cellAttr = 'data-code-cell="' + cell + '"';
          let lineAttr = 'data-code-annotation="' +  annotation + '"';
          const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
          return selector;
        }
        const selectCodeLines = (annoteEl) => {
          const doc = window.document;
          const targetCell = annoteEl.getAttribute("data-target-cell");
          const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
          const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
          const lines = annoteSpan.getAttribute("data-code-lines").split(",");
          const lineIds = lines.map((line) => {
            return targetCell + "-" + line;
          })
          let top = null;
          let height = null;
          let parent = null;
          if (lineIds.length > 0) {
              //compute the position of the single el (top and bottom and make a div)
              const el = window.document.getElementById(lineIds[0]);
              top = el.offsetTop;
              height = el.offsetHeight;
              parent = el.parentElement.parentElement;
            if (lineIds.length > 1) {
              const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
              const bottom = lastEl.offsetTop + lastEl.offsetHeight;
              height = bottom - top;
            }
            if (top !== null && height !== null && parent !== null) {
              // cook up a div (if necessary) and position it 
              let div = window.document.getElementById("code-annotation-line-highlight");
              if (div === null) {
                div = window.document.createElement("div");
                div.setAttribute("id", "code-annotation-line-highlight");
                div.style.position = 'absolute';
                parent.appendChild(div);
              }
              div.style.top = top - 2 + "px";
              div.style.height = height + 4 + "px";
              div.style.left = 0;
              let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
              if (gutterDiv === null) {
                gutterDiv = window.document.createElement("div");
                gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
                gutterDiv.style.position = 'absolute';
                const codeCell = window.document.getElementById(targetCell);
                const gutter = codeCell.querySelector('.code-annotation-gutter');
                gutter.appendChild(gutterDiv);
              }
              gutterDiv.style.top = top - 2 + "px";
              gutterDiv.style.height = height + 4 + "px";
            }
            selectedAnnoteEl = annoteEl;
          }
        };
        const unselectCodeLines = () => {
          const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
          elementsIds.forEach((elId) => {
            const div = window.document.getElementById(elId);
            if (div) {
              div.remove();
            }
          });
          selectedAnnoteEl = undefined;
        };
          // Handle positioning of the toggle
      window.addEventListener(
        "resize",
        throttle(() => {
          elRect = undefined;
          if (selectedAnnoteEl) {
            selectCodeLines(selectedAnnoteEl);
          }
        }, 10)
      );
      function throttle(fn, ms) {
      let throttle = false;
      let timer;
        return (...args) => {
          if(!throttle) { // first call gets through
              fn.apply(this, args);
              throttle = true;
          } else { // all the others get throttled
              if(timer) clearTimeout(timer); // cancel #2
              timer = setTimeout(() => {
                fn.apply(this, args);
                timer = throttle = false;
              }, ms);
          }
        };
      }
        // Attach click handler to the DT
        const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
        for (const annoteDlNode of annoteDls) {
          annoteDlNode.addEventListener('click', (event) => {
            const clickedEl = event.target;
            if (clickedEl !== selectedAnnoteEl) {
              unselectCodeLines();
              const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
              if (activeEl) {
                activeEl.classList.remove('code-annotation-active');
              }
              selectCodeLines(clickedEl);
              clickedEl.classList.add('code-annotation-active');
            } else {
              // Unselect the line
              unselectCodeLines();
              clickedEl.classList.remove('code-annotation-active');
            }
          });
        }
    const findCites = (el) => {
      const parentEl = el.parentElement;
      if (parentEl) {
        const cites = parentEl.dataset.cites;
        if (cites) {
          return {
            el,
            cites: cites.split(' ')
          };
        } else {
          return findCites(el.parentElement)
        }
      } else {
        return undefined;
      }
    };
    var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
    for (var i=0; i<bibliorefs.length; i++) {
      const ref = bibliorefs[i];
      const citeInfo = findCites(ref);
      if (citeInfo) {
        tippyHover(citeInfo.el, function() {
          var popup = window.document.createElement('div');
          citeInfo.cites.forEach(function(cite) {
            var citeDiv = window.document.createElement('div');
            citeDiv.classList.add('hanging-indent');
            citeDiv.classList.add('csl-entry');
            var biblioDiv = window.document.getElementById('ref-' + cite);
            if (biblioDiv) {
              citeDiv.innerHTML = biblioDiv.innerHTML;
            }
            popup.appendChild(citeDiv);
          });
          return popup.innerHTML;
        });
      }
    }
  });
  </script>
</div> <!-- /content -->




</body></html>